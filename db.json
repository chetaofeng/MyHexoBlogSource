{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/pub-images/ASPMVC.png","path":"pub-images/ASPMVC.png","modified":0,"renderable":0},{"_id":"source/pub-images/git.png","path":"pub-images/git.png","modified":0,"renderable":0},{"_id":"source/pub-images/redux-middleware2.png","path":"pub-images/redux-middleware2.png","modified":0,"renderable":0},{"_id":"source/pub-images/redux-middleware1.png","path":"pub-images/redux-middleware1.png","modified":0,"renderable":0},{"_id":"source/pub-images/redux组件配合原理.png","path":"pub-images/redux组件配合原理.png","modified":0,"renderable":0},{"_id":"source/pub-images/avatar.png","path":"pub-images/avatar.png","modified":0,"renderable":0},{"_id":"source/pub-images/UML类图关系.png","path":"pub-images/UML类图关系.png","modified":0,"renderable":0},{"_id":"source/pub-images/alipay.png","path":"pub-images/alipay.png","modified":0,"renderable":0},{"_id":"source/pub-images/git2.png","path":"pub-images/git2.png","modified":0,"renderable":0},{"_id":"source/pub-images/wechatpay.png","path":"pub-images/wechatpay.png","modified":0,"renderable":0},{"_id":"source/pub-images/插件安装.png","path":"pub-images/插件安装.png","modified":0,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"source/pub-images/gradle生命周期.png","path":"pub-images/gradle生命周期.png","modified":0,"renderable":0},{"_id":"source/pub-images/middleware机制示例.png","path":"pub-images/middleware机制示例.png","modified":0,"renderable":0},{"_id":"source/pub-images/react-router-redux示例.png","path":"pub-images/react-router-redux示例.png","modified":0,"renderable":0},{"_id":"source/pub-images/Groovy元编程.png","path":"pub-images/Groovy元编程.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/pub-images/虚拟机文件结构.png","path":"pub-images/虚拟机文件结构.png","modified":0,"renderable":0},{"_id":"source/pub-images/Intelij Groovy.png","path":"pub-images/Intelij Groovy.png","modified":0,"renderable":0},{"_id":"source/pub-images/github设置.png","path":"pub-images/github设置.png","modified":0,"renderable":0},{"_id":"source/pub-images/mysql.png","path":"pub-images/mysql.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"source/pub-images/macOS制作U盘启动.png","path":"pub-images/macOS制作U盘启动.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/pub-images/Parallels Tools.png","path":"pub-images/Parallels Tools.png","modified":0,"renderable":0},{"_id":"source/pub-images/Ecma-262.pdf","path":"pub-images/Ecma-262.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"ccc04c5bd3f67c796bb933179adb43a49f1d50cb","modified":1550128307000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1547136283000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1547136283000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1547136283000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1547136283000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1547136283000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1547136283000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1547136283000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1547136283000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1547136283000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1547136283000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1547136283000},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1547136283000},{"_id":"themes/next/_config.yml","hash":"dfe0d0713c406525c470bd1c2ab57607b3d304f8","modified":1547136283000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1547136283000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1547136283000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1547136283000},{"_id":"source/_drafts/utils.md","hash":"fab8a607b5c40a87e6928869a5e6a218d0e50235","modified":1547136282000},{"_id":"source/_posts/.DS_Store","hash":"fb7f603bb97a082b5167a7d9cffa32f7323dcd4b","modified":1550128925000},{"_id":"source/categories/index.md","hash":"fa0b53baa8854e4a3b5ae132fc48aad1cc69bae6","modified":1547136282000},{"_id":"source/about/index.md","hash":"77c550db4e9fc05177d2eb858815269c8f4e3fca","modified":1547136282000},{"_id":"source/archives/index.md","hash":"52e65dbf6fb364d211ec472dc1d9f7155706986e","modified":1547136282000},{"_id":"source/pub-images/ASPMVC.png","hash":"28bc7b343fc138cb7905cc6eac1a2924f2c0d61e","modified":1547136282000},{"_id":"source/pub-images/git.png","hash":"3a423ec78672ac41dcd934f171eb8a454fe09fc5","modified":1547142775000},{"_id":"source/pub-images/redux-middleware2.png","hash":"c63e7d649ece3473643ab848fb5ccd9547264ca4","modified":1547136283000},{"_id":"source/pub-images/redux-middleware1.png","hash":"9b3e423778b1b3c542e5d15635e4ceeb8e62976e","modified":1547136283000},{"_id":"source/pub-images/redux组件配合原理.png","hash":"fdf407ce536c442b3cccc71e635126fb6a8c5b20","modified":1547136283000},{"_id":"source/schedule/index.md","hash":"ef0329eaf2379ce901c05e96ef611f6c61b824b4","modified":1547136283000},{"_id":"source/tags/index.md","hash":"47105e0b05b1f723de09c91d9bbddd88d4c5aa70","modified":1547136283000},{"_id":"source/pub-images/avatar.png","hash":"a9567e2000759431e70233a7ee6aacf9b75b9f22","modified":1547136283000},{"_id":"source/pub-images/UML类图关系.png","hash":"50429aed6d3ae9a59e403ce272285161c258a3e7","modified":1550113158000},{"_id":"source/pub-images/alipay.png","hash":"6f3de391ca6436179b847c95c5e870f8ec6801d2","modified":1547136283000},{"_id":"source/pub-images/git2.png","hash":"86956ca2c7ca53305d264e0425ea1875da96ba4b","modified":1547142783000},{"_id":"source/pub-images/wechatpay.png","hash":"0611ce39c6e865ffaf32d544820183c4de8222a7","modified":1547136283000},{"_id":"source/pub-images/插件安装.png","hash":"63962106b6f03bf5584f3e879735315ea086b2ae","modified":1547134511000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1547136283000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1547136283000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1547136283000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1547136283000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1547136283000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1547136283000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1547136283000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1547136283000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1547136283000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1547136283000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1547136283000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1547136283000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1547136283000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1547136283000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1547136283000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1547136283000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1547136283000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1547136283000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1547136283000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1547136283000},{"_id":"themes/next/layout/_layout.swig","hash":"6c66478af95827a5aa8230d3e4fce2d65dcff435","modified":1547136283000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1547136283000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1547136283000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1547136283000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1547136283000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1547136283000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1547136283000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1547136283000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1547136283000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1547136283000},{"_id":"themes/next/source/404.html","hash":"b74e38e322d86183d8865cd8dce465058e879e9c","modified":1547136283000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1547136283000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1547136283000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1547136283000},{"_id":"source/_posts/2018-10-05-MySQL安装-Windows/屏幕快照 2018-09-30 上午9.06.54.png","hash":"91f2ddef63424a4f13cd66f27f9ba00495c637a8","modified":1547136282000},{"_id":"source/_posts/CI/Jekins.md","hash":"3641adde17fb8b07b9c8b78b1ea6dc4dfdc54ab0","modified":1550111232000},{"_id":"source/_posts/Java/2018-11-26-Kotlin.md","hash":"2d7f00ea3e6e1555ba7725a83004dbb76583d8e2","modified":1550111201000},{"_id":"source/_posts/Java/2018-12-10-MyBatis.md","hash":"500ed2b1d38f76663873de86e82667581091bb0b","modified":1547136282000},{"_id":"source/_posts/Java/2018-11-26-SpringBoot.md","hash":"c78ba4565de1177a6455c9002bcbef38d70d7c4e","modified":1550111201000},{"_id":"source/_posts/Java/2018-12-19-aa.md","hash":"4d8841d9315cd551e96660d2e91bee8a297118e5","modified":1547144072000},{"_id":"source/_posts/Java/2019-01-02-Java并发编程.md","hash":"9fef95a714b52a1b77c7d76a7fddd856ea5c7f5c","modified":1550111221000},{"_id":"source/_posts/Java/Java8 特性.md","hash":"9b72be2d60bd36feffb2521880328e862e68db56","modified":1550126811000},{"_id":"source/_posts/C#开发/2018-10-05-ASP-NET-MVC使用.md","hash":"82f0ac40e73efa26ada532ff7d7ba73097422684","modified":1547136282000},{"_id":"source/_posts/C#开发/2018-10-05-ASP-NET-WebForms使用.md","hash":"e5e6bc0ed66f9261862e47f37e94940a053d73fb","modified":1547136282000},{"_id":"source/_posts/C#开发/2018-10-05-Razor使用.md","hash":"e25ce4783f44837039314703763e5d96132cd2dc","modified":1547136282000},{"_id":"source/_posts/C#开发/2018-10-05-ASP-NET.md","hash":"aa7c06d9f7579d08c441ba7f4810db3f9ef923bf","modified":1550111288000},{"_id":"source/_posts/C#开发/2018-10-05-WebPages.md","hash":"3d9f87846f42c644a4a9829a34e74917de166f09","modified":1547136282000},{"_id":"source/_posts/C#开发/2018-10-05-Windows下SVN服务器搭建及VS2015插件安装联动.md","hash":"9092c008d58a56fa734ce4d89f167dff27df0983","modified":1547136282000},{"_id":"source/_posts/C#开发/2018-10-06-ASP-NET-HTML表单元素.md","hash":"e045d5dd6e307e26b7d16c8561b276e5cfb71f8b","modified":1547136282000},{"_id":"source/_posts/C#开发/2018-10-17-C.md","hash":"5996ac215e88984f072d62f74101992d16541071","modified":1550111288000},{"_id":"source/_posts/C#开发/2018-11-02-NuGet.md","hash":"a579a2b1df269ceff9d326ce6dad8a6141321706","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-15-React全家桶.md","hash":"c2c039ce4b5a3a68783f836aa4dd4341bb66d2b4","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-26-Jest.md","hash":"d20505dc1321054d0b7b4581190f89adebd9829d","modified":1550111117000},{"_id":"source/_posts/react+rn/2018-10-26-React-Router.md","hash":"fb56c84af0f29f03f7a2ec3c7a37d5b49f34cd27","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-26-React入门.md","hash":"c3478d0c550881d5f5e4a8adf14f8462d73b54ef","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-26-React相关需学习.md","hash":"05727539059211304c288ca2bc91cdc4ada05c2c","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-26-middleware.md","hash":"7f6a720ccf333b447356381ec2c0807dab44f028","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-26-react-router-redux.md","hash":"7fb21c30084752735d9202c07e4b2b85432987fa","modified":1547136282000},{"_id":"source/_posts/Linux/.DS_Store","hash":"7a2f5cda2eca77c1a028ce5f342abc488c28150e","modified":1550128219000},{"_id":"source/_posts/react+rn/2018-10-26-redux-thunk.md","hash":"ddf3efaaad38265ae0b4a8ca0cdf49f34c743345","modified":1547136282000},{"_id":"source/_posts/react+rn/2018-10-26-Redux入门.md","hash":"026e0605ae4b896a5065b9dd6d19e5b48b8d2b94","modified":1547136282000},{"_id":"source/_posts/Linux/CentOS下yum源的搭建与使用.md","hash":"5bd5eea0b8da7da9ecd7a863cd6f727c2271bc30","modified":1550122560000},{"_id":"source/_posts/Linux/CentOS 图形界面 命令行界面切换.md","hash":"4eb40c35d4796d0bc390c7d668fda85ee9fe9237","modified":1550122530000},{"_id":"source/_posts/Linux/CentOS查看硬件信息.md","hash":"7ac5d4a4afe1e899a6b2f7029b9b4720338a7963","modified":1550132219000},{"_id":"source/_posts/Linux/01_linux 配置文件启动顺序.md","hash":"8e137d369572b97f8132afdb4187d9f0854c0374","modified":1550121788000},{"_id":"source/_posts/Linux/CentOS版本说明.md","hash":"6eb4ba4de1c66412cd2028214a8895641fce19fc","modified":1550132391000},{"_id":"source/_posts/Linux/RHEL 7 中 systemctl 的用法（替代service 和 chkconfig）.md","hash":"1c766d0016ae31205c8b58cf5e7b468880ce75fd","modified":1550132458000},{"_id":"source/_posts/Linux/Linux下scp命令详解.md","hash":"d7d5fe2a66f483530deb8ce15a2002ad23c540fa","modified":1550123216000},{"_id":"source/_posts/Linux/CentOS系统GRUB.md","hash":"6c9a65041b231f820be8c2832eb72618d30a9f5c","modified":1550122594000},{"_id":"source/_posts/Linux/Shell编程入门.md","hash":"b3ee9185e3a2517ff842e7679539957dfef11a2b","modified":1550131739000},{"_id":"source/_posts/Linux/XShell使用.md","hash":"0925d2f11e9dede31e5cd3d429b36e6da7d8f324","modified":1550123730000},{"_id":"source/_posts/Linux/Shell脚本调试.md","hash":"51dc1d9b8e90158051d4b597c205402aba2a19d5","modified":1550123096000},{"_id":"source/_posts/Linux/VI编辑器使用.md","hash":"70384288a08bd538166d6932e680010315b9676b","modified":1550123661000},{"_id":"source/_posts/Linux/cat和EOF的使用+action用法.md","hash":"2ee390a6b8061d0a05766b5a6886df7b5cdc7cf4","modified":1550122989000},{"_id":"source/_posts/Linux/linux 磁盘分区工具.md","hash":"b327a92c5b387208e02011cb57c2f27974b9b8bb","modified":1550123824000},{"_id":"source/_posts/Linux/使用Vundle管理配置Vim基本插件.md","hash":"a263a5eedebe9e01375a77e6e89e1271b2c56a5b","modified":1550123600000},{"_id":"source/_posts/Linux/修改Root密码.md","hash":"9f83675505db03e8ac14a36d324b323ca4575ace","modified":1550122636000},{"_id":"source/_posts/Linux/禁用SELinux时配置错误导致系统不能够启动的解决方法.md","hash":"03b9dbdc6472ab55232e6b50a86764cca6023995","modified":1550132487000},{"_id":"source/_posts/Linux/设置网络自动启动.md","hash":"3189b9d0db9cbaac74fea44a988dd8771d43447e","modified":1550132408000},{"_id":"source/_posts/node/NW.js入门.md","hash":"5175c749ff17347861e6c2eda37462d701806904","modified":1550126569000},{"_id":"source/_posts/node/Node API学习.md","hash":"7cc98d24698e8880f81da7d8930a8bda54722818","modified":1550126660000},{"_id":"source/_posts/node/NodeJS快速入门.md","hash":"dbb1a00a8a8c4f8281e11de4e092434d046a2c0d","modified":1550126618000},{"_id":"source/_posts/其他/02_Homebrew.md","hash":"e9e69a9d274b82ddffa2271f2abb3baccde39740","modified":1550110621000},{"_id":"source/_posts/其他/2018-10-06-ngrok的使用.md","hash":"699fc633f403d013b9878473fb17a331fa1fa7b6","modified":1547136282000},{"_id":"source/_posts/其他/2019-1-02-iphone8p重装系统.md","hash":"4220a3328d3e5aae1fe49b14a4c95ae4276d03fa","modified":1550109470000},{"_id":"source/_posts/其他/UML类图大全.md","hash":"3f4bee68699a7037dbfbf5a71d206ed2078e2e15","modified":1550113248000},{"_id":"source/_posts/前端开发/.DS_Store","hash":"4cec0f7a50dcdcb87991814ff5a16e116448c1af","modified":1550128939000},{"_id":"source/_posts/其他/gitbook.md","hash":"28db8f10134a9166886930c97b5f21b3651b33e2","modified":1550112894000},{"_id":"source/_posts/其他/postman.md","hash":"73df6a3c6b3f46bbfcfc37d658e70b89070e8715","modified":1550112832000},{"_id":"source/_posts/其他/svn迁移.md","hash":"fe5a5b8b11604acd91848d2ecd612e44dfce6e0e","modified":1550132670000},{"_id":"source/_posts/前端开发/2018-10-26-CommonJS规范-AMD-CMD.md","hash":"67175f434b9ee240a99547167bdc5b9858d9bd9d","modified":1547136282000},{"_id":"source/_posts/前端开发/2018-10-26-ECMAScript规范.md","hash":"4cb65a0009bb69dd03219b75c138398749c97220","modified":1547136282000},{"_id":"source/_posts/前端开发/Angular入门.md","hash":"b1cb46881e1c9d40b7edbfb4772090233bf2392f","modified":1550129816000},{"_id":"source/_posts/前端开发/Ant Design of React+dva入门.md","hash":"3206de107d254d7791967cbc4b32eebd5acda8fc","modified":1550124236000},{"_id":"source/_posts/前端开发/Antd PRO入门.md","hash":"9a656adbb60c4c3713100cd93cee4aeb4f5742cd","modified":1550124276000},{"_id":"source/_posts/前端开发/CSS预处理技术.md","hash":"4c4de4814bee871b66512dcdfe6effee7d58a3e0","modified":1550125111000},{"_id":"source/_posts/前端开发/Express入门.md","hash":"bf50123b8a2463e9c3eb5d64d4b4927e373ba157","modified":1550124352000},{"_id":"source/_posts/前端开发/ejs模版引擎基本使用.md","hash":"9aa8d715e1e1e4e6e0018cdf091a6166539835af","modified":1550124468000},{"_id":"source/_posts/前端开发/TypeScript入门.md","hash":"488c6a50e63f43225e3b87600358cbde7a109120","modified":1550125365000},{"_id":"source/_posts/前端开发/grunt入门.md","hash":"dc5cfd64b424f1f2c6dbd18c5c3dfbfd42163bc9","modified":1550125648000},{"_id":"source/_posts/前端开发/js测试分类.md","hash":"fdc0f3ae3f152faa00b7a3039cd2556e2ed77412","modified":1550125049000},{"_id":"source/_posts/前端开发/gulp入门.md","hash":"53da47ae7b0d57778746d9b723400389237ce22a","modified":1550125589000},{"_id":"source/_posts/前端开发/pug模版引擎基本使用.md","hash":"3bfb0b448d8b41dec7ed7d44a92c28fb0c94f73c","modified":1550124415000},{"_id":"source/_posts/前端开发/readline模块的使用.md","hash":"1b5217094427216fd9b65a3f6c5302a411e34fc0","modified":1550126695000},{"_id":"source/_posts/前端开发/vue入门.md","hash":"4e4ab32867b04cdf75a938cc49801d22eb48b012","modified":1550131096000},{"_id":"source/_posts/前端开发/异步编程及Async模块的使用.md","hash":"c2a405ede9028098530378b63696af61d96acbee","modified":1550126736000},{"_id":"source/_posts/前端开发/webpack入门.md","hash":"c1c5e4561e9d22a87c129459540c2f8bebc624c8","modified":1550125535000},{"_id":"source/_posts/微信开发/2018-10-06-微信公众平台.md","hash":"4852b0fdc12ba129776ee05b68b66d2b90a4a753","modified":1547136282000},{"_id":"source/_posts/微信开发/2018-10-06-微信第三方登录.md","hash":"5992d3114868084682d93253591ba941aeb19ed5","modified":1547136282000},{"_id":"source/_posts/微信开发/AndroidStudio代码注释及Javadoc生成.md","hash":"595b1a14fab014e9eeba7f0a3979cdfb268d24cb","modified":1550135158000},{"_id":"source/_posts/微信开发/Android中主题(Theme)和样式(Style)使用.md","hash":"16e228acb1bde05df05bb3b4b239da86dc49ef62","modified":1550135081000},{"_id":"source/_posts/微信开发/Android res文件夹解析.md","hash":"c30d3d28801cc585bfe7fb7438b239d09334c129","modified":1550135055000},{"_id":"source/_posts/微信开发/Android应用坐标系及栏目.md","hash":"dc18fbd2000de7fc3f6b0ae918bfe9a6eb64752a","modified":1550135110000},{"_id":"source/_posts/微信开发/Retrofit.md","hash":"5d4395aadb2181a55762e3950a71d34935d29a75","modified":1550134677000},{"_id":"source/_posts/微信开发/Rxjava和lambda语法.md","hash":"cbc15bcd24456c703abb2694aa781066fa9b4c81","modified":1550134649000},{"_id":"source/_posts/微信开发/android中MVP模式简介.md","hash":"6c20c2188b6887477e15398d2aeb25ec5d8eaf5c","modified":1550134725000},{"_id":"source/_posts/微信开发/android中handler的使用.md","hash":"7524bafdf624b99be0b982479ffd382c65149fdf","modified":1550134201000},{"_id":"source/_posts/微信开发/android权限介绍.md","hash":"d850adb7e240a83989016a591862474e65dc3891","modified":1550135189000},{"_id":"source/_posts/微信开发/命令行启动模拟器.md","hash":"3b6754dda50c2f7cc64fcb325b859ff5e4877a80","modified":1550135260000},{"_id":"source/_posts/数据库/2018-10-05-MySQL安装-Windows.md","hash":"d1dbe1a9177c941273e3460c917176e7e4f90e2a","modified":1547136282000},{"_id":"source/_posts/数据库/2018-12-10-MongoDB.md","hash":"fb5bcc76f20ca346526627898e6a1e113739f742","modified":1550132578000},{"_id":"source/_posts/数据库/2018-12-10-MongoDB搭建.md","hash":"99613972d4e0db55414d7f72e8cc96d7b115fa52","modified":1550132595000},{"_id":"source/_posts/数据库/2018-12-10-MongoDB集群搭建.md","hash":"f4502ab87f52664661be241297aec506a76eba5e","modified":1550132604000},{"_id":"source/_posts/数据库/2018-12-12-oracle.md","hash":"4a49dbd086cdf7837ec3af4708a1de68c32ceb50","modified":1547136282000},{"_id":"source/_posts/数据库/MySQL与MariaDB对比.md","hash":"81e0ed2ca67984c9c5dc729594f2d2429fbe8c3b","modified":1550132578000},{"_id":"source/_posts/数据库/MySQL安装-Windows.md","hash":"4f9668848341887d95235e6a86d06faaaa8aad99","modified":1550113316000},{"_id":"source/_posts/数据库/SQLServer连接测试.md","hash":"ae31f49dff8a9503d5939cc087afbde4331af278","modified":1550113381000},{"_id":"source/_posts/容器技术/2018-10-18-docker.md","hash":"61371b13388bb6f8364818444f31849f80ffa068","modified":1547136282000},{"_id":"source/_posts/环境搭建/01_mac系统安装.md","hash":"3f0cf4c5a813577fd1c05294d0e9d5e26e8fcdf9","modified":1550109242000},{"_id":"source/_posts/环境搭建/03_mac虚拟机安装系统及设置.md","hash":"0e513b17b968875bc85379ce584c7b5e6492dc2e","modified":1550111005000},{"_id":"source/_posts/环境搭建/04_git安装配置.md","hash":"e91df2d0106f1e25f3833a02f3a26a0f21221dcd","modified":1550110054000},{"_id":"source/_posts/环境搭建/05_node安装.md","hash":"87f62a0aea330657bc2130a3d4274e9ecf2371af","modified":1550110069000},{"_id":"source/_posts/环境搭建/07_CentOS系统初始设置.md","hash":"a434ebff3618e98f3866a98dc8ffc0c45600b06c","modified":1550110969000},{"_id":"source/_posts/环境搭建/06_Java安装.md","hash":"fa08133b8f666bfdc27f56300648098a3f0f1866","modified":1550110924000},{"_id":"source/_posts/环境搭建/08_Ubuntu系统安装后的设置.md","hash":"d779647b4f6f69340edee513b2c6ad8e104f9898","modified":1550110110000},{"_id":"source/_posts/环境搭建/09_JetBrains系列软件安装使用.md","hash":"f95119831b821ad8cb48c8ffafec087f9cb25b5f","modified":1550110130000},{"_id":"source/_posts/环境搭建/11_VirturalBox安装.md","hash":"a8d91833723907cf1dc6d74ff43fccf444d01a77","modified":1550110204000},{"_id":"source/_posts/环境搭建/10_hexo安装配置.md","hash":"bd3edac58d39f1278205dea6c0965a0802b17929","modified":1550110151000},{"_id":"source/_posts/环境搭建/11_MySQL安装配置.md","hash":"a2a23e0afcff34597db11e07da53da02f574507a","modified":1550110164000},{"_id":"source/_posts/环境搭建/2018-10-08-Gitblit搭建git服务器.md","hash":"1f02bf176d7d41c8863f574c3c0212102cb8e1bc","modified":1550111059000},{"_id":"source/_posts/环境搭建/2018-10-02-GithubPages.md","hash":"c4e29f1baef5705975d368ef4ce4fc7ba0ce0048","modified":1550111034000},{"_id":"source/_posts/移动开发/Activity启动模式.md","hash":"c0303473b080cd0ec6016cddbfa308920a499820","modified":1550112450000},{"_id":"source/_posts/环境搭建/2018-10-08-windows-git.md","hash":"0fee3249a61b7a51f46a46da73d24ae30ea3b6f9","modified":1550111055000},{"_id":"source/_posts/移动开发/RxJava.md","hash":"0f192fec162f814709ec57c3525d0639f3eddcb0","modified":1550111560000},{"_id":"source/_posts/移动开发/Gradle3.0自动化项目构建技术.md","hash":"2fb546d63907246d25e2d713a9710991e1b94010","modified":1550111324000},{"_id":"source/_posts/移动开发/Cordova入门.md","hash":"a696ba1de61cb890e1251e144f7151cb84b3c7ca","modified":1550112347000},{"_id":"source/pub-images/gradle生命周期.png","hash":"ebc6691a71dba2e37579e0120d93c15d5a98aade","modified":1548235014000},{"_id":"source/pub-images/middleware机制示例.png","hash":"69369b3fc34f51f37f7a939317314e3bacdbb512","modified":1547136283000},{"_id":"source/pub-images/react-router-redux示例.png","hash":"56b6b7753009882f3e1312e35ea5fe6be0ae254f","modified":1547136283000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"source/_posts/2018-10-05-MySQL安装-Windows/屏幕快照 2018-09-16 下午4.08.12.png","hash":"0e43632e4b3185d9a67f09833ae0c02eceba3fac","modified":1547136282000},{"_id":"source/pub-images/Groovy元编程.png","hash":"6d792abc1619522d28a282d8f2a9926afb2dfe92","modified":1548212805000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1547136283000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1547136283000},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"f27712f349a819095cc151b9da509a97dc46776f","modified":1547136283000},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"f29b50d83bcdc9e70696b6a8a8917d8b2ad4be10","modified":1547136283000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1547136283000},{"_id":"themes/next/layout/_macro/post.swig","hash":"9314d69ba2f684f78846edfb24deeefd7209716c","modified":1547136283000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1547136283000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"33d601be7bc413d070ba00916ae77b7d694e6b3e","modified":1547136283000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a81cdb1bd26f8f67725927c7389c246ce9da41ca","modified":1550111698000},{"_id":"themes/next/layout/_partials/head.swig","hash":"898bcc59c47ec1ccd973f01be3dd0eea55e13ff4","modified":1547136283000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1547136283000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1547136283000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1547136283000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"c35d88feef06e803cbdc7676a03efea3d4816aa4","modified":1547136283000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1547136283000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1547136283000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1547136283000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1547136283000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1547136283000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1547136283000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1547136283000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1547136283000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1547136283000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1547136283000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1547136283000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1547136283000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1547136283000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1547136283000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1547136283000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1547136283000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1547136283000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1547136283000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1547136283000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1547136283000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1547136283000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1547136283000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1547136283000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1547136283000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1547136283000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1547136283000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1547136283000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1547136283000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1547136283000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1547136283000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1547136283000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1547136283000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1547136283000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1547136283000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1547136283000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1547136283000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1547136283000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1547136283000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1547136283000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1547136283000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1547136283000},{"_id":"source/_posts/2018-10-18-docker/container添加layer.png","hash":"9c62cf1315c5ffaf98f4e83e774830e6eec8c0d0","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/docker软件架构.png","hash":"4c7b9de69c05370a29adf8b2b14f769e848bc0e8","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/前后端分离项目3高部署图.png","hash":"ebd5680be239690dfd27762ce450f135f0f13116","modified":1547136282000},{"_id":"source/pub-images/虚拟机文件结构.png","hash":"168a7e3b379214f0e5bd669351bab77bc19f9884","modified":1547139770000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547136283000},{"_id":"source/_posts/2018-10-18-docker/renren-fast项目技术说明.png","hash":"cbb9703be450a37aec9ae09a28d4376246a98a1b","modified":1547136282000},{"_id":"source/pub-images/Intelij Groovy.png","hash":"afd3d087ba317021e36d7cdfb9fec0c6bcdeaae0","modified":1548135931000},{"_id":"source/pub-images/github设置.png","hash":"d9d43ef9caba8851a2c020f961be4bb5e58e5018","modified":1547142592000},{"_id":"source/pub-images/mysql.png","hash":"b171f09d61f96c9fdf42f23be9848cea995aead3","modified":1548060018000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1547136283000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1547136283000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1547136283000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1547136283000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1547136283000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1547136283000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1547136283000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1547136283000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1547136283000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1547136283000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1547136283000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1547136283000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1547136283000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1547136283000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1547136283000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1547136283000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1547136283000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1547136283000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1547136283000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1547136283000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1547136283000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1547136283000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1547136283000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1547136283000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1547136283000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1547136283000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1547136283000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1547136283000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1547136283000},{"_id":"themes/next/source/js/src/love.js","hash":"ca63890ecac4cc408a20e8772a1ffabb532c6996","modified":1547136283000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1547136283000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1547136283000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1547136283000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1547136283000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1547136283000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1547136283000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1547136283000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1547136283000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1547136283000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1547136283000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1547136283000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1547136283000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1547136283000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1547136283000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1547136283000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1547136283000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1547136283000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1547136283000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1547136283000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1547136283000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1547136283000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1547136283000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1547136283000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1547136283000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1547136283000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1547136283000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1547136283000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1547136283000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1547136283000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1547136283000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1547136283000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1547136283000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1547136283000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1547136283000},{"_id":"source/_posts/2018-10-18-docker/DevOps.png","hash":"de14307bbd87c7db9978b275846a9abf14018ba6","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/docker的client&server.png","hash":"d96d1697f246db846a8ced02feb59062899f4d0a","modified":1547136282000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1547136283000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1547136283000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1547136283000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1547136283000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1547136283000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1547136283000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1547136283000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1547136283000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1547136283000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1547136283000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1547136283000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1547136283000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1547136283000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1547136283000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1547136283000},{"_id":"source/_posts/2018-10-18-docker/Linux系统目录说明.png","hash":"5b4f118c12f050e0a0b03dd2f2ad505b4b056e49","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/前后端分离项目部署图.png","hash":"ff71311d41ae7af689e70037a661cf07ac7ee6c0","modified":1547136282000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1547136283000},{"_id":"source/_posts/2018-10-18-docker/docker物理架构.png","hash":"13d23eff12d0d6ae1a06b41699763a5ced2b5042","modified":1547136282000},{"_id":"source/pub-images/macOS制作U盘启动.png","hash":"9c8c876bc2fe737c53dc158896073dcc4bc0e864","modified":1547127077000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"1a510f995e665b28d85ba4d169b824276c40e4f3","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"90d78b7270739eaab5b054226b684631a319011a","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"f98b91ae0296e0b10c11286f68c4ad7b71471fbb","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1547136283000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1547136283000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1547136283000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1547136283000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1547136283000},{"_id":"source/_posts/2018-10-05-Windows下SVN服务器搭建及VS2015插件安装联动/VS2015+SVN环境搭建.docx","hash":"4c4a48bf2a793b1400a36459947a72b138fadb27","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/基于docker运维整体过程.png","hash":"f334e1fb4d7ee4804e524c3e54f540571cce8746","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/自动化整体过程.png","hash":"922499854267a589be6846bc3d566a60880838d6","modified":1547136282000},{"_id":"source/_posts/2018-10-18-docker/虚拟机和Doker的区别.png","hash":"bb0981a15c25412524aef1b18a03132e5568d77a","modified":1547136282000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1547136283000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1547136283000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1547136283000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1547136283000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1547136283000},{"_id":"source/pub-images/Parallels Tools.png","hash":"178613a2605e9afd5d3bd6db9b13ad63b18c25d1","modified":1547139347000},{"_id":"source/pub-images/Ecma-262.pdf","hash":"b727e3c03b5272e30f11c36a0cd114eaae91bdb8","modified":1547136283000},{"_id":"public/baidusitemap.xml","hash":"a189edeae674e75fe0f98a7abf4e916cdb571295","modified":1550135874867},{"_id":"public/search.xml","hash":"71f890bb702fadfb71900c0b3b3a3017ae156a45","modified":1550135874996},{"_id":"public/sitemap.xml","hash":"6cd8c63851f2cbb619089d67823a6d477cd30506","modified":1550135874996},{"_id":"public/categories/index.html","hash":"6928306f5eb762a308b29115929db48f0710ca59","modified":1550135875021},{"_id":"public/about/index.html","hash":"42b2d1e201f5593b0055c28037c6eb232e93b871","modified":1550135875021},{"_id":"public/archives/index.html","hash":"ce95fff6fdfd0751639f68d6560a9ccbc3a1484f","modified":1550135875022},{"_id":"public/schedule/index.html","hash":"b946cd5cfc6f4da4edbdcb2ee05b20820a8e18d3","modified":1550135875022},{"_id":"public/tags/index.html","hash":"63b242f13fa7ad9b84c88997fb3c4fa43888fb42","modified":1550135875022},{"_id":"public/2019/02/14/微信开发-Android中主题-Theme-和样式-Style-使用/index.html","hash":"ee779b726c49056082ce5bf616feba013a36a101","modified":1550135875022},{"_id":"public/2019/02/14/其他-svn迁移/index.html","hash":"9bc12528ab4d61d0995ae838d6b188bf1e381f0b","modified":1550135875022},{"_id":"public/2019/02/14/数据库-2018-12-10-MongoDB集群搭建/index.html","hash":"d70db5912f1e018f88ae7bf5e5e51bb113ad5358","modified":1550135875022},{"_id":"public/2019/02/14/数据库-2018-12-10-MongoDB搭建/index.html","hash":"13e4c4068ae2e2f46dfd8759485119dce5b82ad6","modified":1550135875022},{"_id":"public/2019/02/14/数据库-MySQL与MariaDB对比/index.html","hash":"f6a679877455b66af8e3ef61221c2ac7ae86f709","modified":1550135875022},{"_id":"public/2019/02/14/数据库-2018-12-10-MongoDB/index.html","hash":"f5f675941759ba841d69d8fde35b629bc6d57ce5","modified":1550135875022},{"_id":"public/2019/02/14/Linux-禁用SELinux时配置错误导致系统不能够启动的解决方法/index.html","hash":"618c9a4e06c71221450694074699b140b557683f","modified":1550135875022},{"_id":"public/2019/02/14/Linux-RHEL-7-中-systemctl-的用法（替代service-和-chkconfig）/index.html","hash":"d4bb9abee3caae70d485321ab669896758c438be","modified":1550135875022},{"_id":"public/2019/02/14/Linux-设置网络自动启动/index.html","hash":"241c08a40eed79ea7d72be94cbb8932e2e4b2e44","modified":1550135875022},{"_id":"public/2019/02/14/Linux-CentOS版本说明/index.html","hash":"54e8a1cc8de981060f8186ccb789f1b8b3271934","modified":1550135875022},{"_id":"public/2019/01/02/Java-2019-01-02-Java并发编程/index.html","hash":"cf6744608a4dbb4c1bc001cf5986bcbd16ac1261","modified":1550135875022},{"_id":"public/2018/12/19/Java-2018-12-19-aa/index.html","hash":"696bb6527583a7a812df71406689c47e227108d8","modified":1550135875022},{"_id":"public/2018/12/19/Linux-CentOS下yum源的搭建与使用/index.html","hash":"0982b405ea3c799cd1d62f44566e986256ee237f","modified":1550135875022},{"_id":"public/2018/12/19/Linux-CentOS-图形界面-命令行界面切换/index.html","hash":"2e32860ff81f73ed636075c9409a8291c647c5d4","modified":1550135875022},{"_id":"public/2018/12/19/Linux-Linux下scp命令详解/index.html","hash":"12a6bbafb61ae69bda53552bbeae261af50bffe5","modified":1550135875022},{"_id":"public/2018/12/19/Linux-CentOS系统GRUB/index.html","hash":"de2790a230ed98aa5cd53f4a0c8078a2e46f9350","modified":1550135875023},{"_id":"public/2018/12/19/Linux-XShell使用/index.html","hash":"bac9fea37bd590085f2d7f706d48ad42bf3bccb9","modified":1550135875023},{"_id":"public/2018/12/19/Linux-Shell脚本调试/index.html","hash":"6488a3a10920550d27f1f0c350c3c952114c9436","modified":1550135875023},{"_id":"public/2018/12/19/Linux-VI编辑器使用/index.html","hash":"3903cfd9a123014d769ea8e2ee51de266fe4bb74","modified":1550135875023},{"_id":"public/2018/12/19/Linux-cat和EOF的使用-action用法/index.html","hash":"6778056660037f543452f6fdd93d7c11679154c7","modified":1550135875023},{"_id":"public/2018/12/19/Linux-linux-磁盘分区工具/index.html","hash":"a247bf2508bc6ae59d3da459527448d2261a4040","modified":1550135875023},{"_id":"public/2018/12/19/Linux-使用Vundle管理配置Vim基本插件/index.html","hash":"da88303266ad98c7c8895618c80c9df545751287","modified":1550135875023},{"_id":"public/2018/12/19/Linux-修改Root密码/index.html","hash":"650e322fd78b21214aa05fe2179c5584ef18585b","modified":1550135875023},{"_id":"public/2018/12/19/其他-02-Homebrew/index.html","hash":"c8d9891c83fab75481ade0c7c412d64851159b1e","modified":1550135875023},{"_id":"public/2018/12/19/其他-UML类图大全/index.html","hash":"49aae2caab8d1114896b24a82eff5499117a2f82","modified":1550135875023},{"_id":"public/2018/12/19/其他-gitbook/index.html","hash":"bf454db6abd6f9df169c6753c77c5c381b4e8c2c","modified":1550135875023},{"_id":"public/2018/12/19/其他-postman/index.html","hash":"4bb07c5065a1ee22eb383f002b4bae651740c353","modified":1550135875023},{"_id":"public/2018/12/19/环境搭建-01-mac系统安装/index.html","hash":"40cb3f9e35cab9d5df8a7cc1f2010b443042c443","modified":1550135875023},{"_id":"public/2018/12/19/环境搭建-03-mac虚拟机安装系统及设置/index.html","hash":"5dd0705aa4818884730804d2fb66765479797acb","modified":1550135875023},{"_id":"public/2018/12/19/环境搭建-04-git安装配置/index.html","hash":"57f27e589bf6250d59cee4117e9f40420481e7b9","modified":1550135875023},{"_id":"public/2018/12/19/环境搭建-05-node安装/index.html","hash":"f97da9dcb93689bd4a4616adae5cca68b6edfe83","modified":1550135875023},{"_id":"public/2018/12/19/环境搭建-07-CentOS系统初始设置/index.html","hash":"947fc0c5cc52c0c6a26b865188651b812f34b65d","modified":1550135875023},{"_id":"public/2018/12/19/环境搭建-06-Java安装/index.html","hash":"066836272063d897c546caf2e8504f2434566152","modified":1550135875024},{"_id":"public/2018/12/19/环境搭建-08-Ubuntu系统安装后的设置/index.html","hash":"6a825313152dc0e3e366de37b1baab28d60fca2e","modified":1550135875024},{"_id":"public/2018/12/19/环境搭建-09-JetBrains系列软件安装使用/index.html","hash":"d3fb7e63552ce005f8095c93f6ce51ea514e4867","modified":1550135875024},{"_id":"public/2018/12/19/Linux-01-linux-配置文件启动顺序/index.html","hash":"bbd3dd23bbc55083613999e8dbf504a3ad929c60","modified":1550135875024},{"_id":"public/2018/12/19/Linux-Shell编程入门/index.html","hash":"53d1e2c15051c16bcba97a7bdee2e7e7571d2c95","modified":1550135875024},{"_id":"public/2018/12/12/数据库-2018-12-12-oracle/index.html","hash":"129714fc0af810dd44b7624de8dc106eef1565a3","modified":1550135875024},{"_id":"public/2018/12/10/Java-2018-12-10-MyBatis/index.html","hash":"0344689e983a5ba71ab4bd81c88925f74402a1df","modified":1550135875024},{"_id":"public/2018/11/26/Java-2018-11-26-Kotlin/index.html","hash":"beea4083db511da72e74978074f3a8400ecf2315","modified":1550135875024},{"_id":"public/2018/11/26/Java-Java8-特性/index.html","hash":"15c99717035e31d4f4ef06ade13f1b38a60cd107","modified":1550135875024},{"_id":"public/2018/11/26/Linux-CentOS查看硬件信息/index.html","hash":"b1488d123e0da32d593b7b896d977a8ab38fd165","modified":1550135875024},{"_id":"public/2018/11/26/Java-2018-11-26-SpringBoot/index.html","hash":"39071a936c281841d62dcf674c5c30221199d083","modified":1550135875024},{"_id":"public/2018/11/02/C-开发-2018-11-02-NuGet/index.html","hash":"f92d1b0a21a70d305c01ccd0336b82798ffb88e1","modified":1550135875024},{"_id":"public/2018/10/26/node-NW-js入门/index.html","hash":"2d96329d999403fcd0b3281210934e2a228fbb07","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-2018-10-26-ECMAScript规范/index.html","hash":"4b401c3a0498f9df07b6ad2d75a43bd9aafdeea9","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-Angular入门/index.html","hash":"15c3e03d121addfec3d9edc2c539a75ec8813b46","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-Ant-Design-of-React-dva入门/index.html","hash":"fd4e0c1dc1bca1b2df589460f3df81756de4e811","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-Antd-PRO入门/index.html","hash":"d364a2bc430e72c53340787dc7ddf9f19e95b114","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-CSS预处理技术/index.html","hash":"ceb7ad61a765d539f34e0a5f8d3c99a5ec46a36e","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-ejs模版引擎基本使用/index.html","hash":"5508a3a193b117bfd0a211b2b76338107177516a","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-TypeScript入门/index.html","hash":"8f2a3cdf4ebf8be05cd1a9a5f791efb8ddce32f9","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-js测试分类/index.html","hash":"7b051de62d21e2ec7d5bee22740d47b033d49c34","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-pug模版引擎基本使用/index.html","hash":"9d6f83fe48257b39f467cff17bfd1058c9e3d798","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-readline模块的使用/index.html","hash":"bf866c0827009ad53bf18210f1e0a5f90badf436","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-异步编程及Async模块的使用/index.html","hash":"642f6a0304640e8b4a7966a87fc7b9f274a5bf21","modified":1550135875025},{"_id":"public/2018/10/26/node-Node-API学习/index.html","hash":"cc0ce3b398e3294640e0de897144011a52ad2aa7","modified":1550135875025},{"_id":"public/2018/10/26/node-NodeJS快速入门/index.html","hash":"4a1836a5a4174c9de6888b512aebfba7de27a405","modified":1550135875025},{"_id":"public/2018/10/26/前端开发-Express入门/index.html","hash":"5ebc9ce8c3194d9df465382cb717d7ded64e90e7","modified":1550135875026},{"_id":"public/2018/10/26/前端开发-grunt入门/index.html","hash":"2b0e471ca455e21bc6230a729d1eef438e4d412d","modified":1550135875026},{"_id":"public/2018/10/26/前端开发-gulp入门/index.html","hash":"661eea745d854e995d329dc6d4a231ec350fbb00","modified":1550135875026},{"_id":"public/2018/10/26/前端开发-vue入门/index.html","hash":"5d90a3ebd678fabc64ca662882c9ab7cfebf6f33","modified":1550135875026},{"_id":"public/2018/10/26/前端开发-webpack入门/index.html","hash":"9584ec8855c95dc2c260d5183949f480989b398c","modified":1550135875026},{"_id":"public/2018/10/26/前端开发-2018-10-26-CommonJS规范-AMD-CMD/index.html","hash":"2b6d5111e1ffa262e1b3591a02c17a7bfc154cae","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-middleware/index.html","hash":"80a3c4105a947922d0778529fbfbcb0e888e48bb","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-redux-thunk/index.html","hash":"a122749edd8e98954e34f071880fef9cee41f07f","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-React相关需学习/index.html","hash":"1fd61d2a3a55b58fab52d789ec611dce117aa8eb","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-Jest/index.html","hash":"a4f671515437f793590bdad8f78e875179f453ec","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-react-router-redux/index.html","hash":"f14acc16e15bc3cd30f83e29d0d722a39047e697","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-Redux入门/index.html","hash":"da4159bf08feddeb8073dece5659e677d334b2b3","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-React-Router/index.html","hash":"f9ff2d716bf4fff80d00752a9e7771262cee9a5c","modified":1550135875026},{"_id":"public/2018/10/26/react-rn-2018-10-26-React入门/index.html","hash":"fae2a1c6b12157d32edfee610c9c999018df0fb1","modified":1550135875026},{"_id":"public/2018/10/18/容器技术-2018-10-18-docker/index.html","hash":"4221a5d1011f768a23d77ec4bc1e52392d94b422","modified":1550135875026},{"_id":"public/2018/10/17/C-开发-2018-10-17-C/index.html","hash":"ac9121a892b20d618ca33fcddd0f2cfaa0e792d7","modified":1550135875027},{"_id":"public/2018/10/15/react-rn-2018-10-15-React全家桶/index.html","hash":"8f379ec3580064c36be7e2349a2ae89a7fd0569d","modified":1550135875027},{"_id":"public/2018/10/08/环境搭建-2018-10-08-windows-git/index.html","hash":"65e7c4b482a87bdf60ad382e2fa66d34e128d392","modified":1550135875027},{"_id":"public/2018/10/08/环境搭建-2018-10-08-Gitblit搭建git服务器/index.html","hash":"97e1ad8ff4ed981858365e5023f6b2bfc2eead3f","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-2018-10-06-微信公众平台/index.html","hash":"9b7c96e68ce48fbc0757df93c254530d1ab09eda","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-AndroidStudio代码注释及Javadoc生成/index.html","hash":"44a4d06dca82ee840eae51ca82bbef91a6f45573","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-Android-res文件夹解析/index.html","hash":"0ce946bfcd414e11d81d1cf5c4890b99e8a6844a","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-Android应用坐标系及栏目/index.html","hash":"3ce74abf253e5f87e7768cac0ae65289abb333bc","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-Retrofit/index.html","hash":"de7c4925a6f0bc134c959a2a1bfb2b81a70de7b3","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-Rxjava和lambda语法/index.html","hash":"8c5cac083f8488a080ad9547b584b91bbddbf2b2","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-android中MVP模式简介/index.html","hash":"2a82071986eca06bf21010ffe6d22f8219d5718e","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-android中handler的使用/index.html","hash":"3bc77bc86c820a25f6b7f0f1371fc0a53e98dc66","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-android权限介绍/index.html","hash":"a0317e6410d6b438ef652733dbc82d86a452f13e","modified":1550135875027},{"_id":"public/2018/10/06/微信开发-命令行启动模拟器/index.html","hash":"f4ef2a66696bbef87d3873f498f334a69fe8fa60","modified":1550135875027},{"_id":"public/2018/10/06/其他-2018-10-06-ngrok的使用/index.html","hash":"1951edaa9a73ad60f76f884c78d30437c03f3985","modified":1550135875028},{"_id":"public/2018/10/06/微信开发-2018-10-06-微信第三方登录/index.html","hash":"38307bebb33191df3c2b5763bd9fa496485ca3a1","modified":1550135875028},{"_id":"public/2018/10/06/C-开发-2018-10-06-ASP-NET-HTML表单元素/index.html","hash":"9685c2ff0a3247fc2b55477499efe804aa69468d","modified":1550135875028},{"_id":"public/2018/10/05/C-开发-2018-10-05-ASP-NET-WebForms使用/index.html","hash":"75ef5ad087b1d8391f0b4c0c30bf4e2e3acdfb1d","modified":1550135875028},{"_id":"public/2018/10/05/C-开发-2018-10-05-ASP-NET-MVC使用/index.html","hash":"71cc905eb60b6ec5cfb70989610272deeaba245f","modified":1550135875028},{"_id":"public/2018/10/05/C-开发-2018-10-05-Razor使用/index.html","hash":"ea220bfbfa1cc0ddafeb79687c48244f5c4fde5f","modified":1550135875028},{"_id":"public/2018/10/05/C-开发-2018-10-05-WebPages/index.html","hash":"c3ff2093f4c017bf818688a10d36737190062eea","modified":1550135875028},{"_id":"public/2018/10/05/C-开发-2018-10-05-ASP-NET/index.html","hash":"65b41d4a428546ee8bb72e29314d2b935850bac5","modified":1550135875028},{"_id":"public/2018/10/05/C-开发-2018-10-05-Windows下SVN服务器搭建及VS2015插件安装联动/index.html","hash":"3dd62833854d619ec3bca4d22a8766126fd6fe25","modified":1550135875028},{"_id":"public/2018/10/05/CI-Jekins/index.html","hash":"d35ac58f40874e6fd41c0bf39848d1ced328d69f","modified":1550135875028},{"_id":"public/2018/10/05/数据库-2018-10-05-MySQL安装-Windows/index.html","hash":"3c226a580907a2088b1f01a3c61aca6b85cdbfbd","modified":1550135875028},{"_id":"public/2018/10/05/数据库-MySQL安装-Windows/index.html","hash":"7916cbe828a02eb7478da3e91d62caf68873c39c","modified":1550135875028},{"_id":"public/2018/10/05/数据库-SQLServer连接测试/index.html","hash":"ee6751e9c70d606e5b6f87872e9f5602935f8abf","modified":1550135875028},{"_id":"public/2018/10/04/环境搭建-11-VirturalBox安装/index.html","hash":"0ec5667f3a3de37808ce4d21582a9f4bd3ccbbd6","modified":1550135875028},{"_id":"public/2018/10/04/环境搭建-10-hexo安装配置/index.html","hash":"1144a901cbb2d94c1036929b9bfa43d6f6098a9b","modified":1550135875028},{"_id":"public/2018/10/04/环境搭建-11-MySQL安装配置/index.html","hash":"80693f4bcb2b297c42ae490aab7376c8ab314c46","modified":1550135875028},{"_id":"public/2018/10/02/环境搭建-2018-10-02-GithubPages/index.html","hash":"cebe01c3022180ecb424dc34961648b8725f2d87","modified":1550135875029},{"_id":"public/2018/10/02/移动开发-Activity启动模式/index.html","hash":"41a5975eb8e6e27dfda326409a338ba0f6f5d98f","modified":1550135875029},{"_id":"public/2018/10/02/移动开发-RxJava/index.html","hash":"744267ed515eb372b738cc5d12a3f0fb08ac3545","modified":1550135875029},{"_id":"public/2018/10/02/移动开发-Gradle3-0自动化项目构建技术/index.html","hash":"39e8b86df7c6d859eb81755aa50407877345ab43","modified":1550135875029},{"_id":"public/2018/10/02/移动开发-Cordova入门/index.html","hash":"023f97040e719a73929bd12fa2318cff515b4acd","modified":1550135875029},{"_id":"public/2018/01/02/其他-2019-1-02-iphone8p重装系统/index.html","hash":"bf3842eab6628c4d903b596367cc71aa1cf4532d","modified":1550135875029},{"_id":"public/archives/page/2/index.html","hash":"4cc0c1d4c7e42469f8bfe01d5f6b861486cbd1cc","modified":1550135875029},{"_id":"public/archives/page/3/index.html","hash":"d019307a7b839db1500898c067eded6063c20ed4","modified":1550135875029},{"_id":"public/archives/page/4/index.html","hash":"7561f1616ac085812b665d6ed2f07eb7547fce90","modified":1550135875029},{"_id":"public/archives/page/5/index.html","hash":"14ab0f958e1b49fcc9490e9ceada4d385c26b216","modified":1550135875029},{"_id":"public/archives/page/6/index.html","hash":"de1632451c4c3a589ee5e22ab85a96d7fb72150a","modified":1550135875029},{"_id":"public/archives/page/7/index.html","hash":"de2d6f9482cafb03d2157b1c28a1bed0489bf995","modified":1550135875029},{"_id":"public/archives/page/8/index.html","hash":"a6c91bc3bfe2adf1e88a2a92666e85cf751742f3","modified":1550135875029},{"_id":"public/archives/page/9/index.html","hash":"ee2177096f92d89444dae5317c638b60ae40ccb9","modified":1550135875029},{"_id":"public/archives/page/10/index.html","hash":"2ced1dfabd545bb53a198ac56e3e7cdd97e3baac","modified":1550135875029},{"_id":"public/archives/page/11/index.html","hash":"da55568926f2634daa659e896c4b3c2b66f79699","modified":1550135875030},{"_id":"public/archives/2018/index.html","hash":"c8e5719e302ac490bd3527677bff550239d731a7","modified":1550135875030},{"_id":"public/archives/2018/page/2/index.html","hash":"0cc76989d9fdf84ddc30ed18edf6d364a3a5b4ae","modified":1550135875030},{"_id":"public/archives/2018/page/3/index.html","hash":"7f59515047ecc7c8d7d6456b6380a08d79f4d2b6","modified":1550135875030},{"_id":"public/archives/2018/page/4/index.html","hash":"f33b19e055e24d296dba85d9c0e2ab5377e1fe0a","modified":1550135875030},{"_id":"public/archives/2018/page/5/index.html","hash":"a17c6e8ca0105da178b33ea870bd2e5f098b6651","modified":1550135875030},{"_id":"public/archives/2018/page/6/index.html","hash":"450a6fd8347ef605372161c1f1d1d135dc20df69","modified":1550135875030},{"_id":"public/archives/2018/page/7/index.html","hash":"a5aa8efeaefe19dd93e1a9dd091a7b51474804e3","modified":1550135875030},{"_id":"public/archives/2018/page/8/index.html","hash":"015ac63c45d2436f9f82158169d8b55dafd26b17","modified":1550135875030},{"_id":"public/archives/2018/page/9/index.html","hash":"963d6d8a32ff8978095120f4e539ed03f03e0e2a","modified":1550135875030},{"_id":"public/archives/2018/page/10/index.html","hash":"4a9f6e8c791f7cd05c7e111a5cedd6ed28d92b0a","modified":1550135875030},{"_id":"public/archives/2018/01/index.html","hash":"542e5e05f2dd58449c94d5afeea3787caffc5482","modified":1550135875030},{"_id":"public/archives/2018/10/index.html","hash":"65ff0dc30931c0ac9069effb087199e4bd74c5ce","modified":1550135875030},{"_id":"public/archives/2018/10/page/2/index.html","hash":"45b8b3b642f1222b11f145443303f38519121d3a","modified":1550135875030},{"_id":"public/archives/2018/10/page/3/index.html","hash":"c302b32157bceb0a883f2e5ba0b200a81d186fe7","modified":1550135875030},{"_id":"public/archives/2018/10/page/4/index.html","hash":"42790a7aa18798e1d51fdbe2626ce44a0d943a51","modified":1550135875030},{"_id":"public/archives/2018/10/page/5/index.html","hash":"e23fa8b13fe758e3ddd6c38965b7a8d653f117b5","modified":1550135875030},{"_id":"public/archives/2018/10/page/6/index.html","hash":"612979f829f857a445ef50af4999d06e4dad6c61","modified":1550135875030},{"_id":"public/archives/2018/10/page/7/index.html","hash":"ae299bc97507180a349234e9d1d685319fa0f5db","modified":1550135875030},{"_id":"public/archives/2018/11/index.html","hash":"98f3de515b07d61fa9a62c052841d5a34757a4a0","modified":1550135875030},{"_id":"public/archives/2018/12/index.html","hash":"96f226a4fedeee06f75b078c303e0fbee9904ce5","modified":1550135875030},{"_id":"public/archives/2018/12/page/2/index.html","hash":"c907908db117d321906bba7818311af6dcd67253","modified":1550135875030},{"_id":"public/archives/2018/12/page/3/index.html","hash":"061231a95b127722d9c83dbdf9c54a212e103483","modified":1550135875030},{"_id":"public/archives/2019/index.html","hash":"155feecd01a3375784455c1a5818b4316318d4e8","modified":1550135875030},{"_id":"public/archives/2019/page/2/index.html","hash":"daf04f02e3a77ba794e0d6b9e137c69984f2fa48","modified":1550135875030},{"_id":"public/archives/2019/01/index.html","hash":"ac25d3008bc104975c619e8dfb0ceab249a74ed5","modified":1550135875031},{"_id":"public/archives/2019/02/index.html","hash":"18ec310217047e380f34b817a6bbbcec8fba7e0b","modified":1550135875031},{"_id":"public/categories/工具/index.html","hash":"270b85f6a78b9a32125c932cd111be8f541cfb54","modified":1550135875031},{"_id":"public/categories/Java/index.html","hash":"ea909d5c49f436d035ad8093c1778e9e18e07c07","modified":1550135875031},{"_id":"public/categories/Kotlin/index.html","hash":"d54a13eb1b0e6209d2d7a5b0613ed757adfe6e7e","modified":1550135875031},{"_id":"public/categories/Spring/index.html","hash":"77530b109dd93467902b709f1c240ead22563444","modified":1550135875031},{"_id":"public/categories/C/index.html","hash":"75ca644aeb3c1f683908c1750f336ec74688f53a","modified":1550135875031},{"_id":"public/categories/react/index.html","hash":"b0203d0737b853c04d5e457779c8e9910934da1a","modified":1550135875031},{"_id":"public/categories/React/index.html","hash":"385ffd898779232899b77966cdebedd2a6bd86be","modified":1550135875031},{"_id":"public/categories/Linux/index.html","hash":"e2549b1e4795463a90f35ac6770476601ce5ea7c","modified":1550135875031},{"_id":"public/categories/Linux/page/2/index.html","hash":"f39003854f04329956327c3d6e1f49558075cfbc","modified":1550135875031},{"_id":"public/categories/前端/index.html","hash":"3f3e73ef5f3b2e1cef07d237cc0aa615a98ad461","modified":1550135875031},{"_id":"public/categories/前端/page/2/index.html","hash":"1a5bfe9a8312365a34621732232b9a154845696d","modified":1550135875031},{"_id":"public/categories/其他/index.html","hash":"7a34ec26b84f836b161f0fecb9706bf7a363d659","modified":1550135875031},{"_id":"public/categories/微信/index.html","hash":"3c6066920a1c02343bb929355a05e6abec557465","modified":1550135875031},{"_id":"public/categories/移动开发/index.html","hash":"0f247bbde9940a724b7a2dfaca0b99aa0b0ba188","modified":1550135875032},{"_id":"public/categories/移动开发/page/2/index.html","hash":"9bce9579246216039efc6b70f68df09404ff7a44","modified":1550135875032},{"_id":"public/categories/数据库/index.html","hash":"2dc44f0a3e41f8d0920775b08c2b58b127b37a67","modified":1550135875032},{"_id":"public/categories/环境搭建/index.html","hash":"02c20770df24972a3a0b83ac1db0858405cf83b4","modified":1550135875032},{"_id":"public/categories/环境搭建/page/2/index.html","hash":"1709dfd61c787ef7f72f5b066c4a52f20251557f","modified":1550135875032},{"_id":"public/categories/docker/index.html","hash":"cb5d9a25dcd10fe331252beee4d55526323c296c","modified":1550135875032},{"_id":"public/index.html","hash":"cfda6b189def219816e782228cfa3e1e9a20599f","modified":1550135875032},{"_id":"public/page/2/index.html","hash":"1bc70cdb1d742da8f2ec3d69d4f7aa585cd0bf0b","modified":1550135875033},{"_id":"public/page/3/index.html","hash":"29d9058b76cdbaed5dca67db9c3211f804e41a36","modified":1550135875033},{"_id":"public/page/4/index.html","hash":"79c57798dcff24a9e09163d51b5892ec36ccb35b","modified":1550135875033},{"_id":"public/page/5/index.html","hash":"b8b4094e0f5625916ef3c0b5f14ad2044d2d690e","modified":1550135875033},{"_id":"public/page/6/index.html","hash":"42d6abdf80ce282f074b80ca3136c7c8bcbfc9bb","modified":1550135875033},{"_id":"public/page/7/index.html","hash":"db8ec7cfddea9270f5fd62b5f1a04d76dd2c4b06","modified":1550135875033},{"_id":"public/page/8/index.html","hash":"d8f6eda228d810c43d300674d40fc10cb6062bcb","modified":1550135875033},{"_id":"public/page/9/index.html","hash":"abb32b6dec5ff964657a9263e60c6e8b6f2e9d08","modified":1550135875033},{"_id":"public/page/10/index.html","hash":"db9d92664c864453f1f3e32237c0e672393e5c51","modified":1550135875033},{"_id":"public/page/11/index.html","hash":"21029127b5e9dc31c0a0ddb86b328cacba11afc5","modified":1550135875033},{"_id":"public/tags/持续集成/index.html","hash":"1ae1884c7632ccc9b21bcf36bc44aa624ee08160","modified":1550135875033},{"_id":"public/tags/MyBatis/index.html","hash":"ed150e4686d5ec79068868f66c236f9ed1df141c","modified":1550135875033},{"_id":"public/tags/Kotlin/index.html","hash":"19b8513b148559042265d6e0be0d4a4e8ae7f647","modified":1550135875034},{"_id":"public/tags/Spring-Boot/index.html","hash":"3f27d833f88144d85d830cf28752d0fb92274281","modified":1550135875034},{"_id":"public/tags/并发编程/index.html","hash":"15a908c3c12e12e91f4e8cb94580b63fef0e0066","modified":1550135875034},{"_id":"public/tags/Java/index.html","hash":"9eba3c01dbeb44ec74da1d9ee21563be39f13fda","modified":1550135875034},{"_id":"public/tags/ASP-NET/index.html","hash":"379f336c9f4fb05ace995557a1356f5fa1da3d31","modified":1550135875034},{"_id":"public/tags/MVC/index.html","hash":"66eb9125dcb556ebadaada21e100f299516d6df7","modified":1550135875034},{"_id":"public/tags/WebForms/index.html","hash":"4d0412dd6b67bc73ac3488963f79841fb464f07a","modified":1550135875034},{"_id":"public/tags/Razor/index.html","hash":"f55f13f9a7da4ccbe3dc5e258f981ec8e83e2740","modified":1550135875034},{"_id":"public/tags/WebPages/index.html","hash":"2f4160ab87803efc01912087222d2a291cb563e7","modified":1550135875034},{"_id":"public/tags/工具/index.html","hash":"b18a21f7cd6feb55118c665da21d599c23202ea4","modified":1550135875034},{"_id":"public/tags/版本控制/index.html","hash":"a442732a28c165c9f47d112aa7a4a1bad6380417","modified":1550135875034},{"_id":"public/tags/HTML表单元素/index.html","hash":"9b32cc701193bc287a086fc7ec754806beb8290c","modified":1550135875034},{"_id":"public/tags/C/index.html","hash":"d369e371c00db93850a934de891bf8bb4318a484","modified":1550135875034},{"_id":"public/tags/react/index.html","hash":"c15fad41dceb79cefce815c0ea5e71773501e3ea","modified":1550135875034},{"_id":"public/tags/Antd/index.html","hash":"adfe80ae9acaef0c7104398552c314a436340e22","modified":1550135875034},{"_id":"public/tags/React/index.html","hash":"469deadd37a12b0efd8b41a83955c1a2d1078dd0","modified":1550135875034},{"_id":"public/tags/React-Router/index.html","hash":"d610d93f616a86f1a4a2eee8d44092bd10c6734b","modified":1550135875035},{"_id":"public/tags/React组件/index.html","hash":"851bffab68c0a1f1804b69478db9046e63e1f47e","modified":1550135875035},{"_id":"public/tags/redux组件库/index.html","hash":"5b7a5c986a9039fbe1944303cdcfaaf70c0226d4","modified":1550135875035},{"_id":"public/tags/CentOS/index.html","hash":"3cc9a29851ca511ca2b7f7af6e2b7e0313dedfe5","modified":1550135875035},{"_id":"public/tags/CentOS/page/2/index.html","hash":"4411c80f89c2ba3b5b8a0ac76973474cd08a015b","modified":1550135875035},{"_id":"public/tags/nw/index.html","hash":"a2fcdef86bd04b9154549ca231d89c0c07d085fc","modified":1550135875035},{"_id":"public/tags/node/index.html","hash":"ef171b3ce1a6620dc1cc80385e0ca61a43bc4556","modified":1550135875035},{"_id":"public/tags/node/page/2/index.html","hash":"a706ba3ca126d6e34b548f36749c7445ea0d73a5","modified":1550135875035},{"_id":"public/tags/mac工具/index.html","hash":"a98ccb2c80de581453a43069b93f28233238c3aa","modified":1550135875035},{"_id":"public/tags/ngrok/index.html","hash":"1d6dafcc5a8d7e4d727d5d1c75db2ef1fc40bfc2","modified":1550135875035},{"_id":"public/tags/网络工具/index.html","hash":"8ccfbe107e9f44a6cb19194f0e48eb4b2d122515","modified":1550135875035},{"_id":"public/tags/忘记锁屏密码/index.html","hash":"113cb8dde9a4a72f1e6c84a318efe28662ed4986","modified":1550135875035},{"_id":"public/tags/UML类图/index.html","hash":"bee7e7acaec2013e901c643c3ee5cd8abbfee7be","modified":1550135875035},{"_id":"public/tags/gitbook/index.html","hash":"efe5f067114d46d94db754249480a2175a9366ab","modified":1550135875035},{"_id":"public/tags/git/index.html","hash":"bd0453df7436699553c51236f97ec1960f9e680a","modified":1550135875035},{"_id":"public/tags/postman/index.html","hash":"e64872058d97b1012bc9bf99d940563044c51432","modified":1550135875035},{"_id":"public/tags/SVN/index.html","hash":"59d694af618edbbaa94f10ad0da3099c496c3a00","modified":1550135875035},{"_id":"public/tags/前端规范/index.html","hash":"bdf730abb2d0c3a08c0ce0daadf536a0badcde12","modified":1550135875035},{"_id":"public/tags/Angular/index.html","hash":"e3c2afc81b3d80f5dd50837fef39bf09e9645bbc","modified":1550135875036},{"_id":"public/tags/dva/index.html","hash":"5b8f0325ad396ce7ad6698f1b1afccb67aef41bb","modified":1550135875036},{"_id":"public/tags/CSS/index.html","hash":"ec558f9700b3799091f49db345d9b3a3637d739b","modified":1550135875036},{"_id":"public/tags/TypeScript/index.html","hash":"107390d20ead52eddfa446c7238802dac5678765","modified":1550135875036},{"_id":"public/tags/Express/index.html","hash":"86cbb62a2cd46fd51f906918121bfb3d7ec39573","modified":1550135875036},{"_id":"public/tags/微信公众平台/index.html","hash":"0c21ae65c8a2c00d01c014cc97af4fb332a80492","modified":1550135875036},{"_id":"public/tags/微信/index.html","hash":"2639f19fb4a1fc45066fd3434e2963195ee80a12","modified":1550135875036},{"_id":"public/tags/android/index.html","hash":"5cabf64a5891417478365c6a7759ec3afbf12669","modified":1550135875036},{"_id":"public/tags/MySQL/index.html","hash":"1b7a10dcce91243fc8bb23904ee017deb0d84516","modified":1550135875036},{"_id":"public/tags/数据库/index.html","hash":"5de251858cd00cec412d03ce875c72c9f08ae105","modified":1550135875036},{"_id":"public/tags/MongoDB/index.html","hash":"a42e9a88f099c45b10ef5a2c80db8886c8671a55","modified":1550135875036},{"_id":"public/tags/SQLServer/index.html","hash":"3d9cd87702effc7acdfff0c49b7430d13f1480dc","modified":1550135875036},{"_id":"public/tags/环境搭建/index.html","hash":"5381a11f522726e6bd756868c5bff06905dd734f","modified":1550135875037},{"_id":"public/tags/Linux/index.html","hash":"4aa11e58cc1b0d98dad0f824ddfffcd28837d35f","modified":1550135875037},{"_id":"public/tags/ubuntu/index.html","hash":"5b2d4015e970e250086893c95f182e3a4a559e31","modified":1550135875037},{"_id":"public/tags/容器技术/index.html","hash":"c074274b055c259caa940fddb97d1d3c6033cc28","modified":1550135875037},{"_id":"public/tags/hexo/index.html","hash":"3901baa882452eb292e5878d4ff7cd1d38dc2df7","modified":1550135875037},{"_id":"public/tags/github/index.html","hash":"b2243313b23f4fb62bad4f8f36cd9f1b63b16373","modified":1550135875037},{"_id":"public/tags/Android/index.html","hash":"6a4bc33140f81235e11eeb5d11d8a2ee0dd89298","modified":1550135875037},{"_id":"public/tags/andrioid/index.html","hash":"009bd0cf123b33652c925dc715d15319629f05db","modified":1550135875037},{"_id":"public/tags/RxJava/index.html","hash":"b8a9a6e2b043229581fd735767e144fb9023b436","modified":1550135875037},{"_id":"public/tags/Redux/index.html","hash":"b8a0775958cb8141554982bfc6d3c5e9576394bd","modified":1550135875037},{"_id":"public/tags/Vue/index.html","hash":"32565e605c744c767910681399fc6552001d021e","modified":1550135875037},{"_id":"public/tags/Oracle/index.html","hash":"c3023aaa6606a9692dd150e624097f4c7b229856","modified":1550135875037},{"_id":"public/tags/Shell编程/index.html","hash":"36c69d812a89381ae016c6681357f7834df72322","modified":1550135875037},{"_id":"public/tags/docker/index.html","hash":"485d2391d2bee08b9b2db7577b49b572513492a0","modified":1550135875037},{"_id":"public/tags/Gradle/index.html","hash":"02c052b86e960505b0812df3a32e63810bda4c02","modified":1550135875037},{"_id":"public/tags/Cordova/index.html","hash":"2d98fd3f9cbae7d802d5f1e355903bd97c74ecab","modified":1550135875038},{"_id":"public/pub-images/git.png","hash":"3a423ec78672ac41dcd934f171eb8a454fe09fc5","modified":1550135875055},{"_id":"public/pub-images/redux-middleware2.png","hash":"c63e7d649ece3473643ab848fb5ccd9547264ca4","modified":1550135875055},{"_id":"public/pub-images/redux-middleware1.png","hash":"9b3e423778b1b3c542e5d15635e4ceeb8e62976e","modified":1550135875055},{"_id":"public/pub-images/redux组件配合原理.png","hash":"fdf407ce536c442b3cccc71e635126fb6a8c5b20","modified":1550135875055},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1550135875055},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550135875055},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550135875055},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1550135875055},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1550135875055},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1550135875055},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1550135875055},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1550135875055},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1550135875055},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1550135875055},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550135875056},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550135875056},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550135875056},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1550135875056},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550135875056},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1550135875056},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1550135875056},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550135875056},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1550135875056},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1550135875056},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550135875056},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550135875057},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550135875057},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550135875057},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550135875057},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550135875057},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1550135875057},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1550135875057},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1550135875057},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1550135875057},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1550135875058},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1550135875058},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550135875058},{"_id":"public/pub-images/ASPMVC.png","hash":"28bc7b343fc138cb7905cc6eac1a2924f2c0d61e","modified":1550135875650},{"_id":"public/pub-images/avatar.png","hash":"a9567e2000759431e70233a7ee6aacf9b75b9f22","modified":1550135875650},{"_id":"public/pub-images/UML类图关系.png","hash":"50429aed6d3ae9a59e403ce272285161c258a3e7","modified":1550135875652},{"_id":"public/pub-images/git2.png","hash":"86956ca2c7ca53305d264e0425ea1875da96ba4b","modified":1550135875652},{"_id":"public/pub-images/alipay.png","hash":"6f3de391ca6436179b847c95c5e870f8ec6801d2","modified":1550135875652},{"_id":"public/pub-images/wechatpay.png","hash":"0611ce39c6e865ffaf32d544820183c4de8222a7","modified":1550135875652},{"_id":"public/pub-images/插件安装.png","hash":"63962106b6f03bf5584f3e879735315ea086b2ae","modified":1550135875652},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550135875652},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550135875652},{"_id":"public/404.html","hash":"b74e38e322d86183d8865cd8dce465058e879e9c","modified":1550135875663},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1550135875663},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1550135875663},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1550135875663},{"_id":"public/js/src/love.js","hash":"ca63890ecac4cc408a20e8772a1ffabb532c6996","modified":1550135875663},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1550135875663},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1550135875663},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550135875663},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1550135875663},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1550135875664},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1550135875664},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1550135875664},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1550135875664},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1550135875664},{"_id":"public/lib/fastclick/README.html","hash":"2a1eeda5db36785ac126a30516dcd7aa31aa6f56","modified":1550135875664},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1550135875664},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1550135875664},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1550135875664},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"e052945954a31250c7dcefa88a0dd00aa0a7bdfa","modified":1550135875664},{"_id":"public/lib/jquery_lazyload/README.html","hash":"5a29ff39d4e456e314db5e497fbeaf6824272209","modified":1550135875664},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1550135875664},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1550135875664},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1550135875664},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1550135875664},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1550135875664},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1550135875664},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1550135875664},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550135875664},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1550135875665},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550135875665},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1550135875665},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1550135875665},{"_id":"public/css/main.css","hash":"f98458ce0b318470d76c7c49cbc0b72fe40b7d01","modified":1550135875665},{"_id":"public/pub-images/middleware机制示例.png","hash":"69369b3fc34f51f37f7a939317314e3bacdbb512","modified":1550135875665},{"_id":"public/pub-images/gradle生命周期.png","hash":"ebc6691a71dba2e37579e0120d93c15d5a98aade","modified":1550135875665},{"_id":"public/pub-images/react-router-redux示例.png","hash":"56b6b7753009882f3e1312e35ea5fe6be0ae254f","modified":1550135875665},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550135875665},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550135875665},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550135875665},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1550135875679},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1550135875679},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1550135875680},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1550135875680},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1550135875680},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550135875680},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1550135875680},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1550135875680},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1550135875692},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1550135875692},{"_id":"public/pub-images/虚拟机文件结构.png","hash":"168a7e3b379214f0e5bd669351bab77bc19f9884","modified":1550135875693},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1550135875705},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550135875705},{"_id":"public/pub-images/Groovy元编程.png","hash":"6d792abc1619522d28a282d8f2a9926afb2dfe92","modified":1550135875707},{"_id":"public/pub-images/github设置.png","hash":"d9d43ef9caba8851a2c020f961be4bb5e58e5018","modified":1550135875707},{"_id":"public/pub-images/mysql.png","hash":"b171f09d61f96c9fdf42f23be9848cea995aead3","modified":1550135875707},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1550135875746},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1550135875747},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1550135875750},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550135875750},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550135875750},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1550135875751},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1550135875751},{"_id":"public/pub-images/Intelij Groovy.png","hash":"afd3d087ba317021e36d7cdfb9fec0c6bcdeaae0","modified":1550135875751},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1550135875808},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1550135875808},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1550135875812},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1550135875833},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1550135875834},{"_id":"public/pub-images/macOS制作U盘启动.png","hash":"9c8c876bc2fe737c53dc158896073dcc4bc0e864","modified":1550135875895},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1550135875923},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550135875927},{"_id":"public/pub-images/Parallels Tools.png","hash":"178613a2605e9afd5d3bd6db9b13ad63b18c25d1","modified":1550135875934},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550135875939},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1550135875964},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1550135875967},{"_id":"public/pub-images/Ecma-262.pdf","hash":"b727e3c03b5272e30f11c36a0cd114eaae91bdb8","modified":1550135876005}],"Category":[{"name":"工具","_id":"cjs4eudwz000a5b8hh288oegw"},{"name":"Java","_id":"cjs4eudx2000f5b8hpoyo4hah"},{"name":"Kotlin","_id":"cjs4eudx5000l5b8hr9raekcs"},{"name":"Spring","_id":"cjs4eudx8000r5b8hhddul7vh"},{"name":"C#","_id":"cjs4eudxa000y5b8hqijlxuin"},{"name":"react","_id":"cjs4eudxr001w5b8h2r3oyazf"},{"name":"React","_id":"cjs4eudxu00235b8h9fa9c0kl"},{"name":"Linux","_id":"cjs4eudye00325b8hl618o3o4"},{"name":"前端","_id":"cjs4eue00005h5b8h59rgv7sh"},{"name":"其他","_id":"cjs4eue05005o5b8h7s48lto5"},{"name":"微信","_id":"cjs4eue1700805b8hmalbm4ic"},{"name":"移动开发","_id":"cjs4eue1c008d5b8hhiqy23en"},{"name":"数据库","_id":"cjs4eue2a009c5b8h5v0p46pp"},{"name":"环境搭建","_id":"cjs4eue2d009w5b8hyf8pm2ji"},{"name":"docker","_id":"cjs4eue5b00eq5b8h8mz9n0sv"}],"Data":[],"Page":[{"title":"分类","date":"2018-03-14T17:58:22.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-03-15 01:58:22\ntype: \"categories\"\n---\n","updated":"2019-01-10T16:04:42.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjs4eudq900015b8hpjf5v3ew","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2018-03-14T17:58:34.000Z","_content":"关于我","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-03-15 01:58:34\n---\n关于我","updated":"2019-01-10T16:04:42.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjs4eudqb00025b8hori5chn1","content":"<p>关于我</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于我</p>\n"},{"title":"归档","date":"2018-03-14T17:59:39.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: 归档\ndate: 2018-03-15 01:59:39\n---\n","updated":"2019-01-10T16:04:42.000Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cjs4eudqc00045b8hj7aighqv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2018-03-14T18:09:19.000Z","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2018-03-15 02:09:19\n---\n","updated":"2019-01-10T16:04:43.000Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"cjs4eudqd00055b8hm86w9m8l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-03-14T17:57:39.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-03-15 01:57:39\ntype: \"tags\"\n---\n","updated":"2019-01-10T16:04:43.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjs4eudqe00065b8hkfv01oqi","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"常用编写技巧记录","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n# 说明","source":"_drafts/utils.md","raw":"---\ntitle: 常用编写技巧记录\ntags:\n  - 编写工具 \ncopyright: true\ncomments: true\ntoc: true\ncategories:\npassword:\n---\n\n# 说明","slug":"utils","published":0,"date":"2019-01-10T16:04:42.000Z","updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudq500005b8hkdks0dkv","content":"<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n"},{"title":"Jenkins","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T02:04:03.000Z","password":null,"_content":"  \n# Jenkins\n官网下载：https://jenkins.io/download/ ,注意下载的版本要与jdk的版本对应\n> Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目；监控外部调用执行的工作\n* 持续集成：指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试 \n* 持续交付：指的是在持续集成的环境基础之上，将代码部署到预生产环境\n* 持续部署：在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的","source":"_posts/CI/Jekins.md","raw":"---\ntitle: Jenkins\ntags:\n  - 持续集成 \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 10:04:03\ncategories: 工具\npassword:\n---\n  \n# Jenkins\n官网下载：https://jenkins.io/download/ ,注意下载的版本要与jdk的版本对应\n> Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目；监控外部调用执行的工作\n* 持续集成：指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试 \n* 持续交付：指的是在持续集成的环境基础之上，将代码部署到预生产环境\n* 持续部署：在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的","slug":"CI-Jekins","published":1,"updated":"2019-02-14T02:27:12.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudwt00085b8hhw1al0yh","content":"<h1 id=\"jenkins\"><a class=\"markdownIt-Anchor\" href=\"#jenkins\"></a> Jenkins</h1>\n<p>官网下载：<a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/download/</a> ,注意下载的版本要与jdk的版本对应</p>\n<blockquote>\n<p>Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目；监控外部调用执行的工作</p>\n</blockquote>\n<ul>\n<li>持续集成：指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试</li>\n<li>持续交付：指的是在持续集成的环境基础之上，将代码部署到预生产环境</li>\n<li>持续部署：在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jenkins\"><a class=\"markdownIt-Anchor\" href=\"#jenkins\"></a> Jenkins</h1>\n<p>官网下载：<a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/download/</a> ,注意下载的版本要与jdk的版本对应</p>\n<blockquote>\n<p>Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目；监控外部调用执行的工作</p>\n</blockquote>\n<ul>\n<li>持续集成：指开发者在代码的开发过程中，可以频繁的将代码部署集成到主干，并进程自动化测试</li>\n<li>持续交付：指的是在持续集成的环境基础之上，将代码部署到预生产环境</li>\n<li>持续部署：在持续交付的基础上，把部署到生产环境的过程自动化，持续部署和持续交付的区别就是最终部署到生产环境是自动化的</li>\n</ul>\n"},{"title":"MyBatis","copyright":true,"comments":1,"toc":true,"date":"2018-12-10T05:43:24.000Z","password":null,"_content":"\nJava持久化框架 瞬态+持久态\n\niBatis-MyBatis\napache-google-github\n\nSQL语句与代码分离；面向配置编程；良好支持复杂数据映射；动态SQL\n\nhttps://github.com/mybatis/mybatis-3\nhttp://www.mybatis.org/mybatis-3/zh/index.html\n\n日志配置\nhttps://www.cnblogs.com/zhaozihan/p/6371133.html\n\nMyBatisg工作流程\n1. 读取配置文件\n2. 生成SqlSessionFactory,表示和数据库的连接，一般是程序级的生命周期\n3. 简历SqlSession\n4. 调用MyBatist提供的API\n5. 查询Map配置\n6. 返回结果\n7. 关闭SqlSession\n~~~\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n  </mappers>\n</configuration>\n~~~\n\nmap文件引用\n1.相对路径 2.绝对路径 3.包路径 \n\nMyBatis配置文件：基本配置文件+映射配置文件\n\ntypeAliases标记定义别名，需要environments标记之前\n\nmap文件方式+注解方式（接口方式）\n\nmappers里面3种写法：resource／class／package \n\nSelect配置属性说明\n两者只能有一个成立\nresultType\nresultMap解决复杂查询时的映射问题，如属性为对象 \n\nparameterType封装hashmap，key既是key也是sql形参\nparameterType封装对象如User，对象参数自动匹配属性，如果对象属性和列名不一样用别名\n\n返回多上记录时MyBatis自动封装成List\n\n事务处理：\nMyBatis事务处理由两种方式处理：JDBC+MANAGED\n\n每张表单独的一个配置文件，方便管理\n\n\nMyBatis自动id返回，\n~~~\none.setUserName(\"123\");\nsession.insert(\"insertOne\",one);\nSystem.out.println(one.id);  //可以正常获取id\n~~~\n\n\n高级查询\n关联查询\n    联合查询：association\n    构造查询：POJO添加构造函数，同时确保要有默认构造函数，防止构造函数重新后找不到默认构造函数\n    子查询：所有联合查询，都可以通过子查询替换，但是他让查询成了N+1次的查询\n    \n    子查询和联合查询的区别：\n    联合查询一次查询占用资源大，子查询N+1次查询占用资源可大可小，MyBatis中子查询可能速度比联合查询速度高如果开启了懒加载的话\n    懒加载的使用：配置要在配置别名之前\n集合查询：Collection标记，适用于查询的对象还有一个集合引用的事后 \n鉴别器：discriminator标记\n    javaType属性：\n    Column属性：\n    Case子标记：\n    \n MyBatis动态SQL：动态生成SQL\n \n \n \n \n https://www.aliyun.com/jiaocheng/811373.html\n \n https://www.jikexueyuan.com/course/oracledb/1-0-0-0/\n ","source":"_posts/Java/2018-12-10-MyBatis.md","raw":"---\ntitle: MyBatis\ntags:\n  - MyBatis\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-10 13:43:24\ncategories: Java\npassword:\n---\n\nJava持久化框架 瞬态+持久态\n\niBatis-MyBatis\napache-google-github\n\nSQL语句与代码分离；面向配置编程；良好支持复杂数据映射；动态SQL\n\nhttps://github.com/mybatis/mybatis-3\nhttp://www.mybatis.org/mybatis-3/zh/index.html\n\n日志配置\nhttps://www.cnblogs.com/zhaozihan/p/6371133.html\n\nMyBatisg工作流程\n1. 读取配置文件\n2. 生成SqlSessionFactory,表示和数据库的连接，一般是程序级的生命周期\n3. 简历SqlSession\n4. 调用MyBatist提供的API\n5. 查询Map配置\n6. 返回结果\n7. 关闭SqlSession\n~~~\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n  </mappers>\n</configuration>\n~~~\n\nmap文件引用\n1.相对路径 2.绝对路径 3.包路径 \n\nMyBatis配置文件：基本配置文件+映射配置文件\n\ntypeAliases标记定义别名，需要environments标记之前\n\nmap文件方式+注解方式（接口方式）\n\nmappers里面3种写法：resource／class／package \n\nSelect配置属性说明\n两者只能有一个成立\nresultType\nresultMap解决复杂查询时的映射问题，如属性为对象 \n\nparameterType封装hashmap，key既是key也是sql形参\nparameterType封装对象如User，对象参数自动匹配属性，如果对象属性和列名不一样用别名\n\n返回多上记录时MyBatis自动封装成List\n\n事务处理：\nMyBatis事务处理由两种方式处理：JDBC+MANAGED\n\n每张表单独的一个配置文件，方便管理\n\n\nMyBatis自动id返回，\n~~~\none.setUserName(\"123\");\nsession.insert(\"insertOne\",one);\nSystem.out.println(one.id);  //可以正常获取id\n~~~\n\n\n高级查询\n关联查询\n    联合查询：association\n    构造查询：POJO添加构造函数，同时确保要有默认构造函数，防止构造函数重新后找不到默认构造函数\n    子查询：所有联合查询，都可以通过子查询替换，但是他让查询成了N+1次的查询\n    \n    子查询和联合查询的区别：\n    联合查询一次查询占用资源大，子查询N+1次查询占用资源可大可小，MyBatis中子查询可能速度比联合查询速度高如果开启了懒加载的话\n    懒加载的使用：配置要在配置别名之前\n集合查询：Collection标记，适用于查询的对象还有一个集合引用的事后 \n鉴别器：discriminator标记\n    javaType属性：\n    Column属性：\n    Case子标记：\n    \n MyBatis动态SQL：动态生成SQL\n \n \n \n \n https://www.aliyun.com/jiaocheng/811373.html\n \n https://www.jikexueyuan.com/course/oracledb/1-0-0-0/\n ","slug":"Java-2018-12-10-MyBatis","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudwx00095b8hpe3jt22r","content":"<p>Java持久化框架 瞬态+持久态</p>\n<p>iBatis-MyBatis<br>\napache-google-github</p>\n<p>SQL语句与代码分离；面向配置编程；良好支持复杂数据映射；动态SQL</p>\n<p><a href=\"https://github.com/mybatis/mybatis-3\" target=\"_blank\" rel=\"noopener\">https://github.com/mybatis/mybatis-3</a><br>\n<a href=\"http://www.mybatis.org/mybatis-3/zh/index.html\" target=\"_blank\" rel=\"noopener\">http://www.mybatis.org/mybatis-3/zh/index.html</a></p>\n<p>日志配置<br>\n<a href=\"https://www.cnblogs.com/zhaozihan/p/6371133.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhaozihan/p/6371133.html</a></p>\n<p>MyBatisg工作流程</p>\n<ol>\n<li>读取配置文件</li>\n<li>生成SqlSessionFactory,表示和数据库的连接，一般是程序级的生命周期</li>\n<li>简历SqlSession</li>\n<li>调用MyBatist提供的API</li>\n<li>查询Map配置</li>\n<li>返回结果</li>\n<li>关闭SqlSession</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class=\"line\">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">  &lt;environments default=&quot;development&quot;&gt;</span><br><span class=\"line\">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class=\"line\">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class=\"line\">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class=\"line\">      &lt;/dataSource&gt;</span><br><span class=\"line\">    &lt;/environment&gt;</span><br><span class=\"line\">  &lt;/environments&gt;</span><br><span class=\"line\">  &lt;mappers&gt;</span><br><span class=\"line\">    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;</span><br><span class=\"line\">  &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n<p>map文件引用<br>\n1.相对路径 2.绝对路径 3.包路径</p>\n<p>MyBatis配置文件：基本配置文件+映射配置文件</p>\n<p>typeAliases标记定义别名，需要environments标记之前</p>\n<p>map文件方式+注解方式（接口方式）</p>\n<p>mappers里面3种写法：resource／class／package</p>\n<p>Select配置属性说明<br>\n两者只能有一个成立<br>\nresultType<br>\nresultMap解决复杂查询时的映射问题，如属性为对象</p>\n<p>parameterType封装hashmap，key既是key也是sql形参<br>\nparameterType封装对象如User，对象参数自动匹配属性，如果对象属性和列名不一样用别名</p>\n<p>返回多上记录时MyBatis自动封装成List</p>\n<p>事务处理：<br>\nMyBatis事务处理由两种方式处理：JDBC+MANAGED</p>\n<p>每张表单独的一个配置文件，方便管理</p>\n<p>MyBatis自动id返回，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one.setUserName(&quot;123&quot;);</span><br><span class=\"line\">session.insert(&quot;insertOne&quot;,one);</span><br><span class=\"line\">System.out.println(one.id);  //可以正常获取id</span><br></pre></td></tr></table></figure>\n<p>高级查询<br>\n关联查询<br>\n联合查询：association<br>\n构造查询：POJO添加构造函数，同时确保要有默认构造函数，防止构造函数重新后找不到默认构造函数<br>\n子查询：所有联合查询，都可以通过子查询替换，但是他让查询成了N+1次的查询</p>\n<pre><code>子查询和联合查询的区别：\n联合查询一次查询占用资源大，子查询N+1次查询占用资源可大可小，MyBatis中子查询可能速度比联合查询速度高如果开启了懒加载的话\n懒加载的使用：配置要在配置别名之前\n</code></pre>\n<p>集合查询：Collection标记，适用于查询的对象还有一个集合引用的事后<br>\n鉴别器：discriminator标记<br>\njavaType属性：<br>\nColumn属性：<br>\nCase子标记：</p>\n<p>MyBatis动态SQL：动态生成SQL</p>\n<p><a href=\"https://www.aliyun.com/jiaocheng/811373.html\" target=\"_blank\" rel=\"noopener\">https://www.aliyun.com/jiaocheng/811373.html</a></p>\n<p><a href=\"https://www.jikexueyuan.com/course/oracledb/1-0-0-0/\" target=\"_blank\" rel=\"noopener\">https://www.jikexueyuan.com/course/oracledb/1-0-0-0/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java持久化框架 瞬态+持久态</p>\n<p>iBatis-MyBatis<br>\napache-google-github</p>\n<p>SQL语句与代码分离；面向配置编程；良好支持复杂数据映射；动态SQL</p>\n<p><a href=\"https://github.com/mybatis/mybatis-3\" target=\"_blank\" rel=\"noopener\">https://github.com/mybatis/mybatis-3</a><br>\n<a href=\"http://www.mybatis.org/mybatis-3/zh/index.html\" target=\"_blank\" rel=\"noopener\">http://www.mybatis.org/mybatis-3/zh/index.html</a></p>\n<p>日志配置<br>\n<a href=\"https://www.cnblogs.com/zhaozihan/p/6371133.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhaozihan/p/6371133.html</a></p>\n<p>MyBatisg工作流程</p>\n<ol>\n<li>读取配置文件</li>\n<li>生成SqlSessionFactory,表示和数据库的连接，一般是程序级的生命周期</li>\n<li>简历SqlSession</li>\n<li>调用MyBatist提供的API</li>\n<li>查询Map配置</li>\n<li>返回结果</li>\n<li>关闭SqlSession</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class=\"line\">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">  &lt;environments default=&quot;development&quot;&gt;</span><br><span class=\"line\">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class=\"line\">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class=\"line\">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class=\"line\">      &lt;/dataSource&gt;</span><br><span class=\"line\">    &lt;/environment&gt;</span><br><span class=\"line\">  &lt;/environments&gt;</span><br><span class=\"line\">  &lt;mappers&gt;</span><br><span class=\"line\">    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;</span><br><span class=\"line\">  &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n<p>map文件引用<br>\n1.相对路径 2.绝对路径 3.包路径</p>\n<p>MyBatis配置文件：基本配置文件+映射配置文件</p>\n<p>typeAliases标记定义别名，需要environments标记之前</p>\n<p>map文件方式+注解方式（接口方式）</p>\n<p>mappers里面3种写法：resource／class／package</p>\n<p>Select配置属性说明<br>\n两者只能有一个成立<br>\nresultType<br>\nresultMap解决复杂查询时的映射问题，如属性为对象</p>\n<p>parameterType封装hashmap，key既是key也是sql形参<br>\nparameterType封装对象如User，对象参数自动匹配属性，如果对象属性和列名不一样用别名</p>\n<p>返回多上记录时MyBatis自动封装成List</p>\n<p>事务处理：<br>\nMyBatis事务处理由两种方式处理：JDBC+MANAGED</p>\n<p>每张表单独的一个配置文件，方便管理</p>\n<p>MyBatis自动id返回，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one.setUserName(&quot;123&quot;);</span><br><span class=\"line\">session.insert(&quot;insertOne&quot;,one);</span><br><span class=\"line\">System.out.println(one.id);  //可以正常获取id</span><br></pre></td></tr></table></figure>\n<p>高级查询<br>\n关联查询<br>\n联合查询：association<br>\n构造查询：POJO添加构造函数，同时确保要有默认构造函数，防止构造函数重新后找不到默认构造函数<br>\n子查询：所有联合查询，都可以通过子查询替换，但是他让查询成了N+1次的查询</p>\n<pre><code>子查询和联合查询的区别：\n联合查询一次查询占用资源大，子查询N+1次查询占用资源可大可小，MyBatis中子查询可能速度比联合查询速度高如果开启了懒加载的话\n懒加载的使用：配置要在配置别名之前\n</code></pre>\n<p>集合查询：Collection标记，适用于查询的对象还有一个集合引用的事后<br>\n鉴别器：discriminator标记<br>\njavaType属性：<br>\nColumn属性：<br>\nCase子标记：</p>\n<p>MyBatis动态SQL：动态生成SQL</p>\n<p><a href=\"https://www.aliyun.com/jiaocheng/811373.html\" target=\"_blank\" rel=\"noopener\">https://www.aliyun.com/jiaocheng/811373.html</a></p>\n<p><a href=\"https://www.jikexueyuan.com/course/oracledb/1-0-0-0/\" target=\"_blank\" rel=\"noopener\">https://www.jikexueyuan.com/course/oracledb/1-0-0-0/</a></p>\n"},{"title":"Kotlin","copyright":true,"comments":1,"toc":true,"date":"2018-11-26T13:25:33.000Z","password":null,"_content":"\nhttp://kotlinlang.org/\nhttps://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt\n\nKotlin作者Andrey\nKotlin是一种在 Java 虚拟机上运行的静态类型编程语言,被称之为 Android 世界的Swift,由 JetBrains 设计开发并开源\nKotlin是一种运行在Java虚拟机、Android、浏览器上的静态语言 \nKotlin可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\nAndroid官方语言；100%兼容Java；Kotlin-js前端开发；Kotlin-jvm服务端开发；Kotlin-native本地执行程序；Kotlin是一门全栈语言\n\n千里之行，始于Hello World\n\n\nKotlin不存在拆箱装箱问题;Kotlin不可隐式转换类型 \nvar tmp:[类型]=[变量值]\n\nBoolean类型\nNumber数据类型：Byte，Short，Int，Long，Float，Double\nChar数据类型：Char\nString数据类型：String         字符串a==b 比较内容；a===b比较应用  字符串模版$args1  ${args1+args2},引号中$引用变量 ，多行\n    var a:String ...\n        a1\n        a2\n    ...\n\nKotlin中 Any 等于 Java中 Object，是顶级类\n\n空类型：任意类型都有可空和不可空两种状态，？表示可为空，!!表示强制认定nullable不可为空\nfun main(args:Array<String>){\n    var name:String = getName() ?: return\n    println(name)\n\n    var tmp:String? = \"Hello Kotlin\"\n    println(tmp)\n    println(tmp!!.length)\n}\n\nfun getName():String?{\n    return null\n}\n \n智能类型转换\nJava方式的：var sub:Subclass = parent as Subclass   //类似于Java方式，转换异常则会抛异常\n安全类型转换：var sub:Subclass? = parent as? Subclass   //如果转换失败，则返回null，不抛异常\n\nif(parent is Subclass)\n\n\nimport com.test as test\n\n区间Range:一个数学上的概念，表示范围；是ClosedRange的子类，IntRange最常用；i in 0..1024 判断i是否在区间内\nvar range:IntRange = 0..1024    //[0,1024]\nvar range:IntRange = 0 until 1024    //[0,1024) == [0,1023]\n\nclassName::java.class.name\nclassName::java.class.simpleName\n\n数组: val array:Array<> = arrayOf(...)\n为了避免不必要的拆箱和装箱，基本类型的数组是定制的\nval arrayOfInt:IntArray = intArrayOf(1,2,4)\nval arrayOfChar:CharArray = charArrayOf('H','e','y')\nval arrayOfString: Array<String> = arrayOf(\"Hello\",\"Kotlin\")\nval arrayOfOther:Array<Other> = arrayOf(Other(1),Other(2))\n\n常量：val，常量因为赋值了，编译器可以推导出来类型，所以类型可以不用写，变量：var\n\nExternal Tools\nTools->Kotlin->Show Kotlin Bytecode\n\n函数：Kotlin中没有申明返回值的默认返回值是Unit\nkotlinc安装，使用和javac一样\n变量函数\nvar int2Long = fun(x:Int):Long{\n    return x.toLong()\n} \nint2Long(123)\nfun sum(arg1:Int,arg2:Int) = arg1+arg2\nLambda表达式调用使用()或者invoke(),如：sum(1,2) 或 sum.invoke(1,2)\nLambda表达式--匿名函数\n\nvar = {arg1:Int,arg2:Int -> arg1+arg2}\n\narrayOfString.forEach { println(it) }   //如果字面函数只有一个参数,可以省略该参数声明,并用“it”代替\narrayOfString.forEach(::println)\n\nLambda表达式中的return\nhttps://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app\n\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\nindexes.forEach {\n    if (it > 5) {\n        return@forEach\n    }\n    println(it)\n}\n\nindexes.forEach label@ {\n    if (it > 5) {\n        return @label\n    }\n    println(it)\n}\n\n函数参数调用时最后一个Lambda可以移出去\n函数参数只有一个Lambda，调用时小括号可以省略\nLambda有一个参数，可默认为it\n入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入\n\n类成员方法和成员变量\nclass B\nclass A{\n\tvar b=0;\n    lateinit var c:String \n    val d:B by lazy{\n        B()\n    }\n}\n属性初始化\n1. 尽量在构造方法中完成\n2. 无法在构造方法中完成的，尝试降级为局部变量\n3. var用lateinit延迟初始化，val用lazy\n4. 可空类型慎用null直接初始化\n\n\n中缀表达式：只有一个参数，且用infix修饰的函数\nclass Book {infix fun on(placeString:String){...}}\nBook() on \"My Desk\" //使用方式\n分支表达式：\nval mode=if(args.isNotEmpty() && args[0] ==1){\n    0\n}else{\n    1    \n}\n\n异常捕捉\ntry ..catch ..finally中的执行完之后，再返回结果，可通过var获取返回值\n\n具名参数：sum(arg1=2,arg0=3)  //参数就可以不按照顺序传递了\n变长参数：如main方法中的args\nfun test(vararg  args:String){}\n默认参数：给出参数默认值\n\n导出可执行程序\n\nkotlin应用场景：\n\nkotlin-android\n\n\n","source":"_posts/Java/2018-11-26-Kotlin.md","raw":"---\ntitle: Kotlin\ntags:\n  - Kotlin\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-11-26 21:25:33\ncategories: Kotlin\npassword:\n---\n\nhttp://kotlinlang.org/\nhttps://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt\n\nKotlin作者Andrey\nKotlin是一种在 Java 虚拟机上运行的静态类型编程语言,被称之为 Android 世界的Swift,由 JetBrains 设计开发并开源\nKotlin是一种运行在Java虚拟机、Android、浏览器上的静态语言 \nKotlin可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\nAndroid官方语言；100%兼容Java；Kotlin-js前端开发；Kotlin-jvm服务端开发；Kotlin-native本地执行程序；Kotlin是一门全栈语言\n\n千里之行，始于Hello World\n\n\nKotlin不存在拆箱装箱问题;Kotlin不可隐式转换类型 \nvar tmp:[类型]=[变量值]\n\nBoolean类型\nNumber数据类型：Byte，Short，Int，Long，Float，Double\nChar数据类型：Char\nString数据类型：String         字符串a==b 比较内容；a===b比较应用  字符串模版$args1  ${args1+args2},引号中$引用变量 ，多行\n    var a:String ...\n        a1\n        a2\n    ...\n\nKotlin中 Any 等于 Java中 Object，是顶级类\n\n空类型：任意类型都有可空和不可空两种状态，？表示可为空，!!表示强制认定nullable不可为空\nfun main(args:Array<String>){\n    var name:String = getName() ?: return\n    println(name)\n\n    var tmp:String? = \"Hello Kotlin\"\n    println(tmp)\n    println(tmp!!.length)\n}\n\nfun getName():String?{\n    return null\n}\n \n智能类型转换\nJava方式的：var sub:Subclass = parent as Subclass   //类似于Java方式，转换异常则会抛异常\n安全类型转换：var sub:Subclass? = parent as? Subclass   //如果转换失败，则返回null，不抛异常\n\nif(parent is Subclass)\n\n\nimport com.test as test\n\n区间Range:一个数学上的概念，表示范围；是ClosedRange的子类，IntRange最常用；i in 0..1024 判断i是否在区间内\nvar range:IntRange = 0..1024    //[0,1024]\nvar range:IntRange = 0 until 1024    //[0,1024) == [0,1023]\n\nclassName::java.class.name\nclassName::java.class.simpleName\n\n数组: val array:Array<> = arrayOf(...)\n为了避免不必要的拆箱和装箱，基本类型的数组是定制的\nval arrayOfInt:IntArray = intArrayOf(1,2,4)\nval arrayOfChar:CharArray = charArrayOf('H','e','y')\nval arrayOfString: Array<String> = arrayOf(\"Hello\",\"Kotlin\")\nval arrayOfOther:Array<Other> = arrayOf(Other(1),Other(2))\n\n常量：val，常量因为赋值了，编译器可以推导出来类型，所以类型可以不用写，变量：var\n\nExternal Tools\nTools->Kotlin->Show Kotlin Bytecode\n\n函数：Kotlin中没有申明返回值的默认返回值是Unit\nkotlinc安装，使用和javac一样\n变量函数\nvar int2Long = fun(x:Int):Long{\n    return x.toLong()\n} \nint2Long(123)\nfun sum(arg1:Int,arg2:Int) = arg1+arg2\nLambda表达式调用使用()或者invoke(),如：sum(1,2) 或 sum.invoke(1,2)\nLambda表达式--匿名函数\n\nvar = {arg1:Int,arg2:Int -> arg1+arg2}\n\narrayOfString.forEach { println(it) }   //如果字面函数只有一个参数,可以省略该参数声明,并用“it”代替\narrayOfString.forEach(::println)\n\nLambda表达式中的return\nhttps://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app\n\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\nindexes.forEach {\n    if (it > 5) {\n        return@forEach\n    }\n    println(it)\n}\n\nindexes.forEach label@ {\n    if (it > 5) {\n        return @label\n    }\n    println(it)\n}\n\n函数参数调用时最后一个Lambda可以移出去\n函数参数只有一个Lambda，调用时小括号可以省略\nLambda有一个参数，可默认为it\n入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入\n\n类成员方法和成员变量\nclass B\nclass A{\n\tvar b=0;\n    lateinit var c:String \n    val d:B by lazy{\n        B()\n    }\n}\n属性初始化\n1. 尽量在构造方法中完成\n2. 无法在构造方法中完成的，尝试降级为局部变量\n3. var用lateinit延迟初始化，val用lazy\n4. 可空类型慎用null直接初始化\n\n\n中缀表达式：只有一个参数，且用infix修饰的函数\nclass Book {infix fun on(placeString:String){...}}\nBook() on \"My Desk\" //使用方式\n分支表达式：\nval mode=if(args.isNotEmpty() && args[0] ==1){\n    0\n}else{\n    1    \n}\n\n异常捕捉\ntry ..catch ..finally中的执行完之后，再返回结果，可通过var获取返回值\n\n具名参数：sum(arg1=2,arg0=3)  //参数就可以不按照顺序传递了\n变长参数：如main方法中的args\nfun test(vararg  args:String){}\n默认参数：给出参数默认值\n\n导出可执行程序\n\nkotlin应用场景：\n\nkotlin-android\n\n\n","slug":"Java-2018-11-26-Kotlin","published":1,"updated":"2019-02-14T02:26:41.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudwz000c5b8hb0yto4xh","content":"<p><a href=\"http://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">http://kotlinlang.org/</a><br>\n<a href=\"https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt\" target=\"_blank\" rel=\"noopener\">https://try.kotlinlang.org/#/Examples/Hello, world!/Simplest version/Simplest version.kt</a></p>\n<p>Kotlin作者Andrey<br>\nKotlin是一种在 Java 虚拟机上运行的静态类型编程语言,被称之为 Android 世界的Swift,由 JetBrains 设计开发并开源<br>\nKotlin是一种运行在Java虚拟机、Android、浏览器上的静态语言<br>\nKotlin可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。<br>\nAndroid官方语言；100%兼容Java；Kotlin-js前端开发；Kotlin-jvm服务端开发；Kotlin-native本地执行程序；Kotlin是一门全栈语言</p>\n<p>千里之行，始于Hello World</p>\n<p>Kotlin不存在拆箱装箱问题;Kotlin不可隐式转换类型<br>\nvar tmp:[类型]=[变量值]</p>\n<p>Boolean类型<br>\nNumber数据类型：Byte，Short，Int，Long，Float，Double<br>\nChar数据类型：Char<br>\nString数据类型：String         字符串a==b 比较内容；a===b比较应用  字符串模版$args1  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>s</mi><mn>1</mn><mo>+</mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>s</mi><mn>2</mn></mrow><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">引</mi><mi mathvariant=\"normal\">号</mi><mi mathvariant=\"normal\">中</mi></mrow><annotation encoding=\"application/x-tex\">{args1+args2},引号中</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">引</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">中</span></span></span></span>引用变量 ，多行<br>\nvar a:String …<br>\na1<br>\na2<br>\n…</p>\n<p>Kotlin中 Any 等于 Java中 Object，是顶级类</p>\n<p>空类型：任意类型都有可空和不可空两种状态，？表示可为空，!!表示强制认定nullable不可为空<br>\nfun main(args:Array<string>){<br>\nvar name:String = getName() ?: return<br>\nprintln(name)</string></p>\n<pre><code>var tmp:String? = &quot;Hello Kotlin&quot;\nprintln(tmp)\nprintln(tmp!!.length)\n</code></pre>\n<p>}</p>\n<p>fun getName():String?{<br>\nreturn null<br>\n}</p>\n<p>智能类型转换<br>\nJava方式的：var sub:Subclass = parent as Subclass   //类似于Java方式，转换异常则会抛异常<br>\n安全类型转换：var sub:Subclass? = parent as? Subclass   //如果转换失败，则返回null，不抛异常</p>\n<p>if(parent is Subclass)</p>\n<p>import com.test as test</p>\n<p>区间Range:一个数学上的概念，表示范围；是ClosedRange的子类，IntRange最常用；i in 0…1024 判断i是否在区间内<br>\nvar range:IntRange = 0…1024    //[0,1024]<br>\nvar range:IntRange = 0 until 1024    //[0,1024) == [0,1023]</p>\n<p>className::java.class.name<br>\nclassName::java.class.simpleName</p>\n<p>数组: val array:Array&lt;&gt; = arrayOf(…)<br>\n为了避免不必要的拆箱和装箱，基本类型的数组是定制的<br>\nval arrayOfInt:IntArray = intArrayOf(1,2,4)<br>\nval arrayOfChar:CharArray = charArrayOf(‘H’,‘e’,‘y’)<br>\nval arrayOfString: Array<string> = arrayOf(“Hello”,“Kotlin”)<br>\nval arrayOfOther:Array<other> = arrayOf(Other(1),Other(2))</other></string></p>\n<p>常量：val，常量因为赋值了，编译器可以推导出来类型，所以类型可以不用写，变量：var</p>\n<p>External Tools<br>\nTools-&gt;Kotlin-&gt;Show Kotlin Bytecode</p>\n<p>函数：Kotlin中没有申明返回值的默认返回值是Unit<br>\nkotlinc安装，使用和javac一样<br>\n变量函数<br>\nvar int2Long = fun(x:Int):Long{<br>\nreturn x.toLong()<br>\n}<br>\nint2Long(123)<br>\nfun sum(arg1:Int,arg2:Int) = arg1+arg2<br>\nLambda表达式调用使用()或者invoke(),如：sum(1,2) 或 sum.invoke(1,2)<br>\nLambda表达式–匿名函数</p>\n<p>var = {arg1:Int,arg2:Int -&gt; arg1+arg2}</p>\n<p>arrayOfString.forEach { println(it) }   //如果字面函数只有一个参数,可以省略该参数声明,并用“it”代替<br>\narrayOfString.forEach(::println)</p>\n<p>Lambda表达式中的return<br>\n<a href=\"https://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app</a></p>\n<p>public inline fun <t> Array<out t=\"\">.forEach(action: (T) -&gt; Unit): Unit {<br>\nfor (element in this) action(element)<br>\n}</out></t></p>\n<p>indexes.forEach {<br>\nif (it &gt; 5) {<br>\nreturn@forEach<br>\n}<br>\nprintln(it)<br>\n}</p>\n<p>indexes.forEach label@ {<br>\nif (it &gt; 5) {<br>\nreturn @label<br>\n}<br>\nprintln(it)<br>\n}</p>\n<p>函数参数调用时最后一个Lambda可以移出去<br>\n函数参数只有一个Lambda，调用时小括号可以省略<br>\nLambda有一个参数，可默认为it<br>\n入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入</p>\n<p>类成员方法和成员变量<br>\nclass B<br>\nclass A{<br>\nvar b=0;<br>\nlateinit var c:String<br>\nval d:B by lazy{<br>\nB()<br>\n}<br>\n}<br>\n属性初始化</p>\n<ol>\n<li>尽量在构造方法中完成</li>\n<li>无法在构造方法中完成的，尝试降级为局部变量</li>\n<li>var用lateinit延迟初始化，val用lazy</li>\n<li>可空类型慎用null直接初始化</li>\n</ol>\n<p>中缀表达式：只有一个参数，且用infix修饰的函数<br>\nclass Book {infix fun on(placeString:String){…}}<br>\nBook() on “My Desk” //使用方式<br>\n分支表达式：<br>\nval mode=if(args.isNotEmpty() &amp;&amp; args[0] ==1){<br>\n0<br>\n}else{<br>\n1<br>\n}</p>\n<p>异常捕捉<br>\ntry …catch …finally中的执行完之后，再返回结果，可通过var获取返回值</p>\n<p>具名参数：sum(arg1=2,arg0=3)  //参数就可以不按照顺序传递了<br>\n变长参数：如main方法中的args<br>\nfun test(vararg  args:String){}<br>\n默认参数：给出参数默认值</p>\n<p>导出可执行程序</p>\n<p>kotlin应用场景：</p>\n<p>kotlin-android</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">http://kotlinlang.org/</a><br>\n<a href=\"https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt\" target=\"_blank\" rel=\"noopener\">https://try.kotlinlang.org/#/Examples/Hello, world!/Simplest version/Simplest version.kt</a></p>\n<p>Kotlin作者Andrey<br>\nKotlin是一种在 Java 虚拟机上运行的静态类型编程语言,被称之为 Android 世界的Swift,由 JetBrains 设计开发并开源<br>\nKotlin是一种运行在Java虚拟机、Android、浏览器上的静态语言<br>\nKotlin可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。<br>\nAndroid官方语言；100%兼容Java；Kotlin-js前端开发；Kotlin-jvm服务端开发；Kotlin-native本地执行程序；Kotlin是一门全栈语言</p>\n<p>千里之行，始于Hello World</p>\n<p>Kotlin不存在拆箱装箱问题;Kotlin不可隐式转换类型<br>\nvar tmp:[类型]=[变量值]</p>\n<p>Boolean类型<br>\nNumber数据类型：Byte，Short，Int，Long，Float，Double<br>\nChar数据类型：Char<br>\nString数据类型：String         字符串a==b 比较内容；a===b比较应用  字符串模版$args1  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mi>s</mi><mn>1</mn><mo>+</mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>s</mi><mn>2</mn></mrow><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">引</mi><mi mathvariant=\"normal\">号</mi><mi mathvariant=\"normal\">中</mi></mrow><annotation encoding=\"application/x-tex\">{args1+args2},引号中</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">s</span><span class=\"mord\">2</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">引</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">中</span></span></span></span>引用变量 ，多行<br>\nvar a:String …<br>\na1<br>\na2<br>\n…</p>\n<p>Kotlin中 Any 等于 Java中 Object，是顶级类</p>\n<p>空类型：任意类型都有可空和不可空两种状态，？表示可为空，!!表示强制认定nullable不可为空<br>\nfun main(args:Array<string>){<br>\nvar name:String = getName() ?: return<br>\nprintln(name)</string></p>\n<pre><code>var tmp:String? = &quot;Hello Kotlin&quot;\nprintln(tmp)\nprintln(tmp!!.length)\n</code></pre>\n<p>}</p>\n<p>fun getName():String?{<br>\nreturn null<br>\n}</p>\n<p>智能类型转换<br>\nJava方式的：var sub:Subclass = parent as Subclass   //类似于Java方式，转换异常则会抛异常<br>\n安全类型转换：var sub:Subclass? = parent as? Subclass   //如果转换失败，则返回null，不抛异常</p>\n<p>if(parent is Subclass)</p>\n<p>import com.test as test</p>\n<p>区间Range:一个数学上的概念，表示范围；是ClosedRange的子类，IntRange最常用；i in 0…1024 判断i是否在区间内<br>\nvar range:IntRange = 0…1024    //[0,1024]<br>\nvar range:IntRange = 0 until 1024    //[0,1024) == [0,1023]</p>\n<p>className::java.class.name<br>\nclassName::java.class.simpleName</p>\n<p>数组: val array:Array&lt;&gt; = arrayOf(…)<br>\n为了避免不必要的拆箱和装箱，基本类型的数组是定制的<br>\nval arrayOfInt:IntArray = intArrayOf(1,2,4)<br>\nval arrayOfChar:CharArray = charArrayOf(‘H’,‘e’,‘y’)<br>\nval arrayOfString: Array<string> = arrayOf(“Hello”,“Kotlin”)<br>\nval arrayOfOther:Array<other> = arrayOf(Other(1),Other(2))</other></string></p>\n<p>常量：val，常量因为赋值了，编译器可以推导出来类型，所以类型可以不用写，变量：var</p>\n<p>External Tools<br>\nTools-&gt;Kotlin-&gt;Show Kotlin Bytecode</p>\n<p>函数：Kotlin中没有申明返回值的默认返回值是Unit<br>\nkotlinc安装，使用和javac一样<br>\n变量函数<br>\nvar int2Long = fun(x:Int):Long{<br>\nreturn x.toLong()<br>\n}<br>\nint2Long(123)<br>\nfun sum(arg1:Int,arg2:Int) = arg1+arg2<br>\nLambda表达式调用使用()或者invoke(),如：sum(1,2) 或 sum.invoke(1,2)<br>\nLambda表达式–匿名函数</p>\n<p>var = {arg1:Int,arg2:Int -&gt; arg1+arg2}</p>\n<p>arrayOfString.forEach { println(it) }   //如果字面函数只有一个参数,可以省略该参数声明,并用“it”代替<br>\narrayOfString.forEach(::println)</p>\n<p>Lambda表达式中的return<br>\n<a href=\"https://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/92cd94cba709?utm_source=oschina-app</a></p>\n<p>public inline fun <t> Array<out t=\"\">.forEach(action: (T) -&gt; Unit): Unit {<br>\nfor (element in this) action(element)<br>\n}</out></t></p>\n<p>indexes.forEach {<br>\nif (it &gt; 5) {<br>\nreturn@forEach<br>\n}<br>\nprintln(it)<br>\n}</p>\n<p>indexes.forEach label@ {<br>\nif (it &gt; 5) {<br>\nreturn @label<br>\n}<br>\nprintln(it)<br>\n}</p>\n<p>函数参数调用时最后一个Lambda可以移出去<br>\n函数参数只有一个Lambda，调用时小括号可以省略<br>\nLambda有一个参数，可默认为it<br>\n入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入</p>\n<p>类成员方法和成员变量<br>\nclass B<br>\nclass A{<br>\nvar b=0;<br>\nlateinit var c:String<br>\nval d:B by lazy{<br>\nB()<br>\n}<br>\n}<br>\n属性初始化</p>\n<ol>\n<li>尽量在构造方法中完成</li>\n<li>无法在构造方法中完成的，尝试降级为局部变量</li>\n<li>var用lateinit延迟初始化，val用lazy</li>\n<li>可空类型慎用null直接初始化</li>\n</ol>\n<p>中缀表达式：只有一个参数，且用infix修饰的函数<br>\nclass Book {infix fun on(placeString:String){…}}<br>\nBook() on “My Desk” //使用方式<br>\n分支表达式：<br>\nval mode=if(args.isNotEmpty() &amp;&amp; args[0] ==1){<br>\n0<br>\n}else{<br>\n1<br>\n}</p>\n<p>异常捕捉<br>\ntry …catch …finally中的执行完之后，再返回结果，可通过var获取返回值</p>\n<p>具名参数：sum(arg1=2,arg0=3)  //参数就可以不按照顺序传递了<br>\n变长参数：如main方法中的args<br>\nfun test(vararg  args:String){}<br>\n默认参数：给出参数默认值</p>\n<p>导出可执行程序</p>\n<p>kotlin应用场景：</p>\n<p>kotlin-android</p>\n"},{"title":"SpringBoot","copyright":true,"comments":1,"toc":true,"date":"2018-11-26T06:41:51.000Z","password":null,"_content":"\nhttp://spring.io/\n\nhttps://www.imooc.com/video/16358\n\n英文文档：https://docs.spring.io/spring-boot/docs/current/reference/\n\nSpring Framework是一种JavaEE的框架\nSpring Boot是一种快速构建的Spring应用\nSpring Cloud是构建SpringBoot的分布式应用\n\nSpringBoot2.0\n编程语言：Java 8+，Kotlin，底层框架：SpringFramework 5.0.X,支持Web Flux\n\nWeb Flux  \n1. 支持函数编程，Java 8 Lambda\n2. 响应式编程,Reactive Streams\n3. 异步编程，Servlet3.1和Asyc NIO\n\nInteliJ中配置Java和Maven\n\n构建项目：\n图形化方式\n1 http://start.spring.io/ ，输入选择Reactive Web\n2 导入项目\n命令行方式（Maven）\nmvn archetype:generate -DinteractiveMode=false -DgroupId=com.test -DartifactId=first-app-by-maven -Dversion=1.0.0-SNAPSHOT\n添加\n <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.9.RELEASE</version>\n    <relativePath/>\n</parent>\n    \n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n\n取消Junit的版本，需要4.1.2以上，取掉之后spring-boot-starter-parent继承版本\n\n\n\n----\n父Module的packaging设置为pom \n\n\n打包方式\nJar包方式 \nWar包方式\n指定Main-class方式\n\n<plugin>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-maven-plugin</artifactId>\n  <version>1.5.4.RELEASE</version>\n  <configuration>\n    <mainClass>${start-class}</mainClass>\n    <layout>ZIP</layout>\n  </configuration>\n  <executions>\n    <execution>\n      <goals>\n        <goal>repackage</goal>\n      </goals>\n    </execution>\n  </executions>\n</plugin> \n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html\n\njar包形式\nmvn -Dmaven.test.skip -U clean package\njava -jar [jar名称.jar]\n\n\nwar包形式，需要有webapp->WEB-INF->web.xml\njava -jar [war名称.war]\n\n\n运行模式\nIDEA方式\nJar／War方式\nMaven插件方式：\nmvn srping-boot:run//需要在Main方法module，使用前，需要在父Module mvn -Dmaven.test.skip -U clean install\nhttps://blog.csdn.net/taiyangdao/article/details/75303181\n\nConcurrentHashMap  http://www.importnew.com/28263.html  https://www.cnblogs.com/heyonggang/p/9112731.html\nAtomicInteger https://www.cnblogs.com/sharkli/p/5623524.html\n好的习惯，实体都实现toString()方法 \n\nFlux & Mono\nFlux：0到N个对象的集合\nMono：0到1个对象的集合\nReactive中的Flux和Mono是异步处理的，都是Publisher\n\n\nhttps://www.imooc.com/learn/1058\n组件自动装配：规约大于配置，专注核心业务\n外部化部署：一次构建、按需调配，到处运行\n嵌入式容器：内置容器、无需部署、独立运行\nSpringBoot Starter:简化依赖、按需装配、自我包含\nProduction-Ready：一站式运维、生态无缝整合\n\nJava 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。\n最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。\n等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。\n目前大数据领域，Java 同样是当仁不让的好手。\n\n现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。\n\n换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。\n\n\nhttps://www.imooc.com/video/16783\nSrpingBoot为微服务框架，与Spring4一起诞生\n\n\nhttps://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/\n","source":"_posts/Java/2018-11-26-SpringBoot.md","raw":"---\ntitle: SpringBoot\ntags: \n  - Spring Boot \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-11-26 14:41:51\ncategories: Spring\npassword:\n---\n\nhttp://spring.io/\n\nhttps://www.imooc.com/video/16358\n\n英文文档：https://docs.spring.io/spring-boot/docs/current/reference/\n\nSpring Framework是一种JavaEE的框架\nSpring Boot是一种快速构建的Spring应用\nSpring Cloud是构建SpringBoot的分布式应用\n\nSpringBoot2.0\n编程语言：Java 8+，Kotlin，底层框架：SpringFramework 5.0.X,支持Web Flux\n\nWeb Flux  \n1. 支持函数编程，Java 8 Lambda\n2. 响应式编程,Reactive Streams\n3. 异步编程，Servlet3.1和Asyc NIO\n\nInteliJ中配置Java和Maven\n\n构建项目：\n图形化方式\n1 http://start.spring.io/ ，输入选择Reactive Web\n2 导入项目\n命令行方式（Maven）\nmvn archetype:generate -DinteractiveMode=false -DgroupId=com.test -DartifactId=first-app-by-maven -Dversion=1.0.0-SNAPSHOT\n添加\n <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.9.RELEASE</version>\n    <relativePath/>\n</parent>\n    \n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n\n取消Junit的版本，需要4.1.2以上，取掉之后spring-boot-starter-parent继承版本\n\n\n\n----\n父Module的packaging设置为pom \n\n\n打包方式\nJar包方式 \nWar包方式\n指定Main-class方式\n\n<plugin>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-maven-plugin</artifactId>\n  <version>1.5.4.RELEASE</version>\n  <configuration>\n    <mainClass>${start-class}</mainClass>\n    <layout>ZIP</layout>\n  </configuration>\n  <executions>\n    <execution>\n      <goals>\n        <goal>repackage</goal>\n      </goals>\n    </execution>\n  </executions>\n</plugin> \n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html\n\njar包形式\nmvn -Dmaven.test.skip -U clean package\njava -jar [jar名称.jar]\n\n\nwar包形式，需要有webapp->WEB-INF->web.xml\njava -jar [war名称.war]\n\n\n运行模式\nIDEA方式\nJar／War方式\nMaven插件方式：\nmvn srping-boot:run//需要在Main方法module，使用前，需要在父Module mvn -Dmaven.test.skip -U clean install\nhttps://blog.csdn.net/taiyangdao/article/details/75303181\n\nConcurrentHashMap  http://www.importnew.com/28263.html  https://www.cnblogs.com/heyonggang/p/9112731.html\nAtomicInteger https://www.cnblogs.com/sharkli/p/5623524.html\n好的习惯，实体都实现toString()方法 \n\nFlux & Mono\nFlux：0到N个对象的集合\nMono：0到1个对象的集合\nReactive中的Flux和Mono是异步处理的，都是Publisher\n\n\nhttps://www.imooc.com/learn/1058\n组件自动装配：规约大于配置，专注核心业务\n外部化部署：一次构建、按需调配，到处运行\n嵌入式容器：内置容器、无需部署、独立运行\nSpringBoot Starter:简化依赖、按需装配、自我包含\nProduction-Ready：一站式运维、生态无缝整合\n\nJava 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。\n最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。\n等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。\n目前大数据领域，Java 同样是当仁不让的好手。\n\n现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。\n\n换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。\n\n\nhttps://www.imooc.com/video/16783\nSrpingBoot为微服务框架，与Spring4一起诞生\n\n\nhttps://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/\n","slug":"Java-2018-11-26-SpringBoot","published":1,"updated":"2019-02-14T02:26:41.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx1000d5b8hz3iayig5","content":"<p><a href=\"http://spring.io/\" target=\"_blank\" rel=\"noopener\">http://spring.io/</a></p>\n<p><a href=\"https://www.imooc.com/video/16358\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/video/16358</a></p>\n<p>英文文档：<a href=\"https://docs.spring.io/spring-boot/docs/current/reference/\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-boot/docs/current/reference/</a></p>\n<p>Spring Framework是一种JavaEE的框架<br>\nSpring Boot是一种快速构建的Spring应用<br>\nSpring Cloud是构建SpringBoot的分布式应用</p>\n<p>SpringBoot2.0<br>\n编程语言：Java 8+，Kotlin，底层框架：SpringFramework 5.0.X,支持Web Flux</p>\n<p>Web Flux</p>\n<ol>\n<li>支持函数编程，Java 8 Lambda</li>\n<li>响应式编程,Reactive Streams</li>\n<li>异步编程，Servlet3.1和Asyc NIO</li>\n</ol>\n<p>InteliJ中配置Java和Maven</p>\n<p>构建项目：<br>\n图形化方式<br>\n1 <a href=\"http://start.spring.io/\" target=\"_blank\" rel=\"noopener\">http://start.spring.io/</a> ，输入选择Reactive Web<br>\n2 导入项目<br>\n命令行方式（Maven）<br>\nmvn archetype:generate -DinteractiveMode=false -DgroupId=com.test -DartifactId=first-app-by-maven -Dversion=1.0.0-SNAPSHOT<br>\n添加<br>\n<parent><br>\n<groupid>org.springframework.boot</groupid><br>\n<artifactid>spring-boot-starter-parent</artifactid><br>\n<version>1.5.9.RELEASE</version><br>\n<relativepath><br>\n</relativepath></parent></p>\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n</dependencies>\n<p>取消Junit的版本，需要4.1.2以上，取掉之后spring-boot-starter-parent继承版本</p>\n<hr>\n<p>父Module的packaging设置为pom</p>\n<p>打包方式<br>\nJar包方式<br>\nWar包方式<br>\n指定Main-class方式</p>\n<plugin>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-maven-plugin</artifactid>\n  <version>1.5.4.RELEASE</version>\n  <configuration>\n    <mainclass>${start-class}</mainclass>\n    <layout>ZIP</layout>\n  </configuration>\n  <executions>\n    <execution>\n      <goals>\n        <goal>repackage</goal>\n      </goals>\n    </execution>\n  </executions>\n</plugin> \n<p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html</a></p>\n<p>jar包形式<br>\nmvn -Dmaven.test.skip -U clean package<br>\njava -jar [jar名称.jar]</p>\n<p>war包形式，需要有webapp-&gt;WEB-INF-&gt;web.xml<br>\njava -jar [war名称.war]</p>\n<p>运行模式<br>\nIDEA方式<br>\nJar／War方式<br>\nMaven插件方式：<br>\nmvn srping-boot:run//需要在Main方法module，使用前，需要在父Module mvn -Dmaven.test.skip -U clean install<br>\n<a href=\"https://blog.csdn.net/taiyangdao/article/details/75303181\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/taiyangdao/article/details/75303181</a></p>\n<p>ConcurrentHashMap  <a href=\"http://www.importnew.com/28263.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/28263.html</a>  <a href=\"https://www.cnblogs.com/heyonggang/p/9112731.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/heyonggang/p/9112731.html</a><br>\nAtomicInteger <a href=\"https://www.cnblogs.com/sharkli/p/5623524.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sharkli/p/5623524.html</a><br>\n好的习惯，实体都实现toString()方法</p>\n<p>Flux &amp; Mono<br>\nFlux：0到N个对象的集合<br>\nMono：0到1个对象的集合<br>\nReactive中的Flux和Mono是异步处理的，都是Publisher</p>\n<p><a href=\"https://www.imooc.com/learn/1058\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/learn/1058</a><br>\n组件自动装配：规约大于配置，专注核心业务<br>\n外部化部署：一次构建、按需调配，到处运行<br>\n嵌入式容器：内置容器、无需部署、独立运行<br>\nSpringBoot Starter:简化依赖、按需装配、自我包含<br>\nProduction-Ready：一站式运维、生态无缝整合</p>\n<p>Java 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。<br>\n最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。<br>\n等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。<br>\n目前大数据领域，Java 同样是当仁不让的好手。</p>\n<p>现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。</p>\n<p>换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。</p>\n<p><a href=\"https://www.imooc.com/video/16783\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/video/16783</a><br>\nSrpingBoot为微服务框架，与Spring4一起诞生</p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://spring.io/\" target=\"_blank\" rel=\"noopener\">http://spring.io/</a></p>\n<p><a href=\"https://www.imooc.com/video/16358\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/video/16358</a></p>\n<p>英文文档：<a href=\"https://docs.spring.io/spring-boot/docs/current/reference/\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-boot/docs/current/reference/</a></p>\n<p>Spring Framework是一种JavaEE的框架<br>\nSpring Boot是一种快速构建的Spring应用<br>\nSpring Cloud是构建SpringBoot的分布式应用</p>\n<p>SpringBoot2.0<br>\n编程语言：Java 8+，Kotlin，底层框架：SpringFramework 5.0.X,支持Web Flux</p>\n<p>Web Flux</p>\n<ol>\n<li>支持函数编程，Java 8 Lambda</li>\n<li>响应式编程,Reactive Streams</li>\n<li>异步编程，Servlet3.1和Asyc NIO</li>\n</ol>\n<p>InteliJ中配置Java和Maven</p>\n<p>构建项目：<br>\n图形化方式<br>\n1 <a href=\"http://start.spring.io/\" target=\"_blank\" rel=\"noopener\">http://start.spring.io/</a> ，输入选择Reactive Web<br>\n2 导入项目<br>\n命令行方式（Maven）<br>\nmvn archetype:generate -DinteractiveMode=false -DgroupId=com.test -DartifactId=first-app-by-maven -Dversion=1.0.0-SNAPSHOT<br>\n添加<br>\n<parent><br>\n<groupid>org.springframework.boot</groupid><br>\n<artifactid>spring-boot-starter-parent</artifactid><br>\n<version>1.5.9.RELEASE</version><br>\n<relativepath><br>\n</relativepath></parent></p>\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n</dependencies>\n<p>取消Junit的版本，需要4.1.2以上，取掉之后spring-boot-starter-parent继承版本</p>\n<hr>\n<p>父Module的packaging设置为pom</p>\n<p>打包方式<br>\nJar包方式<br>\nWar包方式<br>\n指定Main-class方式</p>\n<plugin>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-maven-plugin</artifactid>\n  <version>1.5.4.RELEASE</version>\n  <configuration>\n    <mainclass>${start-class}</mainclass>\n    <layout>ZIP</layout>\n  </configuration>\n  <executions>\n    <execution>\n      <goals>\n        <goal>repackage</goal>\n      </goals>\n    </execution>\n  </executions>\n</plugin> \n<p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html</a></p>\n<p>jar包形式<br>\nmvn -Dmaven.test.skip -U clean package<br>\njava -jar [jar名称.jar]</p>\n<p>war包形式，需要有webapp-&gt;WEB-INF-&gt;web.xml<br>\njava -jar [war名称.war]</p>\n<p>运行模式<br>\nIDEA方式<br>\nJar／War方式<br>\nMaven插件方式：<br>\nmvn srping-boot:run//需要在Main方法module，使用前，需要在父Module mvn -Dmaven.test.skip -U clean install<br>\n<a href=\"https://blog.csdn.net/taiyangdao/article/details/75303181\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/taiyangdao/article/details/75303181</a></p>\n<p>ConcurrentHashMap  <a href=\"http://www.importnew.com/28263.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/28263.html</a>  <a href=\"https://www.cnblogs.com/heyonggang/p/9112731.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/heyonggang/p/9112731.html</a><br>\nAtomicInteger <a href=\"https://www.cnblogs.com/sharkli/p/5623524.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sharkli/p/5623524.html</a><br>\n好的习惯，实体都实现toString()方法</p>\n<p>Flux &amp; Mono<br>\nFlux：0到N个对象的集合<br>\nMono：0到1个对象的集合<br>\nReactive中的Flux和Mono是异步处理的，都是Publisher</p>\n<p><a href=\"https://www.imooc.com/learn/1058\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/learn/1058</a><br>\n组件自动装配：规约大于配置，专注核心业务<br>\n外部化部署：一次构建、按需调配，到处运行<br>\n嵌入式容器：内置容器、无需部署、独立运行<br>\nSpringBoot Starter:简化依赖、按需装配、自我包含<br>\nProduction-Ready：一站式运维、生态无缝整合</p>\n<p>Java 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。<br>\n最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。<br>\n等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。<br>\n目前大数据领域，Java 同样是当仁不让的好手。</p>\n<p>现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。</p>\n<p>换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。</p>\n<p><a href=\"https://www.imooc.com/video/16783\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/video/16783</a><br>\nSrpingBoot为微服务框架，与Spring4一起诞生</p>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/</a></p>\n"},{"title":"aa","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"  \n\nhttps://www.cnblogs.com/god--love-you/p/6133390.html\n\nspringboot\nhttps://blog.csdn.net/forezp/column/info/15397/1\nhttps://blog.csdn.net/vbirdbest/article/category/7490600/3\n\n\nhttps://github.com/lenve/vhr\n\nnetty\nhttps://waylau.com/netty-4-user-guide/\n\nhttps://github.com/doocs/advanced-java\n\n\nhttps://blog.csdn.net/qq_38765404/article/details/78615572\n\nhttp://www.cnblogs.com/felixzh/p/5869212.html\n\n\n\noracle\nhttps://www.cnblogs.com/kane1990/p/OracleNetManager.html\nhttps://blog.csdn.net/u011179993/article/details/51554324\nhttps://www.cnblogs.com/yadongliang/p/5840203.html\nhttp://blog.51cto.com/mazongfei/2126876\nhttps://blog.csdn.net/weixin_37480339/article/details/81017214\nhttps://blog.csdn.net/wangjialiang/article/details/7867791\n\nhttp://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html\n\n\n","source":"_posts/Java/2018-12-19-aa.md","raw":"---\ntitle: aa\ntags:\n  - null\n  - null\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories:\npassword:\n---\n  \n\nhttps://www.cnblogs.com/god--love-you/p/6133390.html\n\nspringboot\nhttps://blog.csdn.net/forezp/column/info/15397/1\nhttps://blog.csdn.net/vbirdbest/article/category/7490600/3\n\n\nhttps://github.com/lenve/vhr\n\nnetty\nhttps://waylau.com/netty-4-user-guide/\n\nhttps://github.com/doocs/advanced-java\n\n\nhttps://blog.csdn.net/qq_38765404/article/details/78615572\n\nhttp://www.cnblogs.com/felixzh/p/5869212.html\n\n\n\noracle\nhttps://www.cnblogs.com/kane1990/p/OracleNetManager.html\nhttps://blog.csdn.net/u011179993/article/details/51554324\nhttps://www.cnblogs.com/yadongliang/p/5840203.html\nhttp://blog.51cto.com/mazongfei/2126876\nhttps://blog.csdn.net/weixin_37480339/article/details/81017214\nhttps://blog.csdn.net/wangjialiang/article/details/7867791\n\nhttp://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html\n\n\n","slug":"Java-2018-12-19-aa","published":1,"updated":"2019-01-10T18:14:32.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx2000e5b8h5268vxyw","content":"<p><a href=\"https://www.cnblogs.com/god--love-you/p/6133390.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/god--love-you/p/6133390.html</a></p>\n<p>springboot<br>\n<a href=\"https://blog.csdn.net/forezp/column/info/15397/1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/forezp/column/info/15397/1</a><br>\n<a href=\"https://blog.csdn.net/vbirdbest/article/category/7490600/3\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/vbirdbest/article/category/7490600/3</a></p>\n<p><a href=\"https://github.com/lenve/vhr\" target=\"_blank\" rel=\"noopener\">https://github.com/lenve/vhr</a></p>\n<p>netty<br>\n<a href=\"https://waylau.com/netty-4-user-guide/\" target=\"_blank\" rel=\"noopener\">https://waylau.com/netty-4-user-guide/</a></p>\n<p><a href=\"https://github.com/doocs/advanced-java\" target=\"_blank\" rel=\"noopener\">https://github.com/doocs/advanced-java</a></p>\n<p><a href=\"https://blog.csdn.net/qq_38765404/article/details/78615572\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38765404/article/details/78615572</a></p>\n<p><a href=\"http://www.cnblogs.com/felixzh/p/5869212.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/felixzh/p/5869212.html</a></p>\n<p>oracle<br>\n<a href=\"https://www.cnblogs.com/kane1990/p/OracleNetManager.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kane1990/p/OracleNetManager.html</a><br>\n<a href=\"https://blog.csdn.net/u011179993/article/details/51554324\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011179993/article/details/51554324</a><br>\n<a href=\"https://www.cnblogs.com/yadongliang/p/5840203.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yadongliang/p/5840203.html</a><br>\n<a href=\"http://blog.51cto.com/mazongfei/2126876\" target=\"_blank\" rel=\"noopener\">http://blog.51cto.com/mazongfei/2126876</a><br>\n<a href=\"https://blog.csdn.net/weixin_37480339/article/details/81017214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_37480339/article/details/81017214</a><br>\n<a href=\"https://blog.csdn.net/wangjialiang/article/details/7867791\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wangjialiang/article/details/7867791</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.cnblogs.com/god--love-you/p/6133390.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/god--love-you/p/6133390.html</a></p>\n<p>springboot<br>\n<a href=\"https://blog.csdn.net/forezp/column/info/15397/1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/forezp/column/info/15397/1</a><br>\n<a href=\"https://blog.csdn.net/vbirdbest/article/category/7490600/3\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/vbirdbest/article/category/7490600/3</a></p>\n<p><a href=\"https://github.com/lenve/vhr\" target=\"_blank\" rel=\"noopener\">https://github.com/lenve/vhr</a></p>\n<p>netty<br>\n<a href=\"https://waylau.com/netty-4-user-guide/\" target=\"_blank\" rel=\"noopener\">https://waylau.com/netty-4-user-guide/</a></p>\n<p><a href=\"https://github.com/doocs/advanced-java\" target=\"_blank\" rel=\"noopener\">https://github.com/doocs/advanced-java</a></p>\n<p><a href=\"https://blog.csdn.net/qq_38765404/article/details/78615572\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38765404/article/details/78615572</a></p>\n<p><a href=\"http://www.cnblogs.com/felixzh/p/5869212.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/felixzh/p/5869212.html</a></p>\n<p>oracle<br>\n<a href=\"https://www.cnblogs.com/kane1990/p/OracleNetManager.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kane1990/p/OracleNetManager.html</a><br>\n<a href=\"https://blog.csdn.net/u011179993/article/details/51554324\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011179993/article/details/51554324</a><br>\n<a href=\"https://www.cnblogs.com/yadongliang/p/5840203.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yadongliang/p/5840203.html</a><br>\n<a href=\"http://blog.51cto.com/mazongfei/2126876\" target=\"_blank\" rel=\"noopener\">http://blog.51cto.com/mazongfei/2126876</a><br>\n<a href=\"https://blog.csdn.net/weixin_37480339/article/details/81017214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_37480339/article/details/81017214</a><br>\n<a href=\"https://blog.csdn.net/wangjialiang/article/details/7867791\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wangjialiang/article/details/7867791</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_13689d7d40102y3d3.html</a></p>\n"},{"title":"Java并发编程","copyright":true,"comments":1,"toc":true,"date":"2019-01-02T07:52:38.000Z","password":null,"_content":"ExecutorService   Semaphore\n\n并发实现一个计数器：引入问题\n\n\n并发与高并发：\n\n\nJava内存模型-写一篇文章\nJava内存模型：Java Memory Model（JMM）\n\nCPU包括运算逻辑部件、寄存器部件和控制部件等。寄存器在CPU上\n\nJava堆：Heap运行时数据区，有垃圾回收来负责，可以动态分配大小，生存期也不必提前告诉编译器，是在运行时动态分配内存的，由于需要动态分配，所以速度比栈慢\nJava栈：Stack速度仅次于寄存器，数据可以共享，缺点是栈中的数据的大小及生存期必须是确定的， \n\n线程之间操作必须通过主内存\n\nhttps://www.cnblogs.com/zhehan54/p/6130030.html\n实现并发的方式有多种：比如多进程、多线程、IO多路复用。\n进程是资源（CPU、内存等）分配的基本单位\n\n\n\n自定义注解\n\nhttps://blog.csdn.net/motui/article/details/79012846\n\n线程安全性-原子性\ncompareAndSwapXXX：当前值和底层值对比，如果一样则执行，如果不一样，则重新获取再比较\n\nAtomicLong  LongAdder\n\n\nhttps://blog.csdn.net/jesonjoke/article/list/1\n\nhttp://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html\n\n\nhttps://me.csdn.net/jesonjoke\n\n","source":"_posts/Java/2019-01-02-Java并发编程.md","raw":"---\ntitle: Java并发编程\ntags:\n  - 并发编程\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-01-02 15:52:38\ncategories: Java\npassword:\n---\nExecutorService   Semaphore\n\n并发实现一个计数器：引入问题\n\n\n并发与高并发：\n\n\nJava内存模型-写一篇文章\nJava内存模型：Java Memory Model（JMM）\n\nCPU包括运算逻辑部件、寄存器部件和控制部件等。寄存器在CPU上\n\nJava堆：Heap运行时数据区，有垃圾回收来负责，可以动态分配大小，生存期也不必提前告诉编译器，是在运行时动态分配内存的，由于需要动态分配，所以速度比栈慢\nJava栈：Stack速度仅次于寄存器，数据可以共享，缺点是栈中的数据的大小及生存期必须是确定的， \n\n线程之间操作必须通过主内存\n\nhttps://www.cnblogs.com/zhehan54/p/6130030.html\n实现并发的方式有多种：比如多进程、多线程、IO多路复用。\n进程是资源（CPU、内存等）分配的基本单位\n\n\n\n自定义注解\n\nhttps://blog.csdn.net/motui/article/details/79012846\n\n线程安全性-原子性\ncompareAndSwapXXX：当前值和底层值对比，如果一样则执行，如果不一样，则重新获取再比较\n\nAtomicLong  LongAdder\n\n\nhttps://blog.csdn.net/jesonjoke/article/list/1\n\nhttp://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html\n\n\nhttps://me.csdn.net/jesonjoke\n\n","slug":"Java-2019-01-02-Java并发编程","published":1,"updated":"2019-02-14T02:27:01.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx3000i5b8h0gvaosck","content":"<p>ExecutorService   Semaphore</p>\n<p>并发实现一个计数器：引入问题</p>\n<p>并发与高并发：</p>\n<p>Java内存模型-写一篇文章<br>\nJava内存模型：Java Memory Model（JMM）</p>\n<p>CPU包括运算逻辑部件、寄存器部件和控制部件等。寄存器在CPU上</p>\n<p>Java堆：Heap运行时数据区，有垃圾回收来负责，可以动态分配大小，生存期也不必提前告诉编译器，是在运行时动态分配内存的，由于需要动态分配，所以速度比栈慢<br>\nJava栈：Stack速度仅次于寄存器，数据可以共享，缺点是栈中的数据的大小及生存期必须是确定的，</p>\n<p>线程之间操作必须通过主内存</p>\n<p><a href=\"https://www.cnblogs.com/zhehan54/p/6130030.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhehan54/p/6130030.html</a><br>\n实现并发的方式有多种：比如多进程、多线程、IO多路复用。<br>\n进程是资源（CPU、内存等）分配的基本单位</p>\n<p>自定义注解</p>\n<p><a href=\"https://blog.csdn.net/motui/article/details/79012846\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/motui/article/details/79012846</a></p>\n<p>线程安全性-原子性<br>\ncompareAndSwapXXX：当前值和底层值对比，如果一样则执行，如果不一样，则重新获取再比较</p>\n<p>AtomicLong  LongAdder</p>\n<p><a href=\"https://blog.csdn.net/jesonjoke/article/list/1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jesonjoke/article/list/1</a></p>\n<p><a href=\"http://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html</a></p>\n<p><a href=\"https://me.csdn.net/jesonjoke\" target=\"_blank\" rel=\"noopener\">https://me.csdn.net/jesonjoke</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ExecutorService   Semaphore</p>\n<p>并发实现一个计数器：引入问题</p>\n<p>并发与高并发：</p>\n<p>Java内存模型-写一篇文章<br>\nJava内存模型：Java Memory Model（JMM）</p>\n<p>CPU包括运算逻辑部件、寄存器部件和控制部件等。寄存器在CPU上</p>\n<p>Java堆：Heap运行时数据区，有垃圾回收来负责，可以动态分配大小，生存期也不必提前告诉编译器，是在运行时动态分配内存的，由于需要动态分配，所以速度比栈慢<br>\nJava栈：Stack速度仅次于寄存器，数据可以共享，缺点是栈中的数据的大小及生存期必须是确定的，</p>\n<p>线程之间操作必须通过主内存</p>\n<p><a href=\"https://www.cnblogs.com/zhehan54/p/6130030.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhehan54/p/6130030.html</a><br>\n实现并发的方式有多种：比如多进程、多线程、IO多路复用。<br>\n进程是资源（CPU、内存等）分配的基本单位</p>\n<p>自定义注解</p>\n<p><a href=\"https://blog.csdn.net/motui/article/details/79012846\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/motui/article/details/79012846</a></p>\n<p>线程安全性-原子性<br>\ncompareAndSwapXXX：当前值和底层值对比，如果一样则执行，如果不一样，则重新获取再比较</p>\n<p>AtomicLong  LongAdder</p>\n<p><a href=\"https://blog.csdn.net/jesonjoke/article/list/1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jesonjoke/article/list/1</a></p>\n<p><a href=\"http://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hongten/p/hongten_oracle_plsql.html</a></p>\n<p><a href=\"https://me.csdn.net/jesonjoke\" target=\"_blank\" rel=\"noopener\">https://me.csdn.net/jesonjoke</a></p>\n"},{"title":"Java8 特性","copyright":true,"comments":1,"toc":true,"date":"2018-11-26T13:25:33.000Z","password":null,"_content":"\n[toc]\n \n# SAM接口 \nJava8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口\n~~~\nPredicate<T>——接收T对象并返回boolean\nConsumer<T>——接收T对象，不返回值\nFunction<T, R>——接收T对象，返回R对象\nSupplier<T>——提供T对象（例如工厂），不接收值\nUnaryOperator<T>——接收T对象，返回T对象\nBinaryOperator<T>——接收两个T对象，返回T对象\n~~~\n\n# lambda表达式\n参考：http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694\n\n# 方法引用和构造器引用\n## 方法引用\n~~~\nobjectName::instanceMethod\n\nClassName::staticMethod\n\nClassName::instanceMethod\n~~~\n1. 前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用\n2. 最后一种方式，等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数\n\n## 构造器引用\n构造器引用语法如下：ClassName::new，把lambda表达式的参数当成ClassName构造器的参数 。例如BigDecimal::new等同于x->new BigDecimal(x)\n\n# Stream语法\nstream就是JAVA8提供给我们的对于元素集合统一、快速、并行操作的一种方式。 \n它能充分运用多核的优势，以及配合lambda表达式、链式结构对集合等进行许多有用的操作\n\n1. Stream是元素的集合，这点让Stream看起来用些类似Iterator,可以把Stream当成一个装饰后的Iterator；\n2. 可以支持顺序和并行的对原Stream进行汇聚的操作；\n~~~\nList<Integer> nums = Lists.newArrayList(1,null,3,4,null,6);\nnums.stream().filter(num -> num != null).count();\n~~~\n\n\n","source":"_posts/Java/Java8 特性.md","raw":"---\ntitle: Java8 特性\ntags:\n  - Java\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-11-26 21:25:33\ncategories: Java\npassword:\n---\n\n[toc]\n \n# SAM接口 \nJava8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口\n~~~\nPredicate<T>——接收T对象并返回boolean\nConsumer<T>——接收T对象，不返回值\nFunction<T, R>——接收T对象，返回R对象\nSupplier<T>——提供T对象（例如工厂），不接收值\nUnaryOperator<T>——接收T对象，返回T对象\nBinaryOperator<T>——接收两个T对象，返回T对象\n~~~\n\n# lambda表达式\n参考：http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694\n\n# 方法引用和构造器引用\n## 方法引用\n~~~\nobjectName::instanceMethod\n\nClassName::staticMethod\n\nClassName::instanceMethod\n~~~\n1. 前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用\n2. 最后一种方式，等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数\n\n## 构造器引用\n构造器引用语法如下：ClassName::new，把lambda表达式的参数当成ClassName构造器的参数 。例如BigDecimal::new等同于x->new BigDecimal(x)\n\n# Stream语法\nstream就是JAVA8提供给我们的对于元素集合统一、快速、并行操作的一种方式。 \n它能充分运用多核的优势，以及配合lambda表达式、链式结构对集合等进行许多有用的操作\n\n1. Stream是元素的集合，这点让Stream看起来用些类似Iterator,可以把Stream当成一个装饰后的Iterator；\n2. 可以支持顺序和并行的对原Stream进行汇聚的操作；\n~~~\nList<Integer> nums = Lists.newArrayList(1,null,3,4,null,6);\nnums.stream().filter(num -> num != null).count();\n~~~\n\n\n","slug":"Java-Java8-特性","published":1,"updated":"2019-02-14T06:46:51.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx4000j5b8hn2d6yipv","content":"<p>[toc]</p>\n<h1 id=\"sam接口\"><a class=\"markdownIt-Anchor\" href=\"#sam接口\"></a> SAM接口</h1>\n<p>Java8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Predicate&lt;T&gt;——接收T对象并返回boolean</span><br><span class=\"line\">Consumer&lt;T&gt;——接收T对象，不返回值</span><br><span class=\"line\">Function&lt;T, R&gt;——接收T对象，返回R对象</span><br><span class=\"line\">Supplier&lt;T&gt;——提供T对象（例如工厂），不接收值</span><br><span class=\"line\">UnaryOperator&lt;T&gt;——接收T对象，返回T对象</span><br><span class=\"line\">BinaryOperator&lt;T&gt;——接收两个T对象，返回T对象</span><br></pre></td></tr></table></figure>\n<h1 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式\"></a> lambda表达式</h1>\n<p>参考：<a href=\"http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694\" target=\"_blank\" rel=\"noopener\">http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694</a></p>\n<h1 id=\"方法引用和构造器引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用和构造器引用\"></a> 方法引用和构造器引用</h1>\n<h2 id=\"方法引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用\"></a> 方法引用</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectName::instanceMethod</span><br><span class=\"line\"></span><br><span class=\"line\">ClassName::staticMethod</span><br><span class=\"line\"></span><br><span class=\"line\">ClassName::instanceMethod</span><br></pre></td></tr></table></figure>\n<ol>\n<li>前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用</li>\n<li>最后一种方式，等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数</li>\n</ol>\n<h2 id=\"构造器引用\"><a class=\"markdownIt-Anchor\" href=\"#构造器引用\"></a> 构造器引用</h2>\n<p>构造器引用语法如下：ClassName::new，把lambda表达式的参数当成ClassName构造器的参数 。例如BigDecimal::new等同于x-&gt;new BigDecimal(x)</p>\n<h1 id=\"stream语法\"><a class=\"markdownIt-Anchor\" href=\"#stream语法\"></a> Stream语法</h1>\n<p>stream就是JAVA8提供给我们的对于元素集合统一、快速、并行操作的一种方式。<br>\n它能充分运用多核的优势，以及配合lambda表达式、链式结构对集合等进行许多有用的操作</p>\n<ol>\n<li>Stream是元素的集合，这点让Stream看起来用些类似Iterator,可以把Stream当成一个装饰后的Iterator；</li>\n<li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = Lists.newArrayList(1,null,3,4,null,6);</span><br><span class=\"line\">nums.stream().filter(num -&gt; num != null).count();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"sam接口\"><a class=\"markdownIt-Anchor\" href=\"#sam接口\"></a> SAM接口</h1>\n<p>Java8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Predicate&lt;T&gt;——接收T对象并返回boolean</span><br><span class=\"line\">Consumer&lt;T&gt;——接收T对象，不返回值</span><br><span class=\"line\">Function&lt;T, R&gt;——接收T对象，返回R对象</span><br><span class=\"line\">Supplier&lt;T&gt;——提供T对象（例如工厂），不接收值</span><br><span class=\"line\">UnaryOperator&lt;T&gt;——接收T对象，返回T对象</span><br><span class=\"line\">BinaryOperator&lt;T&gt;——接收两个T对象，返回T对象</span><br></pre></td></tr></table></figure>\n<h1 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式\"></a> lambda表达式</h1>\n<p>参考：<a href=\"http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694\" target=\"_blank\" rel=\"noopener\">http://note.youdao.com/noteshare?id=3bc7675e64b86f5e9b75534c0e436694</a></p>\n<h1 id=\"方法引用和构造器引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用和构造器引用\"></a> 方法引用和构造器引用</h1>\n<h2 id=\"方法引用\"><a class=\"markdownIt-Anchor\" href=\"#方法引用\"></a> 方法引用</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectName::instanceMethod</span><br><span class=\"line\"></span><br><span class=\"line\">ClassName::staticMethod</span><br><span class=\"line\"></span><br><span class=\"line\">ClassName::instanceMethod</span><br></pre></td></tr></table></figure>\n<ol>\n<li>前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用</li>\n<li>最后一种方式，等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数</li>\n</ol>\n<h2 id=\"构造器引用\"><a class=\"markdownIt-Anchor\" href=\"#构造器引用\"></a> 构造器引用</h2>\n<p>构造器引用语法如下：ClassName::new，把lambda表达式的参数当成ClassName构造器的参数 。例如BigDecimal::new等同于x-&gt;new BigDecimal(x)</p>\n<h1 id=\"stream语法\"><a class=\"markdownIt-Anchor\" href=\"#stream语法\"></a> Stream语法</h1>\n<p>stream就是JAVA8提供给我们的对于元素集合统一、快速、并行操作的一种方式。<br>\n它能充分运用多核的优势，以及配合lambda表达式、链式结构对集合等进行许多有用的操作</p>\n<ol>\n<li>Stream是元素的集合，这点让Stream看起来用些类似Iterator,可以把Stream当成一个装饰后的Iterator；</li>\n<li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = Lists.newArrayList(1,null,3,4,null,6);</span><br><span class=\"line\">nums.stream().filter(num -&gt; num != null).count();</span><br></pre></td></tr></table></figure>\n"},{"title":"ASP.NET MVC学习笔记","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T12:08:31.000Z","password":null,"_content":"# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/mvc_intro.asp， 为个人学习笔记记录。\n\n# MVC项目文件夹 \n典型的 ASP.NET MVC web 应用程序拥有如下文件夹内容：\n<img src=\"/pub-images/ASPMVC.png\" width=256 height=256 />\n~~~\n应用程序信息\n* Properties\n* 引用\n\n应用程序文件夹\n* App_Data 文件夹  //用于存储应用程序数据\n* App_Start 文件夹 //含应用程序的配置逻辑文件\n ** BundleConfig.cs: 注册所使用的捆绑的CSS 和 JS文件。\n ** FilterConfig.cs: 注册外部/全局过滤器，这些过滤器可以被应用到每个Action和Controller中去.\n ** RouteConfig.cs: 配置MVC应用程序的系统路由路径。\n ** Startup.Auth.cs: 配置MVC应用程序的安全信息，包括Authentication和Authorization配置  \n* Content 文件夹   //用于静态文件，比如样式表（CSS 文件）、图表和图像\n* Controllers 文件夹   //包含负责处理用户输入和响应的控制器类,名称必须以 \"Controller\" 结尾\n* Models 文件夹    //包含表示应用程序模型的类。模型存有并操作应用程序的数据\n* Scripts 文件夹   //存储应用程序的 JavaScript 文件\n* Views 文件夹 //存有与应用程序的显示相关的 HTML 文件 \n ** Shared   //用于存储控制器间分享的视图\n ** [名称]   //每个控制器对应的一个文件夹\n ** _ViewStart.cshtml //其内代码被自动添加到由应用程序显示的所有视图。\n\n配置文件\n* Global.asax   //主要是web应用程序的全局设置文件，该文件包含响应 ASP.NET 或HTTP模块所引发的应用程序级别和会话级别事件的代码。Global.asax 文件驻留在 ASP.NET 应用程序的根目录中。运行时，分析 Global.asax 并将其编译到一个动态生成的 .NET Framework 类，该类是从HttpApplication基类派生的。配置 ASP.NET，以便自动拒绝对 Global.asax 文件的任何直接的 URL 请求；外部用户不能下载或查看其中的代码。Global.asax 文件是可选的。只在希望处理应用程序事件或会话事件时，才应创建它.\n* packages.config   //NuGet管理用的\n* Web.config\n~~~\n> 控制器位于 Controllers 文件夹，视图位于 Views 文件夹，模型位于 Models 文件夹。您不必在应用程序代码中使用文件夹名称\n\n# 控制器Controllers\n1. web 服务器通常会将进入的 URL 请求直接映射到服务器上的磁盘文件.某个 URL 请求（比如 \"http://www.abc.cn/index.asp\"）将映射到服务器根目录上的文件 \"index.asp\"。\n> MVC 框架的映射方式有所不同。\n2. MVC 将 URL 映射到方法。这些方法在类中被称为“控制器”。控制器负责处理进入的请求、处理输入、保存数据、并把响应发送回客户端。\n3. 在mvc中所有的controller类都必须使用\"Controller\"后缀来命名,并且对Action也有一定的要求：\n* 必须是一个public方法\n* 必须是实例方法\n* 没有标志NonActionAttribute特性的(NoAction)\n* 不能被重载\n* 必须返回ActionResult类型\n> 具体可返回数据类型请参考：https://blog.csdn.net/pasic/article/details/7110134\n\n# 模型Models\n模型包含所有应用程序逻辑（业务逻辑、验证逻辑、数据访问逻辑），除了纯视图和控制器逻辑。\n\n# HTML帮助器\nHTML 帮助器用于修改 HTML 输出。\n## HTML 链接\n通过 MVC，Html.ActionLink() 不连接到视图。它创建控制器操作（controller action）的连接。\n\n## HTML 表单元素\n* BeginForm()\n* EndForm()\n* TextArea()\n* TextBox()\n* CheckBox()\n* RadioButton()\n* ListBox()\n* DropDownList()\n* Hidden()\n* Password()\n\n~~~\n<%= Html.ValidationSummary(\"Create was unsuccessful. Please correct the errors and \ntry again.\") %>\n<% using (Html.BeginForm()){%>\n<p>\n<label for=\"FirstName\">First Name:</label>\n<%= Html.TextBox(\"FirstName\") %>\n<%= Html.ValidationMessage(\"FirstName\", \"*\") %>\n</p>\n<p>\n<label for=\"LastName\">Last Name:</label>\n<%= Html.TextBox(\"LastName\") %>\n<%= Html.ValidationMessage(\"LastName\", \"*\") %>\n</p>\n<p>\n<label for=\"Password\">Password:</label>\n<%= Html.Password(\"Password\") %>\n<%= Html.ValidationMessage(\"Password\", \"*\") %>\n</p>\n<p>\n<label for=\"Password\">Confirm Password:</label>\n<%= Html.Password(\"ConfirmPassword\") %>\n<%= Html.ValidationMessage(\"ConfirmPassword\", \"*\") %>\n</p>\n<p>\n<label for=\"Profile\">Profile:</label>\n<%= Html.TextArea(\"Profile\", new {cols=60, rows=10})%>\n</p>\n<p>\n<%= Html.CheckBox(\"ReceiveNewsletter\") %>\n<label for=\"ReceiveNewsletter\" style=\"display:inline\">Receive Newsletter?</label>\n</p>\n<p>\n<input type=\"submit\" value=\"Register\" />\n</p>\n<%}%>\n~~~\n\n# MVC参考手册\nhttp://www.w3school.com.cn/aspnet/mvc_reference.asp","source":"_posts/C#开发/2018-10-05-ASP-NET-MVC使用.md","raw":"---\ntitle: ASP.NET MVC学习笔记\ntags:\n  - ASP.NET\n  - MVC\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 20:08:31\ncategories: C#\npassword:\n---\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/mvc_intro.asp， 为个人学习笔记记录。\n\n# MVC项目文件夹 \n典型的 ASP.NET MVC web 应用程序拥有如下文件夹内容：\n<img src=\"/pub-images/ASPMVC.png\" width=256 height=256 />\n~~~\n应用程序信息\n* Properties\n* 引用\n\n应用程序文件夹\n* App_Data 文件夹  //用于存储应用程序数据\n* App_Start 文件夹 //含应用程序的配置逻辑文件\n ** BundleConfig.cs: 注册所使用的捆绑的CSS 和 JS文件。\n ** FilterConfig.cs: 注册外部/全局过滤器，这些过滤器可以被应用到每个Action和Controller中去.\n ** RouteConfig.cs: 配置MVC应用程序的系统路由路径。\n ** Startup.Auth.cs: 配置MVC应用程序的安全信息，包括Authentication和Authorization配置  \n* Content 文件夹   //用于静态文件，比如样式表（CSS 文件）、图表和图像\n* Controllers 文件夹   //包含负责处理用户输入和响应的控制器类,名称必须以 \"Controller\" 结尾\n* Models 文件夹    //包含表示应用程序模型的类。模型存有并操作应用程序的数据\n* Scripts 文件夹   //存储应用程序的 JavaScript 文件\n* Views 文件夹 //存有与应用程序的显示相关的 HTML 文件 \n ** Shared   //用于存储控制器间分享的视图\n ** [名称]   //每个控制器对应的一个文件夹\n ** _ViewStart.cshtml //其内代码被自动添加到由应用程序显示的所有视图。\n\n配置文件\n* Global.asax   //主要是web应用程序的全局设置文件，该文件包含响应 ASP.NET 或HTTP模块所引发的应用程序级别和会话级别事件的代码。Global.asax 文件驻留在 ASP.NET 应用程序的根目录中。运行时，分析 Global.asax 并将其编译到一个动态生成的 .NET Framework 类，该类是从HttpApplication基类派生的。配置 ASP.NET，以便自动拒绝对 Global.asax 文件的任何直接的 URL 请求；外部用户不能下载或查看其中的代码。Global.asax 文件是可选的。只在希望处理应用程序事件或会话事件时，才应创建它.\n* packages.config   //NuGet管理用的\n* Web.config\n~~~\n> 控制器位于 Controllers 文件夹，视图位于 Views 文件夹，模型位于 Models 文件夹。您不必在应用程序代码中使用文件夹名称\n\n# 控制器Controllers\n1. web 服务器通常会将进入的 URL 请求直接映射到服务器上的磁盘文件.某个 URL 请求（比如 \"http://www.abc.cn/index.asp\"）将映射到服务器根目录上的文件 \"index.asp\"。\n> MVC 框架的映射方式有所不同。\n2. MVC 将 URL 映射到方法。这些方法在类中被称为“控制器”。控制器负责处理进入的请求、处理输入、保存数据、并把响应发送回客户端。\n3. 在mvc中所有的controller类都必须使用\"Controller\"后缀来命名,并且对Action也有一定的要求：\n* 必须是一个public方法\n* 必须是实例方法\n* 没有标志NonActionAttribute特性的(NoAction)\n* 不能被重载\n* 必须返回ActionResult类型\n> 具体可返回数据类型请参考：https://blog.csdn.net/pasic/article/details/7110134\n\n# 模型Models\n模型包含所有应用程序逻辑（业务逻辑、验证逻辑、数据访问逻辑），除了纯视图和控制器逻辑。\n\n# HTML帮助器\nHTML 帮助器用于修改 HTML 输出。\n## HTML 链接\n通过 MVC，Html.ActionLink() 不连接到视图。它创建控制器操作（controller action）的连接。\n\n## HTML 表单元素\n* BeginForm()\n* EndForm()\n* TextArea()\n* TextBox()\n* CheckBox()\n* RadioButton()\n* ListBox()\n* DropDownList()\n* Hidden()\n* Password()\n\n~~~\n<%= Html.ValidationSummary(\"Create was unsuccessful. Please correct the errors and \ntry again.\") %>\n<% using (Html.BeginForm()){%>\n<p>\n<label for=\"FirstName\">First Name:</label>\n<%= Html.TextBox(\"FirstName\") %>\n<%= Html.ValidationMessage(\"FirstName\", \"*\") %>\n</p>\n<p>\n<label for=\"LastName\">Last Name:</label>\n<%= Html.TextBox(\"LastName\") %>\n<%= Html.ValidationMessage(\"LastName\", \"*\") %>\n</p>\n<p>\n<label for=\"Password\">Password:</label>\n<%= Html.Password(\"Password\") %>\n<%= Html.ValidationMessage(\"Password\", \"*\") %>\n</p>\n<p>\n<label for=\"Password\">Confirm Password:</label>\n<%= Html.Password(\"ConfirmPassword\") %>\n<%= Html.ValidationMessage(\"ConfirmPassword\", \"*\") %>\n</p>\n<p>\n<label for=\"Profile\">Profile:</label>\n<%= Html.TextArea(\"Profile\", new {cols=60, rows=10})%>\n</p>\n<p>\n<%= Html.CheckBox(\"ReceiveNewsletter\") %>\n<label for=\"ReceiveNewsletter\" style=\"display:inline\">Receive Newsletter?</label>\n</p>\n<p>\n<input type=\"submit\" value=\"Register\" />\n</p>\n<%}%>\n~~~\n\n# MVC参考手册\nhttp://www.w3school.com.cn/aspnet/mvc_reference.asp","slug":"C-开发-2018-10-05-ASP-NET-MVC使用","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx6000n5b8hyy6fjx6f","content":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/mvc_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/mvc_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"mvc项目文件夹\"><a class=\"markdownIt-Anchor\" href=\"#mvc项目文件夹\"></a> MVC项目文件夹</h1>\n<p>典型的 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> MVC web 应用程序拥有如下文件夹内容：<br>\n<img src=\"/pub-images/ASPMVC.png\" width=\"256\" height=\"256\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应用程序信息</span><br><span class=\"line\">* Properties</span><br><span class=\"line\">* 引用</span><br><span class=\"line\"></span><br><span class=\"line\">应用程序文件夹</span><br><span class=\"line\">* App_Data 文件夹  //用于存储应用程序数据</span><br><span class=\"line\">* App_Start 文件夹 //含应用程序的配置逻辑文件</span><br><span class=\"line\"> ** BundleConfig.cs: 注册所使用的捆绑的CSS 和 JS文件。</span><br><span class=\"line\"> ** FilterConfig.cs: 注册外部/全局过滤器，这些过滤器可以被应用到每个Action和Controller中去.</span><br><span class=\"line\"> ** RouteConfig.cs: 配置MVC应用程序的系统路由路径。</span><br><span class=\"line\"> ** Startup.Auth.cs: 配置MVC应用程序的安全信息，包括Authentication和Authorization配置  </span><br><span class=\"line\">* Content 文件夹   //用于静态文件，比如样式表（CSS 文件）、图表和图像</span><br><span class=\"line\">* Controllers 文件夹   //包含负责处理用户输入和响应的控制器类,名称必须以 &quot;Controller&quot; 结尾</span><br><span class=\"line\">* Models 文件夹    //包含表示应用程序模型的类。模型存有并操作应用程序的数据</span><br><span class=\"line\">* Scripts 文件夹   //存储应用程序的 JavaScript 文件</span><br><span class=\"line\">* Views 文件夹 //存有与应用程序的显示相关的 HTML 文件 </span><br><span class=\"line\"> ** Shared   //用于存储控制器间分享的视图</span><br><span class=\"line\"> ** [名称]   //每个控制器对应的一个文件夹</span><br><span class=\"line\"> ** _ViewStart.cshtml //其内代码被自动添加到由应用程序显示的所有视图。</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件</span><br><span class=\"line\">* Global.asax   //主要是web应用程序的全局设置文件，该文件包含响应 ASP.NET 或HTTP模块所引发的应用程序级别和会话级别事件的代码。Global.asax 文件驻留在 ASP.NET 应用程序的根目录中。运行时，分析 Global.asax 并将其编译到一个动态生成的 .NET Framework 类，该类是从HttpApplication基类派生的。配置 ASP.NET，以便自动拒绝对 Global.asax 文件的任何直接的 URL 请求；外部用户不能下载或查看其中的代码。Global.asax 文件是可选的。只在希望处理应用程序事件或会话事件时，才应创建它.</span><br><span class=\"line\">* packages.config   //NuGet管理用的</span><br><span class=\"line\">* Web.config</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>控制器位于 Controllers 文件夹，视图位于 Views 文件夹，模型位于 Models 文件夹。您不必在应用程序代码中使用文件夹名称</p>\n</blockquote>\n<h1 id=\"控制器controllers\"><a class=\"markdownIt-Anchor\" href=\"#控制器controllers\"></a> 控制器Controllers</h1>\n<ol>\n<li>web 服务器通常会将进入的 URL 请求直接映射到服务器上的磁盘文件.某个 URL 请求（比如 “<a href=\"http://www.abc.cn/index.asp\" target=\"_blank\" rel=\"noopener\">http://www.abc.cn/index.asp</a>”）将映射到服务器根目录上的文件 “index.asp”。</li>\n</ol>\n<blockquote>\n<p>MVC 框架的映射方式有所不同。</p>\n</blockquote>\n<ol start=\"2\">\n<li>MVC 将 URL 映射到方法。这些方法在类中被称为“控制器”。控制器负责处理进入的请求、处理输入、保存数据、并把响应发送回客户端。</li>\n<li>在mvc中所有的controller类都必须使用&quot;Controller&quot;后缀来命名,并且对Action也有一定的要求：</li>\n</ol>\n<ul>\n<li>必须是一个public方法</li>\n<li>必须是实例方法</li>\n<li>没有标志NonActionAttribute特性的(NoAction)</li>\n<li>不能被重载</li>\n<li>必须返回ActionResult类型</li>\n</ul>\n<blockquote>\n<p>具体可返回数据类型请参考：<a href=\"https://blog.csdn.net/pasic/article/details/7110134\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pasic/article/details/7110134</a></p>\n</blockquote>\n<h1 id=\"模型models\"><a class=\"markdownIt-Anchor\" href=\"#模型models\"></a> 模型Models</h1>\n<p>模型包含所有应用程序逻辑（业务逻辑、验证逻辑、数据访问逻辑），除了纯视图和控制器逻辑。</p>\n<h1 id=\"html帮助器\"><a class=\"markdownIt-Anchor\" href=\"#html帮助器\"></a> HTML帮助器</h1>\n<p>HTML 帮助器用于修改 HTML 输出。</p>\n<h2 id=\"html-链接\"><a class=\"markdownIt-Anchor\" href=\"#html-链接\"></a> HTML 链接</h2>\n<p>通过 MVC，Html.ActionLink() 不连接到视图。它创建控制器操作（controller action）的连接。</p>\n<h2 id=\"html-表单元素\"><a class=\"markdownIt-Anchor\" href=\"#html-表单元素\"></a> HTML 表单元素</h2>\n<ul>\n<li>BeginForm()</li>\n<li>EndForm()</li>\n<li>TextArea()</li>\n<li>TextBox()</li>\n<li>CheckBox()</li>\n<li>RadioButton()</li>\n<li>ListBox()</li>\n<li>DropDownList()</li>\n<li>Hidden()</li>\n<li>Password()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= Html.ValidationSummary(&quot;Create was unsuccessful. Please correct the errors and </span><br><span class=\"line\">try again.&quot;) %&gt;</span><br><span class=\"line\">&lt;% using (Html.BeginForm())&#123;%&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;FirstName&quot;&gt;First Name:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.TextBox(&quot;FirstName&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;FirstName&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;LastName&quot;&gt;Last Name:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.TextBox(&quot;LastName&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;LastName&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;Password&quot;&gt;Password:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.Password(&quot;Password&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;Password&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;Password&quot;&gt;Confirm Password:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.Password(&quot;ConfirmPassword&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;ConfirmPassword&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;Profile&quot;&gt;Profile:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.TextArea(&quot;Profile&quot;, new &#123;cols=60, rows=10&#125;)%&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;%= Html.CheckBox(&quot;ReceiveNewsletter&quot;) %&gt;</span><br><span class=\"line\">&lt;label for=&quot;ReceiveNewsletter&quot; style=&quot;display:inline&quot;&gt;Receive Newsletter?&lt;/label&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"mvc参考手册\"><a class=\"markdownIt-Anchor\" href=\"#mvc参考手册\"></a> MVC参考手册</h1>\n<p><a href=\"http://www.w3school.com.cn/aspnet/mvc_reference.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/mvc_reference.asp</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/mvc_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/mvc_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"mvc项目文件夹\"><a class=\"markdownIt-Anchor\" href=\"#mvc项目文件夹\"></a> MVC项目文件夹</h1>\n<p>典型的 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> MVC web 应用程序拥有如下文件夹内容：<br>\n<img src=\"/pub-images/ASPMVC.png\" width=\"256\" height=\"256\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应用程序信息</span><br><span class=\"line\">* Properties</span><br><span class=\"line\">* 引用</span><br><span class=\"line\"></span><br><span class=\"line\">应用程序文件夹</span><br><span class=\"line\">* App_Data 文件夹  //用于存储应用程序数据</span><br><span class=\"line\">* App_Start 文件夹 //含应用程序的配置逻辑文件</span><br><span class=\"line\"> ** BundleConfig.cs: 注册所使用的捆绑的CSS 和 JS文件。</span><br><span class=\"line\"> ** FilterConfig.cs: 注册外部/全局过滤器，这些过滤器可以被应用到每个Action和Controller中去.</span><br><span class=\"line\"> ** RouteConfig.cs: 配置MVC应用程序的系统路由路径。</span><br><span class=\"line\"> ** Startup.Auth.cs: 配置MVC应用程序的安全信息，包括Authentication和Authorization配置  </span><br><span class=\"line\">* Content 文件夹   //用于静态文件，比如样式表（CSS 文件）、图表和图像</span><br><span class=\"line\">* Controllers 文件夹   //包含负责处理用户输入和响应的控制器类,名称必须以 &quot;Controller&quot; 结尾</span><br><span class=\"line\">* Models 文件夹    //包含表示应用程序模型的类。模型存有并操作应用程序的数据</span><br><span class=\"line\">* Scripts 文件夹   //存储应用程序的 JavaScript 文件</span><br><span class=\"line\">* Views 文件夹 //存有与应用程序的显示相关的 HTML 文件 </span><br><span class=\"line\"> ** Shared   //用于存储控制器间分享的视图</span><br><span class=\"line\"> ** [名称]   //每个控制器对应的一个文件夹</span><br><span class=\"line\"> ** _ViewStart.cshtml //其内代码被自动添加到由应用程序显示的所有视图。</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件</span><br><span class=\"line\">* Global.asax   //主要是web应用程序的全局设置文件，该文件包含响应 ASP.NET 或HTTP模块所引发的应用程序级别和会话级别事件的代码。Global.asax 文件驻留在 ASP.NET 应用程序的根目录中。运行时，分析 Global.asax 并将其编译到一个动态生成的 .NET Framework 类，该类是从HttpApplication基类派生的。配置 ASP.NET，以便自动拒绝对 Global.asax 文件的任何直接的 URL 请求；外部用户不能下载或查看其中的代码。Global.asax 文件是可选的。只在希望处理应用程序事件或会话事件时，才应创建它.</span><br><span class=\"line\">* packages.config   //NuGet管理用的</span><br><span class=\"line\">* Web.config</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>控制器位于 Controllers 文件夹，视图位于 Views 文件夹，模型位于 Models 文件夹。您不必在应用程序代码中使用文件夹名称</p>\n</blockquote>\n<h1 id=\"控制器controllers\"><a class=\"markdownIt-Anchor\" href=\"#控制器controllers\"></a> 控制器Controllers</h1>\n<ol>\n<li>web 服务器通常会将进入的 URL 请求直接映射到服务器上的磁盘文件.某个 URL 请求（比如 “<a href=\"http://www.abc.cn/index.asp\" target=\"_blank\" rel=\"noopener\">http://www.abc.cn/index.asp</a>”）将映射到服务器根目录上的文件 “index.asp”。</li>\n</ol>\n<blockquote>\n<p>MVC 框架的映射方式有所不同。</p>\n</blockquote>\n<ol start=\"2\">\n<li>MVC 将 URL 映射到方法。这些方法在类中被称为“控制器”。控制器负责处理进入的请求、处理输入、保存数据、并把响应发送回客户端。</li>\n<li>在mvc中所有的controller类都必须使用&quot;Controller&quot;后缀来命名,并且对Action也有一定的要求：</li>\n</ol>\n<ul>\n<li>必须是一个public方法</li>\n<li>必须是实例方法</li>\n<li>没有标志NonActionAttribute特性的(NoAction)</li>\n<li>不能被重载</li>\n<li>必须返回ActionResult类型</li>\n</ul>\n<blockquote>\n<p>具体可返回数据类型请参考：<a href=\"https://blog.csdn.net/pasic/article/details/7110134\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pasic/article/details/7110134</a></p>\n</blockquote>\n<h1 id=\"模型models\"><a class=\"markdownIt-Anchor\" href=\"#模型models\"></a> 模型Models</h1>\n<p>模型包含所有应用程序逻辑（业务逻辑、验证逻辑、数据访问逻辑），除了纯视图和控制器逻辑。</p>\n<h1 id=\"html帮助器\"><a class=\"markdownIt-Anchor\" href=\"#html帮助器\"></a> HTML帮助器</h1>\n<p>HTML 帮助器用于修改 HTML 输出。</p>\n<h2 id=\"html-链接\"><a class=\"markdownIt-Anchor\" href=\"#html-链接\"></a> HTML 链接</h2>\n<p>通过 MVC，Html.ActionLink() 不连接到视图。它创建控制器操作（controller action）的连接。</p>\n<h2 id=\"html-表单元素\"><a class=\"markdownIt-Anchor\" href=\"#html-表单元素\"></a> HTML 表单元素</h2>\n<ul>\n<li>BeginForm()</li>\n<li>EndForm()</li>\n<li>TextArea()</li>\n<li>TextBox()</li>\n<li>CheckBox()</li>\n<li>RadioButton()</li>\n<li>ListBox()</li>\n<li>DropDownList()</li>\n<li>Hidden()</li>\n<li>Password()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= Html.ValidationSummary(&quot;Create was unsuccessful. Please correct the errors and </span><br><span class=\"line\">try again.&quot;) %&gt;</span><br><span class=\"line\">&lt;% using (Html.BeginForm())&#123;%&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;FirstName&quot;&gt;First Name:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.TextBox(&quot;FirstName&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;FirstName&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;LastName&quot;&gt;Last Name:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.TextBox(&quot;LastName&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;LastName&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;Password&quot;&gt;Password:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.Password(&quot;Password&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;Password&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;Password&quot;&gt;Confirm Password:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.Password(&quot;ConfirmPassword&quot;) %&gt;</span><br><span class=\"line\">&lt;%= Html.ValidationMessage(&quot;ConfirmPassword&quot;, &quot;*&quot;) %&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;label for=&quot;Profile&quot;&gt;Profile:&lt;/label&gt;</span><br><span class=\"line\">&lt;%= Html.TextArea(&quot;Profile&quot;, new &#123;cols=60, rows=10&#125;)%&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;%= Html.CheckBox(&quot;ReceiveNewsletter&quot;) %&gt;</span><br><span class=\"line\">&lt;label for=&quot;ReceiveNewsletter&quot; style=&quot;display:inline&quot;&gt;Receive Newsletter?&lt;/label&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"mvc参考手册\"><a class=\"markdownIt-Anchor\" href=\"#mvc参考手册\"></a> MVC参考手册</h1>\n<p><a href=\"http://www.w3school.com.cn/aspnet/mvc_reference.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/mvc_reference.asp</a></p>\n"},{"title":"ASP.NET WebForms学习笔记","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T14:56:59.000Z","password":null,"_content":"# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/aspnet_intro.asp， 为个人学习笔记记录。\n\n# 说明\nWebForms可类比WinForm开发，通过可视化拖动的方式快速完成Web页面开发.","source":"_posts/C#开发/2018-10-05-ASP-NET-WebForms使用.md","raw":"---\ntitle: ASP.NET WebForms学习笔记\ntags:\n  - ASP.NET\n  - WebForms\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 22:56:59\ncategories: C#\npassword:\n---\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/aspnet_intro.asp， 为个人学习笔记记录。\n\n# 说明\nWebForms可类比WinForm开发，通过可视化拖动的方式快速完成Web页面开发.","slug":"C-开发-2018-10-05-ASP-NET-WebForms使用","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx7000p5b8hl2ymwi15","content":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/aspnet_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/aspnet_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>WebForms可类比WinForm开发，通过可视化拖动的方式快速完成Web页面开发.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/aspnet_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/aspnet_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>WebForms可类比WinForm开发，通过可视化拖动的方式快速完成Web页面开发.</p>\n"},{"title":"Razor使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T11:58:54.000Z","password":null,"_content":"\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/razor_intro.asp， 为个人学习笔记记录。\n\n# 说明\nRazor 是一种允许您向网页中嵌入基于服务器的代码的标记语法。Razor 基于 ASP.NET，它为 web 应用程序的创建而设计。\n> 当网页被写入浏览器时，基于服务器的代码能够创建动态内容。在网页加载时，服务器在向浏览器返回页面之前，会执行页面内的基于服务器代码。由于是在服务器上运行，这种代码能执行复杂的任务，比如访问数据库。\n\n# C# 的主要 Razor 语法规则\n* Razor 代码块由 @{ ... } 包围\n* 行内表达式（变量和函数）以 @ 开始\n* 代码语句以分号结束\n* 变量通过 var 关键词进行声明\n* 字符串用引用来包围\n* C# 代码对大小写敏感\n* C# 文件的扩展名是 .cshtml\n\n# 编程\nRazor编程支持变量、循环、逻辑。\n\n## 变量\n~~~\nvar myString = '103';\nint counter = 103; \n\nif (myString.IsInt())\n{\n    myInt=myString.AsInt();\n}\n~~~\n## 循环\n~~~\n<body>\n@for(var i = 10; i < 21; i++)\n    {<p>Line @i</p>}\n</body>\n~~~\n\n~~~\n<body>\n<ul>\n@foreach (var x in Request.ServerVariables)\n    {<li>@x</li>}\n</ul>\n</body>\n~~~\n\n~~~\n<body>\n@{\nvar i = 0;\nwhile (i < 5)\n    {\n    i += 1;\n    <p>Line #@i</p>\n    }\n}\n</body>\n~~~\n\n~~~\n@{var price=25;}\n<html>\n<body>\n@if (price>=30)\n  {\n  <p>The price is high.</p>\n  }\nelse if (price>20 && price<30) \n  {\n  <p>The price is OK.</p>\n  }\nelse\n  {\n  <p>The price is low.</p>\n  }    \n</body>\n</html>\n~~~\n\n~~~\n@{\nvar weekday=DateTime.Now.DayOfWeek;\nvar day=weekday.ToString();\nvar message=\"\";\n}\n<html>\n<body>\n@switch(day)\n{\ncase \"Monday\":\n    message=\"This is the first weekday.\";\n    break;\ncase \"Thursday\":\n    message=\"Only one day before weekend.\";\n    break;\ncase \"Friday\":\n    message=\"Tomorrow is weekend!\";\n    break;\ndefault:\n    message=\"Today is \" + day;\n    break;\n}\n<p>@message</p>\n</body>\n</html>\n~~~","source":"_posts/C#开发/2018-10-05-Razor使用.md","raw":"---\ntitle: Razor使用\ntags:\n  - ASP.NET\n  - Razor\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 19:58:54\ncategories: C#\npassword:\n---\n\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/razor_intro.asp， 为个人学习笔记记录。\n\n# 说明\nRazor 是一种允许您向网页中嵌入基于服务器的代码的标记语法。Razor 基于 ASP.NET，它为 web 应用程序的创建而设计。\n> 当网页被写入浏览器时，基于服务器的代码能够创建动态内容。在网页加载时，服务器在向浏览器返回页面之前，会执行页面内的基于服务器代码。由于是在服务器上运行，这种代码能执行复杂的任务，比如访问数据库。\n\n# C# 的主要 Razor 语法规则\n* Razor 代码块由 @{ ... } 包围\n* 行内表达式（变量和函数）以 @ 开始\n* 代码语句以分号结束\n* 变量通过 var 关键词进行声明\n* 字符串用引用来包围\n* C# 代码对大小写敏感\n* C# 文件的扩展名是 .cshtml\n\n# 编程\nRazor编程支持变量、循环、逻辑。\n\n## 变量\n~~~\nvar myString = '103';\nint counter = 103; \n\nif (myString.IsInt())\n{\n    myInt=myString.AsInt();\n}\n~~~\n## 循环\n~~~\n<body>\n@for(var i = 10; i < 21; i++)\n    {<p>Line @i</p>}\n</body>\n~~~\n\n~~~\n<body>\n<ul>\n@foreach (var x in Request.ServerVariables)\n    {<li>@x</li>}\n</ul>\n</body>\n~~~\n\n~~~\n<body>\n@{\nvar i = 0;\nwhile (i < 5)\n    {\n    i += 1;\n    <p>Line #@i</p>\n    }\n}\n</body>\n~~~\n\n~~~\n@{var price=25;}\n<html>\n<body>\n@if (price>=30)\n  {\n  <p>The price is high.</p>\n  }\nelse if (price>20 && price<30) \n  {\n  <p>The price is OK.</p>\n  }\nelse\n  {\n  <p>The price is low.</p>\n  }    \n</body>\n</html>\n~~~\n\n~~~\n@{\nvar weekday=DateTime.Now.DayOfWeek;\nvar day=weekday.ToString();\nvar message=\"\";\n}\n<html>\n<body>\n@switch(day)\n{\ncase \"Monday\":\n    message=\"This is the first weekday.\";\n    break;\ncase \"Thursday\":\n    message=\"Only one day before weekend.\";\n    break;\ncase \"Friday\":\n    message=\"Tomorrow is weekend!\";\n    break;\ndefault:\n    message=\"Today is \" + day;\n    break;\n}\n<p>@message</p>\n</body>\n</html>\n~~~","slug":"C-开发-2018-10-05-Razor使用","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx8000t5b8hu9r0lg8e","content":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/razor_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/razor_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>Razor 是一种允许您向网页中嵌入基于服务器的代码的标记语法。Razor 基于 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a>，它为 web 应用程序的创建而设计。</p>\n<blockquote>\n<p>当网页被写入浏览器时，基于服务器的代码能够创建动态内容。在网页加载时，服务器在向浏览器返回页面之前，会执行页面内的基于服务器代码。由于是在服务器上运行，这种代码能执行复杂的任务，比如访问数据库。</p>\n</blockquote>\n<h1 id=\"c-的主要-razor-语法规则\"><a class=\"markdownIt-Anchor\" href=\"#c-的主要-razor-语法规则\"></a> C# 的主要 Razor 语法规则</h1>\n<ul>\n<li>Razor 代码块由 @{ … } 包围</li>\n<li>行内表达式（变量和函数）以 @ 开始</li>\n<li>代码语句以分号结束</li>\n<li>变量通过 var 关键词进行声明</li>\n<li>字符串用引用来包围</li>\n<li>C# 代码对大小写敏感</li>\n<li>C# 文件的扩展名是 .cshtml</li>\n</ul>\n<h1 id=\"编程\"><a class=\"markdownIt-Anchor\" href=\"#编程\"></a> 编程</h1>\n<p>Razor编程支持变量、循环、逻辑。</p>\n<h2 id=\"变量\"><a class=\"markdownIt-Anchor\" href=\"#变量\"></a> 变量</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myString = &apos;103&apos;;</span><br><span class=\"line\">int counter = 103; </span><br><span class=\"line\"></span><br><span class=\"line\">if (myString.IsInt())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    myInt=myString.AsInt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@for(var i = 10; i &lt; 21; i++)</span><br><span class=\"line\">    &#123;&lt;p&gt;Line @i&lt;/p&gt;&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">@foreach (var x in Request.ServerVariables)</span><br><span class=\"line\">    &#123;&lt;li&gt;@x&lt;/li&gt;&#125;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@&#123;</span><br><span class=\"line\">var i = 0;</span><br><span class=\"line\">while (i &lt; 5)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    i += 1;</span><br><span class=\"line\">    &lt;p&gt;Line #@i&lt;/p&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;var price=25;&#125;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@if (price&gt;=30)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  &lt;p&gt;The price is high.&lt;/p&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else if (price&gt;20 &amp;&amp; price&lt;30) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  &lt;p&gt;The price is OK.&lt;/p&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  &lt;p&gt;The price is low.&lt;/p&gt;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;</span><br><span class=\"line\">var weekday=DateTime.Now.DayOfWeek;</span><br><span class=\"line\">var day=weekday.ToString();</span><br><span class=\"line\">var message=&quot;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@switch(day)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">case &quot;Monday&quot;:</span><br><span class=\"line\">    message=&quot;This is the first weekday.&quot;;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">case &quot;Thursday&quot;:</span><br><span class=\"line\">    message=&quot;Only one day before weekend.&quot;;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">case &quot;Friday&quot;:</span><br><span class=\"line\">    message=&quot;Tomorrow is weekend!&quot;;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">default:</span><br><span class=\"line\">    message=&quot;Today is &quot; + day;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;p&gt;@message&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/razor_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/razor_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>Razor 是一种允许您向网页中嵌入基于服务器的代码的标记语法。Razor 基于 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a>，它为 web 应用程序的创建而设计。</p>\n<blockquote>\n<p>当网页被写入浏览器时，基于服务器的代码能够创建动态内容。在网页加载时，服务器在向浏览器返回页面之前，会执行页面内的基于服务器代码。由于是在服务器上运行，这种代码能执行复杂的任务，比如访问数据库。</p>\n</blockquote>\n<h1 id=\"c-的主要-razor-语法规则\"><a class=\"markdownIt-Anchor\" href=\"#c-的主要-razor-语法规则\"></a> C# 的主要 Razor 语法规则</h1>\n<ul>\n<li>Razor 代码块由 @{ … } 包围</li>\n<li>行内表达式（变量和函数）以 @ 开始</li>\n<li>代码语句以分号结束</li>\n<li>变量通过 var 关键词进行声明</li>\n<li>字符串用引用来包围</li>\n<li>C# 代码对大小写敏感</li>\n<li>C# 文件的扩展名是 .cshtml</li>\n</ul>\n<h1 id=\"编程\"><a class=\"markdownIt-Anchor\" href=\"#编程\"></a> 编程</h1>\n<p>Razor编程支持变量、循环、逻辑。</p>\n<h2 id=\"变量\"><a class=\"markdownIt-Anchor\" href=\"#变量\"></a> 变量</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myString = &apos;103&apos;;</span><br><span class=\"line\">int counter = 103; </span><br><span class=\"line\"></span><br><span class=\"line\">if (myString.IsInt())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    myInt=myString.AsInt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@for(var i = 10; i &lt; 21; i++)</span><br><span class=\"line\">    &#123;&lt;p&gt;Line @i&lt;/p&gt;&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">@foreach (var x in Request.ServerVariables)</span><br><span class=\"line\">    &#123;&lt;li&gt;@x&lt;/li&gt;&#125;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@&#123;</span><br><span class=\"line\">var i = 0;</span><br><span class=\"line\">while (i &lt; 5)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    i += 1;</span><br><span class=\"line\">    &lt;p&gt;Line #@i&lt;/p&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;var price=25;&#125;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@if (price&gt;=30)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  &lt;p&gt;The price is high.&lt;/p&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else if (price&gt;20 &amp;&amp; price&lt;30) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  &lt;p&gt;The price is OK.&lt;/p&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  &lt;p&gt;The price is low.&lt;/p&gt;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;</span><br><span class=\"line\">var weekday=DateTime.Now.DayOfWeek;</span><br><span class=\"line\">var day=weekday.ToString();</span><br><span class=\"line\">var message=&quot;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">@switch(day)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">case &quot;Monday&quot;:</span><br><span class=\"line\">    message=&quot;This is the first weekday.&quot;;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">case &quot;Thursday&quot;:</span><br><span class=\"line\">    message=&quot;Only one day before weekend.&quot;;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">case &quot;Friday&quot;:</span><br><span class=\"line\">    message=&quot;Tomorrow is weekend!&quot;;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">default:</span><br><span class=\"line\">    message=&quot;Today is &quot; + day;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;p&gt;@message&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ASP.NET简介","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T02:22:55.000Z","password":null,"_content":"\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/index.asp， 为个人学习笔记记录。\n\n# 简介\nASP.NET 是一个开发框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。\nASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。\n当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。\nASP.NET 支持三种开发模式／服务器技术：\n* Web Pages：单页面模型\n* MVC：模型视图控制器\n* Web Forms：事件驱动模型\n\n\n# ASP.NET 文件扩展名\n* ASP 文件的文件扩展名是 .asp\n* ASP.NET 文件的文件扩展名是 .aspx\n* ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml\n* ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml\n\n# 版本区别\n* 2009年发行ASP.NET MVC 1.0版\n* 2010年发行ASP.NET MVC 2.0版，VS2010\n* 2011年发行ASP.NET MVC 3.0版+EF4，需要.Net4.0支持，VS2011\n* 2012年发行ASP.NET MVC 4.0版+EF5，需要.Net4.0支持，VS2012\n* 2013年发行ASP.NET MVC 5.0版+EF6，需要.Net4.5支持，VS2013\n* 2015年发行ASP.NET MVC 6.0版+EF7，需要.Net5.0支持，VS2015\n\n* ASP.NET 5.0　　　　　　将改名为　　ASP.NET Core 1.0\n* ASP.NET MVC 6　　　　 将改名为　　ASP.NET MVC Core 1.0\n* Entity Framework 7.0    将改名为　　Entity Framework Core 1.0\n\n* .NET新的跨平台版本将命名为.NET Core 1.0\n\n# 推荐文章\nWebForms vs. MVC： http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html\n\n","source":"_posts/C#开发/2018-10-05-ASP-NET.md","raw":"---\ntitle: ASP.NET简介\ntags:\n  - ASP.NET \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 10:22:55\ncategories: C#\npassword:\n---\n\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/index.asp， 为个人学习笔记记录。\n\n# 简介\nASP.NET 是一个开发框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。\nASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。\n当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。\nASP.NET 支持三种开发模式／服务器技术：\n* Web Pages：单页面模型\n* MVC：模型视图控制器\n* Web Forms：事件驱动模型\n\n\n# ASP.NET 文件扩展名\n* ASP 文件的文件扩展名是 .asp\n* ASP.NET 文件的文件扩展名是 .aspx\n* ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml\n* ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml\n\n# 版本区别\n* 2009年发行ASP.NET MVC 1.0版\n* 2010年发行ASP.NET MVC 2.0版，VS2010\n* 2011年发行ASP.NET MVC 3.0版+EF4，需要.Net4.0支持，VS2011\n* 2012年发行ASP.NET MVC 4.0版+EF5，需要.Net4.0支持，VS2012\n* 2013年发行ASP.NET MVC 5.0版+EF6，需要.Net4.5支持，VS2013\n* 2015年发行ASP.NET MVC 6.0版+EF7，需要.Net5.0支持，VS2015\n\n* ASP.NET 5.0　　　　　　将改名为　　ASP.NET Core 1.0\n* ASP.NET MVC 6　　　　 将改名为　　ASP.NET MVC Core 1.0\n* Entity Framework 7.0    将改名为　　Entity Framework Core 1.0\n\n* .NET新的跨平台版本将命名为.NET Core 1.0\n\n# 推荐文章\nWebForms vs. MVC： http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html\n\n","slug":"C-开发-2018-10-05-ASP-NET","published":1,"updated":"2019-02-14T02:28:08.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudx9000w5b8hbsj682jy","content":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/index.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/index.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 是一个开发框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。<br>\n<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 是新一代的 ASP。它无法兼容经典 ASP，但 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 可以引用 ASP。<br>\n当浏览器请求 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件时，<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。<br>\n<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 支持三种开发模式／服务器技术：</p>\n<ul>\n<li>Web Pages：单页面模型</li>\n<li>MVC：模型视图控制器</li>\n<li>Web Forms：事件驱动模型</li>\n</ul>\n<h1 id=\"aspnet\"><a class=\"markdownIt-Anchor\" href=\"#aspnet\"></a> <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件扩展名</h1>\n<ul>\n<li>ASP 文件的文件扩展名是 .asp</li>\n<li><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件的文件扩展名是 .aspx</li>\n<li><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件使用 C# 语法的文件扩展名是 .cshtml</li>\n<li><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件使用 Razor VB 语法的文件扩展名是 .vbhtml</li>\n</ul>\n<h1 id=\"版本区别\"><a class=\"markdownIt-Anchor\" href=\"#版本区别\"></a> 版本区别</h1>\n<ul>\n<li>\n<p><a href=\"http://xn--2009ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2009年发行ASP.NET</a> MVC 1.0版</p>\n</li>\n<li>\n<p><a href=\"http://xn--2010ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2010年发行ASP.NET</a> MVC 2.0版，VS2010</p>\n</li>\n<li>\n<p><a href=\"http://xn--2011ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2011年发行ASP.NET</a> MVC 3.0版+EF4，需要.Net4.0支持，VS2011</p>\n</li>\n<li>\n<p><a href=\"http://xn--2012ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2012年发行ASP.NET</a> MVC 4.0版+EF5，需要.Net4.0支持，VS2012</p>\n</li>\n<li>\n<p><a href=\"http://xn--2013ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2013年发行ASP.NET</a> MVC 5.0版+EF6，需要.Net4.5支持，VS2013</p>\n</li>\n<li>\n<p><a href=\"http://xn--2015ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2015年发行ASP.NET</a> MVC 6.0版+EF7，需要.Net5.0支持，VS2015</p>\n</li>\n<li>\n<p><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 5.0　　　　　　将改名为　　<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> Core 1.0</p>\n</li>\n<li>\n<p><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> MVC 6　　　　 将改名为　　<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> MVC Core 1.0</p>\n</li>\n<li>\n<p>Entity Framework 7.0    将改名为　　Entity Framework Core 1.0</p>\n</li>\n<li>\n<p>.NET新的跨平台版本将命名为.NET Core 1.0</p>\n</li>\n</ul>\n<h1 id=\"推荐文章\"><a class=\"markdownIt-Anchor\" href=\"#推荐文章\"></a> 推荐文章</h1>\n<p>WebForms vs. MVC： <a href=\"http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/index.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/index.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 是一个开发框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。<br>\n<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 是新一代的 ASP。它无法兼容经典 ASP，但 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 可以引用 ASP。<br>\n当浏览器请求 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件时，<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。<br>\n<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 支持三种开发模式／服务器技术：</p>\n<ul>\n<li>Web Pages：单页面模型</li>\n<li>MVC：模型视图控制器</li>\n<li>Web Forms：事件驱动模型</li>\n</ul>\n<h1 id=\"aspnet\"><a class=\"markdownIt-Anchor\" href=\"#aspnet\"></a> <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件扩展名</h1>\n<ul>\n<li>ASP 文件的文件扩展名是 .asp</li>\n<li><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件的文件扩展名是 .aspx</li>\n<li><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件使用 C# 语法的文件扩展名是 .cshtml</li>\n<li><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 文件使用 Razor VB 语法的文件扩展名是 .vbhtml</li>\n</ul>\n<h1 id=\"版本区别\"><a class=\"markdownIt-Anchor\" href=\"#版本区别\"></a> 版本区别</h1>\n<ul>\n<li>\n<p><a href=\"http://xn--2009ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2009年发行ASP.NET</a> MVC 1.0版</p>\n</li>\n<li>\n<p><a href=\"http://xn--2010ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2010年发行ASP.NET</a> MVC 2.0版，VS2010</p>\n</li>\n<li>\n<p><a href=\"http://xn--2011ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2011年发行ASP.NET</a> MVC 3.0版+EF4，需要.Net4.0支持，VS2011</p>\n</li>\n<li>\n<p><a href=\"http://xn--2012ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2012年发行ASP.NET</a> MVC 4.0版+EF5，需要.Net4.0支持，VS2012</p>\n</li>\n<li>\n<p><a href=\"http://xn--2013ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2013年发行ASP.NET</a> MVC 5.0版+EF6，需要.Net4.5支持，VS2013</p>\n</li>\n<li>\n<p><a href=\"http://xn--2015ASP-lk3lq40fvu9g.NET\" target=\"_blank\" rel=\"noopener\">2015年发行ASP.NET</a> MVC 6.0版+EF7，需要.Net5.0支持，VS2015</p>\n</li>\n<li>\n<p><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 5.0　　　　　　将改名为　　<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> Core 1.0</p>\n</li>\n<li>\n<p><a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> MVC 6　　　　 将改名为　　<a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> MVC Core 1.0</p>\n</li>\n<li>\n<p>Entity Framework 7.0    将改名为　　Entity Framework Core 1.0</p>\n</li>\n<li>\n<p>.NET新的跨平台版本将命名为.NET Core 1.0</p>\n</li>\n</ul>\n<h1 id=\"推荐文章\"><a class=\"markdownIt-Anchor\" href=\"#推荐文章\"></a> 推荐文章</h1>\n<p>WebForms vs. MVC： <a href=\"http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/heyuquan/p/webForms-vs-mvc.html</a></p>\n"},{"title":"ASP.NET WebPages学习笔记","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T03:37:50.000Z","password":null,"_content":"# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/webpages_intro.asp， 为个人学习笔记记录。\n\n# 说明\nWeb Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。\n\n# 布局\n在因特网上，您会发现很多拥有统一外观的网站：\n* 每页拥有相同的页眉\n* 每页拥有相同的页脚\n* 每页拥有相同的样式和布局\n\n可以通过以下方式实现：\n1. 使用 @RenderPage() 方法从不同的文件导入内容\n \n~~~html \n<html>\n<body>\n@RenderPage(\"header.cshtml\")\n<h1>Hello Web Pages</h1>  \n@RenderPage(\"footer.cshtml\")\n</body>\n</html>\n~~~\n\n2. 使用布局页面\n布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。\n\n布局页面：\n~~~html\n<html>\n<body> \n@RenderBody() \n</body>\n</html>\n~~~\n\n任意网页：\n~~~html\n@{Layout=\"Layout.cshtml\";}\n<h1>Welcome to W3Schools</h1> \n~~~\n\n# 防止代码泄露\n在 ASP.NET 中，名称以下划线开头的文件无法通过 web 来浏览。如果您希望禁止用户查看内容块或布局文件，请对文件重新命名,如：_Layout.cshtml\n\n# ~ 操作符 与 Href 方法\n* 使用 ~ 操作符在编程代码中规定虚拟根目录,作为项目资源路径根路径，如：var myImagesFolder = \"~/images\";\n* Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符），如：\n~~~\n@{var myStyleSheet = \"~/Shared/Site.css\";}\n<!-- 创建指向 CSS 文件的链接 -->\n<link rel=\"stylesheet\" type=\"text/css\" href=\"@Href(myStyleSheet)\" />\n~~~\n\n# Page对象\nPage对象为内置对象，类似与JSP中的Request等对象\n方法|\t描述\n--|--\nhref|\t使用指定的参数构建 URL。\nRenderBody()|\t在布局页中，将呈现不在指定部分中的内容页部分。\nRenderPage(page)|\t在其他页内呈现某一页的内容。\nRenderSection(section)|\t在布局页中，将呈现指定部分的内容。\nWrite(object)|\t将指定的对象作为 HTML 编码的字符串写入。\nWriteLiteral|\t无需先对指定的对象进行 HTML 编码，即可将其写入。\n\n属性|\t描述\n--|--\nisPost|\t返回一个值（true 或 false），指示客户端用来请求网页的 HTTP 数据传输方法是否为 POST 请求。\nLayout|\t获取或设置布局页的路径。\nPage|\t提供对页面、布局页和分页之间共享的页数据的类似属性的访问。\nRequest|\t获得当前 HTTP 请求的 HttpRequest 对象。\nServer|\t获取 HttpServerUtility 对象，该对象所提供的方法能够在网页处理过程中使用。\n\n# Web Pages帮助器\nWeb Helpers 极大地简化了 web 开发和常见的编程任务。其内部实现了表格、图表等内容显示的逻辑及样式，进行了特定封装。\n\n# Web Pages参考手册\nhttp://www.w3school.com.cn/aspnet/webpages_ref_classes.asp","source":"_posts/C#开发/2018-10-05-WebPages.md","raw":"---\ntitle: ASP.NET WebPages学习笔记\ntags:\n  - ASP.NET\n  - WebPages\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 11:37:50\ncategories: C#\npassword:\n---\n# 申明\n文章内容记录自：http://www.w3school.com.cn/aspnet/webpages_intro.asp， 为个人学习笔记记录。\n\n# 说明\nWeb Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。\n\n# 布局\n在因特网上，您会发现很多拥有统一外观的网站：\n* 每页拥有相同的页眉\n* 每页拥有相同的页脚\n* 每页拥有相同的样式和布局\n\n可以通过以下方式实现：\n1. 使用 @RenderPage() 方法从不同的文件导入内容\n \n~~~html \n<html>\n<body>\n@RenderPage(\"header.cshtml\")\n<h1>Hello Web Pages</h1>  \n@RenderPage(\"footer.cshtml\")\n</body>\n</html>\n~~~\n\n2. 使用布局页面\n布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。\n\n布局页面：\n~~~html\n<html>\n<body> \n@RenderBody() \n</body>\n</html>\n~~~\n\n任意网页：\n~~~html\n@{Layout=\"Layout.cshtml\";}\n<h1>Welcome to W3Schools</h1> \n~~~\n\n# 防止代码泄露\n在 ASP.NET 中，名称以下划线开头的文件无法通过 web 来浏览。如果您希望禁止用户查看内容块或布局文件，请对文件重新命名,如：_Layout.cshtml\n\n# ~ 操作符 与 Href 方法\n* 使用 ~ 操作符在编程代码中规定虚拟根目录,作为项目资源路径根路径，如：var myImagesFolder = \"~/images\";\n* Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符），如：\n~~~\n@{var myStyleSheet = \"~/Shared/Site.css\";}\n<!-- 创建指向 CSS 文件的链接 -->\n<link rel=\"stylesheet\" type=\"text/css\" href=\"@Href(myStyleSheet)\" />\n~~~\n\n# Page对象\nPage对象为内置对象，类似与JSP中的Request等对象\n方法|\t描述\n--|--\nhref|\t使用指定的参数构建 URL。\nRenderBody()|\t在布局页中，将呈现不在指定部分中的内容页部分。\nRenderPage(page)|\t在其他页内呈现某一页的内容。\nRenderSection(section)|\t在布局页中，将呈现指定部分的内容。\nWrite(object)|\t将指定的对象作为 HTML 编码的字符串写入。\nWriteLiteral|\t无需先对指定的对象进行 HTML 编码，即可将其写入。\n\n属性|\t描述\n--|--\nisPost|\t返回一个值（true 或 false），指示客户端用来请求网页的 HTTP 数据传输方法是否为 POST 请求。\nLayout|\t获取或设置布局页的路径。\nPage|\t提供对页面、布局页和分页之间共享的页数据的类似属性的访问。\nRequest|\t获得当前 HTTP 请求的 HttpRequest 对象。\nServer|\t获取 HttpServerUtility 对象，该对象所提供的方法能够在网页处理过程中使用。\n\n# Web Pages帮助器\nWeb Helpers 极大地简化了 web 开发和常见的编程任务。其内部实现了表格、图表等内容显示的逻辑及样式，进行了特定封装。\n\n# Web Pages参考手册\nhttp://www.w3school.com.cn/aspnet/webpages_ref_classes.asp","slug":"C-开发-2018-10-05-WebPages","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxb00105b8h6s8eebpo","content":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/webpages_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/webpages_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>Web Pages 是三种 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 编程模型中的一种，用于创建 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 网站和 web 应用程序。</p>\n<h1 id=\"布局\"><a class=\"markdownIt-Anchor\" href=\"#布局\"></a> 布局</h1>\n<p>在因特网上，您会发现很多拥有统一外观的网站：</p>\n<ul>\n<li>每页拥有相同的页眉</li>\n<li>每页拥有相同的页脚</li>\n<li>每页拥有相同的样式和布局</li>\n</ul>\n<p>可以通过以下方式实现：</p>\n<ol>\n<li>使用 @RenderPage() 方法从不同的文件导入内容</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">@RenderPage(\"header.cshtml\")</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello Web Pages<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>  </span><br><span class=\"line\">@RenderPage(\"footer.cshtml\")</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用布局页面<br>\n布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。</li>\n</ol>\n<p>布局页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">@RenderBody() </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>任意网页：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;Layout=\"Layout.cshtml\";&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome to W3Schools<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"防止代码泄露\"><a class=\"markdownIt-Anchor\" href=\"#防止代码泄露\"></a> 防止代码泄露</h1>\n<p>在 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 中，名称以下划线开头的文件无法通过 web 来浏览。如果您希望禁止用户查看内容块或布局文件，请对文件重新命名,如：_Layout.cshtml</p>\n<h1 id=\"~-操作符-与-href-方法\"><a class=\"markdownIt-Anchor\" href=\"#~-操作符-与-href-方法\"></a> ~ 操作符 与 Href 方法</h1>\n<ul>\n<li>使用 ~ 操作符在编程代码中规定虚拟根目录,作为项目资源路径根路径，如：var myImagesFolder = “~/images”;</li>\n<li>Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符），如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;var myStyleSheet = &quot;~/Shared/Site.css&quot;;&#125;</span><br><span class=\"line\">&lt;!-- 创建指向 CSS 文件的链接 --&gt;</span><br><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;@Href(myStyleSheet)&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"page对象\"><a class=\"markdownIt-Anchor\" href=\"#page对象\"></a> Page对象</h1>\n<p>Page对象为内置对象，类似与JSP中的Request等对象</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>href</td>\n<td>使用指定的参数构建 URL。</td>\n</tr>\n<tr>\n<td>RenderBody()</td>\n<td>在布局页中，将呈现不在指定部分中的内容页部分。</td>\n</tr>\n<tr>\n<td>RenderPage(page)</td>\n<td>在其他页内呈现某一页的内容。</td>\n</tr>\n<tr>\n<td>RenderSection(section)</td>\n<td>在布局页中，将呈现指定部分的内容。</td>\n</tr>\n<tr>\n<td>Write(object)</td>\n<td>将指定的对象作为 HTML 编码的字符串写入。</td>\n</tr>\n<tr>\n<td>WriteLiteral</td>\n<td>无需先对指定的对象进行 HTML 编码，即可将其写入。</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isPost</td>\n<td>返回一个值（true 或 false），指示客户端用来请求网页的 HTTP 数据传输方法是否为 POST 请求。</td>\n</tr>\n<tr>\n<td>Layout</td>\n<td>获取或设置布局页的路径。</td>\n</tr>\n<tr>\n<td>Page</td>\n<td>提供对页面、布局页和分页之间共享的页数据的类似属性的访问。</td>\n</tr>\n<tr>\n<td>Request</td>\n<td>获得当前 HTTP 请求的 HttpRequest 对象。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>获取 HttpServerUtility 对象，该对象所提供的方法能够在网页处理过程中使用。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"web-pages帮助器\"><a class=\"markdownIt-Anchor\" href=\"#web-pages帮助器\"></a> Web Pages帮助器</h1>\n<p>Web Helpers 极大地简化了 web 开发和常见的编程任务。其内部实现了表格、图表等内容显示的逻辑及样式，进行了特定封装。</p>\n<h1 id=\"web-pages参考手册\"><a class=\"markdownIt-Anchor\" href=\"#web-pages参考手册\"></a> Web Pages参考手册</h1>\n<p><a href=\"http://www.w3school.com.cn/aspnet/webpages_ref_classes.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/webpages_ref_classes.asp</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"申明\"><a class=\"markdownIt-Anchor\" href=\"#申明\"></a> 申明</h1>\n<p>文章内容记录自：<a href=\"http://www.w3school.com.cn/aspnet/webpages_intro.asp%EF%BC%8C\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/webpages_intro.asp，</a> 为个人学习笔记记录。</p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>Web Pages 是三种 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 编程模型中的一种，用于创建 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 网站和 web 应用程序。</p>\n<h1 id=\"布局\"><a class=\"markdownIt-Anchor\" href=\"#布局\"></a> 布局</h1>\n<p>在因特网上，您会发现很多拥有统一外观的网站：</p>\n<ul>\n<li>每页拥有相同的页眉</li>\n<li>每页拥有相同的页脚</li>\n<li>每页拥有相同的样式和布局</li>\n</ul>\n<p>可以通过以下方式实现：</p>\n<ol>\n<li>使用 @RenderPage() 方法从不同的文件导入内容</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">@RenderPage(\"header.cshtml\")</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello Web Pages<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>  </span><br><span class=\"line\">@RenderPage(\"footer.cshtml\")</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用布局页面<br>\n布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。</li>\n</ol>\n<p>布局页面：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">@RenderBody() </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>任意网页：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;Layout=\"Layout.cshtml\";&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome to W3Schools<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"防止代码泄露\"><a class=\"markdownIt-Anchor\" href=\"#防止代码泄露\"></a> 防止代码泄露</h1>\n<p>在 <a href=\"http://ASP.NET\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> 中，名称以下划线开头的文件无法通过 web 来浏览。如果您希望禁止用户查看内容块或布局文件，请对文件重新命名,如：_Layout.cshtml</p>\n<h1 id=\"~-操作符-与-href-方法\"><a class=\"markdownIt-Anchor\" href=\"#~-操作符-与-href-方法\"></a> ~ 操作符 与 Href 方法</h1>\n<ul>\n<li>使用 ~ 操作符在编程代码中规定虚拟根目录,作为项目资源路径根路径，如：var myImagesFolder = “~/images”;</li>\n<li>Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符），如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&#123;var myStyleSheet = &quot;~/Shared/Site.css&quot;;&#125;</span><br><span class=\"line\">&lt;!-- 创建指向 CSS 文件的链接 --&gt;</span><br><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;@Href(myStyleSheet)&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"page对象\"><a class=\"markdownIt-Anchor\" href=\"#page对象\"></a> Page对象</h1>\n<p>Page对象为内置对象，类似与JSP中的Request等对象</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>href</td>\n<td>使用指定的参数构建 URL。</td>\n</tr>\n<tr>\n<td>RenderBody()</td>\n<td>在布局页中，将呈现不在指定部分中的内容页部分。</td>\n</tr>\n<tr>\n<td>RenderPage(page)</td>\n<td>在其他页内呈现某一页的内容。</td>\n</tr>\n<tr>\n<td>RenderSection(section)</td>\n<td>在布局页中，将呈现指定部分的内容。</td>\n</tr>\n<tr>\n<td>Write(object)</td>\n<td>将指定的对象作为 HTML 编码的字符串写入。</td>\n</tr>\n<tr>\n<td>WriteLiteral</td>\n<td>无需先对指定的对象进行 HTML 编码，即可将其写入。</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isPost</td>\n<td>返回一个值（true 或 false），指示客户端用来请求网页的 HTTP 数据传输方法是否为 POST 请求。</td>\n</tr>\n<tr>\n<td>Layout</td>\n<td>获取或设置布局页的路径。</td>\n</tr>\n<tr>\n<td>Page</td>\n<td>提供对页面、布局页和分页之间共享的页数据的类似属性的访问。</td>\n</tr>\n<tr>\n<td>Request</td>\n<td>获得当前 HTTP 请求的 HttpRequest 对象。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>获取 HttpServerUtility 对象，该对象所提供的方法能够在网页处理过程中使用。</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"web-pages帮助器\"><a class=\"markdownIt-Anchor\" href=\"#web-pages帮助器\"></a> Web Pages帮助器</h1>\n<p>Web Helpers 极大地简化了 web 开发和常见的编程任务。其内部实现了表格、图表等内容显示的逻辑及样式，进行了特定封装。</p>\n<h1 id=\"web-pages参考手册\"><a class=\"markdownIt-Anchor\" href=\"#web-pages参考手册\"></a> Web Pages参考手册</h1>\n<p><a href=\"http://www.w3school.com.cn/aspnet/webpages_ref_classes.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/aspnet/webpages_ref_classes.asp</a></p>\n"},{"title":"Windows下SVN服务器搭建及VS2015插件安装联动","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T02:06:35.000Z","password":null,"_content":"\nSVN服务端软件下载：https://www.visualsvn.com/server/download/\n VisualSVN-Server-3.9.1-x64以管理员权限（有的话）安装,一路默认，选择standard版本,其他都是默认\n\nSVN客户端软件下载：https://www.visualsvn.com/visualsvn/download/tortoisesvn/\n默认安装\n\nVS2015插件下载： https://www.visualsvn.com/visualsvn/download/\n\n\n","source":"_posts/C#开发/2018-10-05-Windows下SVN服务器搭建及VS2015插件安装联动.md","raw":"---\ntitle: Windows下SVN服务器搭建及VS2015插件安装联动\ntags:\n  - 工具\n  - 版本控制\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 10:06:35\ncategories: 工具\npassword:\n---\n\nSVN服务端软件下载：https://www.visualsvn.com/server/download/\n VisualSVN-Server-3.9.1-x64以管理员权限（有的话）安装,一路默认，选择standard版本,其他都是默认\n\nSVN客户端软件下载：https://www.visualsvn.com/visualsvn/download/tortoisesvn/\n默认安装\n\nVS2015插件下载： https://www.visualsvn.com/visualsvn/download/\n\n\n","slug":"C-开发-2018-10-05-Windows下SVN服务器搭建及VS2015插件安装联动","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxc00135b8hhd6ofbyu","content":"<p>SVN服务端软件下载：<a href=\"https://www.visualsvn.com/server/download/\" target=\"_blank\" rel=\"noopener\">https://www.visualsvn.com/server/download/</a><br>\nVisualSVN-Server-3.9.1-x64以管理员权限（有的话）安装,一路默认，选择standard版本,其他都是默认</p>\n<p>SVN客户端软件下载：<a href=\"https://www.visualsvn.com/visualsvn/download/tortoisesvn/\" target=\"_blank\" rel=\"noopener\">https://www.visualsvn.com/visualsvn/download/tortoisesvn/</a><br>\n默认安装</p>\n<p>VS2015插件下载： <a href=\"https://www.visualsvn.com/visualsvn/download/\" target=\"_blank\" rel=\"noopener\">https://www.visualsvn.com/visualsvn/download/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>SVN服务端软件下载：<a href=\"https://www.visualsvn.com/server/download/\" target=\"_blank\" rel=\"noopener\">https://www.visualsvn.com/server/download/</a><br>\nVisualSVN-Server-3.9.1-x64以管理员权限（有的话）安装,一路默认，选择standard版本,其他都是默认</p>\n<p>SVN客户端软件下载：<a href=\"https://www.visualsvn.com/visualsvn/download/tortoisesvn/\" target=\"_blank\" rel=\"noopener\">https://www.visualsvn.com/visualsvn/download/tortoisesvn/</a><br>\n默认安装</p>\n<p>VS2015插件下载： <a href=\"https://www.visualsvn.com/visualsvn/download/\" target=\"_blank\" rel=\"noopener\">https://www.visualsvn.com/visualsvn/download/</a></p>\n"},{"title":"ASP.NET HTML表单元素","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T02:30:42.000Z","password":null,"_content":"\n# BeginForm\nhttps://www.cnblogs.com/sheng-jie/p/6305385.html","source":"_posts/C#开发/2018-10-06-ASP-NET-HTML表单元素.md","raw":"---\ntitle: ASP.NET HTML表单元素\ntags:\n  - ASP.NET\n  - HTML表单元素\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 10:30:42\ncategories: C#\npassword:\n---\n\n# BeginForm\nhttps://www.cnblogs.com/sheng-jie/p/6305385.html","slug":"C-开发-2018-10-06-ASP-NET-HTML表单元素","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxd00155b8hxq3hi5bj","content":"<h1 id=\"beginform\"><a class=\"markdownIt-Anchor\" href=\"#beginform\"></a> BeginForm</h1>\n<p><a href=\"https://www.cnblogs.com/sheng-jie/p/6305385.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sheng-jie/p/6305385.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"beginform\"><a class=\"markdownIt-Anchor\" href=\"#beginform\"></a> BeginForm</h1>\n<p><a href=\"https://www.cnblogs.com/sheng-jie/p/6305385.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sheng-jie/p/6305385.html</a></p>\n"},{"title":"C#","copyright":true,"comments":1,"toc":true,"date":"2018-10-17T07:03:28.000Z","password":null,"_content":"双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，\n\nhttps://blog.csdn.net/zmh458/article/details/78935172\nhttps://www.cnblogs.com/lanpingwang/p/6596758.html\nhttps://www.cnblogs.com/Inspire-Yi/p/6230567.html\n\nhttps://www.jianshu.com/p/c82ef6babf8e\n\nhttps://www.cnblogs.com/caofangsheng/p/5715876.html\nhttps://blog.csdn.net/beglorious/article/details/39637475\n \nhttps://www.cnblogs.com/servicehot/p/6510199.html\n\n\n首先我觉得action的跳转大致可以这样归一下类，跳转到同一控制器内的action和不同控制器内的action、带有参数的action跳转和不带参数的action跳转。\n\n一、RedirectToAction(\"Index\");//一个参数时在本Controller下，不传入参数。\n\n二、RedirectToAction(ActionName,ControllerName) //可以直接跳到别的Controller.\n\n三、RedirectToRoute(new {controller=\"Home\",action=\"Index\"});//可跳到其他controller\n\n四、RedirectToRoute(new {controller=\"Home\",action=\"Index\"， id=param});//可跳到其他controller,带参数。\n\n五、Response.Redirect(\"Index?id=1\");//适用于本controller下的方法名称,可带参数。\n六、return Redirect(\"Index\");//适用于本controller下的方法名称。\n\n七、return View(\"Index\"); //直接显示对应的页面 不经过执行Controller的方法。 \n八、return View(\"~/Views/Home/Index.aspx\");//这种方法是写全路径,直接显示页面,不经过Controller方法\n九、return View();//直接显示页面,不经过Controller方法\n\n\nhttps://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1\n一般情况下我们返回的都是本页面，所以使用return View()就可以解决问题了，\n\n\nhttps://www.cnblogs.com/Cwj-XFH/p/5956142.html\nModel验证是ASP.NET MVC中的重要部分，它主要用于判断输入的数据类型及值是否符合我们设定的规则，这篇文章就介绍下ASP.NET MVC中Model验证的几种方式。\n\n\n后台验证\nDataAnnotation\nValidationAttribute\nIValidatableObject\nIDataErrorInfo\n前端验证\n\n\nViewData和ViewBag\n\nhttps://blog.csdn.net/pasic/article/details/7093802\n\nhttps://www.cnblogs.com/webapi/p/9505400.html\n\n\n系列文章：\nhttps://blog.csdn.net/ydm19891101/article/details/43338999\n\nWebForm与MVC的本质区别：请求的url不同\n\n\nhttps://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&fps=1\n\n\n \nMVC action 返回javascriptResult 需要引入的文件是 \n需要引用这个文件 ：   jquery.unobtrusive-ajax.min.js \n\n同时 用javascrptResult  作为action的返回结果 的话 ，前台必须用ajax.BeginForm  \n\n\nhttps://www.cnblogs.com/zjf1987/p/ActionResult.html\n","source":"_posts/C#开发/2018-10-17-C.md","raw":"---\ntitle: 'C#'\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-17 15:03:28\ncategories: C#\npassword:\n---\n双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，\n\nhttps://blog.csdn.net/zmh458/article/details/78935172\nhttps://www.cnblogs.com/lanpingwang/p/6596758.html\nhttps://www.cnblogs.com/Inspire-Yi/p/6230567.html\n\nhttps://www.jianshu.com/p/c82ef6babf8e\n\nhttps://www.cnblogs.com/caofangsheng/p/5715876.html\nhttps://blog.csdn.net/beglorious/article/details/39637475\n \nhttps://www.cnblogs.com/servicehot/p/6510199.html\n\n\n首先我觉得action的跳转大致可以这样归一下类，跳转到同一控制器内的action和不同控制器内的action、带有参数的action跳转和不带参数的action跳转。\n\n一、RedirectToAction(\"Index\");//一个参数时在本Controller下，不传入参数。\n\n二、RedirectToAction(ActionName,ControllerName) //可以直接跳到别的Controller.\n\n三、RedirectToRoute(new {controller=\"Home\",action=\"Index\"});//可跳到其他controller\n\n四、RedirectToRoute(new {controller=\"Home\",action=\"Index\"， id=param});//可跳到其他controller,带参数。\n\n五、Response.Redirect(\"Index?id=1\");//适用于本controller下的方法名称,可带参数。\n六、return Redirect(\"Index\");//适用于本controller下的方法名称。\n\n七、return View(\"Index\"); //直接显示对应的页面 不经过执行Controller的方法。 \n八、return View(\"~/Views/Home/Index.aspx\");//这种方法是写全路径,直接显示页面,不经过Controller方法\n九、return View();//直接显示页面,不经过Controller方法\n\n\nhttps://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1\n一般情况下我们返回的都是本页面，所以使用return View()就可以解决问题了，\n\n\nhttps://www.cnblogs.com/Cwj-XFH/p/5956142.html\nModel验证是ASP.NET MVC中的重要部分，它主要用于判断输入的数据类型及值是否符合我们设定的规则，这篇文章就介绍下ASP.NET MVC中Model验证的几种方式。\n\n\n后台验证\nDataAnnotation\nValidationAttribute\nIValidatableObject\nIDataErrorInfo\n前端验证\n\n\nViewData和ViewBag\n\nhttps://blog.csdn.net/pasic/article/details/7093802\n\nhttps://www.cnblogs.com/webapi/p/9505400.html\n\n\n系列文章：\nhttps://blog.csdn.net/ydm19891101/article/details/43338999\n\nWebForm与MVC的本质区别：请求的url不同\n\n\nhttps://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&fps=1\n\n\n \nMVC action 返回javascriptResult 需要引入的文件是 \n需要引用这个文件 ：   jquery.unobtrusive-ajax.min.js \n\n同时 用javascrptResult  作为action的返回结果 的话 ，前台必须用ajax.BeginForm  \n\n\nhttps://www.cnblogs.com/zjf1987/p/ActionResult.html\n","slug":"C-开发-2018-10-17-C","published":1,"updated":"2019-02-14T02:28:08.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxf00195b8h1g91ndvd","content":"<p>双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，</p>\n<p><a href=\"https://blog.csdn.net/zmh458/article/details/78935172\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zmh458/article/details/78935172</a><br>\n<a href=\"https://www.cnblogs.com/lanpingwang/p/6596758.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lanpingwang/p/6596758.html</a><br>\n<a href=\"https://www.cnblogs.com/Inspire-Yi/p/6230567.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Inspire-Yi/p/6230567.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/c82ef6babf8e\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c82ef6babf8e</a></p>\n<p><a href=\"https://www.cnblogs.com/caofangsheng/p/5715876.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/caofangsheng/p/5715876.html</a><br>\n<a href=\"https://blog.csdn.net/beglorious/article/details/39637475\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/beglorious/article/details/39637475</a></p>\n<p><a href=\"https://www.cnblogs.com/servicehot/p/6510199.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/servicehot/p/6510199.html</a></p>\n<p>首先我觉得action的跳转大致可以这样归一下类，跳转到同一控制器内的action和不同控制器内的action、带有参数的action跳转和不带参数的action跳转。</p>\n<p>一、RedirectToAction(“Index”);//一个参数时在本Controller下，不传入参数。</p>\n<p>二、RedirectToAction(ActionName,ControllerName) //可以直接跳到别的Controller.</p>\n<p>三、RedirectToRoute(new {controller=“Home”,action=“Index”});//可跳到其他controller</p>\n<p>四、RedirectToRoute(new {controller=“Home”,action=“Index”， id=param});//可跳到其他controller,带参数。</p>\n<p>五、Response.Redirect(“Index?id=1”);//适用于本controller下的方法名称,可带参数。<br>\n六、return Redirect(“Index”);//适用于本controller下的方法名称。</p>\n<p>七、return View(“Index”); //直接显示对应的页面 不经过执行Controller的方法。<br>\n八、return View(&quot;~/Views/Home/Index.aspx&quot;);//这种方法是写全路径,直接显示页面,不经过Controller方法<br>\n九、return View();//直接显示页面,不经过Controller方法</p>\n<p><a href=\"https://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1</a><br>\n一般情况下我们返回的都是本页面，所以使用return View()就可以解决问题了，</p>\n<p><a href=\"https://www.cnblogs.com/Cwj-XFH/p/5956142.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Cwj-XFH/p/5956142.html</a><br>\n<a href=\"http://xn--ModelASP-3i5qt911ag97a.NET\" target=\"_blank\" rel=\"noopener\">Model验证是ASP.NET</a> MVC中的重要部分，它主要用于判断输入的数据类型及值是否符合我们设定的规则，<a href=\"http://xn--ASP-y28d97a810d83ofj4bmybj3mnv4c.NET\" target=\"_blank\" rel=\"noopener\">这篇文章就介绍下ASP.NET</a> MVC中Model验证的几种方式。</p>\n<p>后台验证<br>\nDataAnnotation<br>\nValidationAttribute<br>\nIValidatableObject<br>\nIDataErrorInfo<br>\n前端验证</p>\n<p>ViewData和ViewBag</p>\n<p><a href=\"https://blog.csdn.net/pasic/article/details/7093802\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pasic/article/details/7093802</a></p>\n<p><a href=\"https://www.cnblogs.com/webapi/p/9505400.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/webapi/p/9505400.html</a></p>\n<p>系列文章：<br>\n<a href=\"https://blog.csdn.net/ydm19891101/article/details/43338999\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ydm19891101/article/details/43338999</a></p>\n<p>WebForm与MVC的本质区别：请求的url不同</p>\n<p><a href=\"https://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&amp;fps=1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&amp;fps=1</a></p>\n<p>MVC action 返回javascriptResult 需要引入的文件是<br>\n需要引用这个文件 ：   jquery.unobtrusive-ajax.min.js</p>\n<p>同时 用javascrptResult  作为action的返回结果 的话 ，前台必须用ajax.BeginForm</p>\n<p><a href=\"https://www.cnblogs.com/zjf1987/p/ActionResult.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zjf1987/p/ActionResult.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，双问号操作符意思是取所赋值??左边的，如果左边为null，取所赋值??右边的，</p>\n<p><a href=\"https://blog.csdn.net/zmh458/article/details/78935172\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zmh458/article/details/78935172</a><br>\n<a href=\"https://www.cnblogs.com/lanpingwang/p/6596758.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lanpingwang/p/6596758.html</a><br>\n<a href=\"https://www.cnblogs.com/Inspire-Yi/p/6230567.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Inspire-Yi/p/6230567.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/c82ef6babf8e\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c82ef6babf8e</a></p>\n<p><a href=\"https://www.cnblogs.com/caofangsheng/p/5715876.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/caofangsheng/p/5715876.html</a><br>\n<a href=\"https://blog.csdn.net/beglorious/article/details/39637475\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/beglorious/article/details/39637475</a></p>\n<p><a href=\"https://www.cnblogs.com/servicehot/p/6510199.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/servicehot/p/6510199.html</a></p>\n<p>首先我觉得action的跳转大致可以这样归一下类，跳转到同一控制器内的action和不同控制器内的action、带有参数的action跳转和不带参数的action跳转。</p>\n<p>一、RedirectToAction(“Index”);//一个参数时在本Controller下，不传入参数。</p>\n<p>二、RedirectToAction(ActionName,ControllerName) //可以直接跳到别的Controller.</p>\n<p>三、RedirectToRoute(new {controller=“Home”,action=“Index”});//可跳到其他controller</p>\n<p>四、RedirectToRoute(new {controller=“Home”,action=“Index”， id=param});//可跳到其他controller,带参数。</p>\n<p>五、Response.Redirect(“Index?id=1”);//适用于本controller下的方法名称,可带参数。<br>\n六、return Redirect(“Index”);//适用于本controller下的方法名称。</p>\n<p>七、return View(“Index”); //直接显示对应的页面 不经过执行Controller的方法。<br>\n八、return View(&quot;~/Views/Home/Index.aspx&quot;);//这种方法是写全路径,直接显示页面,不经过Controller方法<br>\n九、return View();//直接显示页面,不经过Controller方法</p>\n<p><a href=\"https://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhensoft163/article/details/7174661?utm_source=blogxgwz1</a><br>\n一般情况下我们返回的都是本页面，所以使用return View()就可以解决问题了，</p>\n<p><a href=\"https://www.cnblogs.com/Cwj-XFH/p/5956142.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Cwj-XFH/p/5956142.html</a><br>\n<a href=\"http://xn--ModelASP-3i5qt911ag97a.NET\" target=\"_blank\" rel=\"noopener\">Model验证是ASP.NET</a> MVC中的重要部分，它主要用于判断输入的数据类型及值是否符合我们设定的规则，<a href=\"http://xn--ASP-y28d97a810d83ofj4bmybj3mnv4c.NET\" target=\"_blank\" rel=\"noopener\">这篇文章就介绍下ASP.NET</a> MVC中Model验证的几种方式。</p>\n<p>后台验证<br>\nDataAnnotation<br>\nValidationAttribute<br>\nIValidatableObject<br>\nIDataErrorInfo<br>\n前端验证</p>\n<p>ViewData和ViewBag</p>\n<p><a href=\"https://blog.csdn.net/pasic/article/details/7093802\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pasic/article/details/7093802</a></p>\n<p><a href=\"https://www.cnblogs.com/webapi/p/9505400.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/webapi/p/9505400.html</a></p>\n<p>系列文章：<br>\n<a href=\"https://blog.csdn.net/ydm19891101/article/details/43338999\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ydm19891101/article/details/43338999</a></p>\n<p>WebForm与MVC的本质区别：请求的url不同</p>\n<p><a href=\"https://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&amp;fps=1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liupantao/article/details/78582078?locationNum=3&amp;fps=1</a></p>\n<p>MVC action 返回javascriptResult 需要引入的文件是<br>\n需要引用这个文件 ：   jquery.unobtrusive-ajax.min.js</p>\n<p>同时 用javascrptResult  作为action的返回结果 的话 ，前台必须用ajax.BeginForm</p>\n<p><a href=\"https://www.cnblogs.com/zjf1987/p/ActionResult.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zjf1987/p/ActionResult.html</a></p>\n"},{"title":"NuGet","copyright":true,"comments":1,"toc":true,"date":"2018-11-02T02:44:02.000Z","password":null,"_content":"\n\nhttps://www.cnblogs.com/nizhenghua/p/6422078.html","source":"_posts/C#开发/2018-11-02-NuGet.md","raw":"---\ntitle: NuGet\ntags:\n  - C# \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-11-02 10:44:02\ncategories: C#\npassword:\n---\n\n\nhttps://www.cnblogs.com/nizhenghua/p/6422078.html","slug":"C-开发-2018-11-02-NuGet","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxg001a5b8hsv67yvnq","content":"<p><a href=\"https://www.cnblogs.com/nizhenghua/p/6422078.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nizhenghua/p/6422078.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.cnblogs.com/nizhenghua/p/6422078.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nizhenghua/p/6422078.html</a></p>\n"},{"title":"React全家桶","copyright":true,"comments":1,"toc":true,"date":"2018-10-15T00:16:00.000Z","password":null,"_content":"\nReact全家桶+Antd共享单车后台管理系统\n\n# react基础知识\nVue生态：Vue+Vue-Router+Vuex+Axios+Babel+Webpack\nReact生态：React+React-Router+Redux+Axios+Babel+Webpack\n\n编程式实现：需要以具体代码表达在哪里做什么，如何实现 \n声明式实现：只需声明在哪里做什么，无需关心如何实现\n\n\nhttps://react.docschina.org/\nhttps://reactjs.org.cn/\nhttp://facebook.github.io/react/\n\n\nyarn： https://yarnpkg.com/zh-Hans/\n* yarn init\n* yarn add\n* yarn remove\n* yarn install\n\nreact生命周期\n\n\nreact-router ／react-router-dom\n\n按需加载：\nAntd中less样式\nyarn eject:暴露webpack配置，\n\nless-loader安装\nwebpack.config.xxx.js\n\n修改完之后，重启项目\n\n\nhttps://ant.design/docs/react/use-with-create-react-app-cn\n\nbabel-plugin-import\n\n\ncss3  calc属性\nheight:calc(100vh)\n\n\njsonp：https://www.npmjs.com/package/jsonp\n\n浏览器添加debugger\n\n\n伪类方式\n\n\n项目中前端路由用的是 React-Router V4。\n\n官方文档：https://reacttraining.com/react-router/web/guides/quick-start\n\n中文文档：http://reacttraining.cn/\n\nReact-Router 4.0\nReact-Router：基础包\nReact-Router-DOM：浏览器端实现\n\n\nhttps://segmentfault.com/a/1190000011399153\n\n箭头函数不加{}表示直接返回结果 \nthis.props.match.params.XXX\n处理404则不设置path，只设置component即可\n路由外面添加Switch\n\n\n详情页面、登录页面、主页面是同层级页面，还有其他自页面嵌套路由\n\nApp.js设置为{this.props.children}代表可以接受任何组件，APP组件作为HashRouter的根组件\n\n子路由、子组件模式\n\n\n传参数需要箭头函数\n\nModal.confirm()  等价于  Modal['confirm']\n\n{}里面必须是一个根对象\n\n\nhttps://blog.csdn.net/little_blue_ljy/article/details/80281803\nhttps://www.cnblogs.com/guolintao/p/9019504.html\nhttps://www.cnblogs.com/xuyuntao/articles/6391728.html\nhttps://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md\n\n\nES6模版语法:","source":"_posts/react+rn/2018-10-15-React全家桶.md","raw":"---\ntitle: React全家桶\ntags:\n  - react\n  - Antd\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-15 08:16:00\ncategories: react\npassword:\n---\n\nReact全家桶+Antd共享单车后台管理系统\n\n# react基础知识\nVue生态：Vue+Vue-Router+Vuex+Axios+Babel+Webpack\nReact生态：React+React-Router+Redux+Axios+Babel+Webpack\n\n编程式实现：需要以具体代码表达在哪里做什么，如何实现 \n声明式实现：只需声明在哪里做什么，无需关心如何实现\n\n\nhttps://react.docschina.org/\nhttps://reactjs.org.cn/\nhttp://facebook.github.io/react/\n\n\nyarn： https://yarnpkg.com/zh-Hans/\n* yarn init\n* yarn add\n* yarn remove\n* yarn install\n\nreact生命周期\n\n\nreact-router ／react-router-dom\n\n按需加载：\nAntd中less样式\nyarn eject:暴露webpack配置，\n\nless-loader安装\nwebpack.config.xxx.js\n\n修改完之后，重启项目\n\n\nhttps://ant.design/docs/react/use-with-create-react-app-cn\n\nbabel-plugin-import\n\n\ncss3  calc属性\nheight:calc(100vh)\n\n\njsonp：https://www.npmjs.com/package/jsonp\n\n浏览器添加debugger\n\n\n伪类方式\n\n\n项目中前端路由用的是 React-Router V4。\n\n官方文档：https://reacttraining.com/react-router/web/guides/quick-start\n\n中文文档：http://reacttraining.cn/\n\nReact-Router 4.0\nReact-Router：基础包\nReact-Router-DOM：浏览器端实现\n\n\nhttps://segmentfault.com/a/1190000011399153\n\n箭头函数不加{}表示直接返回结果 \nthis.props.match.params.XXX\n处理404则不设置path，只设置component即可\n路由外面添加Switch\n\n\n详情页面、登录页面、主页面是同层级页面，还有其他自页面嵌套路由\n\nApp.js设置为{this.props.children}代表可以接受任何组件，APP组件作为HashRouter的根组件\n\n子路由、子组件模式\n\n\n传参数需要箭头函数\n\nModal.confirm()  等价于  Modal['confirm']\n\n{}里面必须是一个根对象\n\n\nhttps://blog.csdn.net/little_blue_ljy/article/details/80281803\nhttps://www.cnblogs.com/guolintao/p/9019504.html\nhttps://www.cnblogs.com/xuyuntao/articles/6391728.html\nhttps://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md\n\n\nES6模版语法:","slug":"react-rn-2018-10-15-React全家桶","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxi001e5b8h5gb07al4","content":"<p>React全家桶+Antd共享单车后台管理系统</p>\n<h1 id=\"react基础知识\"><a class=\"markdownIt-Anchor\" href=\"#react基础知识\"></a> react基础知识</h1>\n<p>Vue生态：Vue+Vue-Router+Vuex+Axios+Babel+Webpack<br>\nReact生态：React+React-Router+Redux+Axios+Babel+Webpack</p>\n<p>编程式实现：需要以具体代码表达在哪里做什么，如何实现<br>\n声明式实现：只需声明在哪里做什么，无需关心如何实现</p>\n<p><a href=\"https://react.docschina.org/\" target=\"_blank\" rel=\"noopener\">https://react.docschina.org/</a><br>\n<a href=\"https://reactjs.org.cn/\" target=\"_blank\" rel=\"noopener\">https://reactjs.org.cn/</a><br>\n<a href=\"http://facebook.github.io/react/\" target=\"_blank\" rel=\"noopener\">http://facebook.github.io/react/</a></p>\n<p>yarn： <a href=\"https://yarnpkg.com/zh-Hans/\" target=\"_blank\" rel=\"noopener\">https://yarnpkg.com/zh-Hans/</a></p>\n<ul>\n<li>yarn init</li>\n<li>yarn add</li>\n<li>yarn remove</li>\n<li>yarn install</li>\n</ul>\n<p>react生命周期</p>\n<p>react-router ／react-router-dom</p>\n<p>按需加载：<br>\nAntd中less样式<br>\nyarn eject:暴露webpack配置，</p>\n<p>less-loader安装<br>\nwebpack.config.xxx.js</p>\n<p>修改完之后，重启项目</p>\n<p><a href=\"https://ant.design/docs/react/use-with-create-react-app-cn\" target=\"_blank\" rel=\"noopener\">https://ant.design/docs/react/use-with-create-react-app-cn</a></p>\n<p>babel-plugin-import</p>\n<p>css3  calc属性<br>\nheight:calc(100vh)</p>\n<p>jsonp：<a href=\"https://www.npmjs.com/package/jsonp\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/jsonp</a></p>\n<p>浏览器添加debugger</p>\n<p>伪类方式</p>\n<p>项目中前端路由用的是 React-Router V4。</p>\n<p>官方文档：<a href=\"https://reacttraining.com/react-router/web/guides/quick-start\" target=\"_blank\" rel=\"noopener\">https://reacttraining.com/react-router/web/guides/quick-start</a></p>\n<p>中文文档：<a href=\"http://reacttraining.cn/\" target=\"_blank\" rel=\"noopener\">http://reacttraining.cn/</a></p>\n<p>React-Router 4.0<br>\nReact-Router：基础包<br>\nReact-Router-DOM：浏览器端实现</p>\n<p><a href=\"https://segmentfault.com/a/1190000011399153\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000011399153</a></p>\n<p>箭头函数不加{}表示直接返回结果<br>\n<a href=\"http://this.props.match.params.XXX\" target=\"_blank\" rel=\"noopener\">this.props.match.params.XXX</a><br>\n处理404则不设置path，只设置component即可<br>\n路由外面添加Switch</p>\n<p>详情页面、登录页面、主页面是同层级页面，还有其他自页面嵌套路由</p>\n<p>App.js设置为{this.props.children}代表可以接受任何组件，APP组件作为HashRouter的根组件</p>\n<p>子路由、子组件模式</p>\n<p>传参数需要箭头函数</p>\n<p>Modal.confirm()  等价于  Modal[‘confirm’]</p>\n<p>{}里面必须是一个根对象</p>\n<p><a href=\"https://blog.csdn.net/little_blue_ljy/article/details/80281803\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/little_blue_ljy/article/details/80281803</a><br>\n<a href=\"https://www.cnblogs.com/guolintao/p/9019504.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/guolintao/p/9019504.html</a><br>\n<a href=\"https://www.cnblogs.com/xuyuntao/articles/6391728.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xuyuntao/articles/6391728.html</a><br>\n<a href=\"https://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\">https://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md</a></p>\n<p>ES6模版语法:</p>\n","site":{"data":{}},"excerpt":"","more":"<p>React全家桶+Antd共享单车后台管理系统</p>\n<h1 id=\"react基础知识\"><a class=\"markdownIt-Anchor\" href=\"#react基础知识\"></a> react基础知识</h1>\n<p>Vue生态：Vue+Vue-Router+Vuex+Axios+Babel+Webpack<br>\nReact生态：React+React-Router+Redux+Axios+Babel+Webpack</p>\n<p>编程式实现：需要以具体代码表达在哪里做什么，如何实现<br>\n声明式实现：只需声明在哪里做什么，无需关心如何实现</p>\n<p><a href=\"https://react.docschina.org/\" target=\"_blank\" rel=\"noopener\">https://react.docschina.org/</a><br>\n<a href=\"https://reactjs.org.cn/\" target=\"_blank\" rel=\"noopener\">https://reactjs.org.cn/</a><br>\n<a href=\"http://facebook.github.io/react/\" target=\"_blank\" rel=\"noopener\">http://facebook.github.io/react/</a></p>\n<p>yarn： <a href=\"https://yarnpkg.com/zh-Hans/\" target=\"_blank\" rel=\"noopener\">https://yarnpkg.com/zh-Hans/</a></p>\n<ul>\n<li>yarn init</li>\n<li>yarn add</li>\n<li>yarn remove</li>\n<li>yarn install</li>\n</ul>\n<p>react生命周期</p>\n<p>react-router ／react-router-dom</p>\n<p>按需加载：<br>\nAntd中less样式<br>\nyarn eject:暴露webpack配置，</p>\n<p>less-loader安装<br>\nwebpack.config.xxx.js</p>\n<p>修改完之后，重启项目</p>\n<p><a href=\"https://ant.design/docs/react/use-with-create-react-app-cn\" target=\"_blank\" rel=\"noopener\">https://ant.design/docs/react/use-with-create-react-app-cn</a></p>\n<p>babel-plugin-import</p>\n<p>css3  calc属性<br>\nheight:calc(100vh)</p>\n<p>jsonp：<a href=\"https://www.npmjs.com/package/jsonp\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/jsonp</a></p>\n<p>浏览器添加debugger</p>\n<p>伪类方式</p>\n<p>项目中前端路由用的是 React-Router V4。</p>\n<p>官方文档：<a href=\"https://reacttraining.com/react-router/web/guides/quick-start\" target=\"_blank\" rel=\"noopener\">https://reacttraining.com/react-router/web/guides/quick-start</a></p>\n<p>中文文档：<a href=\"http://reacttraining.cn/\" target=\"_blank\" rel=\"noopener\">http://reacttraining.cn/</a></p>\n<p>React-Router 4.0<br>\nReact-Router：基础包<br>\nReact-Router-DOM：浏览器端实现</p>\n<p><a href=\"https://segmentfault.com/a/1190000011399153\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000011399153</a></p>\n<p>箭头函数不加{}表示直接返回结果<br>\n<a href=\"http://this.props.match.params.XXX\" target=\"_blank\" rel=\"noopener\">this.props.match.params.XXX</a><br>\n处理404则不设置path，只设置component即可<br>\n路由外面添加Switch</p>\n<p>详情页面、登录页面、主页面是同层级页面，还有其他自页面嵌套路由</p>\n<p>App.js设置为{this.props.children}代表可以接受任何组件，APP组件作为HashRouter的根组件</p>\n<p>子路由、子组件模式</p>\n<p>传参数需要箭头函数</p>\n<p>Modal.confirm()  等价于  Modal[‘confirm’]</p>\n<p>{}里面必须是一个根对象</p>\n<p><a href=\"https://blog.csdn.net/little_blue_ljy/article/details/80281803\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/little_blue_ljy/article/details/80281803</a><br>\n<a href=\"https://www.cnblogs.com/guolintao/p/9019504.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/guolintao/p/9019504.html</a><br>\n<a href=\"https://www.cnblogs.com/xuyuntao/articles/6391728.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xuyuntao/articles/6391728.html</a><br>\n<a href=\"https://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\">https://github.com/fomenyesu/egg-restapi-module-tool/blob/master/README.cn.md</a></p>\n<p>ES6模版语法:</p>\n"},{"title":"Jest","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:27:45.000Z","password":null,"_content":"\n# 简介\nJest是一个JS的单元测试工具\n\n单元测试可以保证函数或者模块完成我们想要的功能，测试具体功能是否正常\n\n使用Jest需要配置NodeJS环境\n\n# 入门\n1. npm install jest-cli\n2. sum.js\n~~~\nfunction sum(a,b){\n    return a+b;\n}\nmodule.exports=sum;\n~~~\n3. test.js\n~~~\njest.dontMock('../sum');\n\ndescribe('sum',function(){\n    it('adds 1 + 2 to equal 3',function(){\n        var sum = require('../sum');\n        expect(sum(1,2)).toBe(3);\n    });\n});\n~~~","source":"_posts/react+rn/2018-10-26-Jest.md","raw":"---\ntitle: Jest\ntags:\n  - React \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:27:45\ncategories: React\npassword:\n---\n\n# 简介\nJest是一个JS的单元测试工具\n\n单元测试可以保证函数或者模块完成我们想要的功能，测试具体功能是否正常\n\n使用Jest需要配置NodeJS环境\n\n# 入门\n1. npm install jest-cli\n2. sum.js\n~~~\nfunction sum(a,b){\n    return a+b;\n}\nmodule.exports=sum;\n~~~\n3. test.js\n~~~\njest.dontMock('../sum');\n\ndescribe('sum',function(){\n    it('adds 1 + 2 to equal 3',function(){\n        var sum = require('../sum');\n        expect(sum(1,2)).toBe(3);\n    });\n});\n~~~","slug":"react-rn-2018-10-26-Jest","published":1,"updated":"2019-02-14T02:25:17.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxk001h5b8hdievur0m","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Jest是一个JS的单元测试工具</p>\n<p>单元测试可以保证函数或者模块完成我们想要的功能，测试具体功能是否正常</p>\n<p>使用Jest需要配置NodeJS环境</p>\n<h1 id=\"入门\"><a class=\"markdownIt-Anchor\" href=\"#入门\"></a> 入门</h1>\n<ol>\n<li>npm install jest-cli</li>\n<li>sum.js</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sum(a,b)&#123;</span><br><span class=\"line\">    return a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=sum;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>test.js</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jest.dontMock(&apos;../sum&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;sum&apos;,function()&#123;</span><br><span class=\"line\">    it(&apos;adds 1 + 2 to equal 3&apos;,function()&#123;</span><br><span class=\"line\">        var sum = require(&apos;../sum&apos;);</span><br><span class=\"line\">        expect(sum(1,2)).toBe(3);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Jest是一个JS的单元测试工具</p>\n<p>单元测试可以保证函数或者模块完成我们想要的功能，测试具体功能是否正常</p>\n<p>使用Jest需要配置NodeJS环境</p>\n<h1 id=\"入门\"><a class=\"markdownIt-Anchor\" href=\"#入门\"></a> 入门</h1>\n<ol>\n<li>npm install jest-cli</li>\n<li>sum.js</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sum(a,b)&#123;</span><br><span class=\"line\">    return a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=sum;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>test.js</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jest.dontMock(&apos;../sum&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;sum&apos;,function()&#123;</span><br><span class=\"line\">    it(&apos;adds 1 + 2 to equal 3&apos;,function()&#123;</span><br><span class=\"line\">        var sum = require(&apos;../sum&apos;);</span><br><span class=\"line\">        expect(sum(1,2)).toBe(3);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"React Router","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:18:27.000Z","password":null,"_content":"https://reacttraining.com/react-router/\n\n# 概述\nReact Router 4.0 （以下简称 RR4）\n\nRR4 本次采用单代码仓库模型架构（monorepo），这意味者这个仓库里面有若干相互独立的包，分别是：\n~~~\nreact-router React Router 核心\nreact-router-dom 用于 DOM 绑定的 React Router\nreact-router-native 用于 React Native 的 React Router\nreact-router-redux React Router 和 Redux 的集成\nreact-router-config 静态路由配置的小助手\n~~~\n\n> 它是官方维护的，事实上也是唯一可选的路由库。\n\n# react-router 还是 react-router-dom\n1. 在 React 的使用中，我们一般要引入两个包，react 和 react-dom\n2. react-router 和 react-router-dom 两个只要引用一个就行了，不同之处就是后者比前者多出了 <Link> <BrowserRouter> 这样的 DOM 类组件\n\n\n# 学习\n* （阮一峰）http://www.ruanyifeng.com/blog/2016/05/react_router.html\n* （gitbook）http://react-guide.github.io/react-router-cn/docs/API.html","source":"_posts/react+rn/2018-10-26-React-Router.md","raw":"---\ntitle: React Router\ntags:\n  - React\n  - React-Router\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:18:27\ncategories: React\npassword:\n---\nhttps://reacttraining.com/react-router/\n\n# 概述\nReact Router 4.0 （以下简称 RR4）\n\nRR4 本次采用单代码仓库模型架构（monorepo），这意味者这个仓库里面有若干相互独立的包，分别是：\n~~~\nreact-router React Router 核心\nreact-router-dom 用于 DOM 绑定的 React Router\nreact-router-native 用于 React Native 的 React Router\nreact-router-redux React Router 和 Redux 的集成\nreact-router-config 静态路由配置的小助手\n~~~\n\n> 它是官方维护的，事实上也是唯一可选的路由库。\n\n# react-router 还是 react-router-dom\n1. 在 React 的使用中，我们一般要引入两个包，react 和 react-dom\n2. react-router 和 react-router-dom 两个只要引用一个就行了，不同之处就是后者比前者多出了 <Link> <BrowserRouter> 这样的 DOM 类组件\n\n\n# 学习\n* （阮一峰）http://www.ruanyifeng.com/blog/2016/05/react_router.html\n* （gitbook）http://react-guide.github.io/react-router-cn/docs/API.html","slug":"react-rn-2018-10-26-React-Router","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxl001l5b8hk8wq4zqm","content":"<p><a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"noopener\">https://reacttraining.com/react-router/</a></p>\n<h1 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h1>\n<p>React Router 4.0 （以下简称 RR4）</p>\n<p>RR4 本次采用单代码仓库模型架构（monorepo），这意味者这个仓库里面有若干相互独立的包，分别是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-router React Router 核心</span><br><span class=\"line\">react-router-dom 用于 DOM 绑定的 React Router</span><br><span class=\"line\">react-router-native 用于 React Native 的 React Router</span><br><span class=\"line\">react-router-redux React Router 和 Redux 的集成</span><br><span class=\"line\">react-router-config 静态路由配置的小助手</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>它是官方维护的，事实上也是唯一可选的路由库。</p>\n</blockquote>\n<h1 id=\"react-router-还是-react-router-dom\"><a class=\"markdownIt-Anchor\" href=\"#react-router-还是-react-router-dom\"></a> react-router 还是 react-router-dom</h1>\n<ol>\n<li>在 React 的使用中，我们一般要引入两个包，react 和 react-dom</li>\n<li>react-router 和 react-router-dom 两个只要引用一个就行了，不同之处就是后者比前者多出了 <link> <browserrouter> 这样的 DOM 类组件</browserrouter></li>\n</ol>\n<h1 id=\"学习\"><a class=\"markdownIt-Anchor\" href=\"#学习\"></a> 学习</h1>\n<ul>\n<li>（阮一峰）<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/05/react_router.html</a></li>\n<li>（gitbook）<a href=\"http://react-guide.github.io/react-router-cn/docs/API.html\" target=\"_blank\" rel=\"noopener\">http://react-guide.github.io/react-router-cn/docs/API.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://reacttraining.com/react-router/\" target=\"_blank\" rel=\"noopener\">https://reacttraining.com/react-router/</a></p>\n<h1 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h1>\n<p>React Router 4.0 （以下简称 RR4）</p>\n<p>RR4 本次采用单代码仓库模型架构（monorepo），这意味者这个仓库里面有若干相互独立的包，分别是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-router React Router 核心</span><br><span class=\"line\">react-router-dom 用于 DOM 绑定的 React Router</span><br><span class=\"line\">react-router-native 用于 React Native 的 React Router</span><br><span class=\"line\">react-router-redux React Router 和 Redux 的集成</span><br><span class=\"line\">react-router-config 静态路由配置的小助手</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>它是官方维护的，事实上也是唯一可选的路由库。</p>\n</blockquote>\n<h1 id=\"react-router-还是-react-router-dom\"><a class=\"markdownIt-Anchor\" href=\"#react-router-还是-react-router-dom\"></a> react-router 还是 react-router-dom</h1>\n<ol>\n<li>在 React 的使用中，我们一般要引入两个包，react 和 react-dom</li>\n<li>react-router 和 react-router-dom 两个只要引用一个就行了，不同之处就是后者比前者多出了 <link> <browserrouter> 这样的 DOM 类组件</browserrouter></li>\n</ol>\n<h1 id=\"学习\"><a class=\"markdownIt-Anchor\" href=\"#学习\"></a> 学习</h1>\n<ul>\n<li>（阮一峰）<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/05/react_router.html</a></li>\n<li>（gitbook）<a href=\"http://react-guide.github.io/react-router-cn/docs/API.html\" target=\"_blank\" rel=\"noopener\">http://react-guide.github.io/react-router-cn/docs/API.html</a></li>\n</ul>\n"},{"title":"React相关需学习","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:28:57.000Z","password":null,"_content":"\n# ImmutableJS简介\nImmutableJS是FaceBook开发的一个JS库，能够在JS种实现不可变对象\n\n不可变对象可以大大提高对象的比较性能，用于状态和属性判断非常有效\n\n实际上，提高比较性能的代价是降低修改性能，只不过收益更大\n\n# Flux简介\nFlux不是一个具体的框架，而是Facebook提出的一种代码架构\n\nReact只是一个视图库，Fulx是在React基础上对于前端整体的组织方案\n\nFulx目的是保证逻辑清晰、数据流向清晰、依赖关系清晰","source":"_posts/react+rn/2018-10-26-React相关需学习.md","raw":"---\ntitle: React相关需学习\ntags:\n  - React \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:28:57\ncategories: React\npassword:\n---\n\n# ImmutableJS简介\nImmutableJS是FaceBook开发的一个JS库，能够在JS种实现不可变对象\n\n不可变对象可以大大提高对象的比较性能，用于状态和属性判断非常有效\n\n实际上，提高比较性能的代价是降低修改性能，只不过收益更大\n\n# Flux简介\nFlux不是一个具体的框架，而是Facebook提出的一种代码架构\n\nReact只是一个视图库，Fulx是在React基础上对于前端整体的组织方案\n\nFulx目的是保证逻辑清晰、数据流向清晰、依赖关系清晰","slug":"react-rn-2018-10-26-React相关需学习","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxn001n5b8h9gwyea6l","content":"<h1 id=\"immutablejs简介\"><a class=\"markdownIt-Anchor\" href=\"#immutablejs简介\"></a> ImmutableJS简介</h1>\n<p>ImmutableJS是FaceBook开发的一个JS库，能够在JS种实现不可变对象</p>\n<p>不可变对象可以大大提高对象的比较性能，用于状态和属性判断非常有效</p>\n<p>实际上，提高比较性能的代价是降低修改性能，只不过收益更大</p>\n<h1 id=\"flux简介\"><a class=\"markdownIt-Anchor\" href=\"#flux简介\"></a> Flux简介</h1>\n<p>Flux不是一个具体的框架，而是Facebook提出的一种代码架构</p>\n<p>React只是一个视图库，Fulx是在React基础上对于前端整体的组织方案</p>\n<p>Fulx目的是保证逻辑清晰、数据流向清晰、依赖关系清晰</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"immutablejs简介\"><a class=\"markdownIt-Anchor\" href=\"#immutablejs简介\"></a> ImmutableJS简介</h1>\n<p>ImmutableJS是FaceBook开发的一个JS库，能够在JS种实现不可变对象</p>\n<p>不可变对象可以大大提高对象的比较性能，用于状态和属性判断非常有效</p>\n<p>实际上，提高比较性能的代价是降低修改性能，只不过收益更大</p>\n<h1 id=\"flux简介\"><a class=\"markdownIt-Anchor\" href=\"#flux简介\"></a> Flux简介</h1>\n<p>Flux不是一个具体的框架，而是Facebook提出的一种代码架构</p>\n<p>React只是一个视图库，Fulx是在React基础上对于前端整体的组织方案</p>\n<p>Fulx目的是保证逻辑清晰、数据流向清晰、依赖关系清晰</p>\n"},{"title":"middleware","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:32:09.000Z","password":null,"_content":"\nhttps://zhuanlan.zhihu.com/p/20597452\n\n# 简介\n* middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会\n* redux 的 middleware 是为了增强 dispatch 而出现的\n* redux 提供了 applyMiddleware 这个 api 来加载 middleware\n\n![image](/pub-images/redux-middleware1.png)\n![image](/pub-images/redux-middleware2.png)\n\n# 四步理解 middleware 机制\n![image](/pub-images/middleware机制示例.png)\n\n~~~\nvar middlewareAPI = {\n  getState: store.getState,\n  dispatch: (action) => dispatch(action)\n};\nchain = middlewares.map(middleware => middleware(middlewareAPI));\n~~~\n\n## 函数式编程思想设计 middleware\nmiddleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值\n\n柯里化的 middleware 结构好处在于：\n1. 易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流\n2. 共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的\n\n## 给 middleware 分发 store\n创建一个普通的 store 通过如下方式：\n~~~\n//applyMiddleware 函数陆续获得了三个参数\n//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]\n//第二个 next 是 Redux 原生的 createStore\n//最后一个是 reducer\nlet newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);\n~~~\n\n\n## 组合串联 middlewares\n~~~\ndispatch = compose(...chain)(store.dispatch); \n~~~\ncompose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, ... , fx, ..., fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, ... , fx, ..., fn]，从右到左依次执行（ 所以顺序很重要）\n\n## 在 middleware 中调用 dispatch\n在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware","source":"_posts/react+rn/2018-10-26-middleware.md","raw":"---\ntitle: middleware\ntags:\n  - React \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:32:09\ncategories: React\npassword:\n---\n\nhttps://zhuanlan.zhihu.com/p/20597452\n\n# 简介\n* middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会\n* redux 的 middleware 是为了增强 dispatch 而出现的\n* redux 提供了 applyMiddleware 这个 api 来加载 middleware\n\n![image](/pub-images/redux-middleware1.png)\n![image](/pub-images/redux-middleware2.png)\n\n# 四步理解 middleware 机制\n![image](/pub-images/middleware机制示例.png)\n\n~~~\nvar middlewareAPI = {\n  getState: store.getState,\n  dispatch: (action) => dispatch(action)\n};\nchain = middlewares.map(middleware => middleware(middlewareAPI));\n~~~\n\n## 函数式编程思想设计 middleware\nmiddleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值\n\n柯里化的 middleware 结构好处在于：\n1. 易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流\n2. 共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的\n\n## 给 middleware 分发 store\n创建一个普通的 store 通过如下方式：\n~~~\n//applyMiddleware 函数陆续获得了三个参数\n//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]\n//第二个 next 是 Redux 原生的 createStore\n//最后一个是 reducer\nlet newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);\n~~~\n\n\n## 组合串联 middlewares\n~~~\ndispatch = compose(...chain)(store.dispatch); \n~~~\ncompose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, ... , fx, ..., fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, ... , fx, ..., fn]，从右到左依次执行（ 所以顺序很重要）\n\n## 在 middleware 中调用 dispatch\n在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware","slug":"react-rn-2018-10-26-middleware","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxo001r5b8htsn0dyt6","content":"<p><a href=\"https://zhuanlan.zhihu.com/p/20597452\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/20597452</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会</li>\n<li>redux 的 middleware 是为了增强 dispatch 而出现的</li>\n<li>redux 提供了 applyMiddleware 这个 api 来加载 middleware</li>\n</ul>\n<p><img src=\"/pub-images/redux-middleware1.png\" alt=\"image\"><br>\n<img src=\"/pub-images/redux-middleware2.png\" alt=\"image\"></p>\n<h1 id=\"四步理解-middleware-机制\"><a class=\"markdownIt-Anchor\" href=\"#四步理解-middleware-机制\"></a> 四步理解 middleware 机制</h1>\n<p><img src=\"/pub-images/middleware%E6%9C%BA%E5%88%B6%E7%A4%BA%E4%BE%8B.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: (action) =&gt; dispatch(action)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数式编程思想设计-middleware\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程思想设计-middleware\"></a> 函数式编程思想设计 middleware</h2>\n<p>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值</p>\n<p>柯里化的 middleware 结构好处在于：</p>\n<ol>\n<li>易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流</li>\n<li>共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的</li>\n</ol>\n<h2 id=\"给-middleware-分发-store\"><a class=\"markdownIt-Anchor\" href=\"#给-middleware-分发-store\"></a> 给 middleware 分发 store</h2>\n<p>创建一个普通的 store 通过如下方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//applyMiddleware 函数陆续获得了三个参数</span><br><span class=\"line\">//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]</span><br><span class=\"line\">//第二个 next 是 Redux 原生的 createStore</span><br><span class=\"line\">//最后一个是 reducer</span><br><span class=\"line\">let newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);</span><br></pre></td></tr></table></figure>\n<h2 id=\"组合串联-middlewares\"><a class=\"markdownIt-Anchor\" href=\"#组合串联-middlewares\"></a> 组合串联 middlewares</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch = compose(...chain)(store.dispatch);</span><br></pre></td></tr></table></figure>\n<p>compose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, … , fx, …, fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行（ 所以顺序很重要）</p>\n<h2 id=\"在-middleware-中调用-dispatch\"><a class=\"markdownIt-Anchor\" href=\"#在-middleware-中调用-dispatch\"></a> 在 middleware 中调用 dispatch</h2>\n<p>在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://zhuanlan.zhihu.com/p/20597452\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/20597452</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会</li>\n<li>redux 的 middleware 是为了增强 dispatch 而出现的</li>\n<li>redux 提供了 applyMiddleware 这个 api 来加载 middleware</li>\n</ul>\n<p><img src=\"/pub-images/redux-middleware1.png\" alt=\"image\"><br>\n<img src=\"/pub-images/redux-middleware2.png\" alt=\"image\"></p>\n<h1 id=\"四步理解-middleware-机制\"><a class=\"markdownIt-Anchor\" href=\"#四步理解-middleware-机制\"></a> 四步理解 middleware 机制</h1>\n<p><img src=\"/pub-images/middleware%E6%9C%BA%E5%88%B6%E7%A4%BA%E4%BE%8B.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: (action) =&gt; dispatch(action)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数式编程思想设计-middleware\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程思想设计-middleware\"></a> 函数式编程思想设计 middleware</h2>\n<p>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的柯里化 curry，一种使用匿名单参数函数来实现多参数函数的方法。applyMiddleware 会对 logger 这个 middleware 进行层层调用，动态地对 store 和 next 参数赋值</p>\n<p>柯里化的 middleware 结构好处在于：</p>\n<ol>\n<li>易串联，柯里化函数具有延迟执行的特性，通过不断柯里化形成的 middleware 可以累积参数，配合组合（ compose，函数式编程的概念，Step. 2 中会介绍）的方式，很容易形成 pipeline 来处理数据流</li>\n<li>共享store，在 applyMiddleware 执行过程中，store 还是旧的，但是因为闭包的存在，applyMiddleware 完成后，所有的 middlewares 内部拿到的 store 是最新且相同的</li>\n</ol>\n<h2 id=\"给-middleware-分发-store\"><a class=\"markdownIt-Anchor\" href=\"#给-middleware-分发-store\"></a> 给 middleware 分发 store</h2>\n<p>创建一个普通的 store 通过如下方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//applyMiddleware 函数陆续获得了三个参数</span><br><span class=\"line\">//第一个是 middlewares 数组，[mid1, mid2, mid3, ...]</span><br><span class=\"line\">//第二个 next 是 Redux 原生的 createStore</span><br><span class=\"line\">//最后一个是 reducer</span><br><span class=\"line\">let newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);</span><br></pre></td></tr></table></figure>\n<h2 id=\"组合串联-middlewares\"><a class=\"markdownIt-Anchor\" href=\"#组合串联-middlewares\"></a> 组合串联 middlewares</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch = compose(...chain)(store.dispatch);</span><br></pre></td></tr></table></figure>\n<p>compose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, … , fx, …, fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, … , fx, …, fn]，从右到左依次执行（ 所以顺序很重要）</p>\n<h2 id=\"在-middleware-中调用-dispatch\"><a class=\"markdownIt-Anchor\" href=\"#在-middleware-中调用-dispatch\"></a> 在 middleware 中调用 dispatch</h2>\n<p>在middleware 中调用 store.dispatch() 和在其他任何地方调用效果是一样的，而在 middleware 中调用 next()，效果是进入下一个 middleware</p>\n"},{"title":"react-router-redux","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:24:49.000Z","password":null,"_content":"\n# 概述\n> 用Redux去管理你的应用状态（state），使用React Router去管理路由，但是，这两个库不能协同工作，react-router-redux库可以协调这两个库\n\n> react-router-redux允许你使用React Router库中的api，使用Redux库像平常一样去管理应用的状态state。 本库只是简单的加强了React Router库中history这个实例，以允许将history中接受到的变化反应到stae中去。\n\n# 原理示例\n![image](/pub-images/react-router-redux示例.png)\n现在，你进行的所有页面导航和App导航，加强版的history会首先将新的路径通过Redux store传递，然后再通过React Router去更新组件树","source":"_posts/react+rn/2018-10-26-react-router-redux.md","raw":"---\ntitle: react-router-redux\ntags:\n  - React\n  - React组件\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:24:49\ncategories: React\npassword:\n---\n\n# 概述\n> 用Redux去管理你的应用状态（state），使用React Router去管理路由，但是，这两个库不能协同工作，react-router-redux库可以协调这两个库\n\n> react-router-redux允许你使用React Router库中的api，使用Redux库像平常一样去管理应用的状态state。 本库只是简单的加强了React Router库中history这个实例，以允许将history中接受到的变化反应到stae中去。\n\n# 原理示例\n![image](/pub-images/react-router-redux示例.png)\n现在，你进行的所有页面导航和App导航，加强版的history会首先将新的路径通过Redux store传递，然后再通过React Router去更新组件树","slug":"react-rn-2018-10-26-react-router-redux","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxq001u5b8h3pknh1k8","content":"<h1 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h1>\n<blockquote>\n<p>用Redux去管理你的应用状态（state），使用React Router去管理路由，但是，这两个库不能协同工作，react-router-redux库可以协调这两个库</p>\n</blockquote>\n<blockquote>\n<p>react-router-redux允许你使用React Router库中的api，使用Redux库像平常一样去管理应用的状态state。 本库只是简单的加强了React Router库中history这个实例，以允许将history中接受到的变化反应到stae中去。</p>\n</blockquote>\n<h1 id=\"原理示例\"><a class=\"markdownIt-Anchor\" href=\"#原理示例\"></a> 原理示例</h1>\n<p><img src=\"/pub-images/react-router-redux%E7%A4%BA%E4%BE%8B.png\" alt=\"image\"><br>\n现在，你进行的所有页面导航和App导航，加强版的history会首先将新的路径通过Redux store传递，然后再通过React Router去更新组件树</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h1>\n<blockquote>\n<p>用Redux去管理你的应用状态（state），使用React Router去管理路由，但是，这两个库不能协同工作，react-router-redux库可以协调这两个库</p>\n</blockquote>\n<blockquote>\n<p>react-router-redux允许你使用React Router库中的api，使用Redux库像平常一样去管理应用的状态state。 本库只是简单的加强了React Router库中history这个实例，以允许将history中接受到的变化反应到stae中去。</p>\n</blockquote>\n<h1 id=\"原理示例\"><a class=\"markdownIt-Anchor\" href=\"#原理示例\"></a> 原理示例</h1>\n<p><img src=\"/pub-images/react-router-redux%E7%A4%BA%E4%BE%8B.png\" alt=\"image\"><br>\n现在，你进行的所有页面导航和App导航，加强版的history会首先将新的路径通过Redux store传递，然后再通过React Router去更新组件树</p>\n"},{"title":"redux-thunk","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:30:47.000Z","password":null,"_content":"# 简介\n* redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过  fetch 通用远程 API 这些场景，那么久应该使用 redux-thunk 了\n* redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响\n* redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装\n~~~\nfunction add() {\n    return {\n        type: 'ADD',\n    }\n}\n\nfunction addIfOdd() {\n    return (dispatch, getState) => {\n        const currentValue = getState();\n        if (currentValue % 2 == 0) {\n            return false;\n        }\n        //分发一个任务\n        dispatch(add())\n    }\n}\n~~~\n\n# 使用方式\n1. 安装:npm install redux-thunk --save-dev\n2. 导入thunk： import thunk from 'redux-thunk'\n3. 导入中间件: import {createStore,applyMiddleware} from 'redux'\n4. 创建store：let store = createStore(reducer函数，applyMiddleware(thunk))\n5. 激活redux-thunk中间件，只需要在createStore中加入applyMiddleware(thunk)就可以","source":"_posts/react+rn/2018-10-26-redux-thunk.md","raw":"---\ntitle: redux-thunk\ntags:\n  - React\n  - redux组件库\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:30:47\ncategories: React\npassword:\n---\n# 简介\n* redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过  fetch 通用远程 API 这些场景，那么久应该使用 redux-thunk 了\n* redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响\n* redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装\n~~~\nfunction add() {\n    return {\n        type: 'ADD',\n    }\n}\n\nfunction addIfOdd() {\n    return (dispatch, getState) => {\n        const currentValue = getState();\n        if (currentValue % 2 == 0) {\n            return false;\n        }\n        //分发一个任务\n        dispatch(add())\n    }\n}\n~~~\n\n# 使用方式\n1. 安装:npm install redux-thunk --save-dev\n2. 导入thunk： import thunk from 'redux-thunk'\n3. 导入中间件: import {createStore,applyMiddleware} from 'redux'\n4. 创建store：let store = createStore(reducer函数，applyMiddleware(thunk))\n5. 激活redux-thunk中间件，只需要在createStore中加入applyMiddleware(thunk)就可以","slug":"react-rn-2018-10-26-redux-thunk","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxs001z5b8hecb25auc","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过  fetch 通用远程 API 这些场景，那么久应该使用 redux-thunk 了</li>\n<li>redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响</li>\n<li>redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        type: &apos;ADD&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addIfOdd() &#123;</span><br><span class=\"line\">    return (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">        const currentValue = getState();</span><br><span class=\"line\">        if (currentValue % 2 == 0) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //分发一个任务</span><br><span class=\"line\">        dispatch(add())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用方式\"><a class=\"markdownIt-Anchor\" href=\"#使用方式\"></a> 使用方式</h1>\n<ol>\n<li>安装:npm install redux-thunk --save-dev</li>\n<li>导入thunk： import thunk from ‘redux-thunk’</li>\n<li>导入中间件: import {createStore,applyMiddleware} from ‘redux’</li>\n<li>创建store：let store = createStore(reducer函数，applyMiddleware(thunk))</li>\n<li>激活redux-thunk中间件，只需要在createStore中加入applyMiddleware(thunk)就可以</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过  fetch 通用远程 API 这些场景，那么久应该使用 redux-thunk 了</li>\n<li>redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响</li>\n<li>redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        type: &apos;ADD&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addIfOdd() &#123;</span><br><span class=\"line\">    return (dispatch, getState) =&gt; &#123;</span><br><span class=\"line\">        const currentValue = getState();</span><br><span class=\"line\">        if (currentValue % 2 == 0) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //分发一个任务</span><br><span class=\"line\">        dispatch(add())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用方式\"><a class=\"markdownIt-Anchor\" href=\"#使用方式\"></a> 使用方式</h1>\n<ol>\n<li>安装:npm install redux-thunk --save-dev</li>\n<li>导入thunk： import thunk from ‘redux-thunk’</li>\n<li>导入中间件: import {createStore,applyMiddleware} from ‘redux’</li>\n<li>创建store：let store = createStore(reducer函数，applyMiddleware(thunk))</li>\n<li>激活redux-thunk中间件，只需要在createStore中加入applyMiddleware(thunk)就可以</li>\n</ol>\n"},{"title":"CentOS下yum源的搭建与使用","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n[toc]\n\n# yum简介\n* yum就是为了解决依赖关系而存在的\n* yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好\n* YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题\n* yum两种源：本地yum源和网络yum源\n\n# yum工作机制\n1. 服务器端\n* 在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内\n2. 客户端\n* 如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装\n\n# yum文件\n> 在/etc/yum.repos.d 目录下存放的就是yum源的设定文件\n\n> yum repolist all   //此命令可查看启用的源配置文件\n\n*.repo各配置项说明\n~~~\n* [base]：代表容器的名字，里面的名称则可以随意取，但是不能有两个相同的容器名称， 否则 yum 会不晓得该到哪里去找容器相关软体清单档案\n* name：只是说明一下这个容器的意义而已，重要性不高\n* mirrorlist=：列出这个容器可以使用的映射站台，如果不想使用，可以注解到这行\n* baseurl=：这个最重要，因为后面接的就是容器的实际网址！ mirrorlist 是由 yum 程式自行去捉映射站台， baseurl 则是指定固定的一个容器网址\n* enable=1：就是让这个容器被启动  \n* gpgcheck=1：指定是否需要查阅RPM档案内的数位签章！0表示不检测\n* gpgkey=：就是数位签章的公钥档所在位置！使用预设值即可\n~~~\n\n# 更改yum源与更新系统\n* 备份/etc/yum.repos.d/CentOS-Base.repo:\n~~~\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n~~~\n* 进入yum源配置文件所在文件夹\n~~~\ncd /etc/yum.repos.d/\n~~~\n* 下载163或其他的yum源配置文件，放入/etc/yum.repos.d/(操作前请做好相应备份)\n~~~\nwget http://mirrors.163.com/.help/CentOS6-Base-163.repo\n~~~\n* 运行yum makecache生成缓存:yum makecache\n* 更新系统:yum -y update\n# yum基本使用\n参数说明:\n~~~\n-y : 如果在工作过程中如要使用者响应,这个参数可以直接回答yes\nlist : 列出在yum server 上面有的RPM套件\ninstall: 安装某个套件\nupdate : 升级某个套件,如果update后面没有接套件名称,即更新目前主机所有已安装的套件.\ninfo   : 列出某个套件的详细信息,相当于rpm -qi package内容\nclean : 将已下载到本机的packages或headers移除\nremove : 移除已经安装在系统中的某个套件\nyum localinstall package 本地安装软件包\nyum update 全部更新\nyum update package 更新指定程序包package\nyum check-update 检查可更新的程序\nyum info 显示安装包信息\nyum list 显示所有已经安装和可以安装的程序包 \nyum search 查找软件包\nyum remove | erase package1 删除程序包\nyum clean headers 清除header\nyum clean packages 清除下载的rpm包\nyum clean all 清除header与rpm包\n~~~\n\n# yum源服务器的搭建\nyum源的搭建可分为三步：①搭建Apache服务器②挂载ISO镜像，将镜像中的包放至Apache服务器目录下③ISO镜像的包比较老旧，可以定时同步其他源中的包到本地\n\n# 客户端访问yum源服务器","source":"_posts/Linux/CentOS下yum源的搭建与使用.md","raw":"---\ntitle: CentOS下yum源的搭建与使用\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n[toc]\n\n# yum简介\n* yum就是为了解决依赖关系而存在的\n* yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好\n* YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题\n* yum两种源：本地yum源和网络yum源\n\n# yum工作机制\n1. 服务器端\n* 在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内\n2. 客户端\n* 如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装\n\n# yum文件\n> 在/etc/yum.repos.d 目录下存放的就是yum源的设定文件\n\n> yum repolist all   //此命令可查看启用的源配置文件\n\n*.repo各配置项说明\n~~~\n* [base]：代表容器的名字，里面的名称则可以随意取，但是不能有两个相同的容器名称， 否则 yum 会不晓得该到哪里去找容器相关软体清单档案\n* name：只是说明一下这个容器的意义而已，重要性不高\n* mirrorlist=：列出这个容器可以使用的映射站台，如果不想使用，可以注解到这行\n* baseurl=：这个最重要，因为后面接的就是容器的实际网址！ mirrorlist 是由 yum 程式自行去捉映射站台， baseurl 则是指定固定的一个容器网址\n* enable=1：就是让这个容器被启动  \n* gpgcheck=1：指定是否需要查阅RPM档案内的数位签章！0表示不检测\n* gpgkey=：就是数位签章的公钥档所在位置！使用预设值即可\n~~~\n\n# 更改yum源与更新系统\n* 备份/etc/yum.repos.d/CentOS-Base.repo:\n~~~\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n~~~\n* 进入yum源配置文件所在文件夹\n~~~\ncd /etc/yum.repos.d/\n~~~\n* 下载163或其他的yum源配置文件，放入/etc/yum.repos.d/(操作前请做好相应备份)\n~~~\nwget http://mirrors.163.com/.help/CentOS6-Base-163.repo\n~~~\n* 运行yum makecache生成缓存:yum makecache\n* 更新系统:yum -y update\n# yum基本使用\n参数说明:\n~~~\n-y : 如果在工作过程中如要使用者响应,这个参数可以直接回答yes\nlist : 列出在yum server 上面有的RPM套件\ninstall: 安装某个套件\nupdate : 升级某个套件,如果update后面没有接套件名称,即更新目前主机所有已安装的套件.\ninfo   : 列出某个套件的详细信息,相当于rpm -qi package内容\nclean : 将已下载到本机的packages或headers移除\nremove : 移除已经安装在系统中的某个套件\nyum localinstall package 本地安装软件包\nyum update 全部更新\nyum update package 更新指定程序包package\nyum check-update 检查可更新的程序\nyum info 显示安装包信息\nyum list 显示所有已经安装和可以安装的程序包 \nyum search 查找软件包\nyum remove | erase package1 删除程序包\nyum clean headers 清除header\nyum clean packages 清除下载的rpm包\nyum clean all 清除header与rpm包\n~~~\n\n# yum源服务器的搭建\nyum源的搭建可分为三步：①搭建Apache服务器②挂载ISO镜像，将镜像中的包放至Apache服务器目录下③ISO镜像的包比较老旧，可以定时同步其他源中的包到本地\n\n# 客户端访问yum源服务器","slug":"Linux-CentOS下yum源的搭建与使用","published":1,"updated":"2019-02-14T05:36:00.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxt00215b8h75ixkp33","content":"<p>[toc]</p>\n<h1 id=\"yum简介\"><a class=\"markdownIt-Anchor\" href=\"#yum简介\"></a> yum简介</h1>\n<ul>\n<li>yum就是为了解决依赖关系而存在的</li>\n<li>yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好</li>\n<li>YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题</li>\n<li>yum两种源：本地yum源和网络yum源</li>\n</ul>\n<h1 id=\"yum工作机制\"><a class=\"markdownIt-Anchor\" href=\"#yum工作机制\"></a> yum工作机制</h1>\n<ol>\n<li>服务器端</li>\n</ol>\n<ul>\n<li>在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内</li>\n</ul>\n<ol start=\"2\">\n<li>客户端</li>\n</ol>\n<ul>\n<li>如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装</li>\n</ul>\n<h1 id=\"yum文件\"><a class=\"markdownIt-Anchor\" href=\"#yum文件\"></a> yum文件</h1>\n<blockquote>\n<p>在/etc/yum.repos.d 目录下存放的就是yum源的设定文件</p>\n</blockquote>\n<blockquote>\n<p>yum repolist all   //此命令可查看启用的源配置文件</p>\n</blockquote>\n<p>*.repo各配置项说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* [base]：代表容器的名字，里面的名称则可以随意取，但是不能有两个相同的容器名称， 否则 yum 会不晓得该到哪里去找容器相关软体清单档案</span><br><span class=\"line\">* name：只是说明一下这个容器的意义而已，重要性不高</span><br><span class=\"line\">* mirrorlist=：列出这个容器可以使用的映射站台，如果不想使用，可以注解到这行</span><br><span class=\"line\">* baseurl=：这个最重要，因为后面接的就是容器的实际网址！ mirrorlist 是由 yum 程式自行去捉映射站台， baseurl 则是指定固定的一个容器网址</span><br><span class=\"line\">* enable=1：就是让这个容器被启动  </span><br><span class=\"line\">* gpgcheck=1：指定是否需要查阅RPM档案内的数位签章！0表示不检测</span><br><span class=\"line\">* gpgkey=：就是数位签章的公钥档所在位置！使用预设值即可</span><br></pre></td></tr></table></figure>\n<h1 id=\"更改yum源与更新系统\"><a class=\"markdownIt-Anchor\" href=\"#更改yum源与更新系统\"></a> 更改yum源与更新系统</h1>\n<ul>\n<li>备份/etc/yum.repos.d/CentOS-Base.repo:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进入yum源配置文件所在文件夹</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下载163或其他的yum源配置文件，放入/etc/yum.repos.d/(操作前请做好相应备份)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行yum makecache生成缓存:yum makecache</li>\n<li>更新系统:yum -y update</li>\n</ul>\n<h1 id=\"yum基本使用\"><a class=\"markdownIt-Anchor\" href=\"#yum基本使用\"></a> yum基本使用</h1>\n<p>参数说明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-y : 如果在工作过程中如要使用者响应,这个参数可以直接回答yes</span><br><span class=\"line\">list : 列出在yum server 上面有的RPM套件</span><br><span class=\"line\">install: 安装某个套件</span><br><span class=\"line\">update : 升级某个套件,如果update后面没有接套件名称,即更新目前主机所有已安装的套件.</span><br><span class=\"line\">info   : 列出某个套件的详细信息,相当于rpm -qi package内容</span><br><span class=\"line\">clean : 将已下载到本机的packages或headers移除</span><br><span class=\"line\">remove : 移除已经安装在系统中的某个套件</span><br><span class=\"line\">yum localinstall package 本地安装软件包</span><br><span class=\"line\">yum update 全部更新</span><br><span class=\"line\">yum update package 更新指定程序包package</span><br><span class=\"line\">yum check-update 检查可更新的程序</span><br><span class=\"line\">yum info 显示安装包信息</span><br><span class=\"line\">yum list 显示所有已经安装和可以安装的程序包 </span><br><span class=\"line\">yum search 查找软件包</span><br><span class=\"line\">yum remove | erase package1 删除程序包</span><br><span class=\"line\">yum clean headers 清除header</span><br><span class=\"line\">yum clean packages 清除下载的rpm包</span><br><span class=\"line\">yum clean all 清除header与rpm包</span><br></pre></td></tr></table></figure>\n<h1 id=\"yum源服务器的搭建\"><a class=\"markdownIt-Anchor\" href=\"#yum源服务器的搭建\"></a> yum源服务器的搭建</h1>\n<p>yum源的搭建可分为三步：①搭建Apache服务器②挂载ISO镜像，将镜像中的包放至Apache服务器目录下③ISO镜像的包比较老旧，可以定时同步其他源中的包到本地</p>\n<h1 id=\"客户端访问yum源服务器\"><a class=\"markdownIt-Anchor\" href=\"#客户端访问yum源服务器\"></a> 客户端访问yum源服务器</h1>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"yum简介\"><a class=\"markdownIt-Anchor\" href=\"#yum简介\"></a> yum简介</h1>\n<ul>\n<li>yum就是为了解决依赖关系而存在的</li>\n<li>yum源就相当是一个目录项，当我们使用yum机制安装软件时，若需要安装依赖软件，则yum机制就会根据在yum源中定义好的路径查找依赖软件，并将依赖软件安装好</li>\n<li>YUM是“Yellow dog Updater, Modified”的缩写，是一个软件包管理器，YUM从指定的地方（相关网站的rpm包地址或本地的rpm路径）自动下载RPM包并且安装，能够很好的解决依赖关系问题</li>\n<li>yum两种源：本地yum源和网络yum源</li>\n</ul>\n<h1 id=\"yum工作机制\"><a class=\"markdownIt-Anchor\" href=\"#yum工作机制\"></a> yum工作机制</h1>\n<ol>\n<li>服务器端</li>\n</ol>\n<ul>\n<li>在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内</li>\n</ul>\n<ol start=\"2\">\n<li>客户端</li>\n</ol>\n<ul>\n<li>如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装</li>\n</ul>\n<h1 id=\"yum文件\"><a class=\"markdownIt-Anchor\" href=\"#yum文件\"></a> yum文件</h1>\n<blockquote>\n<p>在/etc/yum.repos.d 目录下存放的就是yum源的设定文件</p>\n</blockquote>\n<blockquote>\n<p>yum repolist all   //此命令可查看启用的源配置文件</p>\n</blockquote>\n<p>*.repo各配置项说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* [base]：代表容器的名字，里面的名称则可以随意取，但是不能有两个相同的容器名称， 否则 yum 会不晓得该到哪里去找容器相关软体清单档案</span><br><span class=\"line\">* name：只是说明一下这个容器的意义而已，重要性不高</span><br><span class=\"line\">* mirrorlist=：列出这个容器可以使用的映射站台，如果不想使用，可以注解到这行</span><br><span class=\"line\">* baseurl=：这个最重要，因为后面接的就是容器的实际网址！ mirrorlist 是由 yum 程式自行去捉映射站台， baseurl 则是指定固定的一个容器网址</span><br><span class=\"line\">* enable=1：就是让这个容器被启动  </span><br><span class=\"line\">* gpgcheck=1：指定是否需要查阅RPM档案内的数位签章！0表示不检测</span><br><span class=\"line\">* gpgkey=：就是数位签章的公钥档所在位置！使用预设值即可</span><br></pre></td></tr></table></figure>\n<h1 id=\"更改yum源与更新系统\"><a class=\"markdownIt-Anchor\" href=\"#更改yum源与更新系统\"></a> 更改yum源与更新系统</h1>\n<ul>\n<li>备份/etc/yum.repos.d/CentOS-Base.repo:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进入yum源配置文件所在文件夹</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>下载163或其他的yum源配置文件，放入/etc/yum.repos.d/(操作前请做好相应备份)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行yum makecache生成缓存:yum makecache</li>\n<li>更新系统:yum -y update</li>\n</ul>\n<h1 id=\"yum基本使用\"><a class=\"markdownIt-Anchor\" href=\"#yum基本使用\"></a> yum基本使用</h1>\n<p>参数说明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-y : 如果在工作过程中如要使用者响应,这个参数可以直接回答yes</span><br><span class=\"line\">list : 列出在yum server 上面有的RPM套件</span><br><span class=\"line\">install: 安装某个套件</span><br><span class=\"line\">update : 升级某个套件,如果update后面没有接套件名称,即更新目前主机所有已安装的套件.</span><br><span class=\"line\">info   : 列出某个套件的详细信息,相当于rpm -qi package内容</span><br><span class=\"line\">clean : 将已下载到本机的packages或headers移除</span><br><span class=\"line\">remove : 移除已经安装在系统中的某个套件</span><br><span class=\"line\">yum localinstall package 本地安装软件包</span><br><span class=\"line\">yum update 全部更新</span><br><span class=\"line\">yum update package 更新指定程序包package</span><br><span class=\"line\">yum check-update 检查可更新的程序</span><br><span class=\"line\">yum info 显示安装包信息</span><br><span class=\"line\">yum list 显示所有已经安装和可以安装的程序包 </span><br><span class=\"line\">yum search 查找软件包</span><br><span class=\"line\">yum remove | erase package1 删除程序包</span><br><span class=\"line\">yum clean headers 清除header</span><br><span class=\"line\">yum clean packages 清除下载的rpm包</span><br><span class=\"line\">yum clean all 清除header与rpm包</span><br></pre></td></tr></table></figure>\n<h1 id=\"yum源服务器的搭建\"><a class=\"markdownIt-Anchor\" href=\"#yum源服务器的搭建\"></a> yum源服务器的搭建</h1>\n<p>yum源的搭建可分为三步：①搭建Apache服务器②挂载ISO镜像，将镜像中的包放至Apache服务器目录下③ISO镜像的包比较老旧，可以定时同步其他源中的包到本地</p>\n<h1 id=\"客户端访问yum源服务器\"><a class=\"markdownIt-Anchor\" href=\"#客户端访问yum源服务器\"></a> 客户端访问yum源服务器</h1>\n"},{"title":"CentOS 图形界面 命令行界面切换 - CentOS","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n> 一、修改/etc/inittab文件中的  id:3:initdefault ， 将3改为5则为图形界面 ，反之则为命令行界面，修改完后重新启动系统生效\n\n> 二、如果用户已经启动了字符CentOS界面，想要进入图形CentOS界面可以使用如下命令 startx \n\n> 三、运行级别说明，用 init -x 切换级别，如想进入图形界面则输入 init -5 即可切换；  \n~~~\n* 0 所有进程将被终止，机器将有序的停止，关机时系统处于这个运行级别 \n* 1 单用户模式。用于系统维护，只有少数进程运行，同时所有服务也不启动 \n* 2 多用户模式。和运行级别3一样，只是网络文件系统（NFS）服务没被启动 \n* 3 多用户模式。允许多用户登录系统，是系统默认的启动级别 \n* 4 留给用户自定义的运行级别 \n* 5 多用户模式，并且在系统启动后运行X-Window，给出一个图形化的登录窗口 \n* 6 所有进程被终止，系统重新启动 \n~~~\n\n# 图形界面问题处理\nCentos7解决图形界面卡死问题\n~~~\nkillall -9 gnome-shell\n~~~","source":"_posts/Linux/CentOS 图形界面 命令行界面切换.md","raw":"---\ntitle: CentOS 图形界面 命令行界面切换\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n> 一、修改/etc/inittab文件中的  id:3:initdefault ， 将3改为5则为图形界面 ，反之则为命令行界面，修改完后重新启动系统生效\n\n> 二、如果用户已经启动了字符CentOS界面，想要进入图形CentOS界面可以使用如下命令 startx \n\n> 三、运行级别说明，用 init -x 切换级别，如想进入图形界面则输入 init -5 即可切换；  \n~~~\n* 0 所有进程将被终止，机器将有序的停止，关机时系统处于这个运行级别 \n* 1 单用户模式。用于系统维护，只有少数进程运行，同时所有服务也不启动 \n* 2 多用户模式。和运行级别3一样，只是网络文件系统（NFS）服务没被启动 \n* 3 多用户模式。允许多用户登录系统，是系统默认的启动级别 \n* 4 留给用户自定义的运行级别 \n* 5 多用户模式，并且在系统启动后运行X-Window，给出一个图形化的登录窗口 \n* 6 所有进程被终止，系统重新启动 \n~~~\n\n# 图形界面问题处理\nCentos7解决图形界面卡死问题\n~~~\nkillall -9 gnome-shell\n~~~","slug":"Linux-CentOS-图形界面-命令行界面切换","published":1,"updated":"2019-02-14T05:35:30.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxu00245b8hx0bzhzor","content":"<blockquote>\n<p>一、修改/etc/inittab文件中的  id:3:initdefault ， 将3改为5则为图形界面 ，反之则为命令行界面，修改完后重新启动系统生效</p>\n</blockquote>\n<blockquote>\n<p>二、如果用户已经启动了字符CentOS界面，想要进入图形CentOS界面可以使用如下命令 startx</p>\n</blockquote>\n<blockquote>\n<p>三、运行级别说明，用 init -x 切换级别，如想进入图形界面则输入 init -5 即可切换；</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 0 所有进程将被终止，机器将有序的停止，关机时系统处于这个运行级别 </span><br><span class=\"line\">* 1 单用户模式。用于系统维护，只有少数进程运行，同时所有服务也不启动 </span><br><span class=\"line\">* 2 多用户模式。和运行级别3一样，只是网络文件系统（NFS）服务没被启动 </span><br><span class=\"line\">* 3 多用户模式。允许多用户登录系统，是系统默认的启动级别 </span><br><span class=\"line\">* 4 留给用户自定义的运行级别 </span><br><span class=\"line\">* 5 多用户模式，并且在系统启动后运行X-Window，给出一个图形化的登录窗口 </span><br><span class=\"line\">* 6 所有进程被终止，系统重新启动</span><br></pre></td></tr></table></figure>\n<h1 id=\"图形界面问题处理\"><a class=\"markdownIt-Anchor\" href=\"#图形界面问题处理\"></a> 图形界面问题处理</h1>\n<p>Centos7解决图形界面卡死问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">killall -9 gnome-shell</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一、修改/etc/inittab文件中的  id:3:initdefault ， 将3改为5则为图形界面 ，反之则为命令行界面，修改完后重新启动系统生效</p>\n</blockquote>\n<blockquote>\n<p>二、如果用户已经启动了字符CentOS界面，想要进入图形CentOS界面可以使用如下命令 startx</p>\n</blockquote>\n<blockquote>\n<p>三、运行级别说明，用 init -x 切换级别，如想进入图形界面则输入 init -5 即可切换；</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 0 所有进程将被终止，机器将有序的停止，关机时系统处于这个运行级别 </span><br><span class=\"line\">* 1 单用户模式。用于系统维护，只有少数进程运行，同时所有服务也不启动 </span><br><span class=\"line\">* 2 多用户模式。和运行级别3一样，只是网络文件系统（NFS）服务没被启动 </span><br><span class=\"line\">* 3 多用户模式。允许多用户登录系统，是系统默认的启动级别 </span><br><span class=\"line\">* 4 留给用户自定义的运行级别 </span><br><span class=\"line\">* 5 多用户模式，并且在系统启动后运行X-Window，给出一个图形化的登录窗口 </span><br><span class=\"line\">* 6 所有进程被终止，系统重新启动</span><br></pre></td></tr></table></figure>\n<h1 id=\"图形界面问题处理\"><a class=\"markdownIt-Anchor\" href=\"#图形界面问题处理\"></a> 图形界面问题处理</h1>\n<p>Centos7解决图形界面卡死问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">killall -9 gnome-shell</span><br></pre></td></tr></table></figure>"},{"title":"CentOS查看硬件信息","copyright":true,"comments":1,"toc":true,"date":"2018-11-26T13:25:33.000Z","password":null,"_content":"\n* 操作系统信息：lsb_release -a ；uname -a\n* 查看网卡型号：lspci | grep  Ethernet controller \n* 查看硬盘信息：df -ah\n* 查看内存信息：cat /proc/meminfo \n* 查看CPU信息：more /proc/cpuinfo | grep \"model name\"","source":"_posts/Linux/CentOS查看硬件信息.md","raw":"---\ntitle: CentOS查看硬件信息\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-11-26 21:25:33\ncategories: Linux\npassword:\n---\n\n* 操作系统信息：lsb_release -a ；uname -a\n* 查看网卡型号：lspci | grep  Ethernet controller \n* 查看硬盘信息：df -ah\n* 查看内存信息：cat /proc/meminfo \n* 查看CPU信息：more /proc/cpuinfo | grep \"model name\"","slug":"Linux-CentOS查看硬件信息","published":1,"updated":"2019-02-14T08:16:59.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxw00275b8hi974k8l3","content":"<ul>\n<li>操作系统信息：lsb_release -a ；uname -a</li>\n<li>查看网卡型号：lspci | grep  Ethernet controller</li>\n<li>查看硬盘信息：df -ah</li>\n<li>查看内存信息：cat /proc/meminfo</li>\n<li>查看CPU信息：more /proc/cpuinfo | grep “model name”</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>操作系统信息：lsb_release -a ；uname -a</li>\n<li>查看网卡型号：lspci | grep  Ethernet controller</li>\n<li>查看硬盘信息：df -ah</li>\n<li>查看内存信息：cat /proc/meminfo</li>\n<li>查看CPU信息：more /proc/cpuinfo | grep “model name”</li>\n</ul>\n"},{"title":"CentOS版本说明","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n* CentOS-7.0-1406-x86_64-DVD.iso             标准安装版，一般下载这个就可以了\n* CentOS-7.0-1406-x86_64-NetInstall.iso       网络安装镜像\n* CentOS-7.0-1406-x86_64-Everything.iso     对完整版安装盘的软件进行补充，集成所有软件。\n* CentOS-7.0-1406-x86_64-GnomeLive.iso   GNOME桌面版\n* CentOS-7.0-1406-x86_64-KdeLive.iso         KDE桌面版\n* CentOS-7.0-1406-x86_64-livecd.iso            光盘上运行的系统，类拟于winpe \n\n1. CentOS-xxxx-LiveCD.ios 和CentOS-xxxx-bin-DVD.iso有什么区别？前者只有700M，后者有3.8G。其差别不仅仅在大小上，其更本质的差别是，CentOS-xxxx-LiveCD.ios只能加载到内存里运行，不能安装。CentOS-xxx-bin-DVD1.iso才可以安装到硬盘上。\n2. CentOS-xxx-bin-DVD1.iso，CentOS-xxx-bin-DVD2.iso分别是干什么的？前者是3.8G，后者是500M。其差别是DVD1是CentOS的安装文件，DVD2是CentOS的一些软件（就简单实用CentOS来说是不需要的）。","source":"_posts/Linux/CentOS版本说明.md","raw":"---\ntitle: CentOS版本说明\ntags:\n  - CentOS \ncopyright: true\ncomments: true\ntoc: true\ncategories: Linux\npassword:\n---\n\n* CentOS-7.0-1406-x86_64-DVD.iso             标准安装版，一般下载这个就可以了\n* CentOS-7.0-1406-x86_64-NetInstall.iso       网络安装镜像\n* CentOS-7.0-1406-x86_64-Everything.iso     对完整版安装盘的软件进行补充，集成所有软件。\n* CentOS-7.0-1406-x86_64-GnomeLive.iso   GNOME桌面版\n* CentOS-7.0-1406-x86_64-KdeLive.iso         KDE桌面版\n* CentOS-7.0-1406-x86_64-livecd.iso            光盘上运行的系统，类拟于winpe \n\n1. CentOS-xxxx-LiveCD.ios 和CentOS-xxxx-bin-DVD.iso有什么区别？前者只有700M，后者有3.8G。其差别不仅仅在大小上，其更本质的差别是，CentOS-xxxx-LiveCD.ios只能加载到内存里运行，不能安装。CentOS-xxx-bin-DVD1.iso才可以安装到硬盘上。\n2. CentOS-xxx-bin-DVD1.iso，CentOS-xxx-bin-DVD2.iso分别是干什么的？前者是3.8G，后者是500M。其差别是DVD1是CentOS的安装文件，DVD2是CentOS的一些软件（就简单实用CentOS来说是不需要的）。","slug":"Linux-CentOS版本说明","published":1,"date":"2019-02-14T08:19:51.000Z","updated":"2019-02-14T08:19:51.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxx002b5b8h00sks71y","content":"<ul>\n<li>CentOS-7.0-1406-x86_64-DVD.iso             标准安装版，一般下载这个就可以了</li>\n<li>CentOS-7.0-1406-x86_64-NetInstall.iso       网络安装镜像</li>\n<li>CentOS-7.0-1406-x86_64-Everything.iso     对完整版安装盘的软件进行补充，集成所有软件。</li>\n<li>CentOS-7.0-1406-x86_64-GnomeLive.iso   GNOME桌面版</li>\n<li>CentOS-7.0-1406-x86_64-KdeLive.iso         KDE桌面版</li>\n<li>CentOS-7.0-1406-x86_64-livecd.iso            光盘上运行的系统，类拟于winpe</li>\n</ul>\n<ol>\n<li>CentOS-xxxx-LiveCD.ios 和CentOS-xxxx-bin-DVD.iso有什么区别？前者只有700M，后者有3.8G。其差别不仅仅在大小上，其更本质的差别是，CentOS-xxxx-LiveCD.ios只能加载到内存里运行，不能安装。CentOS-xxx-bin-DVD1.iso才可以安装到硬盘上。</li>\n<li>CentOS-xxx-bin-DVD1.iso，CentOS-xxx-bin-DVD2.iso分别是干什么的？前者是3.8G，后者是500M。其差别是DVD1是CentOS的安装文件，DVD2是CentOS的一些软件（就简单实用CentOS来说是不需要的）。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>CentOS-7.0-1406-x86_64-DVD.iso             标准安装版，一般下载这个就可以了</li>\n<li>CentOS-7.0-1406-x86_64-NetInstall.iso       网络安装镜像</li>\n<li>CentOS-7.0-1406-x86_64-Everything.iso     对完整版安装盘的软件进行补充，集成所有软件。</li>\n<li>CentOS-7.0-1406-x86_64-GnomeLive.iso   GNOME桌面版</li>\n<li>CentOS-7.0-1406-x86_64-KdeLive.iso         KDE桌面版</li>\n<li>CentOS-7.0-1406-x86_64-livecd.iso            光盘上运行的系统，类拟于winpe</li>\n</ul>\n<ol>\n<li>CentOS-xxxx-LiveCD.ios 和CentOS-xxxx-bin-DVD.iso有什么区别？前者只有700M，后者有3.8G。其差别不仅仅在大小上，其更本质的差别是，CentOS-xxxx-LiveCD.ios只能加载到内存里运行，不能安装。CentOS-xxx-bin-DVD1.iso才可以安装到硬盘上。</li>\n<li>CentOS-xxx-bin-DVD1.iso，CentOS-xxx-bin-DVD2.iso分别是干什么的？前者是3.8G，后者是500M。其差别是DVD1是CentOS的安装文件，DVD2是CentOS的一些软件（就简单实用CentOS来说是不需要的）。</li>\n</ol>\n"},{"title":"RHEL 7 中 systemctl 的用法（替代service 和 chkconfig）","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n\n> systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。\n\n> Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。\n\n> Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统\n\n> 启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；禁用服务就是删除此软链接，添加服务就是添加软连接\n\n> Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。\n\n* 启动一个服务：systemctl start postfix.service\n* 关闭一个服务：systemctl stop postfix.service\n* 重启一个服务：systemctl restart postfix.service\n* 显示一个服务的状态：systemctl status postfix.service\n* 在开机时启用一个服务：systemctl enable postfix.service\n* 在开机时禁用一个服务：systemctl disable postfix.service\n* 查看服务是否开机启动：systemctl is-enabled postfix.service\n* 查看已启动的服务列表：systemctl list-unit-files|grep enabled\n* 查看启动失败的服务列表：systemctl --failed\n>使用命令 systemctl is-enabled postfix.service 得到的值可以是enable、disable或static，这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。 \n\n\n更多：https://linux.cn/article-5926-1.html\n","source":"_posts/Linux/RHEL 7 中 systemctl 的用法（替代service 和 chkconfig）.md","raw":"---\ntitle: RHEL 7 中 systemctl 的用法（替代service 和 chkconfig）\ntags:\n  - CentOS \ncopyright: true\ncomments: true\ntoc: true\ncategories: Linux\npassword:\n---\n\n\n> systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。\n\n> Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。\n\n> Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统\n\n> 启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；禁用服务就是删除此软链接，添加服务就是添加软连接\n\n> Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。\n\n* 启动一个服务：systemctl start postfix.service\n* 关闭一个服务：systemctl stop postfix.service\n* 重启一个服务：systemctl restart postfix.service\n* 显示一个服务的状态：systemctl status postfix.service\n* 在开机时启用一个服务：systemctl enable postfix.service\n* 在开机时禁用一个服务：systemctl disable postfix.service\n* 查看服务是否开机启动：systemctl is-enabled postfix.service\n* 查看已启动的服务列表：systemctl list-unit-files|grep enabled\n* 查看启动失败的服务列表：systemctl --failed\n>使用命令 systemctl is-enabled postfix.service 得到的值可以是enable、disable或static，这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。 \n\n\n更多：https://linux.cn/article-5926-1.html\n","slug":"Linux-RHEL-7-中-systemctl-的用法（替代service-和-chkconfig）","published":1,"date":"2019-02-14T08:20:58.000Z","updated":"2019-02-14T08:20:58.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudxz002d5b8hzg9wxuik","content":"<blockquote>\n<p>systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。</p>\n</blockquote>\n<blockquote>\n<p>Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。</p>\n</blockquote>\n<blockquote>\n<p>Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统</p>\n</blockquote>\n<blockquote>\n<p>启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；禁用服务就是删除此软链接，添加服务就是添加软连接</p>\n</blockquote>\n<blockquote>\n<p>Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。</p>\n</blockquote>\n<ul>\n<li>启动一个服务：systemctl start postfix.service</li>\n<li>关闭一个服务：systemctl stop postfix.service</li>\n<li>重启一个服务：systemctl restart postfix.service</li>\n<li>显示一个服务的状态：systemctl status postfix.service</li>\n<li>在开机时启用一个服务：systemctl enable postfix.service</li>\n<li>在开机时禁用一个服务：systemctl disable postfix.service</li>\n<li>查看服务是否开机启动：systemctl is-enabled postfix.service</li>\n<li>查看已启动的服务列表：systemctl list-unit-files|grep enabled</li>\n<li>查看启动失败的服务列表：systemctl --failed</li>\n</ul>\n<blockquote>\n<p>使用命令 systemctl is-enabled postfix.service 得到的值可以是enable、disable或static，这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。</p>\n</blockquote>\n<p>更多：<a href=\"https://linux.cn/article-5926-1.html\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-5926-1.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>systemctl是RHEL 7 的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。</p>\n</blockquote>\n<blockquote>\n<p>Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。</p>\n</blockquote>\n<blockquote>\n<p>Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统</p>\n</blockquote>\n<blockquote>\n<p>启用服务就是在当前“runlevel”的配置文件目录/etc/systemd/system/multi-user.target.wants/里，建立/usr/lib/systemd/system里面对应服务配置文件的软链接；禁用服务就是删除此软链接，添加服务就是添加软连接</p>\n</blockquote>\n<blockquote>\n<p>Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。</p>\n</blockquote>\n<ul>\n<li>启动一个服务：systemctl start postfix.service</li>\n<li>关闭一个服务：systemctl stop postfix.service</li>\n<li>重启一个服务：systemctl restart postfix.service</li>\n<li>显示一个服务的状态：systemctl status postfix.service</li>\n<li>在开机时启用一个服务：systemctl enable postfix.service</li>\n<li>在开机时禁用一个服务：systemctl disable postfix.service</li>\n<li>查看服务是否开机启动：systemctl is-enabled postfix.service</li>\n<li>查看已启动的服务列表：systemctl list-unit-files|grep enabled</li>\n<li>查看启动失败的服务列表：systemctl --failed</li>\n</ul>\n<blockquote>\n<p>使用命令 systemctl is-enabled postfix.service 得到的值可以是enable、disable或static，这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。</p>\n</blockquote>\n<p>更多：<a href=\"https://linux.cn/article-5926-1.html\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-5926-1.html</a></p>\n"},{"title":"CentOS修改Root密码","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# scp简介\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。\n\n# scp作用说明\n1. 我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的\n2. 我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。\n\n# 使用举例\n~~~\n#将本地文件拷贝到服务器上\nscp -rp /path/filename username@remoteIP:/path \n#将远程文件从服务器下载到本地\nscp -rp username@remoteIP:/path/filename /path \n\n#压缩传输\ntar cvzf - /path/ | ssh username@remoteip \"cd /some/path/; cat -> path.tar.gz\" \n#压缩传输一个目录并解压\ntar cvzf - /path/ | ssh username@remoteip \"cd /some/path/; tar xvzf -\" \n~~~\n\n# 脚本方式举例\n~~~\n#!/bin/bash  \nssh root@192.168.0.23   << remotessh  \nkillall -9 java  \ncd /data/apache-tomcat-7.0.53/webapps/  \nexit  \nremotessh  \n~~~\n远程执行的内容在“<< remotessh ” 至“ remotessh ”之间，在远程机器上的操作就位于其中，注意的点：<< remotessh，ssh后直到遇到remotessh这样的内容结束，remotessh可以随便修改成其他形式。在结束前，加exit退出远程节点\n\n# 参数\n* -v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误\n* -C 使能压缩选项\n* -4 强行使用 IPV4 地址\n* -6 强行使用 IPV6 地址","source":"_posts/Linux/Linux下scp命令详解.md","raw":"---\ntitle: CentOS修改Root密码\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n# scp简介\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。\n\n# scp作用说明\n1. 我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的\n2. 我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。\n\n# 使用举例\n~~~\n#将本地文件拷贝到服务器上\nscp -rp /path/filename username@remoteIP:/path \n#将远程文件从服务器下载到本地\nscp -rp username@remoteIP:/path/filename /path \n\n#压缩传输\ntar cvzf - /path/ | ssh username@remoteip \"cd /some/path/; cat -> path.tar.gz\" \n#压缩传输一个目录并解压\ntar cvzf - /path/ | ssh username@remoteip \"cd /some/path/; tar xvzf -\" \n~~~\n\n# 脚本方式举例\n~~~\n#!/bin/bash  \nssh root@192.168.0.23   << remotessh  \nkillall -9 java  \ncd /data/apache-tomcat-7.0.53/webapps/  \nexit  \nremotessh  \n~~~\n远程执行的内容在“<< remotessh ” 至“ remotessh ”之间，在远程机器上的操作就位于其中，注意的点：<< remotessh，ssh后直到遇到remotessh这样的内容结束，remotessh可以随便修改成其他形式。在结束前，加exit退出远程节点\n\n# 参数\n* -v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误\n* -C 使能压缩选项\n* -4 强行使用 IPV4 地址\n* -6 强行使用 IPV6 地址","slug":"Linux-Linux下scp命令详解","published":1,"updated":"2019-02-14T05:46:56.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudy3002g5b8hgkxokeoh","content":"<h1 id=\"scp简介\"><a class=\"markdownIt-Anchor\" href=\"#scp简介\"></a> scp简介</h1>\n<p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。</p>\n<h1 id=\"scp作用说明\"><a class=\"markdownIt-Anchor\" href=\"#scp作用说明\"></a> scp作用说明</h1>\n<ol>\n<li>我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的</li>\n<li>我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。</li>\n</ol>\n<h1 id=\"使用举例\"><a class=\"markdownIt-Anchor\" href=\"#使用举例\"></a> 使用举例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#将本地文件拷贝到服务器上</span><br><span class=\"line\">scp -rp /path/filename username@remoteIP:/path </span><br><span class=\"line\">#将远程文件从服务器下载到本地</span><br><span class=\"line\">scp -rp username@remoteIP:/path/filename /path </span><br><span class=\"line\"></span><br><span class=\"line\">#压缩传输</span><br><span class=\"line\">tar cvzf - /path/ | ssh username@remoteip &quot;cd /some/path/; cat -&gt; path.tar.gz&quot; </span><br><span class=\"line\">#压缩传输一个目录并解压</span><br><span class=\"line\">tar cvzf - /path/ | ssh username@remoteip &quot;cd /some/path/; tar xvzf -&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"脚本方式举例\"><a class=\"markdownIt-Anchor\" href=\"#脚本方式举例\"></a> 脚本方式举例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash  </span><br><span class=\"line\">ssh root@192.168.0.23   &lt;&lt; remotessh  </span><br><span class=\"line\">killall -9 java  </span><br><span class=\"line\">cd /data/apache-tomcat-7.0.53/webapps/  </span><br><span class=\"line\">exit  </span><br><span class=\"line\">remotessh</span><br></pre></td></tr></table></figure>\n<p>远程执行的内容在“&lt;&lt; remotessh ” 至“ remotessh ”之间，在远程机器上的操作就位于其中，注意的点：&lt;&lt; remotessh，ssh后直到遇到remotessh这样的内容结束，remotessh可以随便修改成其他形式。在结束前，加exit退出远程节点</p>\n<h1 id=\"参数\"><a class=\"markdownIt-Anchor\" href=\"#参数\"></a> 参数</h1>\n<ul>\n<li>-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误</li>\n<li>-C 使能压缩选项</li>\n<li>-4 强行使用 IPV4 地址</li>\n<li>-6 强行使用 IPV6 地址</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"scp简介\"><a class=\"markdownIt-Anchor\" href=\"#scp简介\"></a> scp简介</h1>\n<p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。</p>\n<h1 id=\"scp作用说明\"><a class=\"markdownIt-Anchor\" href=\"#scp作用说明\"></a> scp作用说明</h1>\n<ol>\n<li>我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的</li>\n<li>我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。</li>\n</ol>\n<h1 id=\"使用举例\"><a class=\"markdownIt-Anchor\" href=\"#使用举例\"></a> 使用举例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#将本地文件拷贝到服务器上</span><br><span class=\"line\">scp -rp /path/filename username@remoteIP:/path </span><br><span class=\"line\">#将远程文件从服务器下载到本地</span><br><span class=\"line\">scp -rp username@remoteIP:/path/filename /path </span><br><span class=\"line\"></span><br><span class=\"line\">#压缩传输</span><br><span class=\"line\">tar cvzf - /path/ | ssh username@remoteip &quot;cd /some/path/; cat -&gt; path.tar.gz&quot; </span><br><span class=\"line\">#压缩传输一个目录并解压</span><br><span class=\"line\">tar cvzf - /path/ | ssh username@remoteip &quot;cd /some/path/; tar xvzf -&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"脚本方式举例\"><a class=\"markdownIt-Anchor\" href=\"#脚本方式举例\"></a> 脚本方式举例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash  </span><br><span class=\"line\">ssh root@192.168.0.23   &lt;&lt; remotessh  </span><br><span class=\"line\">killall -9 java  </span><br><span class=\"line\">cd /data/apache-tomcat-7.0.53/webapps/  </span><br><span class=\"line\">exit  </span><br><span class=\"line\">remotessh</span><br></pre></td></tr></table></figure>\n<p>远程执行的内容在“&lt;&lt; remotessh ” 至“ remotessh ”之间，在远程机器上的操作就位于其中，注意的点：&lt;&lt; remotessh，ssh后直到遇到remotessh这样的内容结束，remotessh可以随便修改成其他形式。在结束前，加exit退出远程节点</p>\n<h1 id=\"参数\"><a class=\"markdownIt-Anchor\" href=\"#参数\"></a> 参数</h1>\n<ul>\n<li>-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误</li>\n<li>-C 使能压缩选项</li>\n<li>-4 强行使用 IPV4 地址</li>\n<li>-6 强行使用 IPV6 地址</li>\n</ul>\n"},{"title":"CentOS系统GRUB","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"[toc]\n\n# 简介\n> Grub（GRand Unified Bootloader）是统一资源引导器，也就是引导加载器；它的工作是提供一个菜单，允许用户选择要启动的系统或不同的内核版本；把用户选定的内核装载到RAM中的特定空间中，然后解压、展开，而后把系统控制权移交给内核\n\n> 它目前有两个版本：\n1. GRUB 0.X：Grub Legacy\n2. GRUB 1.X：Grub2\n\n![Grub启动流程图](http://note.youdao.com/yws/api/personal/file/WEB1757c30da1a3a8c8f9ff3272fc6119ea?method=download&shareKey=df69cd3a77eed3186307b58a07a55ad5)\n\n# Grub Legacy概述\n> Grub Legacy是最经典的Grub程序。它分为三个部分stage1、stage1_5和stage2\n\n1. stage1\n> 即写入mbr中存储的bootloader程序。它的任务就是将stage1_5（此时并不能算是磁盘分区/boot/grub/下的stage1_5,因为stage1无法识别文件系统）载入内存执行\n\n2. stage1_5\n> 位于mbr之后的扇区，通过提供基本文件系统驱动让stage1中的bootloader程序能识别磁盘分区/boot/grub/上的stage2文件并载入内存执行\n\n\n注意：此处若是boot分区的文件系统类型不属于stage1_5的中的一个，则会借助ramdisk来加载在/lib64/moudles/下额外的文件系统驱动。\n\n3. stage2\n> 这个程序主要给用户提供一个比较友好的启动菜单，而后去加载位于同一个磁盘分区/boot/的内核文件（例如 vmlinuz-2.6.32-573.el6.x86_64）\n\n# Grub的配置文件和功用\n> 配置文件：/boot/grub/grub.conf，保证grub和内核等在一个目录；此外它创建了一个链接文件/etc/grub.conf指向配置文件来保证用户使用配置文件一致性\n\n配置项：\n~~~\ndefault=#：设定默认启动的菜单项：菜单项（title）编号从0开始\ntimeout=#：指定菜单项等待选项选择的时长；\nsplashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE：指明菜单背景图片文件路径；\nhiddemenu：隐藏菜单\npassword [--md5] STRING：菜单编辑认证；\ntitle TITLE：定义菜单项“标题”，可出现多次；\n   root（hd#，#）：grub查找stage2及kernel文件所在设备分区：为grub的“根”\n   kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核\n   initrd /PATH/TO/INITRAMFS_FILE：内核匹配的ramfs文件\n   password [--md5] STRING：启动选定的内核或者操作系统进行认证；\n~~~\n\n示例：\n>  /boot/grub/menu.lst 或者 /boot/grub/grub.conf  CentOS下这两个文件是绑定的\n\n~~~\n# grub.conf generated by anaconda     \n#     \n# Note that you do not have to rerun grub after making changes to this file     \n# NOTICE:  You have a /boot partition.  This means that     \n#          all kernel and initrd paths are relative to /boot/, eg.     \n#          root (hd1,0)     \n#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00     \n#          initrd /initrd-version.img     \n#boot=/dev/sdb     \ndefault=0    \ntimeout=5    \nsplashimage=(hd0,0)/grub/splash.xpm.gz     \nhiddenmenu     \ntitle CentOS (2.6.18-274.3.1.el5)     \n        root (hd0,0)     \n        kernel /vmlinuz-2.6.18-274.3.1.el5 ro root=/dev/VolGroup00/LogVol00     \n        initrd /initrd-2.6.18-274.3.1.el5.img     \ntitle CentOS (2.6.18-238.el5)     \n        root (hd0,0)     \n        kernel /vmlinuz-2.6.18-238.el5 ro root=/dev/VolGroup00/LogVol00     \n        initrd /initrd-2.6.18-238.el5.img     \ntitle Other     \n        rootnoverify (hd0,3)     \n        chainloader +1  \n~~~\n\n功用\n~~~\n1. 提供菜单、并提供交互式接口\n* e：编辑模式，用于编辑菜单\n* c：命令模式，交互式接口\n2. 加载用户选择的内核或操作系统\n* 允许传递参数给内核；可隐藏此菜单（通过grub.conf中的hiddenmenu）\n3. 为菜单提供了保护机制\n* 为编辑菜单进行认证（title上定义的password）\n* 为启用内核或者操作系统进行认证（title下的password字段）\n~~~\n\n# Grub的命令行接口和编辑功能\n1. 进入grub的命令行界面和编辑界面\n* 启动机器时，按ESC键可进入内核选择界面\n* 按c可进入命令行界面\n* 按e可进入编辑界面\n2. rub的命令行命令和编辑命令\n\ngrub的命令行命令\n~~~\nhelp：获取帮助信息\nhelp KEYWORD：获取某一具体命令的帮助信息\nfind (hd#,#)/PATH/TO/SOMEFFILE：查找文件（内核文件等）\nroot (hd#,#)：设定那个磁盘是根，执行后，fnd不需指磁盘了；\nkernel /PATH/TO/KERNEL_FILE：设定本次启动时用到的内核文件；\ninitrd /PATH/TO/OMOTRAMFS_FILE：设定为选定的initrd文件\nboot：引导启动选定的内核；\n~~~\ngrub的编辑命令\n~~~\nb：boot，启动\ne：edit，编辑选中的项\no：在选中行的下一行新加一行\nO：在选中行的上一行添加一行\nd：删除选中行\nESC：可以退出编辑界面进入主界面\n~~~\n# grub的安装\n1. grub-install\n\n使用格式：grub-install --root-directory=/PATH/TO/rootDIR DEVICE\n示例：grub-install --root-directory=/ /dev/sda3\n2. grub命令（shell中输入）\n\ngrub> root (hd0,0)\n\ngrub> setup (hd0)","source":"_posts/Linux/CentOS系统GRUB.md","raw":"---\ntitle: CentOS系统GRUB\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n[toc]\n\n# 简介\n> Grub（GRand Unified Bootloader）是统一资源引导器，也就是引导加载器；它的工作是提供一个菜单，允许用户选择要启动的系统或不同的内核版本；把用户选定的内核装载到RAM中的特定空间中，然后解压、展开，而后把系统控制权移交给内核\n\n> 它目前有两个版本：\n1. GRUB 0.X：Grub Legacy\n2. GRUB 1.X：Grub2\n\n![Grub启动流程图](http://note.youdao.com/yws/api/personal/file/WEB1757c30da1a3a8c8f9ff3272fc6119ea?method=download&shareKey=df69cd3a77eed3186307b58a07a55ad5)\n\n# Grub Legacy概述\n> Grub Legacy是最经典的Grub程序。它分为三个部分stage1、stage1_5和stage2\n\n1. stage1\n> 即写入mbr中存储的bootloader程序。它的任务就是将stage1_5（此时并不能算是磁盘分区/boot/grub/下的stage1_5,因为stage1无法识别文件系统）载入内存执行\n\n2. stage1_5\n> 位于mbr之后的扇区，通过提供基本文件系统驱动让stage1中的bootloader程序能识别磁盘分区/boot/grub/上的stage2文件并载入内存执行\n\n\n注意：此处若是boot分区的文件系统类型不属于stage1_5的中的一个，则会借助ramdisk来加载在/lib64/moudles/下额外的文件系统驱动。\n\n3. stage2\n> 这个程序主要给用户提供一个比较友好的启动菜单，而后去加载位于同一个磁盘分区/boot/的内核文件（例如 vmlinuz-2.6.32-573.el6.x86_64）\n\n# Grub的配置文件和功用\n> 配置文件：/boot/grub/grub.conf，保证grub和内核等在一个目录；此外它创建了一个链接文件/etc/grub.conf指向配置文件来保证用户使用配置文件一致性\n\n配置项：\n~~~\ndefault=#：设定默认启动的菜单项：菜单项（title）编号从0开始\ntimeout=#：指定菜单项等待选项选择的时长；\nsplashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE：指明菜单背景图片文件路径；\nhiddemenu：隐藏菜单\npassword [--md5] STRING：菜单编辑认证；\ntitle TITLE：定义菜单项“标题”，可出现多次；\n   root（hd#，#）：grub查找stage2及kernel文件所在设备分区：为grub的“根”\n   kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核\n   initrd /PATH/TO/INITRAMFS_FILE：内核匹配的ramfs文件\n   password [--md5] STRING：启动选定的内核或者操作系统进行认证；\n~~~\n\n示例：\n>  /boot/grub/menu.lst 或者 /boot/grub/grub.conf  CentOS下这两个文件是绑定的\n\n~~~\n# grub.conf generated by anaconda     \n#     \n# Note that you do not have to rerun grub after making changes to this file     \n# NOTICE:  You have a /boot partition.  This means that     \n#          all kernel and initrd paths are relative to /boot/, eg.     \n#          root (hd1,0)     \n#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00     \n#          initrd /initrd-version.img     \n#boot=/dev/sdb     \ndefault=0    \ntimeout=5    \nsplashimage=(hd0,0)/grub/splash.xpm.gz     \nhiddenmenu     \ntitle CentOS (2.6.18-274.3.1.el5)     \n        root (hd0,0)     \n        kernel /vmlinuz-2.6.18-274.3.1.el5 ro root=/dev/VolGroup00/LogVol00     \n        initrd /initrd-2.6.18-274.3.1.el5.img     \ntitle CentOS (2.6.18-238.el5)     \n        root (hd0,0)     \n        kernel /vmlinuz-2.6.18-238.el5 ro root=/dev/VolGroup00/LogVol00     \n        initrd /initrd-2.6.18-238.el5.img     \ntitle Other     \n        rootnoverify (hd0,3)     \n        chainloader +1  \n~~~\n\n功用\n~~~\n1. 提供菜单、并提供交互式接口\n* e：编辑模式，用于编辑菜单\n* c：命令模式，交互式接口\n2. 加载用户选择的内核或操作系统\n* 允许传递参数给内核；可隐藏此菜单（通过grub.conf中的hiddenmenu）\n3. 为菜单提供了保护机制\n* 为编辑菜单进行认证（title上定义的password）\n* 为启用内核或者操作系统进行认证（title下的password字段）\n~~~\n\n# Grub的命令行接口和编辑功能\n1. 进入grub的命令行界面和编辑界面\n* 启动机器时，按ESC键可进入内核选择界面\n* 按c可进入命令行界面\n* 按e可进入编辑界面\n2. rub的命令行命令和编辑命令\n\ngrub的命令行命令\n~~~\nhelp：获取帮助信息\nhelp KEYWORD：获取某一具体命令的帮助信息\nfind (hd#,#)/PATH/TO/SOMEFFILE：查找文件（内核文件等）\nroot (hd#,#)：设定那个磁盘是根，执行后，fnd不需指磁盘了；\nkernel /PATH/TO/KERNEL_FILE：设定本次启动时用到的内核文件；\ninitrd /PATH/TO/OMOTRAMFS_FILE：设定为选定的initrd文件\nboot：引导启动选定的内核；\n~~~\ngrub的编辑命令\n~~~\nb：boot，启动\ne：edit，编辑选中的项\no：在选中行的下一行新加一行\nO：在选中行的上一行添加一行\nd：删除选中行\nESC：可以退出编辑界面进入主界面\n~~~\n# grub的安装\n1. grub-install\n\n使用格式：grub-install --root-directory=/PATH/TO/rootDIR DEVICE\n示例：grub-install --root-directory=/ /dev/sda3\n2. grub命令（shell中输入）\n\ngrub> root (hd0,0)\n\ngrub> setup (hd0)","slug":"Linux-CentOS系统GRUB","published":1,"updated":"2019-02-14T05:36:34.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudy5002i5b8huctoprh4","content":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Grub（GRand Unified Bootloader）是统一资源引导器，也就是引导加载器；它的工作是提供一个菜单，允许用户选择要启动的系统或不同的内核版本；把用户选定的内核装载到RAM中的特定空间中，然后解压、展开，而后把系统控制权移交给内核</p>\n</blockquote>\n<blockquote>\n<p>它目前有两个版本：</p>\n</blockquote>\n<ol>\n<li>GRUB 0.X：Grub Legacy</li>\n<li>GRUB 1.X：Grub2</li>\n</ol>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB1757c30da1a3a8c8f9ff3272fc6119ea?method=download&amp;shareKey=df69cd3a77eed3186307b58a07a55ad5\" alt=\"Grub启动流程图\"></p>\n<h1 id=\"grub-legacy概述\"><a class=\"markdownIt-Anchor\" href=\"#grub-legacy概述\"></a> Grub Legacy概述</h1>\n<blockquote>\n<p>Grub Legacy是最经典的Grub程序。它分为三个部分stage1、stage1_5和stage2</p>\n</blockquote>\n<ol>\n<li>stage1</li>\n</ol>\n<blockquote>\n<p>即写入mbr中存储的bootloader程序。它的任务就是将stage1_5（此时并不能算是磁盘分区/boot/grub/下的stage1_5,因为stage1无法识别文件系统）载入内存执行</p>\n</blockquote>\n<ol start=\"2\">\n<li>stage1_5</li>\n</ol>\n<blockquote>\n<p>位于mbr之后的扇区，通过提供基本文件系统驱动让stage1中的bootloader程序能识别磁盘分区/boot/grub/上的stage2文件并载入内存执行</p>\n</blockquote>\n<p>注意：此处若是boot分区的文件系统类型不属于stage1_5的中的一个，则会借助ramdisk来加载在/lib64/moudles/下额外的文件系统驱动。</p>\n<ol start=\"3\">\n<li>stage2</li>\n</ol>\n<blockquote>\n<p>这个程序主要给用户提供一个比较友好的启动菜单，而后去加载位于同一个磁盘分区/boot/的内核文件（例如 vmlinuz-2.6.32-573.el6.x86_64）</p>\n</blockquote>\n<h1 id=\"grub的配置文件和功用\"><a class=\"markdownIt-Anchor\" href=\"#grub的配置文件和功用\"></a> Grub的配置文件和功用</h1>\n<blockquote>\n<p>配置文件：/boot/grub/grub.conf，保证grub和内核等在一个目录；此外它创建了一个链接文件/etc/grub.conf指向配置文件来保证用户使用配置文件一致性</p>\n</blockquote>\n<p>配置项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default=#：设定默认启动的菜单项：菜单项（title）编号从0开始</span><br><span class=\"line\">timeout=#：指定菜单项等待选项选择的时长；</span><br><span class=\"line\">splashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE：指明菜单背景图片文件路径；</span><br><span class=\"line\">hiddemenu：隐藏菜单</span><br><span class=\"line\">password [--md5] STRING：菜单编辑认证；</span><br><span class=\"line\">title TITLE：定义菜单项“标题”，可出现多次；</span><br><span class=\"line\">   root（hd#，#）：grub查找stage2及kernel文件所在设备分区：为grub的“根”</span><br><span class=\"line\">   kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核</span><br><span class=\"line\">   initrd /PATH/TO/INITRAMFS_FILE：内核匹配的ramfs文件</span><br><span class=\"line\">   password [--md5] STRING：启动选定的内核或者操作系统进行认证；</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<blockquote>\n<p>/boot/grub/menu.lst 或者 /boot/grub/grub.conf  CentOS下这两个文件是绑定的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># grub.conf generated by anaconda     </span><br><span class=\"line\">#     </span><br><span class=\"line\"># Note that you do not have to rerun grub after making changes to this file     </span><br><span class=\"line\"># NOTICE:  You have a /boot partition.  This means that     </span><br><span class=\"line\">#          all kernel and initrd paths are relative to /boot/, eg.     </span><br><span class=\"line\">#          root (hd1,0)     </span><br><span class=\"line\">#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00     </span><br><span class=\"line\">#          initrd /initrd-version.img     </span><br><span class=\"line\">#boot=/dev/sdb     </span><br><span class=\"line\">default=0    </span><br><span class=\"line\">timeout=5    </span><br><span class=\"line\">splashimage=(hd0,0)/grub/splash.xpm.gz     </span><br><span class=\"line\">hiddenmenu     </span><br><span class=\"line\">title CentOS (2.6.18-274.3.1.el5)     </span><br><span class=\"line\">        root (hd0,0)     </span><br><span class=\"line\">        kernel /vmlinuz-2.6.18-274.3.1.el5 ro root=/dev/VolGroup00/LogVol00     </span><br><span class=\"line\">        initrd /initrd-2.6.18-274.3.1.el5.img     </span><br><span class=\"line\">title CentOS (2.6.18-238.el5)     </span><br><span class=\"line\">        root (hd0,0)     </span><br><span class=\"line\">        kernel /vmlinuz-2.6.18-238.el5 ro root=/dev/VolGroup00/LogVol00     </span><br><span class=\"line\">        initrd /initrd-2.6.18-238.el5.img     </span><br><span class=\"line\">title Other     </span><br><span class=\"line\">        rootnoverify (hd0,3)     </span><br><span class=\"line\">        chainloader +1</span><br></pre></td></tr></table></figure>\n<p>功用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 提供菜单、并提供交互式接口</span><br><span class=\"line\">* e：编辑模式，用于编辑菜单</span><br><span class=\"line\">* c：命令模式，交互式接口</span><br><span class=\"line\">2. 加载用户选择的内核或操作系统</span><br><span class=\"line\">* 允许传递参数给内核；可隐藏此菜单（通过grub.conf中的hiddenmenu）</span><br><span class=\"line\">3. 为菜单提供了保护机制</span><br><span class=\"line\">* 为编辑菜单进行认证（title上定义的password）</span><br><span class=\"line\">* 为启用内核或者操作系统进行认证（title下的password字段）</span><br></pre></td></tr></table></figure>\n<h1 id=\"grub的命令行接口和编辑功能\"><a class=\"markdownIt-Anchor\" href=\"#grub的命令行接口和编辑功能\"></a> Grub的命令行接口和编辑功能</h1>\n<ol>\n<li>进入grub的命令行界面和编辑界面</li>\n</ol>\n<ul>\n<li>启动机器时，按ESC键可进入内核选择界面</li>\n<li>按c可进入命令行界面</li>\n<li>按e可进入编辑界面</li>\n</ul>\n<ol start=\"2\">\n<li>rub的命令行命令和编辑命令</li>\n</ol>\n<p>grub的命令行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">help：获取帮助信息</span><br><span class=\"line\">help KEYWORD：获取某一具体命令的帮助信息</span><br><span class=\"line\">find (hd#,#)/PATH/TO/SOMEFFILE：查找文件（内核文件等）</span><br><span class=\"line\">root (hd#,#)：设定那个磁盘是根，执行后，fnd不需指磁盘了；</span><br><span class=\"line\">kernel /PATH/TO/KERNEL_FILE：设定本次启动时用到的内核文件；</span><br><span class=\"line\">initrd /PATH/TO/OMOTRAMFS_FILE：设定为选定的initrd文件</span><br><span class=\"line\">boot：引导启动选定的内核；</span><br></pre></td></tr></table></figure>\n<p>grub的编辑命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b：boot，启动</span><br><span class=\"line\">e：edit，编辑选中的项</span><br><span class=\"line\">o：在选中行的下一行新加一行</span><br><span class=\"line\">O：在选中行的上一行添加一行</span><br><span class=\"line\">d：删除选中行</span><br><span class=\"line\">ESC：可以退出编辑界面进入主界面</span><br></pre></td></tr></table></figure>\n<h1 id=\"grub的安装\"><a class=\"markdownIt-Anchor\" href=\"#grub的安装\"></a> grub的安装</h1>\n<ol>\n<li>grub-install</li>\n</ol>\n<p>使用格式：grub-install --root-directory=/PATH/TO/rootDIR DEVICE<br>\n示例：grub-install --root-directory=/ /dev/sda3<br>\n2. grub命令（shell中输入）</p>\n<p>grub&gt; root (hd0,0)</p>\n<p>grub&gt; setup (hd0)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Grub（GRand Unified Bootloader）是统一资源引导器，也就是引导加载器；它的工作是提供一个菜单，允许用户选择要启动的系统或不同的内核版本；把用户选定的内核装载到RAM中的特定空间中，然后解压、展开，而后把系统控制权移交给内核</p>\n</blockquote>\n<blockquote>\n<p>它目前有两个版本：</p>\n</blockquote>\n<ol>\n<li>GRUB 0.X：Grub Legacy</li>\n<li>GRUB 1.X：Grub2</li>\n</ol>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB1757c30da1a3a8c8f9ff3272fc6119ea?method=download&amp;shareKey=df69cd3a77eed3186307b58a07a55ad5\" alt=\"Grub启动流程图\"></p>\n<h1 id=\"grub-legacy概述\"><a class=\"markdownIt-Anchor\" href=\"#grub-legacy概述\"></a> Grub Legacy概述</h1>\n<blockquote>\n<p>Grub Legacy是最经典的Grub程序。它分为三个部分stage1、stage1_5和stage2</p>\n</blockquote>\n<ol>\n<li>stage1</li>\n</ol>\n<blockquote>\n<p>即写入mbr中存储的bootloader程序。它的任务就是将stage1_5（此时并不能算是磁盘分区/boot/grub/下的stage1_5,因为stage1无法识别文件系统）载入内存执行</p>\n</blockquote>\n<ol start=\"2\">\n<li>stage1_5</li>\n</ol>\n<blockquote>\n<p>位于mbr之后的扇区，通过提供基本文件系统驱动让stage1中的bootloader程序能识别磁盘分区/boot/grub/上的stage2文件并载入内存执行</p>\n</blockquote>\n<p>注意：此处若是boot分区的文件系统类型不属于stage1_5的中的一个，则会借助ramdisk来加载在/lib64/moudles/下额外的文件系统驱动。</p>\n<ol start=\"3\">\n<li>stage2</li>\n</ol>\n<blockquote>\n<p>这个程序主要给用户提供一个比较友好的启动菜单，而后去加载位于同一个磁盘分区/boot/的内核文件（例如 vmlinuz-2.6.32-573.el6.x86_64）</p>\n</blockquote>\n<h1 id=\"grub的配置文件和功用\"><a class=\"markdownIt-Anchor\" href=\"#grub的配置文件和功用\"></a> Grub的配置文件和功用</h1>\n<blockquote>\n<p>配置文件：/boot/grub/grub.conf，保证grub和内核等在一个目录；此外它创建了一个链接文件/etc/grub.conf指向配置文件来保证用户使用配置文件一致性</p>\n</blockquote>\n<p>配置项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default=#：设定默认启动的菜单项：菜单项（title）编号从0开始</span><br><span class=\"line\">timeout=#：指定菜单项等待选项选择的时长；</span><br><span class=\"line\">splashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE：指明菜单背景图片文件路径；</span><br><span class=\"line\">hiddemenu：隐藏菜单</span><br><span class=\"line\">password [--md5] STRING：菜单编辑认证；</span><br><span class=\"line\">title TITLE：定义菜单项“标题”，可出现多次；</span><br><span class=\"line\">   root（hd#，#）：grub查找stage2及kernel文件所在设备分区：为grub的“根”</span><br><span class=\"line\">   kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核</span><br><span class=\"line\">   initrd /PATH/TO/INITRAMFS_FILE：内核匹配的ramfs文件</span><br><span class=\"line\">   password [--md5] STRING：启动选定的内核或者操作系统进行认证；</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<blockquote>\n<p>/boot/grub/menu.lst 或者 /boot/grub/grub.conf  CentOS下这两个文件是绑定的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># grub.conf generated by anaconda     </span><br><span class=\"line\">#     </span><br><span class=\"line\"># Note that you do not have to rerun grub after making changes to this file     </span><br><span class=\"line\"># NOTICE:  You have a /boot partition.  This means that     </span><br><span class=\"line\">#          all kernel and initrd paths are relative to /boot/, eg.     </span><br><span class=\"line\">#          root (hd1,0)     </span><br><span class=\"line\">#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00     </span><br><span class=\"line\">#          initrd /initrd-version.img     </span><br><span class=\"line\">#boot=/dev/sdb     </span><br><span class=\"line\">default=0    </span><br><span class=\"line\">timeout=5    </span><br><span class=\"line\">splashimage=(hd0,0)/grub/splash.xpm.gz     </span><br><span class=\"line\">hiddenmenu     </span><br><span class=\"line\">title CentOS (2.6.18-274.3.1.el5)     </span><br><span class=\"line\">        root (hd0,0)     </span><br><span class=\"line\">        kernel /vmlinuz-2.6.18-274.3.1.el5 ro root=/dev/VolGroup00/LogVol00     </span><br><span class=\"line\">        initrd /initrd-2.6.18-274.3.1.el5.img     </span><br><span class=\"line\">title CentOS (2.6.18-238.el5)     </span><br><span class=\"line\">        root (hd0,0)     </span><br><span class=\"line\">        kernel /vmlinuz-2.6.18-238.el5 ro root=/dev/VolGroup00/LogVol00     </span><br><span class=\"line\">        initrd /initrd-2.6.18-238.el5.img     </span><br><span class=\"line\">title Other     </span><br><span class=\"line\">        rootnoverify (hd0,3)     </span><br><span class=\"line\">        chainloader +1</span><br></pre></td></tr></table></figure>\n<p>功用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 提供菜单、并提供交互式接口</span><br><span class=\"line\">* e：编辑模式，用于编辑菜单</span><br><span class=\"line\">* c：命令模式，交互式接口</span><br><span class=\"line\">2. 加载用户选择的内核或操作系统</span><br><span class=\"line\">* 允许传递参数给内核；可隐藏此菜单（通过grub.conf中的hiddenmenu）</span><br><span class=\"line\">3. 为菜单提供了保护机制</span><br><span class=\"line\">* 为编辑菜单进行认证（title上定义的password）</span><br><span class=\"line\">* 为启用内核或者操作系统进行认证（title下的password字段）</span><br></pre></td></tr></table></figure>\n<h1 id=\"grub的命令行接口和编辑功能\"><a class=\"markdownIt-Anchor\" href=\"#grub的命令行接口和编辑功能\"></a> Grub的命令行接口和编辑功能</h1>\n<ol>\n<li>进入grub的命令行界面和编辑界面</li>\n</ol>\n<ul>\n<li>启动机器时，按ESC键可进入内核选择界面</li>\n<li>按c可进入命令行界面</li>\n<li>按e可进入编辑界面</li>\n</ul>\n<ol start=\"2\">\n<li>rub的命令行命令和编辑命令</li>\n</ol>\n<p>grub的命令行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">help：获取帮助信息</span><br><span class=\"line\">help KEYWORD：获取某一具体命令的帮助信息</span><br><span class=\"line\">find (hd#,#)/PATH/TO/SOMEFFILE：查找文件（内核文件等）</span><br><span class=\"line\">root (hd#,#)：设定那个磁盘是根，执行后，fnd不需指磁盘了；</span><br><span class=\"line\">kernel /PATH/TO/KERNEL_FILE：设定本次启动时用到的内核文件；</span><br><span class=\"line\">initrd /PATH/TO/OMOTRAMFS_FILE：设定为选定的initrd文件</span><br><span class=\"line\">boot：引导启动选定的内核；</span><br></pre></td></tr></table></figure>\n<p>grub的编辑命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b：boot，启动</span><br><span class=\"line\">e：edit，编辑选中的项</span><br><span class=\"line\">o：在选中行的下一行新加一行</span><br><span class=\"line\">O：在选中行的上一行添加一行</span><br><span class=\"line\">d：删除选中行</span><br><span class=\"line\">ESC：可以退出编辑界面进入主界面</span><br></pre></td></tr></table></figure>\n<h1 id=\"grub的安装\"><a class=\"markdownIt-Anchor\" href=\"#grub的安装\"></a> grub的安装</h1>\n<ol>\n<li>grub-install</li>\n</ol>\n<p>使用格式：grub-install --root-directory=/PATH/TO/rootDIR DEVICE<br>\n示例：grub-install --root-directory=/ /dev/sda3<br>\n2. grub命令（shell中输入）</p>\n<p>grub&gt; root (hd0,0)</p>\n<p>grub&gt; setup (hd0)</p>\n"},{"title":"XShell使用","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 简介\n> Xshell是一款服务器终端模拟软件，用户可以使用Xshell软件在Windows、Mac OS电脑上访问不同系统的服务器主机，让你可以方便对其进行控制管理。\n\n> 创新的设计和优良的体验，让用户以最高效率对服务器进行管理\n\n# 功能特色\n* 可以保存多个vps登陆信息，免去每次输入的烦恼\n* 设置命令快捷按钮\n* 通过代理登陆vps\n* 鼠标右键粘贴可将本地粘贴板内容复制到vps\n\n# Xshell 注册说明\n1. 公司名字随便填\n2. 注册码 690313-111999-999313\n\n# 注意事项\n安装完成之后键盘输入无反应，解决方法：\n~~~\n文件--属性--终端--编码 改成Unicode(UTF-8)\n~~~\n","source":"_posts/Linux/XShell使用.md","raw":"---\ntitle: XShell使用\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n# 简介\n> Xshell是一款服务器终端模拟软件，用户可以使用Xshell软件在Windows、Mac OS电脑上访问不同系统的服务器主机，让你可以方便对其进行控制管理。\n\n> 创新的设计和优良的体验，让用户以最高效率对服务器进行管理\n\n# 功能特色\n* 可以保存多个vps登陆信息，免去每次输入的烦恼\n* 设置命令快捷按钮\n* 通过代理登陆vps\n* 鼠标右键粘贴可将本地粘贴板内容复制到vps\n\n# Xshell 注册说明\n1. 公司名字随便填\n2. 注册码 690313-111999-999313\n\n# 注意事项\n安装完成之后键盘输入无反应，解决方法：\n~~~\n文件--属性--终端--编码 改成Unicode(UTF-8)\n~~~\n","slug":"Linux-XShell使用","published":1,"updated":"2019-02-14T05:55:30.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudy6002m5b8hw97kjg0a","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Xshell是一款服务器终端模拟软件，用户可以使用Xshell软件在Windows、Mac OS电脑上访问不同系统的服务器主机，让你可以方便对其进行控制管理。</p>\n</blockquote>\n<blockquote>\n<p>创新的设计和优良的体验，让用户以最高效率对服务器进行管理</p>\n</blockquote>\n<h1 id=\"功能特色\"><a class=\"markdownIt-Anchor\" href=\"#功能特色\"></a> 功能特色</h1>\n<ul>\n<li>可以保存多个vps登陆信息，免去每次输入的烦恼</li>\n<li>设置命令快捷按钮</li>\n<li>通过代理登陆vps</li>\n<li>鼠标右键粘贴可将本地粘贴板内容复制到vps</li>\n</ul>\n<h1 id=\"xshell-注册说明\"><a class=\"markdownIt-Anchor\" href=\"#xshell-注册说明\"></a> Xshell 注册说明</h1>\n<ol>\n<li>公司名字随便填</li>\n<li>注册码 690313-111999-999313</li>\n</ol>\n<h1 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h1>\n<p>安装完成之后键盘输入无反应，解决方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件--属性--终端--编码 改成Unicode(UTF-8)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Xshell是一款服务器终端模拟软件，用户可以使用Xshell软件在Windows、Mac OS电脑上访问不同系统的服务器主机，让你可以方便对其进行控制管理。</p>\n</blockquote>\n<blockquote>\n<p>创新的设计和优良的体验，让用户以最高效率对服务器进行管理</p>\n</blockquote>\n<h1 id=\"功能特色\"><a class=\"markdownIt-Anchor\" href=\"#功能特色\"></a> 功能特色</h1>\n<ul>\n<li>可以保存多个vps登陆信息，免去每次输入的烦恼</li>\n<li>设置命令快捷按钮</li>\n<li>通过代理登陆vps</li>\n<li>鼠标右键粘贴可将本地粘贴板内容复制到vps</li>\n</ul>\n<h1 id=\"xshell-注册说明\"><a class=\"markdownIt-Anchor\" href=\"#xshell-注册说明\"></a> Xshell 注册说明</h1>\n<ol>\n<li>公司名字随便填</li>\n<li>注册码 690313-111999-999313</li>\n</ol>\n<h1 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h1>\n<p>安装完成之后键盘输入无反应，解决方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件--属性--终端--编码 改成Unicode(UTF-8)</span><br></pre></td></tr></table></figure>\n"},{"title":"Shell脚本调试","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 前言\n> shell编程在unix/linux世界中使用得非常广泛，熟练掌握shell编程也是成为一名优秀的unix/linux开发者和系统管理员的必经之路\n\n> 与其它高级语言相比，shell解释器缺乏相应的调试机制和调试工具的支持，其输出的错误信息又往往很不明确\n\n# 调试方法\n## 通过echo方式\n~~~\n功能: 最简单的调试方法，可以在任何怀疑出错的地方用echo打印变量\n场合: 所有怀疑可能有问题的地方\n示例: echo $VAR\n~~~\n## 通过test的方式\n返回值为0为真,1表假\n~~~\ntest -f /test.sh | echo $?\n~~~\n\n## 使用调试工具-bashdb\n> 使用shell调试器bashdb，这是一个类似于GDB的调试工具，可以完成对shell脚本的断点设置，单步执行，变量观察等许多功能\n\n用法：bashdb -c script.sh   或者 bashdb script.sh\n\n## 通过trap来调试\n~~~\n作用: 用于捕获指定的信号并执行预定义的命令\n语法: trap `command` signal\n说明: signal是要捕获的信号,command是捕获到指定的信号，所要执行的命令, 可以用kill -l命令看到系统中全部可用的信号名,捕获信号后所执行的命令,可以是一条或多条合法的Shell语句,也可以是一个函数名, Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助\n\nShell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助.SHELL三个伪信号:\n\n* EXIT  从一个函数中退出或整个执行完毕\n* ERR   当一个命令执行不成功，返回非0状态时\n* DEBUG 脚本中每一条命令执行之前\n~~~\n\n~~~\n#!/bin/bash\nerrorTrap()\n{\n    echo \"[LINE:$1]Error: Command or function exited with status $?\"\n}\nfoo()\n{\n    return 1;\n}\ntrap 'errorTrap $LINENO' ERR\nabc\nfoo\n脚本输出:\n[root@localhost:shell]# bash test.sh\ntest.sh: line 12: abc: command not found\n[LINE:12]Error: Command or function exited with status 127\n[LINE:9]Error: Command or function exited with status 1\n~~~\n在调试过程中，为了跟踪某些变量的值，我们常常需要在shell脚本的许多地方插入相同的echo语句来打印相关变量的值，这种做法显得烦琐而笨拙。而通过捕获DEBUG信号，我们只需要一条trap语句就可以完成对相关变量的全程跟踪。\n~~~\n#!/bin/bash\ntrap 'echo “before execute line:$LINENO, a=$a,b=$b,c=$c”' DEBUG\na=1\nif [ \"$a\" -eq 1 ]\nthen\n  b=2\nelse\n  b=1\nfi\nc=3\necho \"end\"\n~~~\n其执行输出结果如下：\n~~~\nbefore execute line:3, a=,b=,c=\nbefore execute line:4, a=1,b=,c=\nbefore execute line:6, a=1,b=,c=\nbefore execute line:10, a=1,b=2,c=\nbefore execute line:11, a=1,b=2,c=3\nend\n~~~\n\n## 使用tee命令\n> 在shell脚本中管道以及输入输出重定向使用得非常多，在管道的作用下，一些命令的执行结果直接成为了下一条命令的输入。如果我们发现由管道连接起来的一批命令的执行结果并非如预期的那样，就需要逐步检查各条命令的执行结果来判断问题出在哪儿，但因为使用了管道，这些中间结果并不会显示在屏幕上，给调试带来了困难，此时我们就可以借助于tee命令了\n\n> tee命令会从标准输入读取数据，将其内容输出到标准输出设备,同时又可将内容保存成文件\n~~~\nipaddr=`/sbin/ifconfig | grep 'inet addr:' | grep -v '127.0.0.1'\n| tee temp.txt | cut -d : -f3 | awk '{print $1}'`\n~~~\n\n## 使用\"调试钩子\"\n> 在C语言程序中，我们经常使用DEBUG宏来控制是否要输出调试信息，在shell脚本中我们同样可以使用这样的机制，这样的代码块通常称之为“调试钩子”或“调试块”.如下列代码所示：\n~~~\nif [ “$DEBUG” = “true” ]; then\necho “debugging”  #此处可以输出调试信息\nfi\n~~~\n\n## 通过选项方式\n* -n:选项只做语法检查，而不执行脚本  //sh -n script_name.sh\n* -x:启动调试   //sh -x script_name.sh\n > 进入调试模式后，Shell依次执行读入的语句，产生的输出中有的带加号，有的不带。带加号表示该条语句是Shell执行的；不带加号表示该语句是Shell产生的输出；前面有“++”号的行是执行trap机制中指定的命令。\"+\"号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令\n~~~\n1).在命令行提供参数：$ sh -x script.sh\n2).脚本开头提供参数：#!/bin/sh -x\n3).在脚本中用set命令启用or禁用参数：其中set -x表启用，set +x表禁用\n~~~\n* -c:该选项使Shell解析器从字符串而非文件中读取并执行命令,如：bash -c 'x=1;y=2;let z=x+y;echo \"z=$z\"'\n* -v：区别于-x参数,该选项打印命令行的原始内容，-x参数打印出经过替换后命令行的内容，适用于仅想显示命令行的原始内容\n* Ctrl + Z:中断调试，观察结果，然后再按fg键继续调试即可\n* 调试代码块:-x选项是调试整个脚本的，如果脚本很大，会很不方便，还有一种方法是调试某一块代码的\n~~~\nset -x\n...\ncode block\n...\nset +x\n~~~\n\n# shell内置的环境变量\n* $LINENO：代表shell脚本的当前行号，类似于C语言中的内置宏__LINE__\n* $FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量${FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字，而变量${FUNCNAME[1]}则代表调用函数${FUNCNAME[0]}的函数的名字，余者可以依此类推\n* $PS4：\n\n# 常见错误诊断\n* xxx.sh: cannot shift\n~~~\n这种错误一般是参数传递有误，比如没有给参数，或者参数个数少了。因为shell脚本使用shift来获取下一个参数，如果个数不对，shift命令就会失败\n~~~\n* xxx.sh: ^M: not found\n~~~\n^M是Windows上的回车符\\r在UNIX上的显示形式。这种情况多半是在Windows上编辑了shell脚本，然后拿到UNIX/Linux上执行。如下处理即可：\ntr -d \"\\015\" < oldfile.sh > newfile.sh  //\\r的ASCII码是\\015\n~~~","source":"_posts/Linux/Shell脚本调试.md","raw":"---\ntitle: Shell脚本调试\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n# 前言\n> shell编程在unix/linux世界中使用得非常广泛，熟练掌握shell编程也是成为一名优秀的unix/linux开发者和系统管理员的必经之路\n\n> 与其它高级语言相比，shell解释器缺乏相应的调试机制和调试工具的支持，其输出的错误信息又往往很不明确\n\n# 调试方法\n## 通过echo方式\n~~~\n功能: 最简单的调试方法，可以在任何怀疑出错的地方用echo打印变量\n场合: 所有怀疑可能有问题的地方\n示例: echo $VAR\n~~~\n## 通过test的方式\n返回值为0为真,1表假\n~~~\ntest -f /test.sh | echo $?\n~~~\n\n## 使用调试工具-bashdb\n> 使用shell调试器bashdb，这是一个类似于GDB的调试工具，可以完成对shell脚本的断点设置，单步执行，变量观察等许多功能\n\n用法：bashdb -c script.sh   或者 bashdb script.sh\n\n## 通过trap来调试\n~~~\n作用: 用于捕获指定的信号并执行预定义的命令\n语法: trap `command` signal\n说明: signal是要捕获的信号,command是捕获到指定的信号，所要执行的命令, 可以用kill -l命令看到系统中全部可用的信号名,捕获信号后所执行的命令,可以是一条或多条合法的Shell语句,也可以是一个函数名, Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助\n\nShell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助.SHELL三个伪信号:\n\n* EXIT  从一个函数中退出或整个执行完毕\n* ERR   当一个命令执行不成功，返回非0状态时\n* DEBUG 脚本中每一条命令执行之前\n~~~\n\n~~~\n#!/bin/bash\nerrorTrap()\n{\n    echo \"[LINE:$1]Error: Command or function exited with status $?\"\n}\nfoo()\n{\n    return 1;\n}\ntrap 'errorTrap $LINENO' ERR\nabc\nfoo\n脚本输出:\n[root@localhost:shell]# bash test.sh\ntest.sh: line 12: abc: command not found\n[LINE:12]Error: Command or function exited with status 127\n[LINE:9]Error: Command or function exited with status 1\n~~~\n在调试过程中，为了跟踪某些变量的值，我们常常需要在shell脚本的许多地方插入相同的echo语句来打印相关变量的值，这种做法显得烦琐而笨拙。而通过捕获DEBUG信号，我们只需要一条trap语句就可以完成对相关变量的全程跟踪。\n~~~\n#!/bin/bash\ntrap 'echo “before execute line:$LINENO, a=$a,b=$b,c=$c”' DEBUG\na=1\nif [ \"$a\" -eq 1 ]\nthen\n  b=2\nelse\n  b=1\nfi\nc=3\necho \"end\"\n~~~\n其执行输出结果如下：\n~~~\nbefore execute line:3, a=,b=,c=\nbefore execute line:4, a=1,b=,c=\nbefore execute line:6, a=1,b=,c=\nbefore execute line:10, a=1,b=2,c=\nbefore execute line:11, a=1,b=2,c=3\nend\n~~~\n\n## 使用tee命令\n> 在shell脚本中管道以及输入输出重定向使用得非常多，在管道的作用下，一些命令的执行结果直接成为了下一条命令的输入。如果我们发现由管道连接起来的一批命令的执行结果并非如预期的那样，就需要逐步检查各条命令的执行结果来判断问题出在哪儿，但因为使用了管道，这些中间结果并不会显示在屏幕上，给调试带来了困难，此时我们就可以借助于tee命令了\n\n> tee命令会从标准输入读取数据，将其内容输出到标准输出设备,同时又可将内容保存成文件\n~~~\nipaddr=`/sbin/ifconfig | grep 'inet addr:' | grep -v '127.0.0.1'\n| tee temp.txt | cut -d : -f3 | awk '{print $1}'`\n~~~\n\n## 使用\"调试钩子\"\n> 在C语言程序中，我们经常使用DEBUG宏来控制是否要输出调试信息，在shell脚本中我们同样可以使用这样的机制，这样的代码块通常称之为“调试钩子”或“调试块”.如下列代码所示：\n~~~\nif [ “$DEBUG” = “true” ]; then\necho “debugging”  #此处可以输出调试信息\nfi\n~~~\n\n## 通过选项方式\n* -n:选项只做语法检查，而不执行脚本  //sh -n script_name.sh\n* -x:启动调试   //sh -x script_name.sh\n > 进入调试模式后，Shell依次执行读入的语句，产生的输出中有的带加号，有的不带。带加号表示该条语句是Shell执行的；不带加号表示该语句是Shell产生的输出；前面有“++”号的行是执行trap机制中指定的命令。\"+\"号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令\n~~~\n1).在命令行提供参数：$ sh -x script.sh\n2).脚本开头提供参数：#!/bin/sh -x\n3).在脚本中用set命令启用or禁用参数：其中set -x表启用，set +x表禁用\n~~~\n* -c:该选项使Shell解析器从字符串而非文件中读取并执行命令,如：bash -c 'x=1;y=2;let z=x+y;echo \"z=$z\"'\n* -v：区别于-x参数,该选项打印命令行的原始内容，-x参数打印出经过替换后命令行的内容，适用于仅想显示命令行的原始内容\n* Ctrl + Z:中断调试，观察结果，然后再按fg键继续调试即可\n* 调试代码块:-x选项是调试整个脚本的，如果脚本很大，会很不方便，还有一种方法是调试某一块代码的\n~~~\nset -x\n...\ncode block\n...\nset +x\n~~~\n\n# shell内置的环境变量\n* $LINENO：代表shell脚本的当前行号，类似于C语言中的内置宏__LINE__\n* $FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量${FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字，而变量${FUNCNAME[1]}则代表调用函数${FUNCNAME[0]}的函数的名字，余者可以依此类推\n* $PS4：\n\n# 常见错误诊断\n* xxx.sh: cannot shift\n~~~\n这种错误一般是参数传递有误，比如没有给参数，或者参数个数少了。因为shell脚本使用shift来获取下一个参数，如果个数不对，shift命令就会失败\n~~~\n* xxx.sh: ^M: not found\n~~~\n^M是Windows上的回车符\\r在UNIX上的显示形式。这种情况多半是在Windows上编辑了shell脚本，然后拿到UNIX/Linux上执行。如下处理即可：\ntr -d \"\\015\" < oldfile.sh > newfile.sh  //\\r的ASCII码是\\015\n~~~","slug":"Linux-Shell脚本调试","published":1,"updated":"2019-02-14T05:44:56.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudy8002p5b8hyemlcote","content":"<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h1>\n<blockquote>\n<p>shell编程在unix/linux世界中使用得非常广泛，熟练掌握shell编程也是成为一名优秀的unix/linux开发者和系统管理员的必经之路</p>\n</blockquote>\n<blockquote>\n<p>与其它高级语言相比，shell解释器缺乏相应的调试机制和调试工具的支持，其输出的错误信息又往往很不明确</p>\n</blockquote>\n<h1 id=\"调试方法\"><a class=\"markdownIt-Anchor\" href=\"#调试方法\"></a> 调试方法</h1>\n<h2 id=\"通过echo方式\"><a class=\"markdownIt-Anchor\" href=\"#通过echo方式\"></a> 通过echo方式</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能: 最简单的调试方法，可以在任何怀疑出错的地方用echo打印变量</span><br><span class=\"line\">场合: 所有怀疑可能有问题的地方</span><br><span class=\"line\">示例: echo $VAR</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过test的方式\"><a class=\"markdownIt-Anchor\" href=\"#通过test的方式\"></a> 通过test的方式</h2>\n<p>返回值为0为真,1表假</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test -f /test.sh | echo $?</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用调试工具-bashdb\"><a class=\"markdownIt-Anchor\" href=\"#使用调试工具-bashdb\"></a> 使用调试工具-bashdb</h2>\n<blockquote>\n<p>使用shell调试器bashdb，这是一个类似于GDB的调试工具，可以完成对shell脚本的断点设置，单步执行，变量观察等许多功能</p>\n</blockquote>\n<p>用法：bashdb -c <a href=\"http://script.sh\" target=\"_blank\" rel=\"noopener\">script.sh</a>   或者 bashdb <a href=\"http://script.sh\" target=\"_blank\" rel=\"noopener\">script.sh</a></p>\n<h2 id=\"通过trap来调试\"><a class=\"markdownIt-Anchor\" href=\"#通过trap来调试\"></a> 通过trap来调试</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用: 用于捕获指定的信号并执行预定义的命令</span><br><span class=\"line\">语法: trap `command` signal</span><br><span class=\"line\">说明: signal是要捕获的信号,command是捕获到指定的信号，所要执行的命令, 可以用kill -l命令看到系统中全部可用的信号名,捕获信号后所执行的命令,可以是一条或多条合法的Shell语句,也可以是一个函数名, Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助</span><br><span class=\"line\"></span><br><span class=\"line\">Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助.SHELL三个伪信号:</span><br><span class=\"line\"></span><br><span class=\"line\">* EXIT  从一个函数中退出或整个执行完毕</span><br><span class=\"line\">* ERR   当一个命令执行不成功，返回非0状态时</span><br><span class=\"line\">* DEBUG 脚本中每一条命令执行之前</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">errorTrap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    echo &quot;[LINE:$1]Error: Command or function exited with status $?&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trap &apos;errorTrap $LINENO&apos; ERR</span><br><span class=\"line\">abc</span><br><span class=\"line\">foo</span><br><span class=\"line\">脚本输出:</span><br><span class=\"line\">[root@localhost:shell]# bash test.sh</span><br><span class=\"line\">test.sh: line 12: abc: command not found</span><br><span class=\"line\">[LINE:12]Error: Command or function exited with status 127</span><br><span class=\"line\">[LINE:9]Error: Command or function exited with status 1</span><br></pre></td></tr></table></figure>\n<p>在调试过程中，为了跟踪某些变量的值，我们常常需要在shell脚本的许多地方插入相同的echo语句来打印相关变量的值，这种做法显得烦琐而笨拙。而通过捕获DEBUG信号，我们只需要一条trap语句就可以完成对相关变量的全程跟踪。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">trap &apos;echo “before execute line:$LINENO, a=$a,b=$b,c=$c”&apos; DEBUG</span><br><span class=\"line\">a=1</span><br><span class=\"line\">if [ &quot;$a&quot; -eq 1 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  b=2</span><br><span class=\"line\">else</span><br><span class=\"line\">  b=1</span><br><span class=\"line\">fi</span><br><span class=\"line\">c=3</span><br><span class=\"line\">echo &quot;end&quot;</span><br></pre></td></tr></table></figure>\n<p>其执行输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before execute line:3, a=,b=,c=</span><br><span class=\"line\">before execute line:4, a=1,b=,c=</span><br><span class=\"line\">before execute line:6, a=1,b=,c=</span><br><span class=\"line\">before execute line:10, a=1,b=2,c=</span><br><span class=\"line\">before execute line:11, a=1,b=2,c=3</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用tee命令\"><a class=\"markdownIt-Anchor\" href=\"#使用tee命令\"></a> 使用tee命令</h2>\n<blockquote>\n<p>在shell脚本中管道以及输入输出重定向使用得非常多，在管道的作用下，一些命令的执行结果直接成为了下一条命令的输入。如果我们发现由管道连接起来的一批命令的执行结果并非如预期的那样，就需要逐步检查各条命令的执行结果来判断问题出在哪儿，但因为使用了管道，这些中间结果并不会显示在屏幕上，给调试带来了困难，此时我们就可以借助于tee命令了</p>\n</blockquote>\n<blockquote>\n<p>tee命令会从标准输入读取数据，将其内容输出到标准输出设备,同时又可将内容保存成文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipaddr=`/sbin/ifconfig | grep &apos;inet addr:&apos; | grep -v &apos;127.0.0.1&apos;</span><br><span class=\"line\">| tee temp.txt | cut -d : -f3 | awk &apos;&#123;print $1&#125;&apos;`</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用调试钩子\"><a class=\"markdownIt-Anchor\" href=\"#使用调试钩子\"></a> 使用&quot;调试钩子&quot;</h2>\n<blockquote>\n<p>在C语言程序中，我们经常使用DEBUG宏来控制是否要输出调试信息，在shell脚本中我们同样可以使用这样的机制，这样的代码块通常称之为“调试钩子”或“调试块”.如下列代码所示：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if [ “$DEBUG” = “true” ]; then</span><br><span class=\"line\">echo “debugging”  #此处可以输出调试信息</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过选项方式\"><a class=\"markdownIt-Anchor\" href=\"#通过选项方式\"></a> 通过选项方式</h2>\n<ul>\n<li>-n:选项只做语法检查，而不执行脚本  //sh -n script_name.sh</li>\n<li>-x:启动调试   //sh -x script_name.sh</li>\n</ul>\n<blockquote>\n<p>进入调试模式后，Shell依次执行读入的语句，产生的输出中有的带加号，有的不带。带加号表示该条语句是Shell执行的；不带加号表示该语句是Shell产生的输出；前面有“++”号的行是执行trap机制中指定的命令。&quot;+&quot;号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1).在命令行提供参数：$ sh -x script.sh</span><br><span class=\"line\">2).脚本开头提供参数：#!/bin/sh -x</span><br><span class=\"line\">3).在脚本中用set命令启用or禁用参数：其中set -x表启用，set +x表禁用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c:该选项使Shell解析器从字符串而非文件中读取并执行命令,如：bash -c ‘x=1;y=2;let z=x+y;echo “z=$z”’</li>\n<li>-v：区别于-x参数,该选项打印命令行的原始内容，-x参数打印出经过替换后命令行的内容，适用于仅想显示命令行的原始内容</li>\n<li>Ctrl + Z:中断调试，观察结果，然后再按fg键继续调试即可</li>\n<li>调试代码块:-x选项是调试整个脚本的，如果脚本很大，会很不方便，还有一种方法是调试某一块代码的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set -x</span><br><span class=\"line\">...</span><br><span class=\"line\">code block</span><br><span class=\"line\">...</span><br><span class=\"line\">set +x</span><br></pre></td></tr></table></figure>\n<h1 id=\"shell内置的环境变量\"><a class=\"markdownIt-Anchor\" href=\"#shell内置的环境变量\"></a> shell内置的环境变量</h1>\n<ul>\n<li>$LINENO：代表shell脚本的当前行号，类似于C语言中的内置宏__LINE__</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mi>U</mi><mi>N</mi><mi>C</mi><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi><mi mathvariant=\"normal\">：</mi><mi mathvariant=\"normal\">函</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">它</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">一</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">组</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">量</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">其</mi><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">包</mi><mi mathvariant=\"normal\">含</mi><mi mathvariant=\"normal\">了</mi><mi mathvariant=\"normal\">整</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">调</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">链</mi><mi mathvariant=\"normal\">上</mi><mi mathvariant=\"normal\">所</mi><mi mathvariant=\"normal\">有</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">函</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">故</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">量</mi></mrow><annotation encoding=\"application/x-tex\">FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">函</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">它</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">其</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">包</span><span class=\"mord cjk_fallback\">含</span><span class=\"mord cjk_fallback\">了</span><span class=\"mord cjk_fallback\">整</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">调</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">链</span><span class=\"mord cjk_fallback\">上</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">有</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">函</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">故</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span></span></span></span>{FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字，而变量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi>F</mi><mi>U</mi><mi>N</mi><mi>C</mi><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><mi mathvariant=\"normal\">则</mi><mi mathvariant=\"normal\">代</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">调</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">函</mi><mi mathvariant=\"normal\">数</mi></mrow><annotation encoding=\"application/x-tex\">{FUNCNAME[1]}则代表调用函数</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span><span class=\"mord cjk_fallback\">则</span><span class=\"mord cjk_fallback\">代</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">调</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">函</span><span class=\"mord cjk_fallback\">数</span></span></span></span>{FUNCNAME[0]}的函数的名字，余者可以依此类推</li>\n<li>$PS4：</li>\n</ul>\n<h1 id=\"常见错误诊断\"><a class=\"markdownIt-Anchor\" href=\"#常见错误诊断\"></a> 常见错误诊断</h1>\n<ul>\n<li><a href=\"http://xxx.sh\" target=\"_blank\" rel=\"noopener\">xxx.sh</a>: cannot shift</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这种错误一般是参数传递有误，比如没有给参数，或者参数个数少了。因为shell脚本使用shift来获取下一个参数，如果个数不对，shift命令就会失败</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://xxx.sh\" target=\"_blank\" rel=\"noopener\">xxx.sh</a>: ^M: not found</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^M是Windows上的回车符\\r在UNIX上的显示形式。这种情况多半是在Windows上编辑了shell脚本，然后拿到UNIX/Linux上执行。如下处理即可：</span><br><span class=\"line\">tr -d &quot;\\015&quot; &lt; oldfile.sh &gt; newfile.sh  //\\r的ASCII码是\\015</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h1>\n<blockquote>\n<p>shell编程在unix/linux世界中使用得非常广泛，熟练掌握shell编程也是成为一名优秀的unix/linux开发者和系统管理员的必经之路</p>\n</blockquote>\n<blockquote>\n<p>与其它高级语言相比，shell解释器缺乏相应的调试机制和调试工具的支持，其输出的错误信息又往往很不明确</p>\n</blockquote>\n<h1 id=\"调试方法\"><a class=\"markdownIt-Anchor\" href=\"#调试方法\"></a> 调试方法</h1>\n<h2 id=\"通过echo方式\"><a class=\"markdownIt-Anchor\" href=\"#通过echo方式\"></a> 通过echo方式</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">功能: 最简单的调试方法，可以在任何怀疑出错的地方用echo打印变量</span><br><span class=\"line\">场合: 所有怀疑可能有问题的地方</span><br><span class=\"line\">示例: echo $VAR</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过test的方式\"><a class=\"markdownIt-Anchor\" href=\"#通过test的方式\"></a> 通过test的方式</h2>\n<p>返回值为0为真,1表假</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test -f /test.sh | echo $?</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用调试工具-bashdb\"><a class=\"markdownIt-Anchor\" href=\"#使用调试工具-bashdb\"></a> 使用调试工具-bashdb</h2>\n<blockquote>\n<p>使用shell调试器bashdb，这是一个类似于GDB的调试工具，可以完成对shell脚本的断点设置，单步执行，变量观察等许多功能</p>\n</blockquote>\n<p>用法：bashdb -c <a href=\"http://script.sh\" target=\"_blank\" rel=\"noopener\">script.sh</a>   或者 bashdb <a href=\"http://script.sh\" target=\"_blank\" rel=\"noopener\">script.sh</a></p>\n<h2 id=\"通过trap来调试\"><a class=\"markdownIt-Anchor\" href=\"#通过trap来调试\"></a> 通过trap来调试</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用: 用于捕获指定的信号并执行预定义的命令</span><br><span class=\"line\">语法: trap `command` signal</span><br><span class=\"line\">说明: signal是要捕获的信号,command是捕获到指定的信号，所要执行的命令, 可以用kill -l命令看到系统中全部可用的信号名,捕获信号后所执行的命令,可以是一条或多条合法的Shell语句,也可以是一个函数名, Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助</span><br><span class=\"line\"></span><br><span class=\"line\">Shell脚本执行时，会产生三个伪信号(之所以称为伪信息，因这是shell自己产生，而非操作系统产生)，通过使用trap 捕获这三个伪信号并输出信息对调试大有帮助.SHELL三个伪信号:</span><br><span class=\"line\"></span><br><span class=\"line\">* EXIT  从一个函数中退出或整个执行完毕</span><br><span class=\"line\">* ERR   当一个命令执行不成功，返回非0状态时</span><br><span class=\"line\">* DEBUG 脚本中每一条命令执行之前</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">errorTrap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    echo &quot;[LINE:$1]Error: Command or function exited with status $?&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trap &apos;errorTrap $LINENO&apos; ERR</span><br><span class=\"line\">abc</span><br><span class=\"line\">foo</span><br><span class=\"line\">脚本输出:</span><br><span class=\"line\">[root@localhost:shell]# bash test.sh</span><br><span class=\"line\">test.sh: line 12: abc: command not found</span><br><span class=\"line\">[LINE:12]Error: Command or function exited with status 127</span><br><span class=\"line\">[LINE:9]Error: Command or function exited with status 1</span><br></pre></td></tr></table></figure>\n<p>在调试过程中，为了跟踪某些变量的值，我们常常需要在shell脚本的许多地方插入相同的echo语句来打印相关变量的值，这种做法显得烦琐而笨拙。而通过捕获DEBUG信号，我们只需要一条trap语句就可以完成对相关变量的全程跟踪。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">trap &apos;echo “before execute line:$LINENO, a=$a,b=$b,c=$c”&apos; DEBUG</span><br><span class=\"line\">a=1</span><br><span class=\"line\">if [ &quot;$a&quot; -eq 1 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  b=2</span><br><span class=\"line\">else</span><br><span class=\"line\">  b=1</span><br><span class=\"line\">fi</span><br><span class=\"line\">c=3</span><br><span class=\"line\">echo &quot;end&quot;</span><br></pre></td></tr></table></figure>\n<p>其执行输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before execute line:3, a=,b=,c=</span><br><span class=\"line\">before execute line:4, a=1,b=,c=</span><br><span class=\"line\">before execute line:6, a=1,b=,c=</span><br><span class=\"line\">before execute line:10, a=1,b=2,c=</span><br><span class=\"line\">before execute line:11, a=1,b=2,c=3</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用tee命令\"><a class=\"markdownIt-Anchor\" href=\"#使用tee命令\"></a> 使用tee命令</h2>\n<blockquote>\n<p>在shell脚本中管道以及输入输出重定向使用得非常多，在管道的作用下，一些命令的执行结果直接成为了下一条命令的输入。如果我们发现由管道连接起来的一批命令的执行结果并非如预期的那样，就需要逐步检查各条命令的执行结果来判断问题出在哪儿，但因为使用了管道，这些中间结果并不会显示在屏幕上，给调试带来了困难，此时我们就可以借助于tee命令了</p>\n</blockquote>\n<blockquote>\n<p>tee命令会从标准输入读取数据，将其内容输出到标准输出设备,同时又可将内容保存成文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipaddr=`/sbin/ifconfig | grep &apos;inet addr:&apos; | grep -v &apos;127.0.0.1&apos;</span><br><span class=\"line\">| tee temp.txt | cut -d : -f3 | awk &apos;&#123;print $1&#125;&apos;`</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用调试钩子\"><a class=\"markdownIt-Anchor\" href=\"#使用调试钩子\"></a> 使用&quot;调试钩子&quot;</h2>\n<blockquote>\n<p>在C语言程序中，我们经常使用DEBUG宏来控制是否要输出调试信息，在shell脚本中我们同样可以使用这样的机制，这样的代码块通常称之为“调试钩子”或“调试块”.如下列代码所示：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if [ “$DEBUG” = “true” ]; then</span><br><span class=\"line\">echo “debugging”  #此处可以输出调试信息</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过选项方式\"><a class=\"markdownIt-Anchor\" href=\"#通过选项方式\"></a> 通过选项方式</h2>\n<ul>\n<li>-n:选项只做语法检查，而不执行脚本  //sh -n script_name.sh</li>\n<li>-x:启动调试   //sh -x script_name.sh</li>\n</ul>\n<blockquote>\n<p>进入调试模式后，Shell依次执行读入的语句，产生的输出中有的带加号，有的不带。带加号表示该条语句是Shell执行的；不带加号表示该语句是Shell产生的输出；前面有“++”号的行是执行trap机制中指定的命令。&quot;+&quot;号后面显示的是经过了变量替换之后的命令行的内容，有助于分析实际执行的是什么命令</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1).在命令行提供参数：$ sh -x script.sh</span><br><span class=\"line\">2).脚本开头提供参数：#!/bin/sh -x</span><br><span class=\"line\">3).在脚本中用set命令启用or禁用参数：其中set -x表启用，set +x表禁用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-c:该选项使Shell解析器从字符串而非文件中读取并执行命令,如：bash -c ‘x=1;y=2;let z=x+y;echo “z=$z”’</li>\n<li>-v：区别于-x参数,该选项打印命令行的原始内容，-x参数打印出经过替换后命令行的内容，适用于仅想显示命令行的原始内容</li>\n<li>Ctrl + Z:中断调试，观察结果，然后再按fg键继续调试即可</li>\n<li>调试代码块:-x选项是调试整个脚本的，如果脚本很大，会很不方便，还有一种方法是调试某一块代码的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set -x</span><br><span class=\"line\">...</span><br><span class=\"line\">code block</span><br><span class=\"line\">...</span><br><span class=\"line\">set +x</span><br></pre></td></tr></table></figure>\n<h1 id=\"shell内置的环境变量\"><a class=\"markdownIt-Anchor\" href=\"#shell内置的环境变量\"></a> shell内置的环境变量</h1>\n<ul>\n<li>$LINENO：代表shell脚本的当前行号，类似于C语言中的内置宏__LINE__</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mi>U</mi><mi>N</mi><mi>C</mi><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi><mi mathvariant=\"normal\">：</mi><mi mathvariant=\"normal\">函</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">它</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">一</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">组</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">量</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">其</mi><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">包</mi><mi mathvariant=\"normal\">含</mi><mi mathvariant=\"normal\">了</mi><mi mathvariant=\"normal\">整</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">调</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">链</mi><mi mathvariant=\"normal\">上</mi><mi mathvariant=\"normal\">所</mi><mi mathvariant=\"normal\">有</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">函</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">故</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">量</mi></mrow><annotation encoding=\"application/x-tex\">FUNCNAME：函数的名字，它是一个数组变量，其中包含了整个调用链上所有的函数的名字，故变量</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">函</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">它</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">其</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">包</span><span class=\"mord cjk_fallback\">含</span><span class=\"mord cjk_fallback\">了</span><span class=\"mord cjk_fallback\">整</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">调</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">链</span><span class=\"mord cjk_fallback\">上</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">有</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">函</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">故</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span></span></span></span>{FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字，而变量<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi>F</mi><mi>U</mi><mi>N</mi><mi>C</mi><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><mi mathvariant=\"normal\">则</mi><mi mathvariant=\"normal\">代</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">调</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">函</mi><mi mathvariant=\"normal\">数</mi></mrow><annotation encoding=\"application/x-tex\">{FUNCNAME[1]}则代表调用函数</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span><span class=\"mord cjk_fallback\">则</span><span class=\"mord cjk_fallback\">代</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">调</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">函</span><span class=\"mord cjk_fallback\">数</span></span></span></span>{FUNCNAME[0]}的函数的名字，余者可以依此类推</li>\n<li>$PS4：</li>\n</ul>\n<h1 id=\"常见错误诊断\"><a class=\"markdownIt-Anchor\" href=\"#常见错误诊断\"></a> 常见错误诊断</h1>\n<ul>\n<li><a href=\"http://xxx.sh\" target=\"_blank\" rel=\"noopener\">xxx.sh</a>: cannot shift</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这种错误一般是参数传递有误，比如没有给参数，或者参数个数少了。因为shell脚本使用shift来获取下一个参数，如果个数不对，shift命令就会失败</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://xxx.sh\" target=\"_blank\" rel=\"noopener\">xxx.sh</a>: ^M: not found</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^M是Windows上的回车符\\r在UNIX上的显示形式。这种情况多半是在Windows上编辑了shell脚本，然后拿到UNIX/Linux上执行。如下处理即可：</span><br><span class=\"line\">tr -d &quot;\\015&quot; &lt; oldfile.sh &gt; newfile.sh  //\\r的ASCII码是\\015</span><br></pre></td></tr></table></figure>"},{"title":"VI编辑器使用","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n> vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，对Unix及Linux系统的任何版本，vi编辑器是完全相同的。\n\n# vi的基本概念\n1. 命令行模式command mode\n> 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode；\n2. 插入模式（Insert mode）\n> 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式\n3. 底行模式（last line mode）\n> 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……\n\n不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）\n# vi的基本操作\n1. 进入vi的命令\n~~~\nvi filename:打开或新建文件，并将光标置于第一行首\nvi +n filename：打开文件，并将光标置于第n行首\nvi + filename ：打开文件，并将光标置于最后一行首\nvi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处\nvi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename\nvi filename....filename ：打开多个文件，依次编辑\n~~~\n2. 退出vi及保存文件\n> 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」\n~~~\n: w filename （输入 「w filename」将文章以指定的文件名filename保存）\n: wq (输入「wq」，存盘并退出vi)\n: q! (输入q!， 不存盘强制退出vi)\n~~~\n3. 移动光标\n~~~\n按「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。\n按「ctrl」+「b」：屏幕往\"后\"移动一页\n按「ctrl」+「f」：屏幕往\"前\"移动一页\n按「ctrl」+「u」：屏幕往\"后\"移动半页\n按「ctrl」+「d」：屏幕往\"前\"移动半页\n按数字「0」：移到文章的开头\n按「G」：移动到文章的最后\n按「$」：移动到光标所在行的\"行尾\"\n按「^」：移动到光标所在行的\"行首\"\n按「w」：光标跳到下个字的开头\n按「e」：光标跳到下个字的字尾\n按「b」：光标回到上个字的开头\n按「#l」：光标移到该行的第#个位置，如：5l,56l\n~~~\n4. 删除文字\n~~~\n「x」：每按一次，删除光标所在位置的\"后面\"一个字符\n「#x」：例如，「6x」表示删除光标所在位置的\"后面\"6个字符\n「X」：大写的X，每按一次，删除光标所在位置的\"前面\"一个字符\n「#X」：例如，「20X」表示删除光标所在位置的\"前面\"20个字符\n「dd」：删除光标所在行\n「#dd」：从光标所在行开始删除#行\n~~~\n5. 复制\n~~~\n「yw」：将光标所在之处到字尾的字符复制到缓冲区中\n「#yw」：复制#个字到缓冲区\n「yy」：复制光标所在行到缓冲区\n「#yy」：例如，「6yy」表示拷贝从光标所在的该行\"往下数\"6行文字\n「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与\"y\"有关的复制命令都必须与\"p\"配合才能完成复制与粘贴功能\n~~~\n6. 恢复上一次操作\n~~~\n「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次\"u\"可以执行多次恢复\n~~~\n7. 跳至指定的行\n~~~\n「ctrl」+「g」列出光标所在行的行号\n「#G」：例如，「15G」，表示移动光标至文章的第15行行首\n~~~\n8. 列出行号\n~~~\n命令行模式：输入「set nu」后，会在文件中的每一行前面列出行号\n~~~\n9. 跳到文件中的某一行\n~~~\n命令行模式：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行\n~~~\n10. 查找字符\n~~~\n* 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止;\n* 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止\n~~~","source":"_posts/Linux/VI编辑器使用.md","raw":"---\ntitle: VI编辑器使用\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n> vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，对Unix及Linux系统的任何版本，vi编辑器是完全相同的。\n\n# vi的基本概念\n1. 命令行模式command mode\n> 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode；\n2. 插入模式（Insert mode）\n> 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式\n3. 底行模式（last line mode）\n> 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……\n\n不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）\n# vi的基本操作\n1. 进入vi的命令\n~~~\nvi filename:打开或新建文件，并将光标置于第一行首\nvi +n filename：打开文件，并将光标置于第n行首\nvi + filename ：打开文件，并将光标置于最后一行首\nvi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处\nvi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename\nvi filename....filename ：打开多个文件，依次编辑\n~~~\n2. 退出vi及保存文件\n> 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」\n~~~\n: w filename （输入 「w filename」将文章以指定的文件名filename保存）\n: wq (输入「wq」，存盘并退出vi)\n: q! (输入q!， 不存盘强制退出vi)\n~~~\n3. 移动光标\n~~~\n按「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。\n按「ctrl」+「b」：屏幕往\"后\"移动一页\n按「ctrl」+「f」：屏幕往\"前\"移动一页\n按「ctrl」+「u」：屏幕往\"后\"移动半页\n按「ctrl」+「d」：屏幕往\"前\"移动半页\n按数字「0」：移到文章的开头\n按「G」：移动到文章的最后\n按「$」：移动到光标所在行的\"行尾\"\n按「^」：移动到光标所在行的\"行首\"\n按「w」：光标跳到下个字的开头\n按「e」：光标跳到下个字的字尾\n按「b」：光标回到上个字的开头\n按「#l」：光标移到该行的第#个位置，如：5l,56l\n~~~\n4. 删除文字\n~~~\n「x」：每按一次，删除光标所在位置的\"后面\"一个字符\n「#x」：例如，「6x」表示删除光标所在位置的\"后面\"6个字符\n「X」：大写的X，每按一次，删除光标所在位置的\"前面\"一个字符\n「#X」：例如，「20X」表示删除光标所在位置的\"前面\"20个字符\n「dd」：删除光标所在行\n「#dd」：从光标所在行开始删除#行\n~~~\n5. 复制\n~~~\n「yw」：将光标所在之处到字尾的字符复制到缓冲区中\n「#yw」：复制#个字到缓冲区\n「yy」：复制光标所在行到缓冲区\n「#yy」：例如，「6yy」表示拷贝从光标所在的该行\"往下数\"6行文字\n「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与\"y\"有关的复制命令都必须与\"p\"配合才能完成复制与粘贴功能\n~~~\n6. 恢复上一次操作\n~~~\n「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次\"u\"可以执行多次恢复\n~~~\n7. 跳至指定的行\n~~~\n「ctrl」+「g」列出光标所在行的行号\n「#G」：例如，「15G」，表示移动光标至文章的第15行行首\n~~~\n8. 列出行号\n~~~\n命令行模式：输入「set nu」后，会在文件中的每一行前面列出行号\n~~~\n9. 跳到文件中的某一行\n~~~\n命令行模式：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行\n~~~\n10. 查找字符\n~~~\n* 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止;\n* 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止\n~~~","slug":"Linux-VI编辑器使用","published":1,"updated":"2019-02-14T05:54:21.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudy9002t5b8h1e5ucu7q","content":"<blockquote>\n<p>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，对Unix及Linux系统的任何版本，vi编辑器是完全相同的。</p>\n</blockquote>\n<h1 id=\"vi的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#vi的基本概念\"></a> vi的基本概念</h1>\n<ol>\n<li>命令行模式command mode</li>\n</ol>\n<blockquote>\n<p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode；</p>\n</blockquote>\n<ol start=\"2\">\n<li>插入模式（Insert mode）</li>\n</ol>\n<blockquote>\n<p>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式</p>\n</blockquote>\n<ol start=\"3\">\n<li>底行模式（last line mode）</li>\n</ol>\n<blockquote>\n<p>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……</p>\n</blockquote>\n<p>不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）</p>\n<h1 id=\"vi的基本操作\"><a class=\"markdownIt-Anchor\" href=\"#vi的基本操作\"></a> vi的基本操作</h1>\n<ol>\n<li>进入vi的命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi filename:打开或新建文件，并将光标置于第一行首</span><br><span class=\"line\">vi +n filename：打开文件，并将光标置于第n行首</span><br><span class=\"line\">vi + filename ：打开文件，并将光标置于最后一行首</span><br><span class=\"line\">vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处</span><br><span class=\"line\">vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename</span><br><span class=\"line\">vi filename....filename ：打开多个文件，依次编辑</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>退出vi及保存文件</li>\n</ol>\n<blockquote>\n<p>在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">: w filename （输入 「w filename」将文章以指定的文件名filename保存）</span><br><span class=\"line\">: wq (输入「wq」，存盘并退出vi)</span><br><span class=\"line\">: q! (输入q!， 不存盘强制退出vi)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>移动光标</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">按「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。</span><br><span class=\"line\">按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页</span><br><span class=\"line\">按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页</span><br><span class=\"line\">按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页</span><br><span class=\"line\">按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页</span><br><span class=\"line\">按数字「0」：移到文章的开头</span><br><span class=\"line\">按「G」：移动到文章的最后</span><br><span class=\"line\">按「$」：移动到光标所在行的&quot;行尾&quot;</span><br><span class=\"line\">按「^」：移动到光标所在行的&quot;行首&quot;</span><br><span class=\"line\">按「w」：光标跳到下个字的开头</span><br><span class=\"line\">按「e」：光标跳到下个字的字尾</span><br><span class=\"line\">按「b」：光标回到上个字的开头</span><br><span class=\"line\">按「#l」：光标移到该行的第#个位置，如：5l,56l</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>删除文字</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符</span><br><span class=\"line\">「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符</span><br><span class=\"line\">「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符</span><br><span class=\"line\">「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符</span><br><span class=\"line\">「dd」：删除光标所在行</span><br><span class=\"line\">「#dd」：从光标所在行开始删除#行</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>复制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「yw」：将光标所在之处到字尾的字符复制到缓冲区中</span><br><span class=\"line\">「#yw」：复制#个字到缓冲区</span><br><span class=\"line\">「yy」：复制光标所在行到缓冲区</span><br><span class=\"line\">「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字</span><br><span class=\"line\">「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>恢复上一次操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次恢复</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>跳至指定的行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「ctrl」+「g」列出光标所在行的行号</span><br><span class=\"line\">「#G」：例如，「15G」，表示移动光标至文章的第15行行首</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>列出行号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令行模式：输入「set nu」后，会在文件中的每一行前面列出行号</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>跳到文件中的某一行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令行模式：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>查找字符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止;</span><br><span class=\"line\">* 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，对Unix及Linux系统的任何版本，vi编辑器是完全相同的。</p>\n</blockquote>\n<h1 id=\"vi的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#vi的基本概念\"></a> vi的基本概念</h1>\n<ol>\n<li>命令行模式command mode</li>\n</ol>\n<blockquote>\n<p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode；</p>\n</blockquote>\n<ol start=\"2\">\n<li>插入模式（Insert mode）</li>\n</ol>\n<blockquote>\n<p>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式</p>\n</blockquote>\n<ol start=\"3\">\n<li>底行模式（last line mode）</li>\n</ol>\n<blockquote>\n<p>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……</p>\n</blockquote>\n<p>不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）</p>\n<h1 id=\"vi的基本操作\"><a class=\"markdownIt-Anchor\" href=\"#vi的基本操作\"></a> vi的基本操作</h1>\n<ol>\n<li>进入vi的命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi filename:打开或新建文件，并将光标置于第一行首</span><br><span class=\"line\">vi +n filename：打开文件，并将光标置于第n行首</span><br><span class=\"line\">vi + filename ：打开文件，并将光标置于最后一行首</span><br><span class=\"line\">vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处</span><br><span class=\"line\">vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename</span><br><span class=\"line\">vi filename....filename ：打开多个文件，依次编辑</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>退出vi及保存文件</li>\n</ol>\n<blockquote>\n<p>在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">: w filename （输入 「w filename」将文章以指定的文件名filename保存）</span><br><span class=\"line\">: wq (输入「wq」，存盘并退出vi)</span><br><span class=\"line\">: q! (输入q!， 不存盘强制退出vi)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>移动光标</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">按「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。</span><br><span class=\"line\">按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页</span><br><span class=\"line\">按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页</span><br><span class=\"line\">按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页</span><br><span class=\"line\">按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页</span><br><span class=\"line\">按数字「0」：移到文章的开头</span><br><span class=\"line\">按「G」：移动到文章的最后</span><br><span class=\"line\">按「$」：移动到光标所在行的&quot;行尾&quot;</span><br><span class=\"line\">按「^」：移动到光标所在行的&quot;行首&quot;</span><br><span class=\"line\">按「w」：光标跳到下个字的开头</span><br><span class=\"line\">按「e」：光标跳到下个字的字尾</span><br><span class=\"line\">按「b」：光标回到上个字的开头</span><br><span class=\"line\">按「#l」：光标移到该行的第#个位置，如：5l,56l</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>删除文字</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符</span><br><span class=\"line\">「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符</span><br><span class=\"line\">「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符</span><br><span class=\"line\">「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符</span><br><span class=\"line\">「dd」：删除光标所在行</span><br><span class=\"line\">「#dd」：从光标所在行开始删除#行</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>复制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「yw」：将光标所在之处到字尾的字符复制到缓冲区中</span><br><span class=\"line\">「#yw」：复制#个字到缓冲区</span><br><span class=\"line\">「yy」：复制光标所在行到缓冲区</span><br><span class=\"line\">「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字</span><br><span class=\"line\">「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>恢复上一次操作</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次恢复</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>跳至指定的行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「ctrl」+「g」列出光标所在行的行号</span><br><span class=\"line\">「#G」：例如，「15G」，表示移动光标至文章的第15行行首</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>列出行号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令行模式：输入「set nu」后，会在文件中的每一行前面列出行号</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>跳到文件中的某一行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令行模式：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>查找字符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止;</span><br><span class=\"line\">* 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止</span><br></pre></td></tr></table></figure>"},{"title":"cat和EOF的使用+action用法","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 简介\n* cat：用于显示文本文件内容，全部输出\n* EOF： “end of file”，表示文本结束符\n\n> EOF“通常与”<<“结合使用，“<<EOF“表示后续的输入作为子命令或子shell的输入，直到遇到”EOF“，再次返回到主调shell，可将其理解为分界符（delimiter）\n\n> 当shell看到”<<“知道其后面输入的分界符，当shell再次看到分界符时，两个分界符中间的部分将作为标准输入,其使用形式如下：\n\n~~~\n交互式程序(命令)<<EOF\ncommand1\ncommand2\n...\nEOF     //最后的”EOF“必须单独占一行，必须顶行写，前面不能用制表符或者空格\n~~~\n\n# cat+EOF的使用\n> 第一种形式和第二种形式没有什么本质的区别，第一种形式将内容直接输出到标准输出（屏幕），而第二种形式将标准输出进行重定向，将本应输出到屏幕的内容重定向到文件\n\n1. cat<<EOF\n2. cat<<EOF>filename或者cat>>filename<<EOF\n\n==说明==：关于“>”、“>>”、“<”、“<<”等的意思，请自行查看bash的介绍\n\n# EOF与-EOF的区别\n\n> 如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。\n而<<-就是为了解决这一问题:\n\n> 如果重定向的操作符是<<-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除\n---\n\n# action  \"\" /bin/true 的用法\n> action是个bash的函数.true命令啥都不做，只设置退出码为0\n\n> 使用举例：==action “操作成功！” /bin/true==\n~~~\n# Run some action. Log its output.\naction() {\n  local STRING rc\n\n  STRING=$1\n  echo -n \"$STRING \"\n  shift\n  \"$@\" && success $\"$STRING\" || failure $\"$STRING\"\n  rc=$?\n  echo\n  return $rc\n}\n~~~","source":"_posts/Linux/cat和EOF的使用+action用法.md","raw":"---\ntitle: cat和EOF的使用+action用法\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n# 简介\n* cat：用于显示文本文件内容，全部输出\n* EOF： “end of file”，表示文本结束符\n\n> EOF“通常与”<<“结合使用，“<<EOF“表示后续的输入作为子命令或子shell的输入，直到遇到”EOF“，再次返回到主调shell，可将其理解为分界符（delimiter）\n\n> 当shell看到”<<“知道其后面输入的分界符，当shell再次看到分界符时，两个分界符中间的部分将作为标准输入,其使用形式如下：\n\n~~~\n交互式程序(命令)<<EOF\ncommand1\ncommand2\n...\nEOF     //最后的”EOF“必须单独占一行，必须顶行写，前面不能用制表符或者空格\n~~~\n\n# cat+EOF的使用\n> 第一种形式和第二种形式没有什么本质的区别，第一种形式将内容直接输出到标准输出（屏幕），而第二种形式将标准输出进行重定向，将本应输出到屏幕的内容重定向到文件\n\n1. cat<<EOF\n2. cat<<EOF>filename或者cat>>filename<<EOF\n\n==说明==：关于“>”、“>>”、“<”、“<<”等的意思，请自行查看bash的介绍\n\n# EOF与-EOF的区别\n\n> 如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。\n而<<-就是为了解决这一问题:\n\n> 如果重定向的操作符是<<-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除\n---\n\n# action  \"\" /bin/true 的用法\n> action是个bash的函数.true命令啥都不做，只设置退出码为0\n\n> 使用举例：==action “操作成功！” /bin/true==\n~~~\n# Run some action. Log its output.\naction() {\n  local STRING rc\n\n  STRING=$1\n  echo -n \"$STRING \"\n  shift\n  \"$@\" && success $\"$STRING\" || failure $\"$STRING\"\n  rc=$?\n  echo\n  return $rc\n}\n~~~","slug":"Linux-cat和EOF的使用-action用法","published":1,"updated":"2019-02-14T05:43:09.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudya002v5b8hdsl1a93z","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>cat：用于显示文本文件内容，全部输出</li>\n<li>EOF： “end of file”，表示文本结束符</li>\n</ul>\n<blockquote>\n<p>EOF“通常与”&lt;&lt;“结合使用，“&lt;&lt;EOF“表示后续的输入作为子命令或子shell的输入，直到遇到”EOF“，再次返回到主调shell，可将其理解为分界符（delimiter）</p>\n</blockquote>\n<blockquote>\n<p>当shell看到”&lt;&lt;“知道其后面输入的分界符，当shell再次看到分界符时，两个分界符中间的部分将作为标准输入,其使用形式如下：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">交互式程序(命令)&lt;&lt;EOF</span><br><span class=\"line\">command1</span><br><span class=\"line\">command2</span><br><span class=\"line\">...</span><br><span class=\"line\">EOF     //最后的”EOF“必须单独占一行，必须顶行写，前面不能用制表符或者空格</span><br></pre></td></tr></table></figure>\n<h1 id=\"cateof的使用\"><a class=\"markdownIt-Anchor\" href=\"#cateof的使用\"></a> cat+EOF的使用</h1>\n<blockquote>\n<p>第一种形式和第二种形式没有什么本质的区别，第一种形式将内容直接输出到标准输出（屏幕），而第二种形式将标准输出进行重定向，将本应输出到屏幕的内容重定向到文件</p>\n</blockquote>\n<ol>\n<li>cat&lt;&lt;EOF</li>\n<li>cat&lt;<eof>filename或者cat&gt;&gt;filename&lt;&lt;EOF</eof></li>\n</ol>\n<p>==说明==：关于“&gt;”、“&gt;&gt;”、“&lt;”、“&lt;&lt;”等的意思，请自行查看bash的介绍</p>\n<h1 id=\"eof与-eof的区别\"><a class=\"markdownIt-Anchor\" href=\"#eof与-eof的区别\"></a> EOF与-EOF的区别</h1>\n<blockquote>\n<p>如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。<br>\n而&lt;&lt;-就是为了解决这一问题:</p>\n</blockquote>\n<blockquote>\n<p>如果重定向的操作符是&lt;&lt;-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除</p>\n</blockquote>\n<hr>\n<h1 id=\"action-bintrue-的用法\"><a class=\"markdownIt-Anchor\" href=\"#action-bintrue-的用法\"></a> action  “” /bin/true 的用法</h1>\n<blockquote>\n<p>action是个bash的函数.true命令啥都不做，只设置退出码为0</p>\n</blockquote>\n<blockquote>\n<p>使用举例：==action “操作成功！” /bin/true==</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run some action. Log its output.</span><br><span class=\"line\">action() &#123;</span><br><span class=\"line\">  local STRING rc</span><br><span class=\"line\"></span><br><span class=\"line\">  STRING=$1</span><br><span class=\"line\">  echo -n &quot;$STRING &quot;</span><br><span class=\"line\">  shift</span><br><span class=\"line\">  &quot;$@&quot; &amp;&amp; success $&quot;$STRING&quot; || failure $&quot;$STRING&quot;</span><br><span class=\"line\">  rc=$?</span><br><span class=\"line\">  echo</span><br><span class=\"line\">  return $rc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>cat：用于显示文本文件内容，全部输出</li>\n<li>EOF： “end of file”，表示文本结束符</li>\n</ul>\n<blockquote>\n<p>EOF“通常与”&lt;&lt;“结合使用，“&lt;&lt;EOF“表示后续的输入作为子命令或子shell的输入，直到遇到”EOF“，再次返回到主调shell，可将其理解为分界符（delimiter）</p>\n</blockquote>\n<blockquote>\n<p>当shell看到”&lt;&lt;“知道其后面输入的分界符，当shell再次看到分界符时，两个分界符中间的部分将作为标准输入,其使用形式如下：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">交互式程序(命令)&lt;&lt;EOF</span><br><span class=\"line\">command1</span><br><span class=\"line\">command2</span><br><span class=\"line\">...</span><br><span class=\"line\">EOF     //最后的”EOF“必须单独占一行，必须顶行写，前面不能用制表符或者空格</span><br></pre></td></tr></table></figure>\n<h1 id=\"cateof的使用\"><a class=\"markdownIt-Anchor\" href=\"#cateof的使用\"></a> cat+EOF的使用</h1>\n<blockquote>\n<p>第一种形式和第二种形式没有什么本质的区别，第一种形式将内容直接输出到标准输出（屏幕），而第二种形式将标准输出进行重定向，将本应输出到屏幕的内容重定向到文件</p>\n</blockquote>\n<ol>\n<li>cat&lt;&lt;EOF</li>\n<li>cat&lt;<eof>filename或者cat&gt;&gt;filename&lt;&lt;EOF</eof></li>\n</ol>\n<p>==说明==：关于“&gt;”、“&gt;&gt;”、“&lt;”、“&lt;&lt;”等的意思，请自行查看bash的介绍</p>\n<h1 id=\"eof与-eof的区别\"><a class=\"markdownIt-Anchor\" href=\"#eof与-eof的区别\"></a> EOF与-EOF的区别</h1>\n<blockquote>\n<p>如果结束分解符EOF前有制表符或者空格，则EOF不会被当做结束分界符，只会继续被当做stdin来输入。<br>\n而&lt;&lt;-就是为了解决这一问题:</p>\n</blockquote>\n<blockquote>\n<p>如果重定向的操作符是&lt;&lt;-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除</p>\n</blockquote>\n<hr>\n<h1 id=\"action-bintrue-的用法\"><a class=\"markdownIt-Anchor\" href=\"#action-bintrue-的用法\"></a> action  “” /bin/true 的用法</h1>\n<blockquote>\n<p>action是个bash的函数.true命令啥都不做，只设置退出码为0</p>\n</blockquote>\n<blockquote>\n<p>使用举例：==action “操作成功！” /bin/true==</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run some action. Log its output.</span><br><span class=\"line\">action() &#123;</span><br><span class=\"line\">  local STRING rc</span><br><span class=\"line\"></span><br><span class=\"line\">  STRING=$1</span><br><span class=\"line\">  echo -n &quot;$STRING &quot;</span><br><span class=\"line\">  shift</span><br><span class=\"line\">  &quot;$@&quot; &amp;&amp; success $&quot;$STRING&quot; || failure $&quot;$STRING&quot;</span><br><span class=\"line\">  rc=$?</span><br><span class=\"line\">  echo</span><br><span class=\"line\">  return $rc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"linux 磁盘分区工具","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n\nGParted是一款linux下的功能非常强大的分区工具，和windows下的‘分区魔术师’类似，操作和显示上也很相似。GParted可以方便的创建、删除分区，也可以调整分区的大小和移动分区的位置。GParted支持多种linux下常见的分区格式，包括ext2、ext4、fat、hfs、jfs、reiser4、reiserfs、xfs，甚至ntfs。另外官方还提供了 LiveCD 和 LiveUSB 版本的 GParted，方便在没有主系统的情况下对硬盘进行分区！\nGParted可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区已安装新操作系统、备份特定分区到另一块硬盘等。 　　\nGParted使用libparted来识别、调整分区表，并有各个文件系统工具来处理分区上的文件系统。这些文件系统工具并不是必须的，但要处理一中文件系统就必须先安装相应的工具。 　　\nGParted使用C++写成，使用gtkmm提供GTK+界面。 　　\nGParted项目还提供了一个包含GParted和全部文件系统工具的Live CD，也可以制作成Live USB或使用其他介质。这个Live CD系统基于Debian GNU/Linux。其它Linux Live CD版本也大多包含GParted，如Knoppix等。\n\n运行环境：Win2003,WinXP,Win2000,Win9X软件大小：140.3 MB\n\n下载地址：\nhttp://centoscn.com/plus/download.php?open=2&id=139&uhash=b720444ddecfffb41999608b","source":"_posts/Linux/linux 磁盘分区工具.md","raw":"---\ntitle: linux 磁盘分区工具\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n\nGParted是一款linux下的功能非常强大的分区工具，和windows下的‘分区魔术师’类似，操作和显示上也很相似。GParted可以方便的创建、删除分区，也可以调整分区的大小和移动分区的位置。GParted支持多种linux下常见的分区格式，包括ext2、ext4、fat、hfs、jfs、reiser4、reiserfs、xfs，甚至ntfs。另外官方还提供了 LiveCD 和 LiveUSB 版本的 GParted，方便在没有主系统的情况下对硬盘进行分区！\nGParted可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区已安装新操作系统、备份特定分区到另一块硬盘等。 　　\nGParted使用libparted来识别、调整分区表，并有各个文件系统工具来处理分区上的文件系统。这些文件系统工具并不是必须的，但要处理一中文件系统就必须先安装相应的工具。 　　\nGParted使用C++写成，使用gtkmm提供GTK+界面。 　　\nGParted项目还提供了一个包含GParted和全部文件系统工具的Live CD，也可以制作成Live USB或使用其他介质。这个Live CD系统基于Debian GNU/Linux。其它Linux Live CD版本也大多包含GParted，如Knoppix等。\n\n运行环境：Win2003,WinXP,Win2000,Win9X软件大小：140.3 MB\n\n下载地址：\nhttp://centoscn.com/plus/download.php?open=2&id=139&uhash=b720444ddecfffb41999608b","slug":"Linux-linux-磁盘分区工具","published":1,"updated":"2019-02-14T05:57:04.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyc002y5b8hm8wkm03d","content":"<p>GParted是一款linux下的功能非常强大的分区工具，和windows下的‘分区魔术师’类似，操作和显示上也很相似。GParted可以方便的创建、删除分区，也可以调整分区的大小和移动分区的位置。GParted支持多种linux下常见的分区格式，包括ext2、ext4、fat、hfs、jfs、reiser4、reiserfs、xfs，甚至ntfs。另外官方还提供了 LiveCD 和 LiveUSB 版本的 GParted，方便在没有主系统的情况下对硬盘进行分区！<br>\nGParted可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区已安装新操作系统、备份特定分区到另一块硬盘等。 　　<br>\nGParted使用libparted来识别、调整分区表，并有各个文件系统工具来处理分区上的文件系统。这些文件系统工具并不是必须的，但要处理一中文件系统就必须先安装相应的工具。 　　<br>\nGParted使用C++写成，使用gtkmm提供GTK+界面。 　　<br>\nGParted项目还提供了一个包含GParted和全部文件系统工具的Live CD，也可以制作成Live USB或使用其他介质。这个Live CD系统基于Debian GNU/Linux。其它Linux Live CD版本也大多包含GParted，如Knoppix等。</p>\n<p>运行环境：Win2003,WinXP,Win2000,Win9X软件大小：140.3 MB</p>\n<p>下载地址：<br>\n<a href=\"http://centoscn.com/plus/download.php?open=2&amp;id=139&amp;uhash=b720444ddecfffb41999608b\" target=\"_blank\" rel=\"noopener\">http://centoscn.com/plus/download.php?open=2&amp;id=139&amp;uhash=b720444ddecfffb41999608b</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>GParted是一款linux下的功能非常强大的分区工具，和windows下的‘分区魔术师’类似，操作和显示上也很相似。GParted可以方便的创建、删除分区，也可以调整分区的大小和移动分区的位置。GParted支持多种linux下常见的分区格式，包括ext2、ext4、fat、hfs、jfs、reiser4、reiserfs、xfs，甚至ntfs。另外官方还提供了 LiveCD 和 LiveUSB 版本的 GParted，方便在没有主系统的情况下对硬盘进行分区！<br>\nGParted可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区已安装新操作系统、备份特定分区到另一块硬盘等。 　　<br>\nGParted使用libparted来识别、调整分区表，并有各个文件系统工具来处理分区上的文件系统。这些文件系统工具并不是必须的，但要处理一中文件系统就必须先安装相应的工具。 　　<br>\nGParted使用C++写成，使用gtkmm提供GTK+界面。 　　<br>\nGParted项目还提供了一个包含GParted和全部文件系统工具的Live CD，也可以制作成Live USB或使用其他介质。这个Live CD系统基于Debian GNU/Linux。其它Linux Live CD版本也大多包含GParted，如Knoppix等。</p>\n<p>运行环境：Win2003,WinXP,Win2000,Win9X软件大小：140.3 MB</p>\n<p>下载地址：<br>\n<a href=\"http://centoscn.com/plus/download.php?open=2&amp;id=139&amp;uhash=b720444ddecfffb41999608b\" target=\"_blank\" rel=\"noopener\">http://centoscn.com/plus/download.php?open=2&amp;id=139&amp;uhash=b720444ddecfffb41999608b</a></p>\n"},{"title":"使用Vundle管理配置Vim基本插件","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 说明\n官网：https://github.com/VundleVim/Vundle.vim\n> Vundle是基于Git仓库的插件管理软件。Vundle将插件的安装简化为类似yum软件安装的过程\n\n> 其特色在于使用git来管理插件,更新方便，支持搜索，一键更新，从此只需要一个vimrc走天下\n\n# 配置说明\n1. 在Github vim-scripts 用户下的repos,只需要写出repos名称\n2. 在Github其他用户下的repos, 需要写出”用户名/repos名”\n3. 不在Github上的插件，需要写出git全路径\n\n具体步骤：\n\n1. 需要有git环境，CentOS7自带，可通过git命令查看\n2. 安装Vundle：git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n3. 修改.vimrc／vimrc文件，在CentOS7中是vimrc文件，修改前先备份.\n* 将以下内容放置到文件最开头，最小配置如下：\n~~~\nset nocompatibl \nfiletype off\n\nset rtp+=~/.vim/bundle/Vundle.vim\n\ncall vundle#begin()\n\nPlugin 'VundleVim/Vundle.vim'\n\ncall vundle#end()\n\nfiletype plugin indent on\n~~~\n在Plugin之后，添加自己想要安装的插件\n4. 插件安装： \n~~~\n# 在vim中\n:PluginInstall\n\n# 在终端\nvim +PluginInstall +qall\n~~~\n# 命令说明\n~~~\n:PluginList -列举出列表中(.vimrc中)配置的所有插件\n:PluginInstall -安装列表中全部插件\n:PluginInstall! -更新列表中全部插件\n:PluginSearch foo -查找foo插件\n:PluginSearch! foo -刷新foo插件缓存\n:PluginClean -清除列表中没有的插件\n:PluginClean! -清除列表中没有的插件\n~~~\n\n# 常用插件说明\n* rename.vim：在Vim中为文件重命名。\n* vim-coffee-script：在Vim中舒心 的编写、编译Coffeescript。\n* vim-mkdir：当你在Vim中新建文件的时候， 自动帮你创建不存在的目录。\n* vim-surround：快速的删除、修改和添加 括号、引号、XML标签等等。\n* matchit：用%去在两个对应的字符间跳转。\n* tComment：快速注释、反注释代码。\n* emmet-vim：Emmet的Vim版。\n* tabular：快速对齐。\n* snipmate.vim：快速的代码片段。\n* vim-easymotion：在文件中快速定位。\n* vim-instant-markdown：Vim中对 \n* Markdown文档的实时预览。\n* NERDTree:一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录\n* MiniBufExplorer:提供多文件同时编辑功能，并在编辑器上方显示文件的标签\n* 一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件\n* \n\n# 网络上配置收藏\n1. https://github.com/deepzz0/dotfiles/blob/master/.vimrc\n2.\n~~~\nif &compatible\n  set nocompatible\nend\n\nfiletype off\nset rtp+=~/.vim/bundle/vundle/\ncall vundle#rc()\n\n\" Let Vundle manage Vundle\nBundle 'gmarik/vundle'\n\n\" Define bundles via Github repos\nBundle 'christoomey/vim-run-interactive'\nBundle 'croaky/vim-colors-github'\nBundle 'danro/rename.vim'\nBundle 'kchmck/vim-coffee-script'\nBundle 'kien/ctrlp.vim'\nBundle 'pbrisbin/vim-mkdir'\nBundle 'scrooloose/syntastic'\nBundle 'slim-template/vim-slim'\nBundle 'thoughtbot/vim-rspec'\nBundle 'tpope/vim-bundler'\nBundle 'tpope/vim-endwise'\nBundle 'tpope/vim-fugitive'\nBundle 'tpope/vim-rails'\nBundle 'tpope/vim-surround'\nBundle 'vim-ruby/vim-ruby'\nBundle 'vim-scripts/ctags.vim'\nBundle 'vim-scripts/matchit.zip'\nBundle 'vim-scripts/tComment'\nBundle \"mattn/emmet-vim\"\nBundle \"scrooloose/nerdtree\"\nBundle \"Lokaltog/vim-powerline\"\nBundle \"godlygeek/tabular\"\nBundle \"msanders/snipmate.vim\"\nBundle \"jelera/vim-javascript-syntax\"\nBundle \"altercation/vim-colors-solarized\"\nBundle \"othree/html5.vim\"\nBundle \"xsbeats/vim-blade\"\nBundle \"Raimondi/delimitMate\"\nBundle \"groenewege/vim-less\"\nBundle \"evanmiller/nginx-vim-syntax\"\nBundle \"Lokaltog/vim-easymotion\"\nBundle \"tomasr/molokai\"\n\nif filereadable(expand(\"~/.vimrc.bundles.local\"))\n  source ~/.vimrc.bundles.local\nendif\n\nfiletype on\n~~~","source":"_posts/Linux/使用Vundle管理配置Vim基本插件.md","raw":"---\ntitle: 使用Vundle管理配置Vim基本插件\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n# 说明\n官网：https://github.com/VundleVim/Vundle.vim\n> Vundle是基于Git仓库的插件管理软件。Vundle将插件的安装简化为类似yum软件安装的过程\n\n> 其特色在于使用git来管理插件,更新方便，支持搜索，一键更新，从此只需要一个vimrc走天下\n\n# 配置说明\n1. 在Github vim-scripts 用户下的repos,只需要写出repos名称\n2. 在Github其他用户下的repos, 需要写出”用户名/repos名”\n3. 不在Github上的插件，需要写出git全路径\n\n具体步骤：\n\n1. 需要有git环境，CentOS7自带，可通过git命令查看\n2. 安装Vundle：git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n3. 修改.vimrc／vimrc文件，在CentOS7中是vimrc文件，修改前先备份.\n* 将以下内容放置到文件最开头，最小配置如下：\n~~~\nset nocompatibl \nfiletype off\n\nset rtp+=~/.vim/bundle/Vundle.vim\n\ncall vundle#begin()\n\nPlugin 'VundleVim/Vundle.vim'\n\ncall vundle#end()\n\nfiletype plugin indent on\n~~~\n在Plugin之后，添加自己想要安装的插件\n4. 插件安装： \n~~~\n# 在vim中\n:PluginInstall\n\n# 在终端\nvim +PluginInstall +qall\n~~~\n# 命令说明\n~~~\n:PluginList -列举出列表中(.vimrc中)配置的所有插件\n:PluginInstall -安装列表中全部插件\n:PluginInstall! -更新列表中全部插件\n:PluginSearch foo -查找foo插件\n:PluginSearch! foo -刷新foo插件缓存\n:PluginClean -清除列表中没有的插件\n:PluginClean! -清除列表中没有的插件\n~~~\n\n# 常用插件说明\n* rename.vim：在Vim中为文件重命名。\n* vim-coffee-script：在Vim中舒心 的编写、编译Coffeescript。\n* vim-mkdir：当你在Vim中新建文件的时候， 自动帮你创建不存在的目录。\n* vim-surround：快速的删除、修改和添加 括号、引号、XML标签等等。\n* matchit：用%去在两个对应的字符间跳转。\n* tComment：快速注释、反注释代码。\n* emmet-vim：Emmet的Vim版。\n* tabular：快速对齐。\n* snipmate.vim：快速的代码片段。\n* vim-easymotion：在文件中快速定位。\n* vim-instant-markdown：Vim中对 \n* Markdown文档的实时预览。\n* NERDTree:一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录\n* MiniBufExplorer:提供多文件同时编辑功能，并在编辑器上方显示文件的标签\n* 一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件\n* \n\n# 网络上配置收藏\n1. https://github.com/deepzz0/dotfiles/blob/master/.vimrc\n2.\n~~~\nif &compatible\n  set nocompatible\nend\n\nfiletype off\nset rtp+=~/.vim/bundle/vundle/\ncall vundle#rc()\n\n\" Let Vundle manage Vundle\nBundle 'gmarik/vundle'\n\n\" Define bundles via Github repos\nBundle 'christoomey/vim-run-interactive'\nBundle 'croaky/vim-colors-github'\nBundle 'danro/rename.vim'\nBundle 'kchmck/vim-coffee-script'\nBundle 'kien/ctrlp.vim'\nBundle 'pbrisbin/vim-mkdir'\nBundle 'scrooloose/syntastic'\nBundle 'slim-template/vim-slim'\nBundle 'thoughtbot/vim-rspec'\nBundle 'tpope/vim-bundler'\nBundle 'tpope/vim-endwise'\nBundle 'tpope/vim-fugitive'\nBundle 'tpope/vim-rails'\nBundle 'tpope/vim-surround'\nBundle 'vim-ruby/vim-ruby'\nBundle 'vim-scripts/ctags.vim'\nBundle 'vim-scripts/matchit.zip'\nBundle 'vim-scripts/tComment'\nBundle \"mattn/emmet-vim\"\nBundle \"scrooloose/nerdtree\"\nBundle \"Lokaltog/vim-powerline\"\nBundle \"godlygeek/tabular\"\nBundle \"msanders/snipmate.vim\"\nBundle \"jelera/vim-javascript-syntax\"\nBundle \"altercation/vim-colors-solarized\"\nBundle \"othree/html5.vim\"\nBundle \"xsbeats/vim-blade\"\nBundle \"Raimondi/delimitMate\"\nBundle \"groenewege/vim-less\"\nBundle \"evanmiller/nginx-vim-syntax\"\nBundle \"Lokaltog/vim-easymotion\"\nBundle \"tomasr/molokai\"\n\nif filereadable(expand(\"~/.vimrc.bundles.local\"))\n  source ~/.vimrc.bundles.local\nendif\n\nfiletype on\n~~~","slug":"Linux-使用Vundle管理配置Vim基本插件","published":1,"updated":"2019-02-14T05:53:20.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyd00305b8hn2j6rmh4","content":"<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>官网：<a href=\"https://github.com/VundleVim/Vundle.vim\" target=\"_blank\" rel=\"noopener\">https://github.com/VundleVim/Vundle.vim</a></p>\n<blockquote>\n<p>Vundle是基于Git仓库的插件管理软件。Vundle将插件的安装简化为类似yum软件安装的过程</p>\n</blockquote>\n<blockquote>\n<p>其特色在于使用git来管理插件,更新方便，支持搜索，一键更新，从此只需要一个vimrc走天下</p>\n</blockquote>\n<h1 id=\"配置说明\"><a class=\"markdownIt-Anchor\" href=\"#配置说明\"></a> 配置说明</h1>\n<ol>\n<li>在Github vim-scripts 用户下的repos,只需要写出repos名称</li>\n<li>在Github其他用户下的repos, 需要写出”用户名/repos名”</li>\n<li>不在Github上的插件，需要写出git全路径</li>\n</ol>\n<p>具体步骤：</p>\n<ol>\n<li>需要有git环境，CentOS7自带，可通过git命令查看</li>\n<li>安装Vundle：git clone <a href=\"https://github.com/VundleVim/Vundle.vim.git\" target=\"_blank\" rel=\"noopener\">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</li>\n<li>修改.vimrc／vimrc文件，在CentOS7中是vimrc文件，修改前先备份.</li>\n</ol>\n<ul>\n<li>将以下内容放置到文件最开头，最小配置如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set nocompatibl </span><br><span class=\"line\">filetype off</span><br><span class=\"line\"></span><br><span class=\"line\">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class=\"line\"></span><br><span class=\"line\">call vundle#begin()</span><br><span class=\"line\"></span><br><span class=\"line\">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">call vundle#end()</span><br><span class=\"line\"></span><br><span class=\"line\">filetype plugin indent on</span><br></pre></td></tr></table></figure>\n<p>在Plugin之后，添加自己想要安装的插件<br>\n4. 插件安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在vim中</span><br><span class=\"line\">:PluginInstall</span><br><span class=\"line\"></span><br><span class=\"line\"># 在终端</span><br><span class=\"line\">vim +PluginInstall +qall</span><br></pre></td></tr></table></figure>\n<h1 id=\"命令说明\"><a class=\"markdownIt-Anchor\" href=\"#命令说明\"></a> 命令说明</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:PluginList -列举出列表中(.vimrc中)配置的所有插件</span><br><span class=\"line\">:PluginInstall -安装列表中全部插件</span><br><span class=\"line\">:PluginInstall! -更新列表中全部插件</span><br><span class=\"line\">:PluginSearch foo -查找foo插件</span><br><span class=\"line\">:PluginSearch! foo -刷新foo插件缓存</span><br><span class=\"line\">:PluginClean -清除列表中没有的插件</span><br><span class=\"line\">:PluginClean! -清除列表中没有的插件</span><br></pre></td></tr></table></figure>\n<h1 id=\"常用插件说明\"><a class=\"markdownIt-Anchor\" href=\"#常用插件说明\"></a> 常用插件说明</h1>\n<ul>\n<li>rename.vim：在Vim中为文件重命名。</li>\n<li>vim-coffee-script：在Vim中舒心 的编写、编译Coffeescript。</li>\n<li>vim-mkdir：当你在Vim中新建文件的时候， 自动帮你创建不存在的目录。</li>\n<li>vim-surround：快速的删除、修改和添加 括号、引号、XML标签等等。</li>\n<li>matchit：用%去在两个对应的字符间跳转。</li>\n<li>tComment：快速注释、反注释代码。</li>\n<li>emmet-vim：Emmet的Vim版。</li>\n<li>tabular：快速对齐。</li>\n<li>snipmate.vim：快速的代码片段。</li>\n<li>vim-easymotion：在文件中快速定位。</li>\n<li>vim-instant-markdown：Vim中对</li>\n<li>Markdown文档的实时预览。</li>\n<li>NERDTree:一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录</li>\n<li>MiniBufExplorer:提供多文件同时编辑功能，并在编辑器上方显示文件的标签</li>\n<li>一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件</li>\n<li></li>\n</ul>\n<h1 id=\"网络上配置收藏\"><a class=\"markdownIt-Anchor\" href=\"#网络上配置收藏\"></a> 网络上配置收藏</h1>\n<ol>\n<li><a href=\"https://github.com/deepzz0/dotfiles/blob/master/.vimrc\" target=\"_blank\" rel=\"noopener\">https://github.com/deepzz0/dotfiles/blob/master/.vimrc</a></li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &amp;compatible</span><br><span class=\"line\">  set nocompatible</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">filetype off</span><br><span class=\"line\">set rtp+=~/.vim/bundle/vundle/</span><br><span class=\"line\">call vundle#rc()</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Let Vundle manage Vundle</span><br><span class=\"line\">Bundle &apos;gmarik/vundle&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Define bundles via Github repos</span><br><span class=\"line\">Bundle &apos;christoomey/vim-run-interactive&apos;</span><br><span class=\"line\">Bundle &apos;croaky/vim-colors-github&apos;</span><br><span class=\"line\">Bundle &apos;danro/rename.vim&apos;</span><br><span class=\"line\">Bundle &apos;kchmck/vim-coffee-script&apos;</span><br><span class=\"line\">Bundle &apos;kien/ctrlp.vim&apos;</span><br><span class=\"line\">Bundle &apos;pbrisbin/vim-mkdir&apos;</span><br><span class=\"line\">Bundle &apos;scrooloose/syntastic&apos;</span><br><span class=\"line\">Bundle &apos;slim-template/vim-slim&apos;</span><br><span class=\"line\">Bundle &apos;thoughtbot/vim-rspec&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-bundler&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-endwise&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-fugitive&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-rails&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-surround&apos;</span><br><span class=\"line\">Bundle &apos;vim-ruby/vim-ruby&apos;</span><br><span class=\"line\">Bundle &apos;vim-scripts/ctags.vim&apos;</span><br><span class=\"line\">Bundle &apos;vim-scripts/matchit.zip&apos;</span><br><span class=\"line\">Bundle &apos;vim-scripts/tComment&apos;</span><br><span class=\"line\">Bundle &quot;mattn/emmet-vim&quot;</span><br><span class=\"line\">Bundle &quot;scrooloose/nerdtree&quot;</span><br><span class=\"line\">Bundle &quot;Lokaltog/vim-powerline&quot;</span><br><span class=\"line\">Bundle &quot;godlygeek/tabular&quot;</span><br><span class=\"line\">Bundle &quot;msanders/snipmate.vim&quot;</span><br><span class=\"line\">Bundle &quot;jelera/vim-javascript-syntax&quot;</span><br><span class=\"line\">Bundle &quot;altercation/vim-colors-solarized&quot;</span><br><span class=\"line\">Bundle &quot;othree/html5.vim&quot;</span><br><span class=\"line\">Bundle &quot;xsbeats/vim-blade&quot;</span><br><span class=\"line\">Bundle &quot;Raimondi/delimitMate&quot;</span><br><span class=\"line\">Bundle &quot;groenewege/vim-less&quot;</span><br><span class=\"line\">Bundle &quot;evanmiller/nginx-vim-syntax&quot;</span><br><span class=\"line\">Bundle &quot;Lokaltog/vim-easymotion&quot;</span><br><span class=\"line\">Bundle &quot;tomasr/molokai&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">if filereadable(expand(&quot;~/.vimrc.bundles.local&quot;))</span><br><span class=\"line\">  source ~/.vimrc.bundles.local</span><br><span class=\"line\">endif</span><br><span class=\"line\"></span><br><span class=\"line\">filetype on</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>官网：<a href=\"https://github.com/VundleVim/Vundle.vim\" target=\"_blank\" rel=\"noopener\">https://github.com/VundleVim/Vundle.vim</a></p>\n<blockquote>\n<p>Vundle是基于Git仓库的插件管理软件。Vundle将插件的安装简化为类似yum软件安装的过程</p>\n</blockquote>\n<blockquote>\n<p>其特色在于使用git来管理插件,更新方便，支持搜索，一键更新，从此只需要一个vimrc走天下</p>\n</blockquote>\n<h1 id=\"配置说明\"><a class=\"markdownIt-Anchor\" href=\"#配置说明\"></a> 配置说明</h1>\n<ol>\n<li>在Github vim-scripts 用户下的repos,只需要写出repos名称</li>\n<li>在Github其他用户下的repos, 需要写出”用户名/repos名”</li>\n<li>不在Github上的插件，需要写出git全路径</li>\n</ol>\n<p>具体步骤：</p>\n<ol>\n<li>需要有git环境，CentOS7自带，可通过git命令查看</li>\n<li>安装Vundle：git clone <a href=\"https://github.com/VundleVim/Vundle.vim.git\" target=\"_blank\" rel=\"noopener\">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</li>\n<li>修改.vimrc／vimrc文件，在CentOS7中是vimrc文件，修改前先备份.</li>\n</ol>\n<ul>\n<li>将以下内容放置到文件最开头，最小配置如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set nocompatibl </span><br><span class=\"line\">filetype off</span><br><span class=\"line\"></span><br><span class=\"line\">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class=\"line\"></span><br><span class=\"line\">call vundle#begin()</span><br><span class=\"line\"></span><br><span class=\"line\">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">call vundle#end()</span><br><span class=\"line\"></span><br><span class=\"line\">filetype plugin indent on</span><br></pre></td></tr></table></figure>\n<p>在Plugin之后，添加自己想要安装的插件<br>\n4. 插件安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在vim中</span><br><span class=\"line\">:PluginInstall</span><br><span class=\"line\"></span><br><span class=\"line\"># 在终端</span><br><span class=\"line\">vim +PluginInstall +qall</span><br></pre></td></tr></table></figure>\n<h1 id=\"命令说明\"><a class=\"markdownIt-Anchor\" href=\"#命令说明\"></a> 命令说明</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:PluginList -列举出列表中(.vimrc中)配置的所有插件</span><br><span class=\"line\">:PluginInstall -安装列表中全部插件</span><br><span class=\"line\">:PluginInstall! -更新列表中全部插件</span><br><span class=\"line\">:PluginSearch foo -查找foo插件</span><br><span class=\"line\">:PluginSearch! foo -刷新foo插件缓存</span><br><span class=\"line\">:PluginClean -清除列表中没有的插件</span><br><span class=\"line\">:PluginClean! -清除列表中没有的插件</span><br></pre></td></tr></table></figure>\n<h1 id=\"常用插件说明\"><a class=\"markdownIt-Anchor\" href=\"#常用插件说明\"></a> 常用插件说明</h1>\n<ul>\n<li>rename.vim：在Vim中为文件重命名。</li>\n<li>vim-coffee-script：在Vim中舒心 的编写、编译Coffeescript。</li>\n<li>vim-mkdir：当你在Vim中新建文件的时候， 自动帮你创建不存在的目录。</li>\n<li>vim-surround：快速的删除、修改和添加 括号、引号、XML标签等等。</li>\n<li>matchit：用%去在两个对应的字符间跳转。</li>\n<li>tComment：快速注释、反注释代码。</li>\n<li>emmet-vim：Emmet的Vim版。</li>\n<li>tabular：快速对齐。</li>\n<li>snipmate.vim：快速的代码片段。</li>\n<li>vim-easymotion：在文件中快速定位。</li>\n<li>vim-instant-markdown：Vim中对</li>\n<li>Markdown文档的实时预览。</li>\n<li>NERDTree:一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录</li>\n<li>MiniBufExplorer:提供多文件同时编辑功能，并在编辑器上方显示文件的标签</li>\n<li>一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件</li>\n<li></li>\n</ul>\n<h1 id=\"网络上配置收藏\"><a class=\"markdownIt-Anchor\" href=\"#网络上配置收藏\"></a> 网络上配置收藏</h1>\n<ol>\n<li><a href=\"https://github.com/deepzz0/dotfiles/blob/master/.vimrc\" target=\"_blank\" rel=\"noopener\">https://github.com/deepzz0/dotfiles/blob/master/.vimrc</a></li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &amp;compatible</span><br><span class=\"line\">  set nocompatible</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">filetype off</span><br><span class=\"line\">set rtp+=~/.vim/bundle/vundle/</span><br><span class=\"line\">call vundle#rc()</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Let Vundle manage Vundle</span><br><span class=\"line\">Bundle &apos;gmarik/vundle&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; Define bundles via Github repos</span><br><span class=\"line\">Bundle &apos;christoomey/vim-run-interactive&apos;</span><br><span class=\"line\">Bundle &apos;croaky/vim-colors-github&apos;</span><br><span class=\"line\">Bundle &apos;danro/rename.vim&apos;</span><br><span class=\"line\">Bundle &apos;kchmck/vim-coffee-script&apos;</span><br><span class=\"line\">Bundle &apos;kien/ctrlp.vim&apos;</span><br><span class=\"line\">Bundle &apos;pbrisbin/vim-mkdir&apos;</span><br><span class=\"line\">Bundle &apos;scrooloose/syntastic&apos;</span><br><span class=\"line\">Bundle &apos;slim-template/vim-slim&apos;</span><br><span class=\"line\">Bundle &apos;thoughtbot/vim-rspec&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-bundler&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-endwise&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-fugitive&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-rails&apos;</span><br><span class=\"line\">Bundle &apos;tpope/vim-surround&apos;</span><br><span class=\"line\">Bundle &apos;vim-ruby/vim-ruby&apos;</span><br><span class=\"line\">Bundle &apos;vim-scripts/ctags.vim&apos;</span><br><span class=\"line\">Bundle &apos;vim-scripts/matchit.zip&apos;</span><br><span class=\"line\">Bundle &apos;vim-scripts/tComment&apos;</span><br><span class=\"line\">Bundle &quot;mattn/emmet-vim&quot;</span><br><span class=\"line\">Bundle &quot;scrooloose/nerdtree&quot;</span><br><span class=\"line\">Bundle &quot;Lokaltog/vim-powerline&quot;</span><br><span class=\"line\">Bundle &quot;godlygeek/tabular&quot;</span><br><span class=\"line\">Bundle &quot;msanders/snipmate.vim&quot;</span><br><span class=\"line\">Bundle &quot;jelera/vim-javascript-syntax&quot;</span><br><span class=\"line\">Bundle &quot;altercation/vim-colors-solarized&quot;</span><br><span class=\"line\">Bundle &quot;othree/html5.vim&quot;</span><br><span class=\"line\">Bundle &quot;xsbeats/vim-blade&quot;</span><br><span class=\"line\">Bundle &quot;Raimondi/delimitMate&quot;</span><br><span class=\"line\">Bundle &quot;groenewege/vim-less&quot;</span><br><span class=\"line\">Bundle &quot;evanmiller/nginx-vim-syntax&quot;</span><br><span class=\"line\">Bundle &quot;Lokaltog/vim-easymotion&quot;</span><br><span class=\"line\">Bundle &quot;tomasr/molokai&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">if filereadable(expand(&quot;~/.vimrc.bundles.local&quot;))</span><br><span class=\"line\">  source ~/.vimrc.bundles.local</span><br><span class=\"line\">endif</span><br><span class=\"line\"></span><br><span class=\"line\">filetype on</span><br></pre></td></tr></table></figure>"},{"title":"CentOS修改Root密码","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n1. 进入单用户模式\n开机按ESC，选择内核后按e，后选择Kernerl再按e，在“<rhgb quiet”后输入空格1或s或S或Single回车，按b键重启进入命令行模式\n2. 修改密码：passwd root\n3. 重启：init 5","source":"_posts/Linux/修改Root密码.md","raw":"---\ntitle: CentOS修改Root密码\ntags:\n  - CentOS\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n1. 进入单用户模式\n开机按ESC，选择内核后按e，后选择Kernerl再按e，在“<rhgb quiet”后输入空格1或s或S或Single回车，按b键重启进入命令行模式\n2. 修改密码：passwd root\n3. 重启：init 5","slug":"Linux-修改Root密码","published":1,"updated":"2019-02-14T05:37:16.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudye00345b8hf9sxvdmq","content":"<ol>\n<li>进入单用户模式<br>\n开机按ESC，选择内核后按e，后选择Kernerl再按e，在“&lt;rhgb quiet”后输入空格1或s或S或Single回车，按b键重启进入命令行模式</li>\n<li>修改密码：passwd root</li>\n<li>重启：init 5</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>进入单用户模式<br>\n开机按ESC，选择内核后按e，后选择Kernerl再按e，在“&lt;rhgb quiet”后输入空格1或s或S或Single回车，按b键重启进入命令行模式</li>\n<li>修改密码：passwd root</li>\n<li>重启：init 5</li>\n</ol>\n"},{"title":"CentOS设置网络自动启动","copyright":true,"comments":1,"toc":true,"password":null,"_content":" \n# 设置网络自启动\n修改/etc/sysconfig/network-scripts/ifcfg-ethX文件，修改其中ONBOOT===no==的值为yes即可\n\n如果想要自己设置静态ip，需要在上边文件的最后添加以下内容：\n~~~\nIPADDR=192.168.7.106 #静态IP  \nGATEWAY=192.168.7.1 #默认网关  \nNETMASK=255.255.255.0 #子网掩码  \nDNS1=192.168.7.1 #DNS 配置\n~~~\n重启服务即可","source":"_posts/Linux/设置网络自动启动.md","raw":"---\ntitle: CentOS设置网络自动启动\ntags:\n  - CentOS \ncopyright: true\ncomments: true\ntoc: true\ncategories: Linux\npassword:\n---\n \n# 设置网络自启动\n修改/etc/sysconfig/network-scripts/ifcfg-ethX文件，修改其中ONBOOT===no==的值为yes即可\n\n如果想要自己设置静态ip，需要在上边文件的最后添加以下内容：\n~~~\nIPADDR=192.168.7.106 #静态IP  \nGATEWAY=192.168.7.1 #默认网关  \nNETMASK=255.255.255.0 #子网掩码  \nDNS1=192.168.7.1 #DNS 配置\n~~~\n重启服务即可","slug":"Linux-设置网络自动启动","published":1,"date":"2019-02-14T08:20:08.000Z","updated":"2019-02-14T08:20:08.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyf00375b8hbvru5das","content":"<h1 id=\"设置网络自启动\"><a class=\"markdownIt-Anchor\" href=\"#设置网络自启动\"></a> 设置网络自启动</h1>\n<p>修改/etc/sysconfig/network-scripts/ifcfg-ethX文件，修改其中ONBOOT===no==的值为yes即可</p>\n<p>如果想要自己设置静态ip，需要在上边文件的最后添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPADDR=192.168.7.106 #静态IP  </span><br><span class=\"line\">GATEWAY=192.168.7.1 #默认网关  </span><br><span class=\"line\">NETMASK=255.255.255.0 #子网掩码  </span><br><span class=\"line\">DNS1=192.168.7.1 #DNS 配置</span><br></pre></td></tr></table></figure>\n<p>重启服务即可</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设置网络自启动\"><a class=\"markdownIt-Anchor\" href=\"#设置网络自启动\"></a> 设置网络自启动</h1>\n<p>修改/etc/sysconfig/network-scripts/ifcfg-ethX文件，修改其中ONBOOT===no==的值为yes即可</p>\n<p>如果想要自己设置静态ip，需要在上边文件的最后添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPADDR=192.168.7.106 #静态IP  </span><br><span class=\"line\">GATEWAY=192.168.7.1 #默认网关  </span><br><span class=\"line\">NETMASK=255.255.255.0 #子网掩码  </span><br><span class=\"line\">DNS1=192.168.7.1 #DNS 配置</span><br></pre></td></tr></table></figure>\n<p>重启服务即可</p>\n"},{"title":"禁用SELinux时配置错误导致系统不能够启动的解决方法","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\nCentOS在安装某些软件的时候，需要关闭SELinux，在修改配置文件/etc/selinux/config过程中，设置方法为：\n~~~\n# SELINUX=enforcing\nSELINUX=disabled\n~~~\n如果设置之后，没有设置回来，则启动的时候就会无法启动，解决办法为：\n\n* 系统启动的时候，按下‘e’键进入grub编辑界面，\n* 编辑grub菜单，选择“kernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet” 一栏\n* 按‘e’键进入编辑\n* 在末尾增加enforcing=0，即：\nkernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet enforcing=0\n* 按‘b’键继续引导，OK顺利前进。\n","source":"_posts/Linux/禁用SELinux时配置错误导致系统不能够启动的解决方法.md","raw":"---\ntitle: 禁用SELinux时配置错误导致系统不能够启动的解决方法\ntags:\n  - CentOS \ncopyright: true\ncomments: true\ntoc: true\ncategories: Linux\npassword:\n---\n\nCentOS在安装某些软件的时候，需要关闭SELinux，在修改配置文件/etc/selinux/config过程中，设置方法为：\n~~~\n# SELINUX=enforcing\nSELINUX=disabled\n~~~\n如果设置之后，没有设置回来，则启动的时候就会无法启动，解决办法为：\n\n* 系统启动的时候，按下‘e’键进入grub编辑界面，\n* 编辑grub菜单，选择“kernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet” 一栏\n* 按‘e’键进入编辑\n* 在末尾增加enforcing=0，即：\nkernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet enforcing=0\n* 按‘b’键继续引导，OK顺利前进。\n","slug":"Linux-禁用SELinux时配置错误导致系统不能够启动的解决方法","published":1,"date":"2019-02-14T08:21:27.000Z","updated":"2019-02-14T08:21:27.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyh003a5b8hg8csm1ot","content":"<p>CentOS在安装某些软件的时候，需要关闭SELinux，在修改配置文件/etc/selinux/config过程中，设置方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SELINUX=enforcing</span><br><span class=\"line\">SELINUX=disabled</span><br></pre></td></tr></table></figure>\n<p>如果设置之后，没有设置回来，则启动的时候就会无法启动，解决办法为：</p>\n<ul>\n<li>系统启动的时候，按下‘e’键进入grub编辑界面，</li>\n<li>编辑grub菜单，选择“kernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet” 一栏</li>\n<li>按‘e’键进入编辑</li>\n<li>在末尾增加enforcing=0，即：<br>\nkernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet enforcing=0</li>\n<li>按‘b’键继续引导，OK顺利前进。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>CentOS在安装某些软件的时候，需要关闭SELinux，在修改配置文件/etc/selinux/config过程中，设置方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SELINUX=enforcing</span><br><span class=\"line\">SELINUX=disabled</span><br></pre></td></tr></table></figure>\n<p>如果设置之后，没有设置回来，则启动的时候就会无法启动，解决办法为：</p>\n<ul>\n<li>系统启动的时候，按下‘e’键进入grub编辑界面，</li>\n<li>编辑grub菜单，选择“kernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet” 一栏</li>\n<li>按‘e’键进入编辑</li>\n<li>在末尾增加enforcing=0，即：<br>\nkernel /vmlinuz-2.6.23.1-42.fc8 ro root=/dev/vogroup00/logvol00 rhgb quiet enforcing=0</li>\n<li>按‘b’键继续引导，OK顺利前进。</li>\n</ul>\n"},{"title":"NW.js入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n# 简介\nNW.js （原名 node-webkit）是一个基于 Chromium 和 node.js 的应用运行时，通过它可以用 HTML 和 JavaScript 编写原生应用程序。它还允许您从 DOM 调用 Node.js 的模块 ，实现了一个用所有 Web 技术来写原生应用程序的新的开发模式。\n\n* 官网：https://nwjs.io/\n* 中文文档：https://www.gitbook.com/book/wizardforcel/nwjs-doc/details\n# 功能特性\n* 用现代 HTML5,CSS3,JS 和 WebGL 来编写应用程序\n* 完全支持 Node.js APIs 和所有其 第三方模块\n* 良好的性能:Node 和 WebKit\n* 运行在相同的线程:函数调用是更简洁;对象在同一堆可以互相引用\n* 容易打包和分发应用程序\n* 支持 Linux、Mac OS X 和 Windows\n\n# 窗口外观常用属性\n在package.json文件中设置\n~~~\ntitle : 字符串，设置默认 title。\nwidth/height : 主窗口的大小。\ntoolbar : bool 值。是否显示导航栏。\nicon : 窗口的 icon。\nposition :字符串。窗口打开时的位置，可以设置为“null”、“center”或者“mouse”。\nmin_width/min_height : 窗口的最小值。\nmax_width/max_height : 窗口显示的最大值。\nresizable : bool 值。是否允许调整窗口大小。\nalways-on-top : bool 值。窗口置顶。\nfullscreen : bool 值。是否全屏显示。\nshow_in_taskbar : 是否在任务栏显示图标。\nframe : bool 值。如果设置为 false，程序将无边框显示。\n~~~\n\n# webstorm项目创建及调试\n## 下载三个不同 OS 平台的 NW.js\n\n## 创建项目并运行\n1. 创建空项目\n2. 创建package.json,编辑起内容，最简为:\n~~~\n{\n  \"name\": \"helloworld\", \n  \"version\": \"0.0.1\",\n  \"main\": \"index.html\" \n}\n~~~\n3. 在webstorm 中添加一个nw.js：run -- edit configurations -- + nw.js\n~~~\nNW.js app : 可以是当前项目目录，但要包含package.json文件. 或者是一个.nw的文件\nNW.js interpreter 指定可执行的 nw(官网下的包中的) (mac下是nwjs),如：/MyDeveloper/nwjs-v0.22.1-osx-x64/nwjs.app\nworking direction ： 项目目录\n~~~\n4. 运行查看效果\n\n## 调试\nhttps://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html\n\n# 打包到各个平台\nhttps://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps\n\n## mac下打包\n1. 拷贝下载的nwjs-sdk-v0.22.1-osx-x64.zip中的nwjs.app文件到项目的根目录的同级目录\n2. 修改nwjs.app目录名称为你想要的名称，如：MyNW.app\n3. 在项目根目录执行如下命令：zip -r ../MyNW.app/Contents/Resources/app.nw *,将当前目录下所有文件打包到MyNW.app中\n4. open MyNW.app可以打开项目\n5. 制作成dmg文件\n- - 在应用程序->实用工具下打开磁盘工具\n- - 新建一个磁盘映像，放在桌面上(可随意)，名称设置为temp.dmg(可随意)，存储为mytemp\n- - 拷贝4中的文件到mytemp中\n- - 执行：ln -s /Applications /Volumes/temp.dmg/Applications\n6. 成功\n\n问题：4中制作的文件太大\n\n\n## 代码加密保护\n> 有些情况下，代码还是不能直接暴露给用户的；我们可以使用V8 Snapshot 的方式来达到代码加密保护的目的\n\n具体的方式是:\n1. 使用 /nwjs.exe 来运行 nwjc source.js core.bin命令\n2. 在index.html里使用require('nw.gui').Window.get().evalNWBin(null, './app/v0.0.1/core.bin');(注意这里的路径，是相对于nw.exe的位置)将代码引入到项目中； \n3. 加密的代码里不要使用 let、const这些关键字，可能因为这个始终编译不通过\n\n## 自动更新\n### 项目代码需要更新\n前面介绍项目接口就提到 /app/v0.0.1/ 就是放置V0.0.1的所有代码的位置； \n那么如果要更新到V0.0.2，那我们新建一个文件夹 /app/V0.0.2,然后把V0.0.2的代码都放到这个文件下，然后把/package.json替换成新版本的package.json；这样重启客户端之后，然会读取v0.0.2的代码了。具体的更新代码就不写了，可以把新版本的代码打包成zip包，然后客户端下载好，解压就行。\n\n### nw.js本身需要更新\n通常情况下，不会遇到需要更新nw.js 本身的情况，因为当选定一个版本的NW.js后，就认定它了，除非遇到了什么无法解决的BUG\n\n## 系列教程\nhttps://blog.csdn.net/zeping891103/column/info/19257\n\n","source":"_posts/node/NW.js入门.md","raw":"---\ntitle: NW.js入门\ntags:\n  - nw\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n# 简介\nNW.js （原名 node-webkit）是一个基于 Chromium 和 node.js 的应用运行时，通过它可以用 HTML 和 JavaScript 编写原生应用程序。它还允许您从 DOM 调用 Node.js 的模块 ，实现了一个用所有 Web 技术来写原生应用程序的新的开发模式。\n\n* 官网：https://nwjs.io/\n* 中文文档：https://www.gitbook.com/book/wizardforcel/nwjs-doc/details\n# 功能特性\n* 用现代 HTML5,CSS3,JS 和 WebGL 来编写应用程序\n* 完全支持 Node.js APIs 和所有其 第三方模块\n* 良好的性能:Node 和 WebKit\n* 运行在相同的线程:函数调用是更简洁;对象在同一堆可以互相引用\n* 容易打包和分发应用程序\n* 支持 Linux、Mac OS X 和 Windows\n\n# 窗口外观常用属性\n在package.json文件中设置\n~~~\ntitle : 字符串，设置默认 title。\nwidth/height : 主窗口的大小。\ntoolbar : bool 值。是否显示导航栏。\nicon : 窗口的 icon。\nposition :字符串。窗口打开时的位置，可以设置为“null”、“center”或者“mouse”。\nmin_width/min_height : 窗口的最小值。\nmax_width/max_height : 窗口显示的最大值。\nresizable : bool 值。是否允许调整窗口大小。\nalways-on-top : bool 值。窗口置顶。\nfullscreen : bool 值。是否全屏显示。\nshow_in_taskbar : 是否在任务栏显示图标。\nframe : bool 值。如果设置为 false，程序将无边框显示。\n~~~\n\n# webstorm项目创建及调试\n## 下载三个不同 OS 平台的 NW.js\n\n## 创建项目并运行\n1. 创建空项目\n2. 创建package.json,编辑起内容，最简为:\n~~~\n{\n  \"name\": \"helloworld\", \n  \"version\": \"0.0.1\",\n  \"main\": \"index.html\" \n}\n~~~\n3. 在webstorm 中添加一个nw.js：run -- edit configurations -- + nw.js\n~~~\nNW.js app : 可以是当前项目目录，但要包含package.json文件. 或者是一个.nw的文件\nNW.js interpreter 指定可执行的 nw(官网下的包中的) (mac下是nwjs),如：/MyDeveloper/nwjs-v0.22.1-osx-x64/nwjs.app\nworking direction ： 项目目录\n~~~\n4. 运行查看效果\n\n## 调试\nhttps://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html\n\n# 打包到各个平台\nhttps://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps\n\n## mac下打包\n1. 拷贝下载的nwjs-sdk-v0.22.1-osx-x64.zip中的nwjs.app文件到项目的根目录的同级目录\n2. 修改nwjs.app目录名称为你想要的名称，如：MyNW.app\n3. 在项目根目录执行如下命令：zip -r ../MyNW.app/Contents/Resources/app.nw *,将当前目录下所有文件打包到MyNW.app中\n4. open MyNW.app可以打开项目\n5. 制作成dmg文件\n- - 在应用程序->实用工具下打开磁盘工具\n- - 新建一个磁盘映像，放在桌面上(可随意)，名称设置为temp.dmg(可随意)，存储为mytemp\n- - 拷贝4中的文件到mytemp中\n- - 执行：ln -s /Applications /Volumes/temp.dmg/Applications\n6. 成功\n\n问题：4中制作的文件太大\n\n\n## 代码加密保护\n> 有些情况下，代码还是不能直接暴露给用户的；我们可以使用V8 Snapshot 的方式来达到代码加密保护的目的\n\n具体的方式是:\n1. 使用 /nwjs.exe 来运行 nwjc source.js core.bin命令\n2. 在index.html里使用require('nw.gui').Window.get().evalNWBin(null, './app/v0.0.1/core.bin');(注意这里的路径，是相对于nw.exe的位置)将代码引入到项目中； \n3. 加密的代码里不要使用 let、const这些关键字，可能因为这个始终编译不通过\n\n## 自动更新\n### 项目代码需要更新\n前面介绍项目接口就提到 /app/v0.0.1/ 就是放置V0.0.1的所有代码的位置； \n那么如果要更新到V0.0.2，那我们新建一个文件夹 /app/V0.0.2,然后把V0.0.2的代码都放到这个文件下，然后把/package.json替换成新版本的package.json；这样重启客户端之后，然会读取v0.0.2的代码了。具体的更新代码就不写了，可以把新版本的代码打包成zip包，然后客户端下载好，解压就行。\n\n### nw.js本身需要更新\n通常情况下，不会遇到需要更新nw.js 本身的情况，因为当选定一个版本的NW.js后，就认定它了，除非遇到了什么无法解决的BUG\n\n## 系列教程\nhttps://blog.csdn.net/zeping891103/column/info/19257\n\n","slug":"node-NW-js入门","published":1,"updated":"2019-02-14T06:42:49.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyi003b5b8hs41dbi39","content":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>NW.js （原名 node-webkit）是一个基于 Chromium 和 node.js 的应用运行时，通过它可以用 HTML 和 JavaScript 编写原生应用程序。它还允许您从 DOM 调用 Node.js 的模块 ，实现了一个用所有 Web 技术来写原生应用程序的新的开发模式。</p>\n<ul>\n<li>官网：<a href=\"https://nwjs.io/\" target=\"_blank\" rel=\"noopener\">https://nwjs.io/</a></li>\n<li>中文文档：<a href=\"https://www.gitbook.com/book/wizardforcel/nwjs-doc/details\" target=\"_blank\" rel=\"noopener\">https://www.gitbook.com/book/wizardforcel/nwjs-doc/details</a></li>\n</ul>\n<h1 id=\"功能特性\"><a class=\"markdownIt-Anchor\" href=\"#功能特性\"></a> 功能特性</h1>\n<ul>\n<li>用现代 HTML5,CSS3,JS 和 WebGL 来编写应用程序</li>\n<li>完全支持 Node.js APIs 和所有其 第三方模块</li>\n<li>良好的性能:Node 和 WebKit</li>\n<li>运行在相同的线程:函数调用是更简洁;对象在同一堆可以互相引用</li>\n<li>容易打包和分发应用程序</li>\n<li>支持 Linux、Mac OS X 和 Windows</li>\n</ul>\n<h1 id=\"窗口外观常用属性\"><a class=\"markdownIt-Anchor\" href=\"#窗口外观常用属性\"></a> 窗口外观常用属性</h1>\n<p>在package.json文件中设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title : 字符串，设置默认 title。</span><br><span class=\"line\">width/height : 主窗口的大小。</span><br><span class=\"line\">toolbar : bool 值。是否显示导航栏。</span><br><span class=\"line\">icon : 窗口的 icon。</span><br><span class=\"line\">position :字符串。窗口打开时的位置，可以设置为“null”、“center”或者“mouse”。</span><br><span class=\"line\">min_width/min_height : 窗口的最小值。</span><br><span class=\"line\">max_width/max_height : 窗口显示的最大值。</span><br><span class=\"line\">resizable : bool 值。是否允许调整窗口大小。</span><br><span class=\"line\">always-on-top : bool 值。窗口置顶。</span><br><span class=\"line\">fullscreen : bool 值。是否全屏显示。</span><br><span class=\"line\">show_in_taskbar : 是否在任务栏显示图标。</span><br><span class=\"line\">frame : bool 值。如果设置为 false，程序将无边框显示。</span><br></pre></td></tr></table></figure>\n<h1 id=\"webstorm项目创建及调试\"><a class=\"markdownIt-Anchor\" href=\"#webstorm项目创建及调试\"></a> webstorm项目创建及调试</h1>\n<h2 id=\"下载三个不同-os-平台的-nwjs\"><a class=\"markdownIt-Anchor\" href=\"#下载三个不同-os-平台的-nwjs\"></a> 下载三个不同 OS 平台的 NW.js</h2>\n<h2 id=\"创建项目并运行\"><a class=\"markdownIt-Anchor\" href=\"#创建项目并运行\"></a> 创建项目并运行</h2>\n<ol>\n<li>创建空项目</li>\n<li>创建package.json,编辑起内容，最简为:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;helloworld&quot;, </span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.html&quot; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在webstorm 中添加一个nw.js：run – edit configurations – + nw.js</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NW.js app : 可以是当前项目目录，但要包含package.json文件. 或者是一个.nw的文件</span><br><span class=\"line\">NW.js interpreter 指定可执行的 nw(官网下的包中的) (mac下是nwjs),如：/MyDeveloper/nwjs-v0.22.1-osx-x64/nwjs.app</span><br><span class=\"line\">working direction ： 项目目录</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>运行查看效果</li>\n</ol>\n<h2 id=\"调试\"><a class=\"markdownIt-Anchor\" href=\"#调试\"></a> 调试</h2>\n<p><a href=\"https://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html\" target=\"_blank\" rel=\"noopener\">https://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html</a></p>\n<h1 id=\"打包到各个平台\"><a class=\"markdownIt-Anchor\" href=\"#打包到各个平台\"></a> 打包到各个平台</h1>\n<p><a href=\"https://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps\" target=\"_blank\" rel=\"noopener\">https://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps</a></p>\n<h2 id=\"mac下打包\"><a class=\"markdownIt-Anchor\" href=\"#mac下打包\"></a> mac下打包</h2>\n<ol>\n<li>拷贝下载的nwjs-sdk-v0.22.1-osx-x64.zip中的nwjs.app文件到项目的根目录的同级目录</li>\n<li>修改nwjs.app目录名称为你想要的名称，如：MyNW.app</li>\n<li>在项目根目录执行如下命令：zip -r …/MyNW.app/Contents/Resources/app.nw *,将当前目录下所有文件打包到MyNW.app中</li>\n<li>open MyNW.app可以打开项目</li>\n<li>制作成dmg文件</li>\n</ol>\n<ul>\n<li>\n<ul>\n<li>在应用程序-&gt;实用工具下打开磁盘工具</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>新建一个磁盘映像，放在桌面上(可随意)，名称设置为temp.dmg(可随意)，存储为mytemp</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>拷贝4中的文件到mytemp中</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>执行：ln -s /Applications /Volumes/temp.dmg/Applications</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>成功</li>\n</ol>\n<p>问题：4中制作的文件太大</p>\n<h2 id=\"代码加密保护\"><a class=\"markdownIt-Anchor\" href=\"#代码加密保护\"></a> 代码加密保护</h2>\n<blockquote>\n<p>有些情况下，代码还是不能直接暴露给用户的；我们可以使用V8 Snapshot 的方式来达到代码加密保护的目的</p>\n</blockquote>\n<p>具体的方式是:</p>\n<ol>\n<li>使用 /nwjs.exe 来运行 nwjc source.js core.bin命令</li>\n<li>在index.html里使用require(‘nw.gui’).Window.get().evalNWBin(null, ‘./app/v0.0.1/core.bin’);(注意这里的路径，是相对于nw.exe的位置)将代码引入到项目中；</li>\n<li>加密的代码里不要使用 let、const这些关键字，可能因为这个始终编译不通过</li>\n</ol>\n<h2 id=\"自动更新\"><a class=\"markdownIt-Anchor\" href=\"#自动更新\"></a> 自动更新</h2>\n<h3 id=\"项目代码需要更新\"><a class=\"markdownIt-Anchor\" href=\"#项目代码需要更新\"></a> 项目代码需要更新</h3>\n<p>前面介绍项目接口就提到 /app/v0.0.1/ 就是放置V0.0.1的所有代码的位置；<br>\n那么如果要更新到V0.0.2，那我们新建一个文件夹 /app/V0.0.2,然后把V0.0.2的代码都放到这个文件下，然后把/package.json替换成新版本的package.json；这样重启客户端之后，然会读取v0.0.2的代码了。具体的更新代码就不写了，可以把新版本的代码打包成zip包，然后客户端下载好，解压就行。</p>\n<h3 id=\"nwjs本身需要更新\"><a class=\"markdownIt-Anchor\" href=\"#nwjs本身需要更新\"></a> nw.js本身需要更新</h3>\n<p>通常情况下，不会遇到需要更新nw.js 本身的情况，因为当选定一个版本的NW.js后，就认定它了，除非遇到了什么无法解决的BUG</p>\n<h2 id=\"系列教程\"><a class=\"markdownIt-Anchor\" href=\"#系列教程\"></a> 系列教程</h2>\n<p><a href=\"https://blog.csdn.net/zeping891103/column/info/19257\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zeping891103/column/info/19257</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>NW.js （原名 node-webkit）是一个基于 Chromium 和 node.js 的应用运行时，通过它可以用 HTML 和 JavaScript 编写原生应用程序。它还允许您从 DOM 调用 Node.js 的模块 ，实现了一个用所有 Web 技术来写原生应用程序的新的开发模式。</p>\n<ul>\n<li>官网：<a href=\"https://nwjs.io/\" target=\"_blank\" rel=\"noopener\">https://nwjs.io/</a></li>\n<li>中文文档：<a href=\"https://www.gitbook.com/book/wizardforcel/nwjs-doc/details\" target=\"_blank\" rel=\"noopener\">https://www.gitbook.com/book/wizardforcel/nwjs-doc/details</a></li>\n</ul>\n<h1 id=\"功能特性\"><a class=\"markdownIt-Anchor\" href=\"#功能特性\"></a> 功能特性</h1>\n<ul>\n<li>用现代 HTML5,CSS3,JS 和 WebGL 来编写应用程序</li>\n<li>完全支持 Node.js APIs 和所有其 第三方模块</li>\n<li>良好的性能:Node 和 WebKit</li>\n<li>运行在相同的线程:函数调用是更简洁;对象在同一堆可以互相引用</li>\n<li>容易打包和分发应用程序</li>\n<li>支持 Linux、Mac OS X 和 Windows</li>\n</ul>\n<h1 id=\"窗口外观常用属性\"><a class=\"markdownIt-Anchor\" href=\"#窗口外观常用属性\"></a> 窗口外观常用属性</h1>\n<p>在package.json文件中设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title : 字符串，设置默认 title。</span><br><span class=\"line\">width/height : 主窗口的大小。</span><br><span class=\"line\">toolbar : bool 值。是否显示导航栏。</span><br><span class=\"line\">icon : 窗口的 icon。</span><br><span class=\"line\">position :字符串。窗口打开时的位置，可以设置为“null”、“center”或者“mouse”。</span><br><span class=\"line\">min_width/min_height : 窗口的最小值。</span><br><span class=\"line\">max_width/max_height : 窗口显示的最大值。</span><br><span class=\"line\">resizable : bool 值。是否允许调整窗口大小。</span><br><span class=\"line\">always-on-top : bool 值。窗口置顶。</span><br><span class=\"line\">fullscreen : bool 值。是否全屏显示。</span><br><span class=\"line\">show_in_taskbar : 是否在任务栏显示图标。</span><br><span class=\"line\">frame : bool 值。如果设置为 false，程序将无边框显示。</span><br></pre></td></tr></table></figure>\n<h1 id=\"webstorm项目创建及调试\"><a class=\"markdownIt-Anchor\" href=\"#webstorm项目创建及调试\"></a> webstorm项目创建及调试</h1>\n<h2 id=\"下载三个不同-os-平台的-nwjs\"><a class=\"markdownIt-Anchor\" href=\"#下载三个不同-os-平台的-nwjs\"></a> 下载三个不同 OS 平台的 NW.js</h2>\n<h2 id=\"创建项目并运行\"><a class=\"markdownIt-Anchor\" href=\"#创建项目并运行\"></a> 创建项目并运行</h2>\n<ol>\n<li>创建空项目</li>\n<li>创建package.json,编辑起内容，最简为:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;helloworld&quot;, </span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.html&quot; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在webstorm 中添加一个nw.js：run – edit configurations – + nw.js</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NW.js app : 可以是当前项目目录，但要包含package.json文件. 或者是一个.nw的文件</span><br><span class=\"line\">NW.js interpreter 指定可执行的 nw(官网下的包中的) (mac下是nwjs),如：/MyDeveloper/nwjs-v0.22.1-osx-x64/nwjs.app</span><br><span class=\"line\">working direction ： 项目目录</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>运行查看效果</li>\n</ol>\n<h2 id=\"调试\"><a class=\"markdownIt-Anchor\" href=\"#调试\"></a> 调试</h2>\n<p><a href=\"https://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html\" target=\"_blank\" rel=\"noopener\">https://www.jetbrains.com/help/webstorm/2017.1/run-debug-configuration-node-webkit.html</a></p>\n<h1 id=\"打包到各个平台\"><a class=\"markdownIt-Anchor\" href=\"#打包到各个平台\"></a> 打包到各个平台</h1>\n<p><a href=\"https://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps\" target=\"_blank\" rel=\"noopener\">https://github.com/nwjs/nw.js/wiki/how-to-package-and-distribute-your-apps</a></p>\n<h2 id=\"mac下打包\"><a class=\"markdownIt-Anchor\" href=\"#mac下打包\"></a> mac下打包</h2>\n<ol>\n<li>拷贝下载的nwjs-sdk-v0.22.1-osx-x64.zip中的nwjs.app文件到项目的根目录的同级目录</li>\n<li>修改nwjs.app目录名称为你想要的名称，如：MyNW.app</li>\n<li>在项目根目录执行如下命令：zip -r …/MyNW.app/Contents/Resources/app.nw *,将当前目录下所有文件打包到MyNW.app中</li>\n<li>open MyNW.app可以打开项目</li>\n<li>制作成dmg文件</li>\n</ol>\n<ul>\n<li>\n<ul>\n<li>在应用程序-&gt;实用工具下打开磁盘工具</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>新建一个磁盘映像，放在桌面上(可随意)，名称设置为temp.dmg(可随意)，存储为mytemp</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>拷贝4中的文件到mytemp中</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>执行：ln -s /Applications /Volumes/temp.dmg/Applications</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>成功</li>\n</ol>\n<p>问题：4中制作的文件太大</p>\n<h2 id=\"代码加密保护\"><a class=\"markdownIt-Anchor\" href=\"#代码加密保护\"></a> 代码加密保护</h2>\n<blockquote>\n<p>有些情况下，代码还是不能直接暴露给用户的；我们可以使用V8 Snapshot 的方式来达到代码加密保护的目的</p>\n</blockquote>\n<p>具体的方式是:</p>\n<ol>\n<li>使用 /nwjs.exe 来运行 nwjc source.js core.bin命令</li>\n<li>在index.html里使用require(‘nw.gui’).Window.get().evalNWBin(null, ‘./app/v0.0.1/core.bin’);(注意这里的路径，是相对于nw.exe的位置)将代码引入到项目中；</li>\n<li>加密的代码里不要使用 let、const这些关键字，可能因为这个始终编译不通过</li>\n</ol>\n<h2 id=\"自动更新\"><a class=\"markdownIt-Anchor\" href=\"#自动更新\"></a> 自动更新</h2>\n<h3 id=\"项目代码需要更新\"><a class=\"markdownIt-Anchor\" href=\"#项目代码需要更新\"></a> 项目代码需要更新</h3>\n<p>前面介绍项目接口就提到 /app/v0.0.1/ 就是放置V0.0.1的所有代码的位置；<br>\n那么如果要更新到V0.0.2，那我们新建一个文件夹 /app/V0.0.2,然后把V0.0.2的代码都放到这个文件下，然后把/package.json替换成新版本的package.json；这样重启客户端之后，然会读取v0.0.2的代码了。具体的更新代码就不写了，可以把新版本的代码打包成zip包，然后客户端下载好，解压就行。</p>\n<h3 id=\"nwjs本身需要更新\"><a class=\"markdownIt-Anchor\" href=\"#nwjs本身需要更新\"></a> nw.js本身需要更新</h3>\n<p>通常情况下，不会遇到需要更新nw.js 本身的情况，因为当选定一个版本的NW.js后，就认定它了，除非遇到了什么无法解决的BUG</p>\n<h2 id=\"系列教程\"><a class=\"markdownIt-Anchor\" href=\"#系列教程\"></a> 系列教程</h2>\n<p><a href=\"https://blog.csdn.net/zeping891103/column/info/19257\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zeping891103/column/info/19257</a></p>\n"},{"title":"mac系统神器：Homebrew","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# Homebrew\nHomebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。\n\n可以类比Homebrew的功能类似于前端技术的npm，RetHat系列的yum，Ubuntu系统的apt-get\n\n# 安装\n参考官网，使用非常简单： https://brew.sh/index_zh-cn\n安装完之后可更新源： brew update/brew upgrade \n\n# Homebrew使用\n搜索软件：brew search 软件名，如brew search wget\n安装软件：brew install 软件名，如brew install wget\n卸载软件：brew remove 软件名，如brew remove wget\n\n在macOS系统上，git、node都推荐通过Homebrew安装","source":"_posts/其他/02_Homebrew.md","raw":"---\ntitle: mac系统神器：Homebrew\ntags:\n  - mac工具\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 工具\npassword:\n---\n\n# Homebrew\nHomebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。\n\n可以类比Homebrew的功能类似于前端技术的npm，RetHat系列的yum，Ubuntu系统的apt-get\n\n# 安装\n参考官网，使用非常简单： https://brew.sh/index_zh-cn\n安装完之后可更新源： brew update/brew upgrade \n\n# Homebrew使用\n搜索软件：brew search 软件名，如brew search wget\n安装软件：brew install 软件名，如brew install wget\n卸载软件：brew remove 软件名，如brew remove wget\n\n在macOS系统上，git、node都推荐通过Homebrew安装","slug":"其他-02-Homebrew","published":1,"updated":"2019-02-14T02:17:01.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyl003g5b8hfojjezmm","content":"<h1 id=\"homebrew\"><a class=\"markdownIt-Anchor\" href=\"#homebrew\"></a> Homebrew</h1>\n<p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p>\n<p>可以类比Homebrew的功能类似于前端技术的npm，RetHat系列的yum，Ubuntu系统的apt-get</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>参考官网，使用非常简单： <a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"noopener\">https://brew.sh/index_zh-cn</a><br>\n安装完之后可更新源： brew update/brew upgrade</p>\n<h1 id=\"homebrew使用\"><a class=\"markdownIt-Anchor\" href=\"#homebrew使用\"></a> Homebrew使用</h1>\n<p>搜索软件：brew search 软件名，如brew search wget<br>\n安装软件：brew install 软件名，如brew install wget<br>\n卸载软件：brew remove 软件名，如brew remove wget</p>\n<p>在macOS系统上，git、node都推荐通过Homebrew安装</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"homebrew\"><a class=\"markdownIt-Anchor\" href=\"#homebrew\"></a> Homebrew</h1>\n<p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p>\n<p>可以类比Homebrew的功能类似于前端技术的npm，RetHat系列的yum，Ubuntu系统的apt-get</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>参考官网，使用非常简单： <a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"noopener\">https://brew.sh/index_zh-cn</a><br>\n安装完之后可更新源： brew update/brew upgrade</p>\n<h1 id=\"homebrew使用\"><a class=\"markdownIt-Anchor\" href=\"#homebrew使用\"></a> Homebrew使用</h1>\n<p>搜索软件：brew search 软件名，如brew search wget<br>\n安装软件：brew install 软件名，如brew install wget<br>\n卸载软件：brew remove 软件名，如brew remove wget</p>\n<p>在macOS系统上，git、node都推荐通过Homebrew安装</p>\n"},{"title":"ngrok的使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T03:50:40.000Z","password":null,"_content":"\n\nhttps://ngrok.com/\n\nhttps://blog.csdn.net/liu_005/article/details/79557818","source":"_posts/其他/2018-10-06-ngrok的使用.md","raw":"---\ntitle: ngrok的使用\ntags:\n  - ngrok\n  - 网络工具\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 11:50:40\ncategories: 工具\npassword:\n---\n\n\nhttps://ngrok.com/\n\nhttps://blog.csdn.net/liu_005/article/details/79557818","slug":"其他-2018-10-06-ngrok的使用","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudym003j5b8hc4a0y7g0","content":"<p><a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"noopener\">https://ngrok.com/</a></p>\n<p><a href=\"https://blog.csdn.net/liu_005/article/details/79557818\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liu_005/article/details/79557818</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"noopener\">https://ngrok.com/</a></p>\n<p><a href=\"https://blog.csdn.net/liu_005/article/details/79557818\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liu_005/article/details/79557818</a></p>\n"},{"title":"iphone8p重装系统","copyright":true,"comments":1,"toc":true,"date":"2018-01-02T14:10:23.000Z","password":null,"_content":"\n# Github Pages介绍\n \n\n\n","source":"_posts/其他/2019-1-02-iphone8p重装系统.md","raw":"---\ntitle: iphone8p重装系统\ntags: \n  - 忘记锁屏密码\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-01-02 22:10:23\ncategories: 其他\npassword:\n---\n\n# Github Pages介绍\n \n\n\n","slug":"其他-2019-1-02-iphone8p重装系统","published":1,"updated":"2019-02-14T01:57:50.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyo003n5b8h7l9qgx08","content":"<h1 id=\"github-pages介绍\"><a class=\"markdownIt-Anchor\" href=\"#github-pages介绍\"></a> Github Pages介绍</h1>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"github-pages介绍\"><a class=\"markdownIt-Anchor\" href=\"#github-pages介绍\"></a> Github Pages介绍</h1>\n"},{"title":"UML类图大全","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\nhttp://www.cnblogs.com/riky/archive/2007/04/07/704298.html\n\nUML类关系图小结\n在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。\n1. 泛化（Generalization）\n【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：PLC是设备的一种，即既有设备的属性，也有PLC的特性。\n【箭头指向】：带三角箭头的实线，箭头指向父类\n2. 实现（Realization）\n【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。\n【箭头指向】：带三角箭头的虚线，箭头指向接口\n3. 关联（Association)\n【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。\n【代码体现】：成员变量\n【箭头及指向】：带普通箭头的实心线，指向被拥有者\n4. 聚合（Aggregation）\n【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。\n聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。\n【代码体现】：成员变量\n【箭头及指向】：带空心菱形的实心线，菱形指向整体\n5. 组合(Composition)\n【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。\n组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。\n【代码体现】：成员变量\n【箭头及指向】：带实心菱形的实线，菱形指向整体\n6. 依赖(Dependency)\n【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.\n【代码表现】：局部变量、方法的参数或者对静态方法的调用\n【箭头及指向】：带箭头的虚线，指向被使用者\n\n各种关系的强弱顺序：\n泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖 \n下面这张UML图，比较形象地展示了各种类图关系：\n\n![image](/pub-images/UML类图关系.png)\n\n","source":"_posts/其他/UML类图大全.md","raw":"---\ntitle: UML类图大全\ntags:\n  - UML类图\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 工具\npassword:\n---\n\nhttp://www.cnblogs.com/riky/archive/2007/04/07/704298.html\n\nUML类关系图小结\n在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。\n1. 泛化（Generalization）\n【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：PLC是设备的一种，即既有设备的属性，也有PLC的特性。\n【箭头指向】：带三角箭头的实线，箭头指向父类\n2. 实现（Realization）\n【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。\n【箭头指向】：带三角箭头的虚线，箭头指向接口\n3. 关联（Association)\n【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。\n【代码体现】：成员变量\n【箭头及指向】：带普通箭头的实心线，指向被拥有者\n4. 聚合（Aggregation）\n【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。\n聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。\n【代码体现】：成员变量\n【箭头及指向】：带空心菱形的实心线，菱形指向整体\n5. 组合(Composition)\n【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。\n组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。\n【代码体现】：成员变量\n【箭头及指向】：带实心菱形的实线，菱形指向整体\n6. 依赖(Dependency)\n【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.\n【代码表现】：局部变量、方法的参数或者对静态方法的调用\n【箭头及指向】：带箭头的虚线，指向被使用者\n\n各种关系的强弱顺序：\n泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖 \n下面这张UML图，比较形象地展示了各种类图关系：\n\n![image](/pub-images/UML类图关系.png)\n\n","slug":"其他-UML类图大全","published":1,"updated":"2019-02-14T03:00:48.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyq003p5b8hk2powtau","content":"<p><a href=\"http://www.cnblogs.com/riky/archive/2007/04/07/704298.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/riky/archive/2007/04/07/704298.html</a></p>\n<p>UML类关系图小结<br>\n在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p>\n<ol>\n<li>泛化（Generalization）<br>\n【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：PLC是设备的一种，即既有设备的属性，也有PLC的特性。<br>\n【箭头指向】：带三角箭头的实线，箭头指向父类</li>\n<li>实现（Realization）<br>\n【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。<br>\n【箭头指向】：带三角箭头的虚线，箭头指向接口</li>\n<li>关联（Association)<br>\n【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>\n【代码体现】：成员变量<br>\n【箭头及指向】：带普通箭头的实心线，指向被拥有者</li>\n<li>聚合（Aggregation）<br>\n【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>\n聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>\n【代码体现】：成员变量<br>\n【箭头及指向】：带空心菱形的实心线，菱形指向整体</li>\n<li>组合(Composition)<br>\n【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。<br>\n组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<br>\n【代码体现】：成员变量<br>\n【箭头及指向】：带实心菱形的实线，菱形指向整体</li>\n<li>依赖(Dependency)<br>\n【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.<br>\n【代码表现】：局部变量、方法的参数或者对静态方法的调用<br>\n【箭头及指向】：带箭头的虚线，指向被使用者</li>\n</ol>\n<p>各种关系的强弱顺序：<br>\n泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖<br>\n下面这张UML图，比较形象地展示了各种类图关系：</p>\n<p><img src=\"/pub-images/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.cnblogs.com/riky/archive/2007/04/07/704298.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/riky/archive/2007/04/07/704298.html</a></p>\n<p>UML类关系图小结<br>\n在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p>\n<ol>\n<li>泛化（Generalization）<br>\n【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：PLC是设备的一种，即既有设备的属性，也有PLC的特性。<br>\n【箭头指向】：带三角箭头的实线，箭头指向父类</li>\n<li>实现（Realization）<br>\n【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。<br>\n【箭头指向】：带三角箭头的虚线，箭头指向接口</li>\n<li>关联（Association)<br>\n【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>\n【代码体现】：成员变量<br>\n【箭头及指向】：带普通箭头的实心线，指向被拥有者</li>\n<li>聚合（Aggregation）<br>\n【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>\n聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>\n【代码体现】：成员变量<br>\n【箭头及指向】：带空心菱形的实心线，菱形指向整体</li>\n<li>组合(Composition)<br>\n【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。<br>\n组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<br>\n【代码体现】：成员变量<br>\n【箭头及指向】：带实心菱形的实线，菱形指向整体</li>\n<li>依赖(Dependency)<br>\n【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.<br>\n【代码表现】：局部变量、方法的参数或者对静态方法的调用<br>\n【箭头及指向】：带箭头的虚线，指向被使用者</li>\n</ol>\n<p>各种关系的强弱顺序：<br>\n泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖<br>\n下面这张UML图，比较形象地展示了各种类图关系：</p>\n<p><img src=\"/pub-images/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.png\" alt=\"image\"></p>\n"},{"title":"gitbook使用","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\nhttps://my.oschina.net/huangyong/blog/372491\n\nhttp://www.widuu.com/chinese_docker/userguide/dockerhub.html     gitbook教程\n\n# 简介及安装\nGitbook是一个开源的跨平台电子书解决方案。通过Gitbook，可以使用Markdown或者AsciiDoc来编写电子书，然后生成静态网页电子书，pdf，mobi，epub格式\n\n在使用GitBook 之前, 我们需要先安装一些必须的工具，Node.js、GitBook、GitBook Editor、Git版本控制器\n\n* 静态站点：GitBook默认输出该种格式\n* PDF：需要安装gitbook-pdf依赖\n* eBook：需要安装ebook-convert\n\nitBook官方客户端编辑器，支持Win、Linux、Mac系统\n\nhttps://www.gitbook.com/\n> 在线网站，提供在线编写工具，有客户端，免费版本文章默认公开\n\n安装：\n* npm install -g gitbook-cli  //想在系统上的任何地方的gitbook命令，需要安装“gitbook CLI”\n* npm install gitbook -g\n* gitbook -V\n\n# 使用gitbook\n## 创建项目\n> 本地命令创建\n* mkdir MyFirstBook\n* cd MyFirstBook\n* gitbook init\n> https://www.gitbook.com/ 创建在线版本，即托管到 GitBook.com \n账号：github登陆（chetaofeng@163.com）\n\n# 生成图书\n## 输出为静态网站\n在自己的电脑上编辑好图书之后，可以使用Gitbook\n的命令行进行本地预览：\n* gitbook build //生成网站，此命令会生成_book目录，而这个目录中的文件，即是生成的静态网站内容\n* gitbook serve  //启动服务\n* http://localhost:4000\n* gitbook build --output=/tmp/gitbook  //需自己创建好目标目录\n\n## 输出PDF\n* npm install gitbook-pdf -g //依赖\n* gitbook pdf【路径/文件名.pdf】\n\n## 输出电子书mobi\n> 由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以需下载安装 Calibre\n\n> Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：\n~~~\nln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin\n~~~\n\n* gitbook mobi【路径/文件名.mobi】\n\n# 编辑内容\n## README.md\n此文件是简单的电子书介绍，可以把所制作的电子书做一下简单的描述\n\n## SUMMARY.md\n此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。对于 Kindle 电子书来说，此文件所呈现的目录结构就是开头的目录内容和“前往”的目录导航\n\n如果需要“子章节”可以使用 Tab 缩进来实现（最多支持三级标题），如下所示：\n~~~\n# Summary\n\n* [第一章](section1/README.md)\n    * [第一节](section1/example1.md)\n    * [第二节](section1/example2.md)\n* [第二章](section2/README.md)\n    * [第一节](section2/example1.md)\n~~~\n\n## Glossary.md\n对于电子书内容中需要解释的词汇可在此文件中定义。词汇表会被放在电子书末尾。其格式如下所示：\n~~~\n# 电子书\n电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。\n~~~\n\n## book.json\n“book.json”是电子书的配置文件，可以看作是电子书的“原数据”，比如 title、description、isbn、language、direction、styles 等，更多:https://toolchain.gitbook.com/\n\n## 普通章节.md 文件\n每编写一个 .md 文件，不要忘了在“SUMMARY.md”文件中添加一条记录\n\n## 电子书封面图片\nGitBook 帮助文档建议封面图片的尺寸为 1800*2360 像素并且遵循建议：\n* 没有边框\n* 清晰可见的书本标题\n* 任何重要的文字在小版本中应该可见\n* 图片的格式为 jpg 格式\n\n把图片重命名为“cover.jpg”放到电子书项目文件夹即可\n\n# 高级功能\n想要gitBook更美观，或者更符合我们自己的需求，则通过book.json配置进行自定义、以及安装一些常用的插件等\n\n## Book.json配置\nGitBook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json。参考：\n~~~\n{\n\n    //样式风格配置格式\n    \"styles\": {\n        \"website\": \"styles/website.css\",\n        \"ebook\": \"styles/ebook.css\",\n        \"pdf\": \"styles/pdf.css\",\n        \"mobi\": \"styles/mobi.css\",\n        \"epub\": \"styles/epub.css\"\n     },\n\n    //插件安装配置格式\n\n    \"plugins\": [\"myplugin\"],\n    \"pluginsConfig\": {\n        \"myPlugin\": {\n            \"message\": \"Hello World\"\n        }\n     }    \n}\n~~~\n\n## 自定义插件扩展\n插件是扩展GitBook功能最好的方法。使得GitBook功能更加强大\n* 插件搜索：https://plugins.gitbook.com/\n* 插件安装：npm install 【gitbook-plugin-toggle-chapters】 --save-dev\n* 通过Book.json配置插件\n~~~\n\"plugins\": [\"toggle-chapters\"],\n    \"pluginsConfig\": {\n        \"myPlugin\": {\n            \"message\": \"Hello World\"\n        }\n     }\n~~~\n* 常用插件：http://zhaoda.net/2015/11/09/gitbook-plugins/\n\n\n# Android的离线打包\n通过Gitbook，将电子书打包成静态网站。再将静态网站放到Android APP的assets目录下，作为离线网站，打包成一个离线电子书应用（Android APP）\n\n1. 按照Gitbook规范，编写gitbook电子书\n2. 通过Gitbook，将电子书打包成静态网站\n3. 使用git将工程gitbook-android克隆下来，https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR\n4. 将静态网站放在gitbook-android工程的assets/book目录下\n5. 在“gitbook-android\\app\\src\\main\\res\\values\\strings.xml”中修改app_name\n6. 在“gitbook-android\\app\\build.gradle”中修改包名 applicationId \"com.github.snowdream.apps.gitbook\"\n7. 新增以下四个keystore相关的环境变量，用于APK签名. KEYSTORE KEYSTORE_PASSWORD KEY_ALIAS KEY_PASSWORD \n8. 在gitbook-android工程目录下，运行gradle assembleRelease --info即可。\n\n\n\n  ","source":"_posts/其他/gitbook.md","raw":"---\ntitle: gitbook使用\ntags:\n  - gitbook\n  - git\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 工具\npassword:\n---\n\nhttps://my.oschina.net/huangyong/blog/372491\n\nhttp://www.widuu.com/chinese_docker/userguide/dockerhub.html     gitbook教程\n\n# 简介及安装\nGitbook是一个开源的跨平台电子书解决方案。通过Gitbook，可以使用Markdown或者AsciiDoc来编写电子书，然后生成静态网页电子书，pdf，mobi，epub格式\n\n在使用GitBook 之前, 我们需要先安装一些必须的工具，Node.js、GitBook、GitBook Editor、Git版本控制器\n\n* 静态站点：GitBook默认输出该种格式\n* PDF：需要安装gitbook-pdf依赖\n* eBook：需要安装ebook-convert\n\nitBook官方客户端编辑器，支持Win、Linux、Mac系统\n\nhttps://www.gitbook.com/\n> 在线网站，提供在线编写工具，有客户端，免费版本文章默认公开\n\n安装：\n* npm install -g gitbook-cli  //想在系统上的任何地方的gitbook命令，需要安装“gitbook CLI”\n* npm install gitbook -g\n* gitbook -V\n\n# 使用gitbook\n## 创建项目\n> 本地命令创建\n* mkdir MyFirstBook\n* cd MyFirstBook\n* gitbook init\n> https://www.gitbook.com/ 创建在线版本，即托管到 GitBook.com \n账号：github登陆（chetaofeng@163.com）\n\n# 生成图书\n## 输出为静态网站\n在自己的电脑上编辑好图书之后，可以使用Gitbook\n的命令行进行本地预览：\n* gitbook build //生成网站，此命令会生成_book目录，而这个目录中的文件，即是生成的静态网站内容\n* gitbook serve  //启动服务\n* http://localhost:4000\n* gitbook build --output=/tmp/gitbook  //需自己创建好目标目录\n\n## 输出PDF\n* npm install gitbook-pdf -g //依赖\n* gitbook pdf【路径/文件名.pdf】\n\n## 输出电子书mobi\n> 由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以需下载安装 Calibre\n\n> Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：\n~~~\nln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin\n~~~\n\n* gitbook mobi【路径/文件名.mobi】\n\n# 编辑内容\n## README.md\n此文件是简单的电子书介绍，可以把所制作的电子书做一下简单的描述\n\n## SUMMARY.md\n此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。对于 Kindle 电子书来说，此文件所呈现的目录结构就是开头的目录内容和“前往”的目录导航\n\n如果需要“子章节”可以使用 Tab 缩进来实现（最多支持三级标题），如下所示：\n~~~\n# Summary\n\n* [第一章](section1/README.md)\n    * [第一节](section1/example1.md)\n    * [第二节](section1/example2.md)\n* [第二章](section2/README.md)\n    * [第一节](section2/example1.md)\n~~~\n\n## Glossary.md\n对于电子书内容中需要解释的词汇可在此文件中定义。词汇表会被放在电子书末尾。其格式如下所示：\n~~~\n# 电子书\n电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。\n~~~\n\n## book.json\n“book.json”是电子书的配置文件，可以看作是电子书的“原数据”，比如 title、description、isbn、language、direction、styles 等，更多:https://toolchain.gitbook.com/\n\n## 普通章节.md 文件\n每编写一个 .md 文件，不要忘了在“SUMMARY.md”文件中添加一条记录\n\n## 电子书封面图片\nGitBook 帮助文档建议封面图片的尺寸为 1800*2360 像素并且遵循建议：\n* 没有边框\n* 清晰可见的书本标题\n* 任何重要的文字在小版本中应该可见\n* 图片的格式为 jpg 格式\n\n把图片重命名为“cover.jpg”放到电子书项目文件夹即可\n\n# 高级功能\n想要gitBook更美观，或者更符合我们自己的需求，则通过book.json配置进行自定义、以及安装一些常用的插件等\n\n## Book.json配置\nGitBook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json。参考：\n~~~\n{\n\n    //样式风格配置格式\n    \"styles\": {\n        \"website\": \"styles/website.css\",\n        \"ebook\": \"styles/ebook.css\",\n        \"pdf\": \"styles/pdf.css\",\n        \"mobi\": \"styles/mobi.css\",\n        \"epub\": \"styles/epub.css\"\n     },\n\n    //插件安装配置格式\n\n    \"plugins\": [\"myplugin\"],\n    \"pluginsConfig\": {\n        \"myPlugin\": {\n            \"message\": \"Hello World\"\n        }\n     }    \n}\n~~~\n\n## 自定义插件扩展\n插件是扩展GitBook功能最好的方法。使得GitBook功能更加强大\n* 插件搜索：https://plugins.gitbook.com/\n* 插件安装：npm install 【gitbook-plugin-toggle-chapters】 --save-dev\n* 通过Book.json配置插件\n~~~\n\"plugins\": [\"toggle-chapters\"],\n    \"pluginsConfig\": {\n        \"myPlugin\": {\n            \"message\": \"Hello World\"\n        }\n     }\n~~~\n* 常用插件：http://zhaoda.net/2015/11/09/gitbook-plugins/\n\n\n# Android的离线打包\n通过Gitbook，将电子书打包成静态网站。再将静态网站放到Android APP的assets目录下，作为离线网站，打包成一个离线电子书应用（Android APP）\n\n1. 按照Gitbook规范，编写gitbook电子书\n2. 通过Gitbook，将电子书打包成静态网站\n3. 使用git将工程gitbook-android克隆下来，https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR\n4. 将静态网站放在gitbook-android工程的assets/book目录下\n5. 在“gitbook-android\\app\\src\\main\\res\\values\\strings.xml”中修改app_name\n6. 在“gitbook-android\\app\\build.gradle”中修改包名 applicationId \"com.github.snowdream.apps.gitbook\"\n7. 新增以下四个keystore相关的环境变量，用于APK签名. KEYSTORE KEYSTORE_PASSWORD KEY_ALIAS KEY_PASSWORD \n8. 在gitbook-android工程目录下，运行gradle assembleRelease --info即可。\n\n\n\n  ","slug":"其他-gitbook","published":1,"updated":"2019-02-14T02:54:54.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyt003t5b8hm7cibwx3","content":"<p><a href=\"https://my.oschina.net/huangyong/blog/372491\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/huangyong/blog/372491</a></p>\n<p><a href=\"http://www.widuu.com/chinese_docker/userguide/dockerhub.html\" target=\"_blank\" rel=\"noopener\">http://www.widuu.com/chinese_docker/userguide/dockerhub.html</a>     gitbook教程</p>\n<h1 id=\"简介及安装\"><a class=\"markdownIt-Anchor\" href=\"#简介及安装\"></a> 简介及安装</h1>\n<p>Gitbook是一个开源的跨平台电子书解决方案。通过Gitbook，可以使用Markdown或者AsciiDoc来编写电子书，然后生成静态网页电子书，pdf，mobi，epub格式</p>\n<p>在使用GitBook 之前, 我们需要先安装一些必须的工具，Node.js、GitBook、GitBook Editor、Git版本控制器</p>\n<ul>\n<li>静态站点：GitBook默认输出该种格式</li>\n<li>PDF：需要安装gitbook-pdf依赖</li>\n<li>eBook：需要安装ebook-convert</li>\n</ul>\n<p>itBook官方客户端编辑器，支持Win、Linux、Mac系统</p>\n<p><a href=\"https://www.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://www.gitbook.com/</a></p>\n<blockquote>\n<p>在线网站，提供在线编写工具，有客户端，免费版本文章默认公开</p>\n</blockquote>\n<p>安装：</p>\n<ul>\n<li>npm install -g gitbook-cli  //想在系统上的任何地方的gitbook命令，需要安装“gitbook CLI”</li>\n<li>npm install gitbook -g</li>\n<li>gitbook -V</li>\n</ul>\n<h1 id=\"使用gitbook\"><a class=\"markdownIt-Anchor\" href=\"#使用gitbook\"></a> 使用gitbook</h1>\n<h2 id=\"创建项目\"><a class=\"markdownIt-Anchor\" href=\"#创建项目\"></a> 创建项目</h2>\n<blockquote>\n<p>本地命令创建</p>\n</blockquote>\n<ul>\n<li>mkdir MyFirstBook</li>\n<li>cd MyFirstBook</li>\n<li>gitbook init</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://www.gitbook.com/</a> 创建在线版本，即托管到 <a href=\"http://GitBook.com\" target=\"_blank\" rel=\"noopener\">GitBook.com</a><br>\n账号：github登陆（chetaofeng@163.com）</p>\n</blockquote>\n<h1 id=\"生成图书\"><a class=\"markdownIt-Anchor\" href=\"#生成图书\"></a> 生成图书</h1>\n<h2 id=\"输出为静态网站\"><a class=\"markdownIt-Anchor\" href=\"#输出为静态网站\"></a> 输出为静态网站</h2>\n<p>在自己的电脑上编辑好图书之后，可以使用Gitbook<br>\n的命令行进行本地预览：</p>\n<ul>\n<li>gitbook build //生成网站，此命令会生成_book目录，而这个目录中的文件，即是生成的静态网站内容</li>\n<li>gitbook serve  //启动服务</li>\n<li><a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></li>\n<li>gitbook build --output=/tmp/gitbook  //需自己创建好目标目录</li>\n</ul>\n<h2 id=\"输出pdf\"><a class=\"markdownIt-Anchor\" href=\"#输出pdf\"></a> 输出PDF</h2>\n<ul>\n<li>npm install gitbook-pdf -g //依赖</li>\n<li>gitbook pdf【路径/文件名.pdf】</li>\n</ul>\n<h2 id=\"输出电子书mobi\"><a class=\"markdownIt-Anchor\" href=\"#输出电子书mobi\"></a> 输出电子书mobi</h2>\n<blockquote>\n<p>由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以需下载安装 Calibre</p>\n</blockquote>\n<blockquote>\n<p>Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin</span><br></pre></td></tr></table></figure>\n<ul>\n<li>gitbook mobi【路径/文件名.mobi】</li>\n</ul>\n<h1 id=\"编辑内容\"><a class=\"markdownIt-Anchor\" href=\"#编辑内容\"></a> 编辑内容</h1>\n<h2 id=\"readmemd\"><a class=\"markdownIt-Anchor\" href=\"#readmemd\"></a> <a href=\"http://README.md\" target=\"_blank\" rel=\"noopener\">README.md</a></h2>\n<p>此文件是简单的电子书介绍，可以把所制作的电子书做一下简单的描述</p>\n<h2 id=\"summarymd\"><a class=\"markdownIt-Anchor\" href=\"#summarymd\"></a> <a href=\"http://SUMMARY.md\" target=\"_blank\" rel=\"noopener\">SUMMARY.md</a></h2>\n<p>此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。对于 Kindle 电子书来说，此文件所呈现的目录结构就是开头的目录内容和“前往”的目录导航</p>\n<p>如果需要“子章节”可以使用 Tab 缩进来实现（最多支持三级标题），如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Summary</span><br><span class=\"line\"></span><br><span class=\"line\">* [第一章](section1/README.md)</span><br><span class=\"line\">    * [第一节](section1/example1.md)</span><br><span class=\"line\">    * [第二节](section1/example2.md)</span><br><span class=\"line\">* [第二章](section2/README.md)</span><br><span class=\"line\">    * [第一节](section2/example1.md)</span><br></pre></td></tr></table></figure>\n<h2 id=\"glossarymd\"><a class=\"markdownIt-Anchor\" href=\"#glossarymd\"></a> <a href=\"http://Glossary.md\" target=\"_blank\" rel=\"noopener\">Glossary.md</a></h2>\n<p>对于电子书内容中需要解释的词汇可在此文件中定义。词汇表会被放在电子书末尾。其格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 电子书</span><br><span class=\"line\">电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。</span><br></pre></td></tr></table></figure>\n<h2 id=\"bookjson\"><a class=\"markdownIt-Anchor\" href=\"#bookjson\"></a> book.json</h2>\n<p>“book.json”是电子书的配置文件，可以看作是电子书的“原数据”，比如 title、description、isbn、language、direction、styles 等，更多:<a href=\"https://toolchain.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://toolchain.gitbook.com/</a></p>\n<h2 id=\"普通章节md\"><a class=\"markdownIt-Anchor\" href=\"#普通章节md\"></a> <a href=\"http://xn--tkv086brrfx7o.md\" target=\"_blank\" rel=\"noopener\">普通章节.md</a> 文件</h2>\n<p>每编写一个 .md 文件，不要忘了在“<a href=\"http://SUMMARY.md\" target=\"_blank\" rel=\"noopener\">SUMMARY.md</a>”文件中添加一条记录</p>\n<h2 id=\"电子书封面图片\"><a class=\"markdownIt-Anchor\" href=\"#电子书封面图片\"></a> 电子书封面图片</h2>\n<p>GitBook 帮助文档建议封面图片的尺寸为 1800*2360 像素并且遵循建议：</p>\n<ul>\n<li>没有边框</li>\n<li>清晰可见的书本标题</li>\n<li>任何重要的文字在小版本中应该可见</li>\n<li>图片的格式为 jpg 格式</li>\n</ul>\n<p>把图片重命名为“cover.jpg”放到电子书项目文件夹即可</p>\n<h1 id=\"高级功能\"><a class=\"markdownIt-Anchor\" href=\"#高级功能\"></a> 高级功能</h1>\n<p>想要gitBook更美观，或者更符合我们自己的需求，则通过book.json配置进行自定义、以及安装一些常用的插件等</p>\n<h2 id=\"bookjson配置\"><a class=\"markdownIt-Anchor\" href=\"#bookjson配置\"></a> Book.json配置</h2>\n<p>GitBook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json。参考：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //样式风格配置格式</span><br><span class=\"line\">    &quot;styles&quot;: &#123;</span><br><span class=\"line\">        &quot;website&quot;: &quot;styles/website.css&quot;,</span><br><span class=\"line\">        &quot;ebook&quot;: &quot;styles/ebook.css&quot;,</span><br><span class=\"line\">        &quot;pdf&quot;: &quot;styles/pdf.css&quot;,</span><br><span class=\"line\">        &quot;mobi&quot;: &quot;styles/mobi.css&quot;,</span><br><span class=\"line\">        &quot;epub&quot;: &quot;styles/epub.css&quot;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    //插件安装配置格式</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;plugins&quot;: [&quot;myplugin&quot;],</span><br><span class=\"line\">    &quot;pluginsConfig&quot;: &#123;</span><br><span class=\"line\">        &quot;myPlugin&quot;: &#123;</span><br><span class=\"line\">            &quot;message&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义插件扩展\"><a class=\"markdownIt-Anchor\" href=\"#自定义插件扩展\"></a> 自定义插件扩展</h2>\n<p>插件是扩展GitBook功能最好的方法。使得GitBook功能更加强大</p>\n<ul>\n<li>插件搜索：<a href=\"https://plugins.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://plugins.gitbook.com/</a></li>\n<li>插件安装：npm install 【gitbook-plugin-toggle-chapters】 --save-dev</li>\n<li>通过Book.json配置插件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;plugins&quot;: [&quot;toggle-chapters&quot;],</span><br><span class=\"line\">    &quot;pluginsConfig&quot;: &#123;</span><br><span class=\"line\">        &quot;myPlugin&quot;: &#123;</span><br><span class=\"line\">            &quot;message&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常用插件：<a href=\"http://zhaoda.net/2015/11/09/gitbook-plugins/\" target=\"_blank\" rel=\"noopener\">http://zhaoda.net/2015/11/09/gitbook-plugins/</a></li>\n</ul>\n<h1 id=\"android的离线打包\"><a class=\"markdownIt-Anchor\" href=\"#android的离线打包\"></a> Android的离线打包</h1>\n<p>通过Gitbook，将电子书打包成静态网站。再将静态网站放到Android APP的assets目录下，作为离线网站，打包成一个离线电子书应用（Android APP）</p>\n<ol>\n<li>按照Gitbook规范，编写gitbook电子书</li>\n<li>通过Gitbook，将电子书打包成静态网站</li>\n<li>使用git将工程gitbook-android克隆下来，<a href=\"https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR\" target=\"_blank\" rel=\"noopener\">https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR</a></li>\n<li>将静态网站放在gitbook-android工程的assets/book目录下</li>\n<li>在“gitbook-android\\app\\src\\main\\res\\values\\strings.xml”中修改app_name</li>\n<li>在“gitbook-android\\app\\build.gradle”中修改包名 applicationId “com.github.snowdream.apps.gitbook”</li>\n<li>新增以下四个keystore相关的环境变量，用于APK签名. KEYSTORE KEYSTORE_PASSWORD KEY_ALIAS KEY_PASSWORD</li>\n<li>在gitbook-android工程目录下，运行gradle assembleRelease --info即可。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/huangyong/blog/372491\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/huangyong/blog/372491</a></p>\n<p><a href=\"http://www.widuu.com/chinese_docker/userguide/dockerhub.html\" target=\"_blank\" rel=\"noopener\">http://www.widuu.com/chinese_docker/userguide/dockerhub.html</a>     gitbook教程</p>\n<h1 id=\"简介及安装\"><a class=\"markdownIt-Anchor\" href=\"#简介及安装\"></a> 简介及安装</h1>\n<p>Gitbook是一个开源的跨平台电子书解决方案。通过Gitbook，可以使用Markdown或者AsciiDoc来编写电子书，然后生成静态网页电子书，pdf，mobi，epub格式</p>\n<p>在使用GitBook 之前, 我们需要先安装一些必须的工具，Node.js、GitBook、GitBook Editor、Git版本控制器</p>\n<ul>\n<li>静态站点：GitBook默认输出该种格式</li>\n<li>PDF：需要安装gitbook-pdf依赖</li>\n<li>eBook：需要安装ebook-convert</li>\n</ul>\n<p>itBook官方客户端编辑器，支持Win、Linux、Mac系统</p>\n<p><a href=\"https://www.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://www.gitbook.com/</a></p>\n<blockquote>\n<p>在线网站，提供在线编写工具，有客户端，免费版本文章默认公开</p>\n</blockquote>\n<p>安装：</p>\n<ul>\n<li>npm install -g gitbook-cli  //想在系统上的任何地方的gitbook命令，需要安装“gitbook CLI”</li>\n<li>npm install gitbook -g</li>\n<li>gitbook -V</li>\n</ul>\n<h1 id=\"使用gitbook\"><a class=\"markdownIt-Anchor\" href=\"#使用gitbook\"></a> 使用gitbook</h1>\n<h2 id=\"创建项目\"><a class=\"markdownIt-Anchor\" href=\"#创建项目\"></a> 创建项目</h2>\n<blockquote>\n<p>本地命令创建</p>\n</blockquote>\n<ul>\n<li>mkdir MyFirstBook</li>\n<li>cd MyFirstBook</li>\n<li>gitbook init</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://www.gitbook.com/</a> 创建在线版本，即托管到 <a href=\"http://GitBook.com\" target=\"_blank\" rel=\"noopener\">GitBook.com</a><br>\n账号：github登陆（chetaofeng@163.com）</p>\n</blockquote>\n<h1 id=\"生成图书\"><a class=\"markdownIt-Anchor\" href=\"#生成图书\"></a> 生成图书</h1>\n<h2 id=\"输出为静态网站\"><a class=\"markdownIt-Anchor\" href=\"#输出为静态网站\"></a> 输出为静态网站</h2>\n<p>在自己的电脑上编辑好图书之后，可以使用Gitbook<br>\n的命令行进行本地预览：</p>\n<ul>\n<li>gitbook build //生成网站，此命令会生成_book目录，而这个目录中的文件，即是生成的静态网站内容</li>\n<li>gitbook serve  //启动服务</li>\n<li><a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></li>\n<li>gitbook build --output=/tmp/gitbook  //需自己创建好目标目录</li>\n</ul>\n<h2 id=\"输出pdf\"><a class=\"markdownIt-Anchor\" href=\"#输出pdf\"></a> 输出PDF</h2>\n<ul>\n<li>npm install gitbook-pdf -g //依赖</li>\n<li>gitbook pdf【路径/文件名.pdf】</li>\n</ul>\n<h2 id=\"输出电子书mobi\"><a class=\"markdownIt-Anchor\" href=\"#输出电子书mobi\"></a> 输出电子书mobi</h2>\n<blockquote>\n<p>由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以需下载安装 Calibre</p>\n</blockquote>\n<blockquote>\n<p>Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin</span><br></pre></td></tr></table></figure>\n<ul>\n<li>gitbook mobi【路径/文件名.mobi】</li>\n</ul>\n<h1 id=\"编辑内容\"><a class=\"markdownIt-Anchor\" href=\"#编辑内容\"></a> 编辑内容</h1>\n<h2 id=\"readmemd\"><a class=\"markdownIt-Anchor\" href=\"#readmemd\"></a> <a href=\"http://README.md\" target=\"_blank\" rel=\"noopener\">README.md</a></h2>\n<p>此文件是简单的电子书介绍，可以把所制作的电子书做一下简单的描述</p>\n<h2 id=\"summarymd\"><a class=\"markdownIt-Anchor\" href=\"#summarymd\"></a> <a href=\"http://SUMMARY.md\" target=\"_blank\" rel=\"noopener\">SUMMARY.md</a></h2>\n<p>此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。对于 Kindle 电子书来说，此文件所呈现的目录结构就是开头的目录内容和“前往”的目录导航</p>\n<p>如果需要“子章节”可以使用 Tab 缩进来实现（最多支持三级标题），如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Summary</span><br><span class=\"line\"></span><br><span class=\"line\">* [第一章](section1/README.md)</span><br><span class=\"line\">    * [第一节](section1/example1.md)</span><br><span class=\"line\">    * [第二节](section1/example2.md)</span><br><span class=\"line\">* [第二章](section2/README.md)</span><br><span class=\"line\">    * [第一节](section2/example1.md)</span><br></pre></td></tr></table></figure>\n<h2 id=\"glossarymd\"><a class=\"markdownIt-Anchor\" href=\"#glossarymd\"></a> <a href=\"http://Glossary.md\" target=\"_blank\" rel=\"noopener\">Glossary.md</a></h2>\n<p>对于电子书内容中需要解释的词汇可在此文件中定义。词汇表会被放在电子书末尾。其格式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 电子书</span><br><span class=\"line\">电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。</span><br></pre></td></tr></table></figure>\n<h2 id=\"bookjson\"><a class=\"markdownIt-Anchor\" href=\"#bookjson\"></a> book.json</h2>\n<p>“book.json”是电子书的配置文件，可以看作是电子书的“原数据”，比如 title、description、isbn、language、direction、styles 等，更多:<a href=\"https://toolchain.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://toolchain.gitbook.com/</a></p>\n<h2 id=\"普通章节md\"><a class=\"markdownIt-Anchor\" href=\"#普通章节md\"></a> <a href=\"http://xn--tkv086brrfx7o.md\" target=\"_blank\" rel=\"noopener\">普通章节.md</a> 文件</h2>\n<p>每编写一个 .md 文件，不要忘了在“<a href=\"http://SUMMARY.md\" target=\"_blank\" rel=\"noopener\">SUMMARY.md</a>”文件中添加一条记录</p>\n<h2 id=\"电子书封面图片\"><a class=\"markdownIt-Anchor\" href=\"#电子书封面图片\"></a> 电子书封面图片</h2>\n<p>GitBook 帮助文档建议封面图片的尺寸为 1800*2360 像素并且遵循建议：</p>\n<ul>\n<li>没有边框</li>\n<li>清晰可见的书本标题</li>\n<li>任何重要的文字在小版本中应该可见</li>\n<li>图片的格式为 jpg 格式</li>\n</ul>\n<p>把图片重命名为“cover.jpg”放到电子书项目文件夹即可</p>\n<h1 id=\"高级功能\"><a class=\"markdownIt-Anchor\" href=\"#高级功能\"></a> 高级功能</h1>\n<p>想要gitBook更美观，或者更符合我们自己的需求，则通过book.json配置进行自定义、以及安装一些常用的插件等</p>\n<h2 id=\"bookjson配置\"><a class=\"markdownIt-Anchor\" href=\"#bookjson配置\"></a> Book.json配置</h2>\n<p>GitBook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json。参考：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //样式风格配置格式</span><br><span class=\"line\">    &quot;styles&quot;: &#123;</span><br><span class=\"line\">        &quot;website&quot;: &quot;styles/website.css&quot;,</span><br><span class=\"line\">        &quot;ebook&quot;: &quot;styles/ebook.css&quot;,</span><br><span class=\"line\">        &quot;pdf&quot;: &quot;styles/pdf.css&quot;,</span><br><span class=\"line\">        &quot;mobi&quot;: &quot;styles/mobi.css&quot;,</span><br><span class=\"line\">        &quot;epub&quot;: &quot;styles/epub.css&quot;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    //插件安装配置格式</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;plugins&quot;: [&quot;myplugin&quot;],</span><br><span class=\"line\">    &quot;pluginsConfig&quot;: &#123;</span><br><span class=\"line\">        &quot;myPlugin&quot;: &#123;</span><br><span class=\"line\">            &quot;message&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义插件扩展\"><a class=\"markdownIt-Anchor\" href=\"#自定义插件扩展\"></a> 自定义插件扩展</h2>\n<p>插件是扩展GitBook功能最好的方法。使得GitBook功能更加强大</p>\n<ul>\n<li>插件搜索：<a href=\"https://plugins.gitbook.com/\" target=\"_blank\" rel=\"noopener\">https://plugins.gitbook.com/</a></li>\n<li>插件安装：npm install 【gitbook-plugin-toggle-chapters】 --save-dev</li>\n<li>通过Book.json配置插件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;plugins&quot;: [&quot;toggle-chapters&quot;],</span><br><span class=\"line\">    &quot;pluginsConfig&quot;: &#123;</span><br><span class=\"line\">        &quot;myPlugin&quot;: &#123;</span><br><span class=\"line\">            &quot;message&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常用插件：<a href=\"http://zhaoda.net/2015/11/09/gitbook-plugins/\" target=\"_blank\" rel=\"noopener\">http://zhaoda.net/2015/11/09/gitbook-plugins/</a></li>\n</ul>\n<h1 id=\"android的离线打包\"><a class=\"markdownIt-Anchor\" href=\"#android的离线打包\"></a> Android的离线打包</h1>\n<p>通过Gitbook，将电子书打包成静态网站。再将静态网站放到Android APP的assets目录下，作为离线网站，打包成一个离线电子书应用（Android APP）</p>\n<ol>\n<li>按照Gitbook规范，编写gitbook电子书</li>\n<li>通过Gitbook，将电子书打包成静态网站</li>\n<li>使用git将工程gitbook-android克隆下来，<a href=\"https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR\" target=\"_blank\" rel=\"noopener\">https://github.com/snowdream/gitbook-android?spm=5176.100239.blogcont31432.7.rKGSpR</a></li>\n<li>将静态网站放在gitbook-android工程的assets/book目录下</li>\n<li>在“gitbook-android\\app\\src\\main\\res\\values\\strings.xml”中修改app_name</li>\n<li>在“gitbook-android\\app\\build.gradle”中修改包名 applicationId “com.github.snowdream.apps.gitbook”</li>\n<li>新增以下四个keystore相关的环境变量，用于APK签名. KEYSTORE KEYSTORE_PASSWORD KEY_ALIAS KEY_PASSWORD</li>\n<li>在gitbook-android工程目录下，运行gradle assembleRelease --info即可。</li>\n</ol>\n"},{"title":"postman","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\nhttps://www.cnblogs.com/haoduoyu/p/5864775.html\n插件网\nhttp://www.cnplugins.com/tool/specify-postman-methods.html\nhttp://www.cnplugins.com/tool/specify-postman-methods.html\nhttps://www.cnblogs.com/s380774061/p/4624326.html   推荐\nhttps://blog.csdn.net/five3/article/details/53021084   推荐\nhttps://blog.csdn.net/u013613428/article/details/51557804   推荐\nhttps://blog.csdn.net/xiaosongbk/article/details/52801207  token问题\nhttps://blog.csdn.net/u011320646/article/details/77141876 token问题\n\nhttp://www.graphicsmagick.org/\nhttp://baijiahao.baidu.com/s?id=1574259218782197&wfr=spider&for=pc\n\n\n\nhttps://github.com/dmytrodanylyk/folding-plugin\n\n  ","source":"_posts/其他/postman.md","raw":"---\ntitle: postman\ntags:\n  - postman\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 工具\npassword:\n---\n\nhttps://www.cnblogs.com/haoduoyu/p/5864775.html\n插件网\nhttp://www.cnplugins.com/tool/specify-postman-methods.html\nhttp://www.cnplugins.com/tool/specify-postman-methods.html\nhttps://www.cnblogs.com/s380774061/p/4624326.html   推荐\nhttps://blog.csdn.net/five3/article/details/53021084   推荐\nhttps://blog.csdn.net/u013613428/article/details/51557804   推荐\nhttps://blog.csdn.net/xiaosongbk/article/details/52801207  token问题\nhttps://blog.csdn.net/u011320646/article/details/77141876 token问题\n\nhttp://www.graphicsmagick.org/\nhttp://baijiahao.baidu.com/s?id=1574259218782197&wfr=spider&for=pc\n\n\n\nhttps://github.com/dmytrodanylyk/folding-plugin\n\n  ","slug":"其他-postman","published":1,"updated":"2019-02-14T02:53:52.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyv003w5b8hfbmitcht","content":"<p><a href=\"https://www.cnblogs.com/haoduoyu/p/5864775.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/haoduoyu/p/5864775.html</a><br>\n插件网<br>\n<a href=\"http://www.cnplugins.com/tool/specify-postman-methods.html\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/tool/specify-postman-methods.html</a><br>\n<a href=\"http://www.cnplugins.com/tool/specify-postman-methods.html\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/tool/specify-postman-methods.html</a><br>\n<a href=\"https://www.cnblogs.com/s380774061/p/4624326.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/s380774061/p/4624326.html</a>   推荐<br>\n<a href=\"https://blog.csdn.net/five3/article/details/53021084\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/five3/article/details/53021084</a>   推荐<br>\n<a href=\"https://blog.csdn.net/u013613428/article/details/51557804\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013613428/article/details/51557804</a>   推荐<br>\n<a href=\"https://blog.csdn.net/xiaosongbk/article/details/52801207\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiaosongbk/article/details/52801207</a>  token问题<br>\n<a href=\"https://blog.csdn.net/u011320646/article/details/77141876\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011320646/article/details/77141876</a> token问题</p>\n<p><a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">http://www.graphicsmagick.org/</a><br>\n<a href=\"http://baijiahao.baidu.com/s?id=1574259218782197&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">http://baijiahao.baidu.com/s?id=1574259218782197&amp;wfr=spider&amp;for=pc</a></p>\n<p><a href=\"https://github.com/dmytrodanylyk/folding-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/dmytrodanylyk/folding-plugin</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.cnblogs.com/haoduoyu/p/5864775.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/haoduoyu/p/5864775.html</a><br>\n插件网<br>\n<a href=\"http://www.cnplugins.com/tool/specify-postman-methods.html\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/tool/specify-postman-methods.html</a><br>\n<a href=\"http://www.cnplugins.com/tool/specify-postman-methods.html\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/tool/specify-postman-methods.html</a><br>\n<a href=\"https://www.cnblogs.com/s380774061/p/4624326.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/s380774061/p/4624326.html</a>   推荐<br>\n<a href=\"https://blog.csdn.net/five3/article/details/53021084\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/five3/article/details/53021084</a>   推荐<br>\n<a href=\"https://blog.csdn.net/u013613428/article/details/51557804\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013613428/article/details/51557804</a>   推荐<br>\n<a href=\"https://blog.csdn.net/xiaosongbk/article/details/52801207\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiaosongbk/article/details/52801207</a>  token问题<br>\n<a href=\"https://blog.csdn.net/u011320646/article/details/77141876\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011320646/article/details/77141876</a> token问题</p>\n<p><a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">http://www.graphicsmagick.org/</a><br>\n<a href=\"http://baijiahao.baidu.com/s?id=1574259218782197&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">http://baijiahao.baidu.com/s?id=1574259218782197&amp;wfr=spider&amp;for=pc</a></p>\n<p><a href=\"https://github.com/dmytrodanylyk/folding-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/dmytrodanylyk/folding-plugin</a></p>\n"},{"title":"SVN迁移","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\nSVN_Root为所有SVN操作根目录，包括所有的软件、资源库等\n* Soft：为搭建SVN环境相关的软件\n* Subversion：为SVN服务端软件安装目录\n* SVN_BAK：为SVN备份文件\n* repos:SVN仓库的根目录\n* ReadMe：当前目录说明文件\n\n所有命令行操作需要管理员权限\n\n服务启动：\nsvnserve.exe -d -r D:\\SVN_Root\\repos\n\nSVN还原\nsvnadmin load D:\\SVN_Root\\repos\\repos < D:\\repos.dump\n\n注册为系统服务\nsc create svn binpath= \"\\\"D:\\SVN_Root\\Subversion\\bin\\svnserve.exe\\\" --service -r D:\\SVN_Root\\repos\" displayname= \"Subversion Server\" depend= Tcpip start= auto\n\n\n项目更换服务器，需迁移SVN，现记录过程。\n\n Subversion简介\n1. Subversion（简称SVN）是一款功能强大的开源版本控制工具，支持Linux和Windows平台。\n2. SVN可以有两个访问方式，一种是独立服务器直接访问，即利用svnserve命令启动服务，通过svn://yourdomain.com/project进行访问和操作。另一种结合apache，利用HTTP协议，通过http://yourdomain.com/svn/project进行访问及各类操作。如果服务器需要在互联网上共享，一般选择后一种方式。\n3. 通常情况下，如果选择SVN Server和Apache HTTP Server各自独立安装，配置起来会比较繁琐。\n\n软件下载\n服务器：Subversion v1.7 http://sourceforge.net/projects/win32svn/\n客户端：Tortoisesvn V1.7 http://tortoisesvn.net/downloads.html\n\n结构说明\nD:/svnroot\n├─project1\n│     ├─conf\n│     ├─dav\n│     ├─db\n│     │     ├─revprops\n│     │     ├─revs\n│     │     └─transactions\n│     ├─hooks\n│     └─locks\n└─project2\n       ├─conf\n       ├─dav\n       ├─db\n       │     ├─revprops\n       │     ├─revs\n       │     └─transactions\n       ├─hooks\n└─locks\n其中：svnroot文件夹为存放所有仓库，也是服务启动的时候需指定的目录，下面的各项为项目目录\n\n启动服务\n启动独立服务方式\nsvnserve –d –r e:/svn_repository/\n访问方法：svn://localhost/dev，或file:///3:/svn_repository/dev\n启动apache方式\ncd D:/Program Files/CollabNet Subversion Server/httpd/bin\nhttpd.exe\n访问方法：http://localhost/svn/dev/\n\n本项目所使用过程\n所有命令行操作需要管理员权限\n1.服务启动：\nsvnserve.exe -d -r D:\\SVN_Root\\repos\n2.SVN备份（从源服务器备份，如：192.168.11.121）：\nA：svnadmin dump d:\\svn\\repos\\project1> dump.dump >D:\\repos.dump      .dump后缀不能丢\nB：备份d:\\svn\\repos\\project1下conf目录\n3.SVN还原（拷贝.dump文件到目的服务器，如：192.168.7.116）：\n        A：svnadmin create D:\\SVN_Root\\repos\\project1\nB：svnadmin load D:\\SVN_Root\\repos\\project1 < D:\\repos.dump\nC：拷贝2.B中备份的conf文件夹覆盖D:\\SVN_Root\\repos\\project1下conf文件\n4.注册为系统服务\nsc create svn binpath= \"\\\"D:\\SVN_Root\\Subversion\\bin\\svnserve.exe\\\" --service -r D:\\SVN_Root\\repos\" displayname= \"Subversion Server\" depend= Tcpip start= auto\n\n荐读：\nsvnadmin命令：\nhttp://blog.csdn.net/wzq9706/article/details/7319728\nhttp://www.ityen.com/archives/529\nsvn命令：http://blog.sina.com.cn/s/blog_963453200101eiuq.html，svn命令也可通过Tortoisesvn客户端操作代替\n  ","source":"_posts/其他/svn迁移.md","raw":"---\ntitle: SVN迁移\ntags:\n  - SVN \ncopyright: true\ncomments: true\ntoc: true\ncategories: 工具\npassword:\n---\n\nSVN_Root为所有SVN操作根目录，包括所有的软件、资源库等\n* Soft：为搭建SVN环境相关的软件\n* Subversion：为SVN服务端软件安装目录\n* SVN_BAK：为SVN备份文件\n* repos:SVN仓库的根目录\n* ReadMe：当前目录说明文件\n\n所有命令行操作需要管理员权限\n\n服务启动：\nsvnserve.exe -d -r D:\\SVN_Root\\repos\n\nSVN还原\nsvnadmin load D:\\SVN_Root\\repos\\repos < D:\\repos.dump\n\n注册为系统服务\nsc create svn binpath= \"\\\"D:\\SVN_Root\\Subversion\\bin\\svnserve.exe\\\" --service -r D:\\SVN_Root\\repos\" displayname= \"Subversion Server\" depend= Tcpip start= auto\n\n\n项目更换服务器，需迁移SVN，现记录过程。\n\n Subversion简介\n1. Subversion（简称SVN）是一款功能强大的开源版本控制工具，支持Linux和Windows平台。\n2. SVN可以有两个访问方式，一种是独立服务器直接访问，即利用svnserve命令启动服务，通过svn://yourdomain.com/project进行访问和操作。另一种结合apache，利用HTTP协议，通过http://yourdomain.com/svn/project进行访问及各类操作。如果服务器需要在互联网上共享，一般选择后一种方式。\n3. 通常情况下，如果选择SVN Server和Apache HTTP Server各自独立安装，配置起来会比较繁琐。\n\n软件下载\n服务器：Subversion v1.7 http://sourceforge.net/projects/win32svn/\n客户端：Tortoisesvn V1.7 http://tortoisesvn.net/downloads.html\n\n结构说明\nD:/svnroot\n├─project1\n│     ├─conf\n│     ├─dav\n│     ├─db\n│     │     ├─revprops\n│     │     ├─revs\n│     │     └─transactions\n│     ├─hooks\n│     └─locks\n└─project2\n       ├─conf\n       ├─dav\n       ├─db\n       │     ├─revprops\n       │     ├─revs\n       │     └─transactions\n       ├─hooks\n└─locks\n其中：svnroot文件夹为存放所有仓库，也是服务启动的时候需指定的目录，下面的各项为项目目录\n\n启动服务\n启动独立服务方式\nsvnserve –d –r e:/svn_repository/\n访问方法：svn://localhost/dev，或file:///3:/svn_repository/dev\n启动apache方式\ncd D:/Program Files/CollabNet Subversion Server/httpd/bin\nhttpd.exe\n访问方法：http://localhost/svn/dev/\n\n本项目所使用过程\n所有命令行操作需要管理员权限\n1.服务启动：\nsvnserve.exe -d -r D:\\SVN_Root\\repos\n2.SVN备份（从源服务器备份，如：192.168.11.121）：\nA：svnadmin dump d:\\svn\\repos\\project1> dump.dump >D:\\repos.dump      .dump后缀不能丢\nB：备份d:\\svn\\repos\\project1下conf目录\n3.SVN还原（拷贝.dump文件到目的服务器，如：192.168.7.116）：\n        A：svnadmin create D:\\SVN_Root\\repos\\project1\nB：svnadmin load D:\\SVN_Root\\repos\\project1 < D:\\repos.dump\nC：拷贝2.B中备份的conf文件夹覆盖D:\\SVN_Root\\repos\\project1下conf文件\n4.注册为系统服务\nsc create svn binpath= \"\\\"D:\\SVN_Root\\Subversion\\bin\\svnserve.exe\\\" --service -r D:\\SVN_Root\\repos\" displayname= \"Subversion Server\" depend= Tcpip start= auto\n\n荐读：\nsvnadmin命令：\nhttp://blog.csdn.net/wzq9706/article/details/7319728\nhttp://www.ityen.com/archives/529\nsvn命令：http://blog.sina.com.cn/s/blog_963453200101eiuq.html，svn命令也可通过Tortoisesvn客户端操作代替\n  ","slug":"其他-svn迁移","published":1,"date":"2019-02-14T08:24:30.000Z","updated":"2019-02-14T08:24:30.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyx00415b8hdtsnz2s2","content":"<p>SVN_Root为所有SVN操作根目录，包括所有的软件、资源库等</p>\n<ul>\n<li>Soft：为搭建SVN环境相关的软件</li>\n<li>Subversion：为SVN服务端软件安装目录</li>\n<li>SVN_BAK：为SVN备份文件</li>\n<li>repos:SVN仓库的根目录</li>\n<li>ReadMe：当前目录说明文件</li>\n</ul>\n<p>所有命令行操作需要管理员权限</p>\n<p>服务启动：<br>\nsvnserve.exe -d -r D:\\SVN_Root\\repos</p>\n<p>SVN还原<br>\nsvnadmin load D:\\SVN_Root\\repos\\repos &lt; D:\\repos.dump</p>\n<p>注册为系统服务<br>\nsc create svn binpath= ““D:\\SVN_Root\\Subversion\\bin\\svnserve.exe” --service -r D:\\SVN_Root\\repos” displayname= “Subversion Server” depend= Tcpip start= auto</p>\n<p>项目更换服务器，需迁移SVN，现记录过程。</p>\n<p>Subversion简介</p>\n<ol>\n<li>Subversion（简称SVN）是一款功能强大的开源版本控制工具，支持Linux和Windows平台。</li>\n<li>SVN可以有两个访问方式，一种是独立服务器直接访问，即利用svnserve命令启动服务，通过svn://yourdomain.com/project进行访问和操作。另一种结合apache，利用HTTP协议，通过http://yourdomain.com/svn/project进行访问及各类操作。如果服务器需要在互联网上共享，一般选择后一种方式。</li>\n<li>通常情况下，如果选择SVN Server和Apache HTTP Server各自独立安装，配置起来会比较繁琐。</li>\n</ol>\n<p>软件下载<br>\n服务器：Subversion v1.7 <a href=\"http://sourceforge.net/projects/win32svn/\" target=\"_blank\" rel=\"noopener\">http://sourceforge.net/projects/win32svn/</a><br>\n客户端：Tortoisesvn V1.7 <a href=\"http://tortoisesvn.net/downloads.html\" target=\"_blank\" rel=\"noopener\">http://tortoisesvn.net/downloads.html</a></p>\n<p>结构说明<br>\nD:/svnroot<br>\n├─project1<br>\n│     ├─conf<br>\n│     ├─dav<br>\n│     ├─db<br>\n│     │     ├─revprops<br>\n│     │     ├─revs<br>\n│     │     └─transactions<br>\n│     ├─hooks<br>\n│     └─locks<br>\n└─project2<br>\n├─conf<br>\n├─dav<br>\n├─db<br>\n│     ├─revprops<br>\n│     ├─revs<br>\n│     └─transactions<br>\n├─hooks<br>\n└─locks<br>\n其中：svnroot文件夹为存放所有仓库，也是服务启动的时候需指定的目录，下面的各项为项目目录</p>\n<p>启动服务<br>\n启动独立服务方式<br>\nsvnserve –d –r e:/svn_repository/<br>\n访问方法：svn://localhost/dev，或file:///3:/svn_repository/dev<br>\n启动apache方式<br>\ncd D:/Program Files/CollabNet Subversion Server/httpd/bin<br>\nhttpd.exe<br>\n访问方法：<a href=\"http://localhost/svn/dev/\" target=\"_blank\" rel=\"noopener\">http://localhost/svn/dev/</a></p>\n<p>本项目所使用过程<br>\n所有命令行操作需要管理员权限<br>\n1.服务启动：<br>\nsvnserve.exe -d -r D:\\SVN_Root\\repos<br>\n2.SVN备份（从源服务器备份，如：192.168.11.121）：<br>\nA：svnadmin dump d:\\svn\\repos\\project1&gt; dump.dump &gt;D:\\repos.dump      .dump后缀不能丢<br>\nB：备份d:\\svn\\repos\\project1下conf目录<br>\n3.SVN还原（拷贝.dump文件到目的服务器，如：192.168.7.116）：<br>\nA：svnadmin create D:\\SVN_Root\\repos\\project1<br>\nB：svnadmin load D:\\SVN_Root\\repos\\project1 &lt; D:\\repos.dump<br>\nC：拷贝2.B中备份的conf文件夹覆盖D:\\SVN_Root\\repos\\project1下conf文件<br>\n4.注册为系统服务<br>\nsc create svn binpath= ““D:\\SVN_Root\\Subversion\\bin\\svnserve.exe” --service -r D:\\SVN_Root\\repos” displayname= “Subversion Server” depend= Tcpip start= auto</p>\n<p>荐读：<br>\nsvnadmin命令：<br>\n<a href=\"http://blog.csdn.net/wzq9706/article/details/7319728\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/wzq9706/article/details/7319728</a><br>\n<a href=\"http://www.ityen.com/archives/529\" target=\"_blank\" rel=\"noopener\">http://www.ityen.com/archives/529</a><br>\nsvn命令：<a href=\"http://blog.sina.com.cn/s/blog_963453200101eiuq.html%EF%BC%8Csvn%E5%91%BD%E4%BB%A4%E4%B9%9F%E5%8F%AF%E9%80%9A%E8%BF%87Tortoisesvn%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E4%BB%A3%E6%9B%BF\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_963453200101eiuq.html，svn命令也可通过Tortoisesvn客户端操作代替</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>SVN_Root为所有SVN操作根目录，包括所有的软件、资源库等</p>\n<ul>\n<li>Soft：为搭建SVN环境相关的软件</li>\n<li>Subversion：为SVN服务端软件安装目录</li>\n<li>SVN_BAK：为SVN备份文件</li>\n<li>repos:SVN仓库的根目录</li>\n<li>ReadMe：当前目录说明文件</li>\n</ul>\n<p>所有命令行操作需要管理员权限</p>\n<p>服务启动：<br>\nsvnserve.exe -d -r D:\\SVN_Root\\repos</p>\n<p>SVN还原<br>\nsvnadmin load D:\\SVN_Root\\repos\\repos &lt; D:\\repos.dump</p>\n<p>注册为系统服务<br>\nsc create svn binpath= ““D:\\SVN_Root\\Subversion\\bin\\svnserve.exe” --service -r D:\\SVN_Root\\repos” displayname= “Subversion Server” depend= Tcpip start= auto</p>\n<p>项目更换服务器，需迁移SVN，现记录过程。</p>\n<p>Subversion简介</p>\n<ol>\n<li>Subversion（简称SVN）是一款功能强大的开源版本控制工具，支持Linux和Windows平台。</li>\n<li>SVN可以有两个访问方式，一种是独立服务器直接访问，即利用svnserve命令启动服务，通过svn://yourdomain.com/project进行访问和操作。另一种结合apache，利用HTTP协议，通过http://yourdomain.com/svn/project进行访问及各类操作。如果服务器需要在互联网上共享，一般选择后一种方式。</li>\n<li>通常情况下，如果选择SVN Server和Apache HTTP Server各自独立安装，配置起来会比较繁琐。</li>\n</ol>\n<p>软件下载<br>\n服务器：Subversion v1.7 <a href=\"http://sourceforge.net/projects/win32svn/\" target=\"_blank\" rel=\"noopener\">http://sourceforge.net/projects/win32svn/</a><br>\n客户端：Tortoisesvn V1.7 <a href=\"http://tortoisesvn.net/downloads.html\" target=\"_blank\" rel=\"noopener\">http://tortoisesvn.net/downloads.html</a></p>\n<p>结构说明<br>\nD:/svnroot<br>\n├─project1<br>\n│     ├─conf<br>\n│     ├─dav<br>\n│     ├─db<br>\n│     │     ├─revprops<br>\n│     │     ├─revs<br>\n│     │     └─transactions<br>\n│     ├─hooks<br>\n│     └─locks<br>\n└─project2<br>\n├─conf<br>\n├─dav<br>\n├─db<br>\n│     ├─revprops<br>\n│     ├─revs<br>\n│     └─transactions<br>\n├─hooks<br>\n└─locks<br>\n其中：svnroot文件夹为存放所有仓库，也是服务启动的时候需指定的目录，下面的各项为项目目录</p>\n<p>启动服务<br>\n启动独立服务方式<br>\nsvnserve –d –r e:/svn_repository/<br>\n访问方法：svn://localhost/dev，或file:///3:/svn_repository/dev<br>\n启动apache方式<br>\ncd D:/Program Files/CollabNet Subversion Server/httpd/bin<br>\nhttpd.exe<br>\n访问方法：<a href=\"http://localhost/svn/dev/\" target=\"_blank\" rel=\"noopener\">http://localhost/svn/dev/</a></p>\n<p>本项目所使用过程<br>\n所有命令行操作需要管理员权限<br>\n1.服务启动：<br>\nsvnserve.exe -d -r D:\\SVN_Root\\repos<br>\n2.SVN备份（从源服务器备份，如：192.168.11.121）：<br>\nA：svnadmin dump d:\\svn\\repos\\project1&gt; dump.dump &gt;D:\\repos.dump      .dump后缀不能丢<br>\nB：备份d:\\svn\\repos\\project1下conf目录<br>\n3.SVN还原（拷贝.dump文件到目的服务器，如：192.168.7.116）：<br>\nA：svnadmin create D:\\SVN_Root\\repos\\project1<br>\nB：svnadmin load D:\\SVN_Root\\repos\\project1 &lt; D:\\repos.dump<br>\nC：拷贝2.B中备份的conf文件夹覆盖D:\\SVN_Root\\repos\\project1下conf文件<br>\n4.注册为系统服务<br>\nsc create svn binpath= ““D:\\SVN_Root\\Subversion\\bin\\svnserve.exe” --service -r D:\\SVN_Root\\repos” displayname= “Subversion Server” depend= Tcpip start= auto</p>\n<p>荐读：<br>\nsvnadmin命令：<br>\n<a href=\"http://blog.csdn.net/wzq9706/article/details/7319728\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/wzq9706/article/details/7319728</a><br>\n<a href=\"http://www.ityen.com/archives/529\" target=\"_blank\" rel=\"noopener\">http://www.ityen.com/archives/529</a><br>\nsvn命令：<a href=\"http://blog.sina.com.cn/s/blog_963453200101eiuq.html%EF%BC%8Csvn%E5%91%BD%E4%BB%A4%E4%B9%9F%E5%8F%AF%E9%80%9A%E8%BF%87Tortoisesvn%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E4%BB%A3%E6%9B%BF\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_963453200101eiuq.html，svn命令也可通过Tortoisesvn客户端操作代替</a></p>\n"},{"title":"CommonJS规范&AMD&CMD","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:41:00.000Z","password":null,"_content":"\n> 浏览器端的js和服务器端js都主要做了哪些事\n\n服务器端JS | 浏览器端JS\n---------- | ----------\n相同的代码需要多次执行|代码需要从一个服务器端分发到多个客户端执行\nCPU和内存资源是瓶颈|带宽是瓶颈\n加载时从磁盘中加载| 加载时需要通过网络加载\n\n> CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范==\n\n> CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。\n\n> AMD规范则是非同步加载模块，允许指定回调函数。\n\n>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范\n\n[toc]\n\n# CommonJS\n> CommonJS规范: http://javascript.ruanyifeng.com/nodejs/module.html\n\n> CommonJS模块的特点如下:\n\n~~~\n所有代码都运行在模块作用域，不会污染全局作用域。\n模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n模块加载的顺序，按照其在代码中出现的顺序\n~~~\n\n> CommonJS是一种规范，NodeJS是这种规范的实现\n\n> JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。\n\n> CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。 \n\nCommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module) \n\n## require\n> require命令用于加载文件，后缀名默认为.js\n\n> 每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。\n\n> CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值\n \n> require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。\n\n> require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false\n\n> require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列\n\n根据参数的不同格式，require命令去不同路径寻找模块文件\n~~~\n* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文\n* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件\n* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块\n* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require('example-module/path/to/file')，则将先找到example-module的位置，然后再以它为参数，找到后续路径。\n* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索\n* 如果想得到require命令加载的确切文件名，使用require.resolve()方法\n~~~\n\n## exports\n每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports\n\n> 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系\n\n## module\nCommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性==\n\n> 每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。\n\n> module对象可以有一个uri属性，表示这个模块被加载的来源。\n\n每个模块内部，都有一个module对象，代表当前模块。它有以下属性:\n~~~\nmodule.id 模块的识别符，通常是带有绝对路径的模块文件名。\nmodule.filename 模块的文件名，带有绝对路径。\nmodule.loaded 返回一个布尔值，表示模块是否已经完成加载。\nmodule.parent 返回一个对象，表示调用该模块的模块。\nmodule.children 返回一个数组，表示该模块要用到的其他模块。\nmodule.exports 表示模块对外输出的值\n~~~\n\n## 目录的加载规则\n> 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录\n\n> 在目录中放置一个package.json文件，并且将入口文件写入main字段\n\n> 如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件\n\n## 模块的缓存\n> 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性\n\n> 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写\n~~~\n// 删除指定模块的缓存\ndelete require.cache[moduleName];\n\n// 删除所有模块的缓存\nObject.keys(require.cache).forEach(function(key) {\n  delete require.cache[key];\n})\n~~~\n\n# AMD\n> AMD就只有一个接口：define(id?,dependencies?,factory);\n\n> RequireJS就是实现了AMD规范\n\n# CMD\n> 大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版","source":"_posts/前端开发/2018-10-26-CommonJS规范-AMD-CMD.md","raw":"---\ntitle: CommonJS规范&AMD&CMD\ntags:\n  - 前端规范 \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:41:00\ncategories: 前端\npassword:\n---\n\n> 浏览器端的js和服务器端js都主要做了哪些事\n\n服务器端JS | 浏览器端JS\n---------- | ----------\n相同的代码需要多次执行|代码需要从一个服务器端分发到多个客户端执行\nCPU和内存资源是瓶颈|带宽是瓶颈\n加载时从磁盘中加载| 加载时需要通过网络加载\n\n> CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范==\n\n> CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。\n\n> AMD规范则是非同步加载模块，允许指定回调函数。\n\n>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范\n\n[toc]\n\n# CommonJS\n> CommonJS规范: http://javascript.ruanyifeng.com/nodejs/module.html\n\n> CommonJS模块的特点如下:\n\n~~~\n所有代码都运行在模块作用域，不会污染全局作用域。\n模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n模块加载的顺序，按照其在代码中出现的顺序\n~~~\n\n> CommonJS是一种规范，NodeJS是这种规范的实现\n\n> JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。\n\n> CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。 \n\nCommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module) \n\n## require\n> require命令用于加载文件，后缀名默认为.js\n\n> 每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。\n\n> CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值\n \n> require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。\n\n> require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false\n\n> require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列\n\n根据参数的不同格式，require命令去不同路径寻找模块文件\n~~~\n* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文\n* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件\n* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块\n* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require('example-module/path/to/file')，则将先找到example-module的位置，然后再以它为参数，找到后续路径。\n* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索\n* 如果想得到require命令加载的确切文件名，使用require.resolve()方法\n~~~\n\n## exports\n每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports\n\n> 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系\n\n## module\nCommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性==\n\n> 每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。\n\n> module对象可以有一个uri属性，表示这个模块被加载的来源。\n\n每个模块内部，都有一个module对象，代表当前模块。它有以下属性:\n~~~\nmodule.id 模块的识别符，通常是带有绝对路径的模块文件名。\nmodule.filename 模块的文件名，带有绝对路径。\nmodule.loaded 返回一个布尔值，表示模块是否已经完成加载。\nmodule.parent 返回一个对象，表示调用该模块的模块。\nmodule.children 返回一个数组，表示该模块要用到的其他模块。\nmodule.exports 表示模块对外输出的值\n~~~\n\n## 目录的加载规则\n> 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录\n\n> 在目录中放置一个package.json文件，并且将入口文件写入main字段\n\n> 如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件\n\n## 模块的缓存\n> 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性\n\n> 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写\n~~~\n// 删除指定模块的缓存\ndelete require.cache[moduleName];\n\n// 删除所有模块的缓存\nObject.keys(require.cache).forEach(function(key) {\n  delete require.cache[key];\n})\n~~~\n\n# AMD\n> AMD就只有一个接口：define(id?,dependencies?,factory);\n\n> RequireJS就是实现了AMD规范\n\n# CMD\n> 大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版","slug":"前端开发-2018-10-26-CommonJS规范-AMD-CMD","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudyy00445b8h63e1sj15","content":"<blockquote>\n<p>浏览器端的js和服务器端js都主要做了哪些事</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>服务器端JS</th>\n<th>浏览器端JS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>相同的代码需要多次执行</td>\n<td>代码需要从一个服务器端分发到多个客户端执行</td>\n</tr>\n<tr>\n<td>CPU和内存资源是瓶颈</td>\n<td>带宽是瓶颈</td>\n</tr>\n<tr>\n<td>加载时从磁盘中加载</td>\n<td>加载时需要通过网络加载</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范==</p>\n</blockquote>\n<blockquote>\n<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>\n</blockquote>\n<blockquote>\n<p>AMD规范则是非同步加载模块，允许指定回调函数。</p>\n</blockquote>\n<blockquote>\n<p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</p>\n</blockquote>\n<p>[toc]</p>\n<h1 id=\"commonjs\"><a class=\"markdownIt-Anchor\" href=\"#commonjs\"></a> CommonJS</h1>\n<blockquote>\n<p>CommonJS规范: <a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"noopener\">http://javascript.ruanyifeng.com/nodejs/module.html</a></p>\n</blockquote>\n<blockquote>\n<p>CommonJS模块的特点如下:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所有代码都运行在模块作用域，不会污染全局作用域。</span><br><span class=\"line\">模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</span><br><span class=\"line\">模块加载的顺序，按照其在代码中出现的顺序</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>CommonJS是一种规范，NodeJS是这种规范的实现</p>\n</blockquote>\n<blockquote>\n<p>JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。</p>\n</blockquote>\n<blockquote>\n<p>CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。</p>\n</blockquote>\n<p>CommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module)</p>\n<h2 id=\"require\"><a class=\"markdownIt-Anchor\" href=\"#require\"></a> require</h2>\n<blockquote>\n<p>require命令用于加载文件，后缀名默认为.js</p>\n</blockquote>\n<blockquote>\n<p>每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。</p>\n</blockquote>\n<blockquote>\n<p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</p>\n</blockquote>\n<blockquote>\n<p>require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。</p>\n</blockquote>\n<blockquote>\n<p>require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false</p>\n</blockquote>\n<blockquote>\n<p>require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列</p>\n</blockquote>\n<p>根据参数的不同格式，require命令去不同路径寻找模块文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文</span><br><span class=\"line\">* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件</span><br><span class=\"line\">* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块</span><br><span class=\"line\">* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(&apos;example-module/path/to/file&apos;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</span><br><span class=\"line\">* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索</span><br><span class=\"line\">* 如果想得到require命令加载的确切文件名，使用require.resolve()方法</span><br></pre></td></tr></table></figure>\n<h2 id=\"exports\"><a class=\"markdownIt-Anchor\" href=\"#exports\"></a> exports</h2>\n<p>每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports</p>\n<blockquote>\n<p>不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系</p>\n</blockquote>\n<h2 id=\"module\"><a class=\"markdownIt-Anchor\" href=\"#module\"></a> module</h2>\n<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性==</p>\n<blockquote>\n<p>每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。</p>\n</blockquote>\n<blockquote>\n<p>module对象可以有一个uri属性，表示这个模块被加载的来源。</p>\n</blockquote>\n<p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.id 模块的识别符，通常是带有绝对路径的模块文件名。</span><br><span class=\"line\">module.filename 模块的文件名，带有绝对路径。</span><br><span class=\"line\">module.loaded 返回一个布尔值，表示模块是否已经完成加载。</span><br><span class=\"line\">module.parent 返回一个对象，表示调用该模块的模块。</span><br><span class=\"line\">module.children 返回一个数组，表示该模块要用到的其他模块。</span><br><span class=\"line\">module.exports 表示模块对外输出的值</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录的加载规则\"><a class=\"markdownIt-Anchor\" href=\"#目录的加载规则\"></a> 目录的加载规则</h2>\n<blockquote>\n<p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录</p>\n</blockquote>\n<blockquote>\n<p>在目录中放置一个package.json文件，并且将入口文件写入main字段</p>\n</blockquote>\n<blockquote>\n<p>如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件</p>\n</blockquote>\n<h2 id=\"模块的缓存\"><a class=\"markdownIt-Anchor\" href=\"#模块的缓存\"></a> 模块的缓存</h2>\n<blockquote>\n<p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性</p>\n</blockquote>\n<blockquote>\n<p>所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 删除指定模块的缓存</span><br><span class=\"line\">delete require.cache[moduleName];</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除所有模块的缓存</span><br><span class=\"line\">Object.keys(require.cache).forEach(function(key) &#123;</span><br><span class=\"line\">  delete require.cache[key];</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"amd\"><a class=\"markdownIt-Anchor\" href=\"#amd\"></a> AMD</h1>\n<blockquote>\n<p>AMD就只有一个接口：define(id?,dependencies?,factory);</p>\n</blockquote>\n<blockquote>\n<p>RequireJS就是实现了AMD规范</p>\n</blockquote>\n<h1 id=\"cmd\"><a class=\"markdownIt-Anchor\" href=\"#cmd\"></a> CMD</h1>\n<blockquote>\n<p>大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>浏览器端的js和服务器端js都主要做了哪些事</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>服务器端JS</th>\n<th>浏览器端JS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>相同的代码需要多次执行</td>\n<td>代码需要从一个服务器端分发到多个客户端执行</td>\n</tr>\n<tr>\n<td>CPU和内存资源是瓶颈</td>\n<td>带宽是瓶颈</td>\n</tr>\n<tr>\n<td>加载时从磁盘中加载</td>\n<td>加载时需要通过网络加载</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>CommonJS是主要为了JS在==后端的表现制定==的，他是不适合前端的;AMD(异步模块定义)出现了，它就主要==为前端JS的表现制定规范==</p>\n</blockquote>\n<blockquote>\n<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>\n</blockquote>\n<blockquote>\n<p>AMD规范则是非同步加载模块，允许指定回调函数。</p>\n</blockquote>\n<blockquote>\n<p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</p>\n</blockquote>\n<p>[toc]</p>\n<h1 id=\"commonjs\"><a class=\"markdownIt-Anchor\" href=\"#commonjs\"></a> CommonJS</h1>\n<blockquote>\n<p>CommonJS规范: <a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"noopener\">http://javascript.ruanyifeng.com/nodejs/module.html</a></p>\n</blockquote>\n<blockquote>\n<p>CommonJS模块的特点如下:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所有代码都运行在模块作用域，不会污染全局作用域。</span><br><span class=\"line\">模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</span><br><span class=\"line\">模块加载的顺序，按照其在代码中出现的顺序</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>CommonJS是一种规范，NodeJS是这种规范的实现</p>\n</blockquote>\n<blockquote>\n<p>JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。</p>\n</blockquote>\n<blockquote>\n<p>CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写==应用程序==，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。</p>\n</blockquote>\n<p>CommonJS定义的模块分为:模块引用(require)；模块定义(exports)；模块标识(module)</p>\n<h2 id=\"require\"><a class=\"markdownIt-Anchor\" href=\"#require\"></a> require</h2>\n<blockquote>\n<p>require命令用于加载文件，后缀名默认为.js</p>\n</blockquote>\n<blockquote>\n<p>每个模块中有一个自由变量require，它是一个方法，这个方法接受一个参数，即模块的唯一ID。</p>\n</blockquote>\n<blockquote>\n<p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</p>\n</blockquote>\n<blockquote>\n<p>require根据外部模块ID，返回该模块输出的API。如果外部模块被required的时候还没有执行完，require至少应改返回该模块的exports（另一个自由变量）。如果必需的模块不存在，require方法应该抛出一个异常。</p>\n</blockquote>\n<blockquote>\n<p>require可以有一个main属性，属性值要么为undefined，要么等于module（另一个自由变量）;可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身;调用执行的时候（通过require加载该脚本执行），==require.main === module== 返回false</p>\n</blockquote>\n<blockquote>\n<p>require可以有一个paths属性，属性值为由路径字符串组成的数组，路径按优先级从高到低的顺序排列</p>\n</blockquote>\n<p>根据参数的不同格式，require命令去不同路径寻找模块文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文</span><br><span class=\"line\">* 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件</span><br><span class=\"line\">* 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块或者一个位于各级node_modules目录的已安装模块</span><br><span class=\"line\">* 如果参数字符串不以“./“或”/“开头，而且是一个路径如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(&apos;example-module/path/to/file&apos;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</span><br><span class=\"line\">* 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索</span><br><span class=\"line\">* 如果想得到require命令加载的确切文件名，使用require.resolve()方法</span><br></pre></td></tr></table></figure>\n<h2 id=\"exports\"><a class=\"markdownIt-Anchor\" href=\"#exports\"></a> exports</h2>\n<p>每个模块中还有一个自由变量exports，它是一个对象，==模块对外输出的API就绑定在这个对象上==。而且==exports是模块对外输出API的唯一途径==。Node为每个模块提供一个exports变量，指向module.exports</p>\n<blockquote>\n<p>不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系</p>\n</blockquote>\n<h2 id=\"module\"><a class=\"markdownIt-Anchor\" href=\"#module\"></a> module</h2>\n<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。==加载某个模块，其实是加载该模块的module.exports属性==</p>\n<blockquote>\n<p>每个模块中必须有一个自由变量module，它是对象。这个对象有一个id属性，表示该模块的id，同时应该是只读属性。</p>\n</blockquote>\n<blockquote>\n<p>module对象可以有一个uri属性，表示这个模块被加载的来源。</p>\n</blockquote>\n<p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.id 模块的识别符，通常是带有绝对路径的模块文件名。</span><br><span class=\"line\">module.filename 模块的文件名，带有绝对路径。</span><br><span class=\"line\">module.loaded 返回一个布尔值，表示模块是否已经完成加载。</span><br><span class=\"line\">module.parent 返回一个对象，表示调用该模块的模块。</span><br><span class=\"line\">module.children 返回一个数组，表示该模块要用到的其他模块。</span><br><span class=\"line\">module.exports 表示模块对外输出的值</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录的加载规则\"><a class=\"markdownIt-Anchor\" href=\"#目录的加载规则\"></a> 目录的加载规则</h2>\n<blockquote>\n<p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录</p>\n</blockquote>\n<blockquote>\n<p>在目录中放置一个package.json文件，并且将入口文件写入main字段</p>\n</blockquote>\n<blockquote>\n<p>如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件</p>\n</blockquote>\n<h2 id=\"模块的缓存\"><a class=\"markdownIt-Anchor\" href=\"#模块的缓存\"></a> 模块的缓存</h2>\n<blockquote>\n<p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性</p>\n</blockquote>\n<blockquote>\n<p>所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 删除指定模块的缓存</span><br><span class=\"line\">delete require.cache[moduleName];</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除所有模块的缓存</span><br><span class=\"line\">Object.keys(require.cache).forEach(function(key) &#123;</span><br><span class=\"line\">  delete require.cache[key];</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"amd\"><a class=\"markdownIt-Anchor\" href=\"#amd\"></a> AMD</h1>\n<blockquote>\n<p>AMD就只有一个接口：define(id?,dependencies?,factory);</p>\n</blockquote>\n<blockquote>\n<p>RequireJS就是实现了AMD规范</p>\n</blockquote>\n<h1 id=\"cmd\"><a class=\"markdownIt-Anchor\" href=\"#cmd\"></a> CMD</h1>\n<blockquote>\n<p>大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版</p>\n</blockquote>\n"},{"title":"ECMAScript规范","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"> ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，于2015年6月正式发布，也称ECMAScript 2015。\n\n~~~\n参考资料\n《ECMAScript 6 入门》： http://es6.ruanyifeng.com/\n~~~\n\nECMA是标准，js是实现\n\n[toc]\n\n### 历史\n* 1996    ES1.0   js稳定，Netscapte将js提交给ECMA组织，ES正式出现\n* 1998  ES2.0   ES2.0正式发布\n* 1999  ES3.0   ES3被浏览器广泛支持\n* 2007  ES4.0   ES4过于激进，被废除了\n* 2008  ES3.1   4.0退化为严重缩水版3.1，代号Harmony（和谐）\n* 2009  ES5.0   ES5正式发布了，公布了JS.next，即后来的ES6.0\n* 2011  ES5.1   ES5.1成为了ISO国际标准\n* 2013.3  ES6.0   制定草案\n* 2013.12   ES6.0   ES6.0草案发布\n* 2015.6    ES6.0   ES6.0预计发布正式版，同时JS.next指向ES7.0\n\n### 兼容性\n> 目前ES5、ES6支持还可以，凑合；ES5、ES6逐渐沦为后台语言\n\n> 在浏览器中使用需要用到编译工具，babel／traceur（由google出的编译器，把ES6语法编译成ES5）\n\n### 使用的三种方式\n1. 网页内直接使用\n~~~\n<script src=\"traceur.js\"></script>\n<script src=\"bootstrap.js\"></script>\n<script type=\"module\">\n    //此出写ES6代码\n</script>\n~~~\n2. 直接在线编译（主要用于测试） \n* http://babeljs.io/repl/\n* https://google.github.io/traceur-compiler/demo/repl.html\n3. 直接在node中使用\n* 直接用，需添加‘use strict’\n~~~ \n//test.js\n'use strict'\nlet a=2;\nconsole.log(a);\n~~~\nnode test.js\n* node --harmony_desctructuring test.js \n\n### 新增功能\n####  定义变量 let \n* let定义的变量只能在代码块中使用，具备块级作用域；var具备函数级作用域；\n* 块级作用域其实就是匿名函数立即调用\n* 变量不能重复定义\n* 可用于封闭空间;封闭空间可解决i问题\n以前：\n    (function(i){\n        var a=12; \n    })(i);\n现在：\n    {\n        let  a=12;\n    }\n#### 定义常量 const\n定义后则不能修改\n\n#### 字符串连接\n==反单引号==：==``==,内容模版,==${变量名}填充模版==\n#### 解构赋值\n\n* var [a,b,c]=[12,5,101];解析结构，给a、b、c都赋值；\n* json格式（通过名称匹配，与顺序无关）也支持\n* ==模式匹配==：var [a,[b,c],d] =[12,[3,2],101],左侧的样子需要和右侧一样\n* 可==以给默认值==。var {time=12,date} ={data=123}\n    \n#### 复制数组\n数组赋值为引用赋值，复制以前用for循环🔥 Array.from()函数，现在使用==超引用'...'==, var arr2 = [...arr1]; 在函数中通过 ...args 接收多个参数\n#### 循环 \n以前是for或for in，现在：for of，支持数组、json、map\n~~~\n//i表示数组或者json的值，for in中i是下标，for of中表示key+value，实质是jsonObj.entrys(),类似的还有jsonObj.keys()、jsonObj.values()\nfor(var i of arr){\n    console.log(i);\n}\n~~~\n#### map操作  \nget()\\set()\\delete()\n#### 箭头函数  => \n**注意事项**\n* this问题  //this指向了window对象\n* arguments不能使用，箭头函数没有自己的 arguments\n~~~\nfunction foo() { \n  var f = (...args) => args[0]; \n  return f(2); \n}\n\nfoo(1); // 2\n~~~\n\n更多：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n\n#### 对象语法简洁化\n~~~\n//以前\nvar person={\n    name:'abc',\n    age:100,\n    showName:function(){\n        alert(this.name);       //this有问题\n    }\n}\n\n//ES6\nvar name='abc';\nvar age =100;\nvar person={\n    name,\n    age,\n    showName(){\n        alert(this.name);\n    }\n}\n~~~\n\n#### 面向对象\n~~~\n//以前面向对象\nfunction Person(name,age){  //类和构造函数一体\n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.showName=function(){\n    return this.name;\n}\nvar p1 = new Person('abc',100);\nalert(p1.name);\n~~~\n\n~~~\n//ES6面向对象\nclass Person{\n    constructor(name='defalut',age=0){  //此处可以设置默认值，这是函数的功能，即：函数参数可以给默认值\n        this.name = name;\n        this.age = age;\n    }\n    showName(){\n        return this.name;\n    }\n}\n\nvar p1 = new Person('abc',100);\nalert(p1.name);     \nalert(p1.showName());\n~~~\n\n继承\n~~~\n//以前  子类.prototype = new 父类();\nfunction Worker(name,age){\n    Person.apply(this,arguments);\n}\nWorker.prototype=new Person();\n\n//ES6\nclass Woker extends Person{\n    constructor(){\n        super();    //调用父级构造\n    }\n}\n~~~\n\n#### ES5:  this.bind();\n\n#### 模块化\n> 当前使用模块化必须引入traceur和bootstrap，type必须写成module\n\n~~~\n//定义\nexport default {a,b}\n//引用\nimport modA from './a.js';\n//使用\nvar sum = modA.a + modA.b\n~~~\n\n#### Promise\n> 本身为一个对象，用来传递异步操作的数据\n\n> 整体是链式操作\n\n~~~\npending(等待、处理中)  ---> Resolve（完成）   \n                     ---> Reject  (拒绝)\n~~~\n使用\n~~~\nvar p1 = new Promise(function(resolve,reject){\n    if(异步处理成功了)\n        resolve(成功数据)\n    else\n        reject(失败原因)\n});\n~~~\n包含方法如下：\n~~~\n所有方法都支持链式编程\n*  then(成功(resolve数据),失败（reject数据）)  //此方法可以防止异步编程括号深度太多的的问题\n*  catch（function（e）{}）；    // 用来捕获错误\n*  all[p1,p2,p3....]  //用于将多个promise对象组合／包装成一个全新的promise对象,数组中的Promise又一个错误则按错误流程走，所有都成功则按成功流程走\n*  Promise.race([p1,p2....]).then(function(value){}); //返回最先执行的Promise的结果\n*  Promise.reject()         //生成错误的Promise\n*  Promise.resolve()        //生成成功的Promise\n~~~\n\n#### Generator+yield\n> Generator:生成器，是一个函数，可以遍历\n \n* Generator函数名字前有*\n* Generator函数内部使用yield语句\n~~~\n//普通函数\nfunction show(){\n    \n}\n//generator函数\nfunction* show(){\n    yield “Hello”；\n    yield \"World\";\n}\n//generator函数\n*show(){\n    yield “Hello”；\n    yield \"World\";\n}\n\nvar res=show();\nconsole.log(res.next());  //{value:\"Hello\",done:false}\nconsole.log(res.next());  //{value:\"World\",done:false}\nconsole.log(res.next());  //{value:\"undefined\",done:true}\n~~~ \n* Generator函数调用后的对象有next方法\n* next方法每次返回一个value和done结果，value位yield后面的值，done代表是否遍历结束\n* yield语句本身没有返回值或每次返回undefined\n* next可以带参数，所带参数给了上一个yield\n* for ...of循环支持Generator函数\n~~~\nfor (let v of show()){\n        document.write(v);\n}\n~~~\n\n#### 展开运算符\n 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组文本）或多个变量（用于解构赋值）的位置扩展\n1. 用于函数调用\n~~~\nmyFunction(...iterableObj);\n~~~\n2. 用于数组字面量\n~~~\n[...iterableObj, 4, 5, 6]\n~~~\n\nECMA-262文档下载：https://chetaofeng.github.io/pub-images/Ecma-262.pdf","source":"_posts/前端开发/2018-10-26-ECMAScript规范.md","raw":"---\ntitle: ECMAScript规范\ntags:\n  - 前端规范 \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n> ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，于2015年6月正式发布，也称ECMAScript 2015。\n\n~~~\n参考资料\n《ECMAScript 6 入门》： http://es6.ruanyifeng.com/\n~~~\n\nECMA是标准，js是实现\n\n[toc]\n\n### 历史\n* 1996    ES1.0   js稳定，Netscapte将js提交给ECMA组织，ES正式出现\n* 1998  ES2.0   ES2.0正式发布\n* 1999  ES3.0   ES3被浏览器广泛支持\n* 2007  ES4.0   ES4过于激进，被废除了\n* 2008  ES3.1   4.0退化为严重缩水版3.1，代号Harmony（和谐）\n* 2009  ES5.0   ES5正式发布了，公布了JS.next，即后来的ES6.0\n* 2011  ES5.1   ES5.1成为了ISO国际标准\n* 2013.3  ES6.0   制定草案\n* 2013.12   ES6.0   ES6.0草案发布\n* 2015.6    ES6.0   ES6.0预计发布正式版，同时JS.next指向ES7.0\n\n### 兼容性\n> 目前ES5、ES6支持还可以，凑合；ES5、ES6逐渐沦为后台语言\n\n> 在浏览器中使用需要用到编译工具，babel／traceur（由google出的编译器，把ES6语法编译成ES5）\n\n### 使用的三种方式\n1. 网页内直接使用\n~~~\n<script src=\"traceur.js\"></script>\n<script src=\"bootstrap.js\"></script>\n<script type=\"module\">\n    //此出写ES6代码\n</script>\n~~~\n2. 直接在线编译（主要用于测试） \n* http://babeljs.io/repl/\n* https://google.github.io/traceur-compiler/demo/repl.html\n3. 直接在node中使用\n* 直接用，需添加‘use strict’\n~~~ \n//test.js\n'use strict'\nlet a=2;\nconsole.log(a);\n~~~\nnode test.js\n* node --harmony_desctructuring test.js \n\n### 新增功能\n####  定义变量 let \n* let定义的变量只能在代码块中使用，具备块级作用域；var具备函数级作用域；\n* 块级作用域其实就是匿名函数立即调用\n* 变量不能重复定义\n* 可用于封闭空间;封闭空间可解决i问题\n以前：\n    (function(i){\n        var a=12; \n    })(i);\n现在：\n    {\n        let  a=12;\n    }\n#### 定义常量 const\n定义后则不能修改\n\n#### 字符串连接\n==反单引号==：==``==,内容模版,==${变量名}填充模版==\n#### 解构赋值\n\n* var [a,b,c]=[12,5,101];解析结构，给a、b、c都赋值；\n* json格式（通过名称匹配，与顺序无关）也支持\n* ==模式匹配==：var [a,[b,c],d] =[12,[3,2],101],左侧的样子需要和右侧一样\n* 可==以给默认值==。var {time=12,date} ={data=123}\n    \n#### 复制数组\n数组赋值为引用赋值，复制以前用for循环🔥 Array.from()函数，现在使用==超引用'...'==, var arr2 = [...arr1]; 在函数中通过 ...args 接收多个参数\n#### 循环 \n以前是for或for in，现在：for of，支持数组、json、map\n~~~\n//i表示数组或者json的值，for in中i是下标，for of中表示key+value，实质是jsonObj.entrys(),类似的还有jsonObj.keys()、jsonObj.values()\nfor(var i of arr){\n    console.log(i);\n}\n~~~\n#### map操作  \nget()\\set()\\delete()\n#### 箭头函数  => \n**注意事项**\n* this问题  //this指向了window对象\n* arguments不能使用，箭头函数没有自己的 arguments\n~~~\nfunction foo() { \n  var f = (...args) => args[0]; \n  return f(2); \n}\n\nfoo(1); // 2\n~~~\n\n更多：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n\n#### 对象语法简洁化\n~~~\n//以前\nvar person={\n    name:'abc',\n    age:100,\n    showName:function(){\n        alert(this.name);       //this有问题\n    }\n}\n\n//ES6\nvar name='abc';\nvar age =100;\nvar person={\n    name,\n    age,\n    showName(){\n        alert(this.name);\n    }\n}\n~~~\n\n#### 面向对象\n~~~\n//以前面向对象\nfunction Person(name,age){  //类和构造函数一体\n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.showName=function(){\n    return this.name;\n}\nvar p1 = new Person('abc',100);\nalert(p1.name);\n~~~\n\n~~~\n//ES6面向对象\nclass Person{\n    constructor(name='defalut',age=0){  //此处可以设置默认值，这是函数的功能，即：函数参数可以给默认值\n        this.name = name;\n        this.age = age;\n    }\n    showName(){\n        return this.name;\n    }\n}\n\nvar p1 = new Person('abc',100);\nalert(p1.name);     \nalert(p1.showName());\n~~~\n\n继承\n~~~\n//以前  子类.prototype = new 父类();\nfunction Worker(name,age){\n    Person.apply(this,arguments);\n}\nWorker.prototype=new Person();\n\n//ES6\nclass Woker extends Person{\n    constructor(){\n        super();    //调用父级构造\n    }\n}\n~~~\n\n#### ES5:  this.bind();\n\n#### 模块化\n> 当前使用模块化必须引入traceur和bootstrap，type必须写成module\n\n~~~\n//定义\nexport default {a,b}\n//引用\nimport modA from './a.js';\n//使用\nvar sum = modA.a + modA.b\n~~~\n\n#### Promise\n> 本身为一个对象，用来传递异步操作的数据\n\n> 整体是链式操作\n\n~~~\npending(等待、处理中)  ---> Resolve（完成）   \n                     ---> Reject  (拒绝)\n~~~\n使用\n~~~\nvar p1 = new Promise(function(resolve,reject){\n    if(异步处理成功了)\n        resolve(成功数据)\n    else\n        reject(失败原因)\n});\n~~~\n包含方法如下：\n~~~\n所有方法都支持链式编程\n*  then(成功(resolve数据),失败（reject数据）)  //此方法可以防止异步编程括号深度太多的的问题\n*  catch（function（e）{}）；    // 用来捕获错误\n*  all[p1,p2,p3....]  //用于将多个promise对象组合／包装成一个全新的promise对象,数组中的Promise又一个错误则按错误流程走，所有都成功则按成功流程走\n*  Promise.race([p1,p2....]).then(function(value){}); //返回最先执行的Promise的结果\n*  Promise.reject()         //生成错误的Promise\n*  Promise.resolve()        //生成成功的Promise\n~~~\n\n#### Generator+yield\n> Generator:生成器，是一个函数，可以遍历\n \n* Generator函数名字前有*\n* Generator函数内部使用yield语句\n~~~\n//普通函数\nfunction show(){\n    \n}\n//generator函数\nfunction* show(){\n    yield “Hello”；\n    yield \"World\";\n}\n//generator函数\n*show(){\n    yield “Hello”；\n    yield \"World\";\n}\n\nvar res=show();\nconsole.log(res.next());  //{value:\"Hello\",done:false}\nconsole.log(res.next());  //{value:\"World\",done:false}\nconsole.log(res.next());  //{value:\"undefined\",done:true}\n~~~ \n* Generator函数调用后的对象有next方法\n* next方法每次返回一个value和done结果，value位yield后面的值，done代表是否遍历结束\n* yield语句本身没有返回值或每次返回undefined\n* next可以带参数，所带参数给了上一个yield\n* for ...of循环支持Generator函数\n~~~\nfor (let v of show()){\n        document.write(v);\n}\n~~~\n\n#### 展开运算符\n 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组文本）或多个变量（用于解构赋值）的位置扩展\n1. 用于函数调用\n~~~\nmyFunction(...iterableObj);\n~~~\n2. 用于数组字面量\n~~~\n[...iterableObj, 4, 5, 6]\n~~~\n\nECMA-262文档下载：https://chetaofeng.github.io/pub-images/Ecma-262.pdf","slug":"前端开发-2018-10-26-ECMAScript规范","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudz000485b8ht0epwfkr","content":"<blockquote>\n<p>ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，于2015年6月正式发布，也称ECMAScript 2015。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考资料</span><br><span class=\"line\">《ECMAScript 6 入门》： http://es6.ruanyifeng.com/</span><br></pre></td></tr></table></figure>\n<p>ECMA是标准，js是实现</p>\n<p>[toc]</p>\n<h3 id=\"历史\"><a class=\"markdownIt-Anchor\" href=\"#历史\"></a> 历史</h3>\n<ul>\n<li>1996    ES1.0   js稳定，Netscapte将js提交给ECMA组织，ES正式出现</li>\n<li>1998  ES2.0   ES2.0正式发布</li>\n<li>1999  ES3.0   ES3被浏览器广泛支持</li>\n<li>2007  ES4.0   ES4过于激进，被废除了</li>\n<li>2008  ES3.1   4.0退化为严重缩水版3.1，代号Harmony（和谐）</li>\n<li>2009  ES5.0   ES5正式发布了，公布了JS.next，即后来的ES6.0</li>\n<li>2011  ES5.1   ES5.1成为了ISO国际标准</li>\n<li>2013.3  ES6.0   制定草案</li>\n<li>2013.12   ES6.0   ES6.0草案发布</li>\n<li>2015.6    ES6.0   ES6.0预计发布正式版，同时JS.next指向ES7.0</li>\n</ul>\n<h3 id=\"兼容性\"><a class=\"markdownIt-Anchor\" href=\"#兼容性\"></a> 兼容性</h3>\n<blockquote>\n<p>目前ES5、ES6支持还可以，凑合；ES5、ES6逐渐沦为后台语言</p>\n</blockquote>\n<blockquote>\n<p>在浏览器中使用需要用到编译工具，babel／traceur（由google出的编译器，把ES6语法编译成ES5）</p>\n</blockquote>\n<h3 id=\"使用的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#使用的三种方式\"></a> 使用的三种方式</h3>\n<ol>\n<li>网页内直接使用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;traceur.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;module&quot;&gt;</span><br><span class=\"line\">    //此出写ES6代码</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>直接在线编译（主要用于测试）</li>\n</ol>\n<ul>\n<li><a href=\"http://babeljs.io/repl/\" target=\"_blank\" rel=\"noopener\">http://babeljs.io/repl/</a></li>\n<li><a href=\"https://google.github.io/traceur-compiler/demo/repl.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/traceur-compiler/demo/repl.html</a></li>\n</ul>\n<ol start=\"3\">\n<li>直接在node中使用</li>\n</ol>\n<ul>\n<li>直接用，需添加‘use strict’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//test.js</span><br><span class=\"line\">&apos;use strict&apos;</span><br><span class=\"line\">let a=2;</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n<p>node test.js</p>\n<ul>\n<li>node --harmony_desctructuring test.js</li>\n</ul>\n<h3 id=\"新增功能\"><a class=\"markdownIt-Anchor\" href=\"#新增功能\"></a> 新增功能</h3>\n<h4 id=\"定义变量-let\"><a class=\"markdownIt-Anchor\" href=\"#定义变量-let\"></a> 定义变量 let</h4>\n<ul>\n<li>let定义的变量只能在代码块中使用，具备块级作用域；var具备函数级作用域；</li>\n<li>块级作用域其实就是匿名函数立即调用</li>\n<li>变量不能重复定义</li>\n<li>可用于封闭空间;封闭空间可解决i问题<br>\n以前：<br>\n(function(i){<br>\nvar a=12;<br>\n})(i);<br>\n现在：<br>\n{<br>\nlet  a=12;<br>\n}</li>\n</ul>\n<h4 id=\"定义常量-const\"><a class=\"markdownIt-Anchor\" href=\"#定义常量-const\"></a> 定义常量 const</h4>\n<p>定义后则不能修改</p>\n<h4 id=\"字符串连接\"><a class=\"markdownIt-Anchor\" href=\"#字符串连接\"></a> 字符串连接</h4>\n<p>==反单引号==：==``==,内容模版,==${变量名}填充模版==</p>\n<h4 id=\"解构赋值\"><a class=\"markdownIt-Anchor\" href=\"#解构赋值\"></a> 解构赋值</h4>\n<ul>\n<li>var [a,b,c]=[12,5,101];解析结构，给a、b、c都赋值；</li>\n<li>json格式（通过名称匹配，与顺序无关）也支持</li>\n<li>==模式匹配==：var [a,[b,c],d] =[12,[3,2],101],左侧的样子需要和右侧一样</li>\n<li>可==以给默认值==。var {time=12,date} ={data=123}</li>\n</ul>\n<h4 id=\"复制数组\"><a class=\"markdownIt-Anchor\" href=\"#复制数组\"></a> 复制数组</h4>\n<p>数组赋值为引用赋值，复制以前用for循环🔥 Array.from()函数，现在使用==超引用’…’==, var arr2 = […arr1]; 在函数中通过 …args 接收多个参数</p>\n<h4 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h4>\n<p>以前是for或for in，现在：for of，支持数组、json、map</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i表示数组或者json的值，for in中i是下标，for of中表示key+value，实质是jsonObj.entrys(),类似的还有jsonObj.keys()、jsonObj.values()</span><br><span class=\"line\">for(var i of arr)&#123;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"map操作\"><a class=\"markdownIt-Anchor\" href=\"#map操作\"></a> map操作</h4>\n<p>get()\\set()\\delete()</p>\n<h4 id=\"箭头函数\"><a class=\"markdownIt-Anchor\" href=\"#箭头函数\"></a> 箭头函数  =&gt;</h4>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>this问题  //this指向了window对象</li>\n<li>arguments不能使用，箭头函数没有自己的 arguments</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">  var f = (...args) =&gt; args[0]; </span><br><span class=\"line\">  return f(2); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(1); // 2</span><br></pre></td></tr></table></figure>\n<p>更多：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p>\n<h4 id=\"对象语法简洁化\"><a class=\"markdownIt-Anchor\" href=\"#对象语法简洁化\"></a> 对象语法简洁化</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以前</span><br><span class=\"line\">var person=&#123;</span><br><span class=\"line\">    name:&apos;abc&apos;,</span><br><span class=\"line\">    age:100,</span><br><span class=\"line\">    showName:function()&#123;</span><br><span class=\"line\">        alert(this.name);       //this有问题</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6</span><br><span class=\"line\">var name=&apos;abc&apos;;</span><br><span class=\"line\">var age =100;</span><br><span class=\"line\">var person=&#123;</span><br><span class=\"line\">    name,</span><br><span class=\"line\">    age,</span><br><span class=\"line\">    showName()&#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"面向对象\"><a class=\"markdownIt-Anchor\" href=\"#面向对象\"></a> 面向对象</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以前面向对象</span><br><span class=\"line\">function Person(name,age)&#123;  //类和构造函数一体</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.showName=function()&#123;</span><br><span class=\"line\">    return this.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p1 = new Person(&apos;abc&apos;,100);</span><br><span class=\"line\">alert(p1.name);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ES6面向对象</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor(name=&apos;defalut&apos;,age=0)&#123;  //此处可以设置默认值，这是函数的功能，即：函数参数可以给默认值</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    showName()&#123;</span><br><span class=\"line\">        return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p1 = new Person(&apos;abc&apos;,100);</span><br><span class=\"line\">alert(p1.name);     </span><br><span class=\"line\">alert(p1.showName());</span><br></pre></td></tr></table></figure>\n<p>继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以前  子类.prototype = new 父类();</span><br><span class=\"line\">function Worker(name,age)&#123;</span><br><span class=\"line\">    Person.apply(this,arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Worker.prototype=new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6</span><br><span class=\"line\">class Woker extends Person&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super();    //调用父级构造</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"es5-thisbind\"><a class=\"markdownIt-Anchor\" href=\"#es5-thisbind\"></a> ES5:  this.bind();</h4>\n<h4 id=\"模块化\"><a class=\"markdownIt-Anchor\" href=\"#模块化\"></a> 模块化</h4>\n<blockquote>\n<p>当前使用模块化必须引入traceur和bootstrap，type必须写成module</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">export default &#123;a,b&#125;</span><br><span class=\"line\">//引用</span><br><span class=\"line\">import modA from &apos;./a.js&apos;;</span><br><span class=\"line\">//使用</span><br><span class=\"line\">var sum = modA.a + modA.b</span><br></pre></td></tr></table></figure>\n<h4 id=\"promise\"><a class=\"markdownIt-Anchor\" href=\"#promise\"></a> Promise</h4>\n<blockquote>\n<p>本身为一个对象，用来传递异步操作的数据</p>\n</blockquote>\n<blockquote>\n<p>整体是链式操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pending(等待、处理中)  ---&gt; Resolve（完成）   </span><br><span class=\"line\">                     ---&gt; Reject  (拒绝)</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">    if(异步处理成功了)</span><br><span class=\"line\">        resolve(成功数据)</span><br><span class=\"line\">    else</span><br><span class=\"line\">        reject(失败原因)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>包含方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所有方法都支持链式编程</span><br><span class=\"line\">*  then(成功(resolve数据),失败（reject数据）)  //此方法可以防止异步编程括号深度太多的的问题</span><br><span class=\"line\">*  catch（function（e）&#123;&#125;）；    // 用来捕获错误</span><br><span class=\"line\">*  all[p1,p2,p3....]  //用于将多个promise对象组合／包装成一个全新的promise对象,数组中的Promise又一个错误则按错误流程走，所有都成功则按成功流程走</span><br><span class=\"line\">*  Promise.race([p1,p2....]).then(function(value)&#123;&#125;); //返回最先执行的Promise的结果</span><br><span class=\"line\">*  Promise.reject()         //生成错误的Promise</span><br><span class=\"line\">*  Promise.resolve()        //生成成功的Promise</span><br></pre></td></tr></table></figure>\n<h4 id=\"generatoryield\"><a class=\"markdownIt-Anchor\" href=\"#generatoryield\"></a> Generator+yield</h4>\n<blockquote>\n<p>Generator:生成器，是一个函数，可以遍历</p>\n</blockquote>\n<ul>\n<li>Generator函数名字前有*</li>\n<li>Generator函数内部使用yield语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//普通函数</span><br><span class=\"line\">function show()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//generator函数</span><br><span class=\"line\">function* show()&#123;</span><br><span class=\"line\">    yield “Hello”；</span><br><span class=\"line\">    yield &quot;World&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//generator函数</span><br><span class=\"line\">*show()&#123;</span><br><span class=\"line\">    yield “Hello”；</span><br><span class=\"line\">    yield &quot;World&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var res=show();</span><br><span class=\"line\">console.log(res.next());  //&#123;value:&quot;Hello&quot;,done:false&#125;</span><br><span class=\"line\">console.log(res.next());  //&#123;value:&quot;World&quot;,done:false&#125;</span><br><span class=\"line\">console.log(res.next());  //&#123;value:&quot;undefined&quot;,done:true&#125;</span><br><span class=\"line\">~~~ </span><br><span class=\"line\">* Generator函数调用后的对象有next方法</span><br><span class=\"line\">* next方法每次返回一个value和done结果，value位yield后面的值，done代表是否遍历结束</span><br><span class=\"line\">* yield语句本身没有返回值或每次返回undefined</span><br><span class=\"line\">* next可以带参数，所带参数给了上一个yield</span><br><span class=\"line\">* for ...of循环支持Generator函数</span><br></pre></td></tr></table></figure>\n<p>for (let v of show()){<br>\ndocument.write(v);<br>\n}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 展开运算符</span><br><span class=\"line\"> 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组文本）或多个变量（用于解构赋值）的位置扩展</span><br><span class=\"line\">1. 用于函数调用</span><br></pre></td></tr></table></figure>\n<p>myFunction(…iterableObj);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 用于数组字面量</span><br></pre></td></tr></table></figure>\n<p>[…iterableObj, 4, 5, 6]</p>\n<pre class=\"highlight\"><code class=\"\">\nECMA-262文档下载：https://chetaofeng.github.io/pub-images/Ecma-262.pdf</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，于2015年6月正式发布，也称ECMAScript 2015。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考资料</span><br><span class=\"line\">《ECMAScript 6 入门》： http://es6.ruanyifeng.com/</span><br></pre></td></tr></table></figure>\n<p>ECMA是标准，js是实现</p>\n<p>[toc]</p>\n<h3 id=\"历史\"><a class=\"markdownIt-Anchor\" href=\"#历史\"></a> 历史</h3>\n<ul>\n<li>1996    ES1.0   js稳定，Netscapte将js提交给ECMA组织，ES正式出现</li>\n<li>1998  ES2.0   ES2.0正式发布</li>\n<li>1999  ES3.0   ES3被浏览器广泛支持</li>\n<li>2007  ES4.0   ES4过于激进，被废除了</li>\n<li>2008  ES3.1   4.0退化为严重缩水版3.1，代号Harmony（和谐）</li>\n<li>2009  ES5.0   ES5正式发布了，公布了JS.next，即后来的ES6.0</li>\n<li>2011  ES5.1   ES5.1成为了ISO国际标准</li>\n<li>2013.3  ES6.0   制定草案</li>\n<li>2013.12   ES6.0   ES6.0草案发布</li>\n<li>2015.6    ES6.0   ES6.0预计发布正式版，同时JS.next指向ES7.0</li>\n</ul>\n<h3 id=\"兼容性\"><a class=\"markdownIt-Anchor\" href=\"#兼容性\"></a> 兼容性</h3>\n<blockquote>\n<p>目前ES5、ES6支持还可以，凑合；ES5、ES6逐渐沦为后台语言</p>\n</blockquote>\n<blockquote>\n<p>在浏览器中使用需要用到编译工具，babel／traceur（由google出的编译器，把ES6语法编译成ES5）</p>\n</blockquote>\n<h3 id=\"使用的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#使用的三种方式\"></a> 使用的三种方式</h3>\n<ol>\n<li>网页内直接使用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;traceur.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;module&quot;&gt;</span><br><span class=\"line\">    //此出写ES6代码</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>直接在线编译（主要用于测试）</li>\n</ol>\n<ul>\n<li><a href=\"http://babeljs.io/repl/\" target=\"_blank\" rel=\"noopener\">http://babeljs.io/repl/</a></li>\n<li><a href=\"https://google.github.io/traceur-compiler/demo/repl.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/traceur-compiler/demo/repl.html</a></li>\n</ul>\n<ol start=\"3\">\n<li>直接在node中使用</li>\n</ol>\n<ul>\n<li>直接用，需添加‘use strict’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//test.js</span><br><span class=\"line\">&apos;use strict&apos;</span><br><span class=\"line\">let a=2;</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n<p>node test.js</p>\n<ul>\n<li>node --harmony_desctructuring test.js</li>\n</ul>\n<h3 id=\"新增功能\"><a class=\"markdownIt-Anchor\" href=\"#新增功能\"></a> 新增功能</h3>\n<h4 id=\"定义变量-let\"><a class=\"markdownIt-Anchor\" href=\"#定义变量-let\"></a> 定义变量 let</h4>\n<ul>\n<li>let定义的变量只能在代码块中使用，具备块级作用域；var具备函数级作用域；</li>\n<li>块级作用域其实就是匿名函数立即调用</li>\n<li>变量不能重复定义</li>\n<li>可用于封闭空间;封闭空间可解决i问题<br>\n以前：<br>\n(function(i){<br>\nvar a=12;<br>\n})(i);<br>\n现在：<br>\n{<br>\nlet  a=12;<br>\n}</li>\n</ul>\n<h4 id=\"定义常量-const\"><a class=\"markdownIt-Anchor\" href=\"#定义常量-const\"></a> 定义常量 const</h4>\n<p>定义后则不能修改</p>\n<h4 id=\"字符串连接\"><a class=\"markdownIt-Anchor\" href=\"#字符串连接\"></a> 字符串连接</h4>\n<p>==反单引号==：==``==,内容模版,==${变量名}填充模版==</p>\n<h4 id=\"解构赋值\"><a class=\"markdownIt-Anchor\" href=\"#解构赋值\"></a> 解构赋值</h4>\n<ul>\n<li>var [a,b,c]=[12,5,101];解析结构，给a、b、c都赋值；</li>\n<li>json格式（通过名称匹配，与顺序无关）也支持</li>\n<li>==模式匹配==：var [a,[b,c],d] =[12,[3,2],101],左侧的样子需要和右侧一样</li>\n<li>可==以给默认值==。var {time=12,date} ={data=123}</li>\n</ul>\n<h4 id=\"复制数组\"><a class=\"markdownIt-Anchor\" href=\"#复制数组\"></a> 复制数组</h4>\n<p>数组赋值为引用赋值，复制以前用for循环🔥 Array.from()函数，现在使用==超引用’…’==, var arr2 = […arr1]; 在函数中通过 …args 接收多个参数</p>\n<h4 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h4>\n<p>以前是for或for in，现在：for of，支持数组、json、map</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i表示数组或者json的值，for in中i是下标，for of中表示key+value，实质是jsonObj.entrys(),类似的还有jsonObj.keys()、jsonObj.values()</span><br><span class=\"line\">for(var i of arr)&#123;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"map操作\"><a class=\"markdownIt-Anchor\" href=\"#map操作\"></a> map操作</h4>\n<p>get()\\set()\\delete()</p>\n<h4 id=\"箭头函数\"><a class=\"markdownIt-Anchor\" href=\"#箭头函数\"></a> 箭头函数  =&gt;</h4>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>this问题  //this指向了window对象</li>\n<li>arguments不能使用，箭头函数没有自己的 arguments</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">  var f = (...args) =&gt; args[0]; </span><br><span class=\"line\">  return f(2); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(1); // 2</span><br></pre></td></tr></table></figure>\n<p>更多：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p>\n<h4 id=\"对象语法简洁化\"><a class=\"markdownIt-Anchor\" href=\"#对象语法简洁化\"></a> 对象语法简洁化</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以前</span><br><span class=\"line\">var person=&#123;</span><br><span class=\"line\">    name:&apos;abc&apos;,</span><br><span class=\"line\">    age:100,</span><br><span class=\"line\">    showName:function()&#123;</span><br><span class=\"line\">        alert(this.name);       //this有问题</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6</span><br><span class=\"line\">var name=&apos;abc&apos;;</span><br><span class=\"line\">var age =100;</span><br><span class=\"line\">var person=&#123;</span><br><span class=\"line\">    name,</span><br><span class=\"line\">    age,</span><br><span class=\"line\">    showName()&#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"面向对象\"><a class=\"markdownIt-Anchor\" href=\"#面向对象\"></a> 面向对象</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以前面向对象</span><br><span class=\"line\">function Person(name,age)&#123;  //类和构造函数一体</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.showName=function()&#123;</span><br><span class=\"line\">    return this.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p1 = new Person(&apos;abc&apos;,100);</span><br><span class=\"line\">alert(p1.name);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ES6面向对象</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor(name=&apos;defalut&apos;,age=0)&#123;  //此处可以设置默认值，这是函数的功能，即：函数参数可以给默认值</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    showName()&#123;</span><br><span class=\"line\">        return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p1 = new Person(&apos;abc&apos;,100);</span><br><span class=\"line\">alert(p1.name);     </span><br><span class=\"line\">alert(p1.showName());</span><br></pre></td></tr></table></figure>\n<p>继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//以前  子类.prototype = new 父类();</span><br><span class=\"line\">function Worker(name,age)&#123;</span><br><span class=\"line\">    Person.apply(this,arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Worker.prototype=new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6</span><br><span class=\"line\">class Woker extends Person&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super();    //调用父级构造</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"es5-thisbind\"><a class=\"markdownIt-Anchor\" href=\"#es5-thisbind\"></a> ES5:  this.bind();</h4>\n<h4 id=\"模块化\"><a class=\"markdownIt-Anchor\" href=\"#模块化\"></a> 模块化</h4>\n<blockquote>\n<p>当前使用模块化必须引入traceur和bootstrap，type必须写成module</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">export default &#123;a,b&#125;</span><br><span class=\"line\">//引用</span><br><span class=\"line\">import modA from &apos;./a.js&apos;;</span><br><span class=\"line\">//使用</span><br><span class=\"line\">var sum = modA.a + modA.b</span><br></pre></td></tr></table></figure>\n<h4 id=\"promise\"><a class=\"markdownIt-Anchor\" href=\"#promise\"></a> Promise</h4>\n<blockquote>\n<p>本身为一个对象，用来传递异步操作的数据</p>\n</blockquote>\n<blockquote>\n<p>整体是链式操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pending(等待、处理中)  ---&gt; Resolve（完成）   </span><br><span class=\"line\">                     ---&gt; Reject  (拒绝)</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">    if(异步处理成功了)</span><br><span class=\"line\">        resolve(成功数据)</span><br><span class=\"line\">    else</span><br><span class=\"line\">        reject(失败原因)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>包含方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所有方法都支持链式编程</span><br><span class=\"line\">*  then(成功(resolve数据),失败（reject数据）)  //此方法可以防止异步编程括号深度太多的的问题</span><br><span class=\"line\">*  catch（function（e）&#123;&#125;）；    // 用来捕获错误</span><br><span class=\"line\">*  all[p1,p2,p3....]  //用于将多个promise对象组合／包装成一个全新的promise对象,数组中的Promise又一个错误则按错误流程走，所有都成功则按成功流程走</span><br><span class=\"line\">*  Promise.race([p1,p2....]).then(function(value)&#123;&#125;); //返回最先执行的Promise的结果</span><br><span class=\"line\">*  Promise.reject()         //生成错误的Promise</span><br><span class=\"line\">*  Promise.resolve()        //生成成功的Promise</span><br></pre></td></tr></table></figure>\n<h4 id=\"generatoryield\"><a class=\"markdownIt-Anchor\" href=\"#generatoryield\"></a> Generator+yield</h4>\n<blockquote>\n<p>Generator:生成器，是一个函数，可以遍历</p>\n</blockquote>\n<ul>\n<li>Generator函数名字前有*</li>\n<li>Generator函数内部使用yield语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//普通函数</span><br><span class=\"line\">function show()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//generator函数</span><br><span class=\"line\">function* show()&#123;</span><br><span class=\"line\">    yield “Hello”；</span><br><span class=\"line\">    yield &quot;World&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//generator函数</span><br><span class=\"line\">*show()&#123;</span><br><span class=\"line\">    yield “Hello”；</span><br><span class=\"line\">    yield &quot;World&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var res=show();</span><br><span class=\"line\">console.log(res.next());  //&#123;value:&quot;Hello&quot;,done:false&#125;</span><br><span class=\"line\">console.log(res.next());  //&#123;value:&quot;World&quot;,done:false&#125;</span><br><span class=\"line\">console.log(res.next());  //&#123;value:&quot;undefined&quot;,done:true&#125;</span><br><span class=\"line\">~~~ </span><br><span class=\"line\">* Generator函数调用后的对象有next方法</span><br><span class=\"line\">* next方法每次返回一个value和done结果，value位yield后面的值，done代表是否遍历结束</span><br><span class=\"line\">* yield语句本身没有返回值或每次返回undefined</span><br><span class=\"line\">* next可以带参数，所带参数给了上一个yield</span><br><span class=\"line\">* for ...of循环支持Generator函数</span><br></pre></td></tr></table></figure>\n<p>for (let v of show()){<br>\ndocument.write(v);<br>\n}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 展开运算符</span><br><span class=\"line\"> 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组文本）或多个变量（用于解构赋值）的位置扩展</span><br><span class=\"line\">1. 用于函数调用</span><br></pre></td></tr></table></figure>\n<p>myFunction(…iterableObj);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 用于数组字面量</span><br></pre></td></tr></table></figure>\n<p>[…iterableObj, 4, 5, 6]</p>\n<pre class=\"highlight\"><code class=\"\">\nECMA-262文档下载：https://chetaofeng.github.io/pub-images/Ecma-262.pdf</code></pre>\n"},{"title":"Angular入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n~~~\nhttps://angular.io/\nhttps://www.angular.cn/\nhttp://www.angularjs.cn/\n~~~\n\n~~~\n1. Angular和JavaScript不互通（函数、变量、事件都不互通）\n2. Angular的开发模式和传统开发模式完全不通：只需盯住数据，数据是核心\n~~~\n\n# 简介及入门\nAngular2是面向未来的科技，要求浏览器支持ES6+\n\nAngular 应用是由组件组成的。 组件由 HTML 模板和组件类组成，组件类控制视图\n\n每个组件都以@Component装饰器函数开始，它接受一个元数据对象参数。该元素对象描述了 HTML 模板和组件类是如何一起工作的\n\nselector属性为 Angular 指定了在index.html中的自定义<my-app>标签里显示该组件\n~~~\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  template: `<h1>Hello {{name}}</h1>`\n})\nexport class AppComponent { name = 'Angular'; }\n\n注️：template后面不是单引号\n~~~\n\n## 网页版使用示例\n~~~\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>网页版使用示例</title>\n    <script src=\"angular.js\"></script>\n</head>\n<body>\n    <div ng-app=\"\" ng-init=\"str=123\">\n        <input type=\"text\" ng-model=\"str\"/>\n        <div ng-bing=\"str\"></div>\n    </div>\n</body>\n</html>\n~~~\n说明：\n* ng-app:表示此区域内由angular控制\n\n\n# Angular CLI\nhttp://www.itnose.net/detail/6694827.html\n\nAngular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布\n\n0. 因为angular-cli是用typescript写的，所以要先装这两个:npm install -g typescript typings\n1. 全局安装 :npm install -g @angular/cli\n2. 创建新项目:ng new my-app\n3. 启动开发服务器:cd my-app;ng serve --open\n\n* 问题1：/usr/local/lib/node_modules/angular-cli/node_modules/_@ngtools_json-schema@1.0.9@@ngtools/json-schema/src/schema-class-factory.js:34\n~~~\n解决：node版本太低\n~~~\n* 问题2:Installing packages for tooling via npm.\n~~~\n太耗时，强制停止后，通过cnpm下载依赖\n~~~\n\n命令|\t使用说明\n----------|--------\n组件Component|\tng generate component my-new-component\n指令Directive|\tng generate directive my-new-directive\n服务Service|\tng generate pipe my-new-service\n管道Pipe|\tng generate pipe my-new-pipe\n类Class|\tng generate class my-new-class\n接口Interface|\tng generate interface my-new-interface\n枚举对象Enum|\tng generate enum my-new-enum\n模块Module|\tng generate module my-module\n\n# 架构\nAngular 应用使用方法：用 Angular 扩展语法编写 HTML 模板， 用组件类管理这些模板，用服务添加应用逻辑， 用模块打包发布组件与服务\n\n通过引导根模块来启动该应用。 Angular 在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互\n\n![image](http://note.youdao.com/yws/api/personal/file/WEBbb5e44b6400e1044b8304cd17df748bc?method=download&shareKey=1fb157c2334799e7329bcbb28240114b)\n\n## 模块 (module)\n### 模块简介\nAngular 应用是模块化的，并且 Angular 有自己的模块系统，它被称为 Angular 模块或 NgModules\n\n每个 Angular 应用至少有一个模块（根模块），习惯上命名为AppModule。\n\nAngular 模块都是一个带有@NgModule装饰器的类。\n\nNgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是：\n* declarations - 声明本模块中拥有的视图类。Angular 有三种视图类：组件、指令和管道。\n* exports - declarations 的子集，可用于其它模块的组件模板。\n* imports - 本模块声明的组件模板需要的类所在的其它模块。\n* providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。\n* bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。\n~~~\n// src/app/app.module.ts\nimport { NgModule }      from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n@NgModule({\n  imports:      [ BrowserModule ],\n  providers:    [ Logger ],\n  declarations: [ AppComponent ],\n  exports:      [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n~~~\n### Angular 模块库\nAngular 提供了一组 JavaScript 模块。可以把它们看做库模块。每个 Angular 库的名字都带有@angular前缀\n~~~\nimport { Component } from '@angular/core';\n~~~\n\n## 组件 (component)\n组件负责控制屏幕上的一小块区域，我们称之为视图; 组件通过一些由属性和方法组成的 API 与视图交互\n~~~\nexport class HeroListComponent implements OnInit {\n  heroes: Hero[];\n  selectedHero: Hero;\n\n  constructor(private service: HeroService) { }\n\n  ngOnInit() {\n    this.heroes = this.service.getHeroes();\n  }\n\n  selectHero(hero: Hero) { this.selectedHero = hero; }\n}\n\n~~~\n## 模板 (template)\n通过组件的自带的模板来定义组件视图。模板以 HTML 形式存在，告诉 Angular 如何渲染组件\n\n## 元数据 (metadata)\n元数据告诉 Angular 如何处理一个类;要告诉 Angular HeroListComponent是个组件，只要把元数据附加到这个类\n~~~\n@Component({\n  selector:    'hero-list',\n  templateUrl: './hero-list.component.html',\n  providers:  [ HeroService ]\n})\nexport class HeroListComponent implements OnInit {\n/* . . . */\n}\n~~~\n\n## 数据绑定 (data binding)\n数据绑定的语法有四种形式：\n![image](http://note.youdao.com/yws/api/personal/file/WEBa57b03e91f6bd4ed38e8c6b1e8caa70a?method=download&shareKey=b3b585887d1a4e10af48b2acbd8367f2)\n~~~\n<li>{{hero.name}}</li>\n<hero-detail [hero]=\"selectedHero\"></hero-detail>\n<li (click)=\"selectHero(hero)\"></li>\n<input [(ngModel)]=\"hero.name\">\n~~~\n每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。\n\n## 指令 (directive)\nAngular 模板是动态的。当 Angular 渲染它们时，它会根据指令提供的操作对 DOM 进行转换\n\n\n## 服务 (service)\n组件是最大的服务消费者\n~~~\n//src/app/logger.service.ts\nexport class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}\n//src/app/hero.service.ts\nexport class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) => {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}\n~~~\n\n## 依赖注入 (dependency injection)\n\nAngular 使用依赖注入来提供新组件以及组件所需的服务\n\n1. 当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。\n2. 注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。\n3. 当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。 \n\n这就是依赖注入 \n\n![image](http://note.youdao.com/yws/api/personal/file/WEB74722e9c03ab05fe303782eb6e27172b?method=download&shareKey=d698cb66bf2c3035e7b1ada6c2e255e0)\n\n* 函数：参数由调用方决定\n* 依赖注入：参数由定于方决定\n\n# 模版\n~~~\n* {{msg}}  \n\n*  $scope  Controller\n\n* filter    {{123|currency}} {{12321213|date:\"yyyy-MM-dd\"}}\n\n* ng-clack\n~~~","source":"_posts/前端开发/Angular入门.md","raw":"---\ntitle: Angular入门\ntags:\n  - Angular \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n~~~\nhttps://angular.io/\nhttps://www.angular.cn/\nhttp://www.angularjs.cn/\n~~~\n\n~~~\n1. Angular和JavaScript不互通（函数、变量、事件都不互通）\n2. Angular的开发模式和传统开发模式完全不通：只需盯住数据，数据是核心\n~~~\n\n# 简介及入门\nAngular2是面向未来的科技，要求浏览器支持ES6+\n\nAngular 应用是由组件组成的。 组件由 HTML 模板和组件类组成，组件类控制视图\n\n每个组件都以@Component装饰器函数开始，它接受一个元数据对象参数。该元素对象描述了 HTML 模板和组件类是如何一起工作的\n\nselector属性为 Angular 指定了在index.html中的自定义<my-app>标签里显示该组件\n~~~\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  template: `<h1>Hello {{name}}</h1>`\n})\nexport class AppComponent { name = 'Angular'; }\n\n注️：template后面不是单引号\n~~~\n\n## 网页版使用示例\n~~~\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>网页版使用示例</title>\n    <script src=\"angular.js\"></script>\n</head>\n<body>\n    <div ng-app=\"\" ng-init=\"str=123\">\n        <input type=\"text\" ng-model=\"str\"/>\n        <div ng-bing=\"str\"></div>\n    </div>\n</body>\n</html>\n~~~\n说明：\n* ng-app:表示此区域内由angular控制\n\n\n# Angular CLI\nhttp://www.itnose.net/detail/6694827.html\n\nAngular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布\n\n0. 因为angular-cli是用typescript写的，所以要先装这两个:npm install -g typescript typings\n1. 全局安装 :npm install -g @angular/cli\n2. 创建新项目:ng new my-app\n3. 启动开发服务器:cd my-app;ng serve --open\n\n* 问题1：/usr/local/lib/node_modules/angular-cli/node_modules/_@ngtools_json-schema@1.0.9@@ngtools/json-schema/src/schema-class-factory.js:34\n~~~\n解决：node版本太低\n~~~\n* 问题2:Installing packages for tooling via npm.\n~~~\n太耗时，强制停止后，通过cnpm下载依赖\n~~~\n\n命令|\t使用说明\n----------|--------\n组件Component|\tng generate component my-new-component\n指令Directive|\tng generate directive my-new-directive\n服务Service|\tng generate pipe my-new-service\n管道Pipe|\tng generate pipe my-new-pipe\n类Class|\tng generate class my-new-class\n接口Interface|\tng generate interface my-new-interface\n枚举对象Enum|\tng generate enum my-new-enum\n模块Module|\tng generate module my-module\n\n# 架构\nAngular 应用使用方法：用 Angular 扩展语法编写 HTML 模板， 用组件类管理这些模板，用服务添加应用逻辑， 用模块打包发布组件与服务\n\n通过引导根模块来启动该应用。 Angular 在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互\n\n![image](http://note.youdao.com/yws/api/personal/file/WEBbb5e44b6400e1044b8304cd17df748bc?method=download&shareKey=1fb157c2334799e7329bcbb28240114b)\n\n## 模块 (module)\n### 模块简介\nAngular 应用是模块化的，并且 Angular 有自己的模块系统，它被称为 Angular 模块或 NgModules\n\n每个 Angular 应用至少有一个模块（根模块），习惯上命名为AppModule。\n\nAngular 模块都是一个带有@NgModule装饰器的类。\n\nNgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是：\n* declarations - 声明本模块中拥有的视图类。Angular 有三种视图类：组件、指令和管道。\n* exports - declarations 的子集，可用于其它模块的组件模板。\n* imports - 本模块声明的组件模板需要的类所在的其它模块。\n* providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。\n* bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。\n~~~\n// src/app/app.module.ts\nimport { NgModule }      from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n@NgModule({\n  imports:      [ BrowserModule ],\n  providers:    [ Logger ],\n  declarations: [ AppComponent ],\n  exports:      [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n~~~\n### Angular 模块库\nAngular 提供了一组 JavaScript 模块。可以把它们看做库模块。每个 Angular 库的名字都带有@angular前缀\n~~~\nimport { Component } from '@angular/core';\n~~~\n\n## 组件 (component)\n组件负责控制屏幕上的一小块区域，我们称之为视图; 组件通过一些由属性和方法组成的 API 与视图交互\n~~~\nexport class HeroListComponent implements OnInit {\n  heroes: Hero[];\n  selectedHero: Hero;\n\n  constructor(private service: HeroService) { }\n\n  ngOnInit() {\n    this.heroes = this.service.getHeroes();\n  }\n\n  selectHero(hero: Hero) { this.selectedHero = hero; }\n}\n\n~~~\n## 模板 (template)\n通过组件的自带的模板来定义组件视图。模板以 HTML 形式存在，告诉 Angular 如何渲染组件\n\n## 元数据 (metadata)\n元数据告诉 Angular 如何处理一个类;要告诉 Angular HeroListComponent是个组件，只要把元数据附加到这个类\n~~~\n@Component({\n  selector:    'hero-list',\n  templateUrl: './hero-list.component.html',\n  providers:  [ HeroService ]\n})\nexport class HeroListComponent implements OnInit {\n/* . . . */\n}\n~~~\n\n## 数据绑定 (data binding)\n数据绑定的语法有四种形式：\n![image](http://note.youdao.com/yws/api/personal/file/WEBa57b03e91f6bd4ed38e8c6b1e8caa70a?method=download&shareKey=b3b585887d1a4e10af48b2acbd8367f2)\n~~~\n<li>{{hero.name}}</li>\n<hero-detail [hero]=\"selectedHero\"></hero-detail>\n<li (click)=\"selectHero(hero)\"></li>\n<input [(ngModel)]=\"hero.name\">\n~~~\n每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。\n\n## 指令 (directive)\nAngular 模板是动态的。当 Angular 渲染它们时，它会根据指令提供的操作对 DOM 进行转换\n\n\n## 服务 (service)\n组件是最大的服务消费者\n~~~\n//src/app/logger.service.ts\nexport class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}\n//src/app/hero.service.ts\nexport class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) => {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}\n~~~\n\n## 依赖注入 (dependency injection)\n\nAngular 使用依赖注入来提供新组件以及组件所需的服务\n\n1. 当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。\n2. 注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。\n3. 当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。 \n\n这就是依赖注入 \n\n![image](http://note.youdao.com/yws/api/personal/file/WEB74722e9c03ab05fe303782eb6e27172b?method=download&shareKey=d698cb66bf2c3035e7b1ada6c2e255e0)\n\n* 函数：参数由调用方决定\n* 依赖注入：参数由定于方决定\n\n# 模版\n~~~\n* {{msg}}  \n\n*  $scope  Controller\n\n* filter    {{123|currency}} {{12321213|date:\"yyyy-MM-dd\"}}\n\n* ng-clack\n~~~","slug":"前端开发-Angular入门","published":1,"updated":"2019-02-14T07:36:56.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudz2004a5b8hgrgnlgtp","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://angular.io/</span><br><span class=\"line\">https://www.angular.cn/</span><br><span class=\"line\">http://www.angularjs.cn/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Angular和JavaScript不互通（函数、变量、事件都不互通）</span><br><span class=\"line\">2. Angular的开发模式和传统开发模式完全不通：只需盯住数据，数据是核心</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介及入门\"><a class=\"markdownIt-Anchor\" href=\"#简介及入门\"></a> 简介及入门</h1>\n<p>Angular2是面向未来的科技，要求浏览器支持ES6+</p>\n<p>Angular 应用是由组件组成的。 组件由 HTML 模板和组件类组成，组件类控制视图</p>\n<p>每个组件都以@Component装饰器函数开始，它接受一个元数据对象参数。该元素对象描述了 HTML 模板和组件类是如何一起工作的</p>\n<p>selector属性为 Angular 指定了在index.html中的自定义<my-app>标签里显示该组件</my-app></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: &apos;my-app&apos;,</span><br><span class=\"line\">  template: `&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;`</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppComponent &#123; name = &apos;Angular&apos;; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">注️：template后面不是单引号</span><br></pre></td></tr></table></figure>\n<h2 id=\"网页版使用示例\"><a class=\"markdownIt-Anchor\" href=\"#网页版使用示例\"></a> 网页版使用示例</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;网页版使用示例&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div ng-app=&quot;&quot; ng-init=&quot;str=123&quot;&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; ng-model=&quot;str&quot;/&gt;</span><br><span class=\"line\">        &lt;div ng-bing=&quot;str&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>ng-app:表示此区域内由angular控制</li>\n</ul>\n<h1 id=\"angular-cli\"><a class=\"markdownIt-Anchor\" href=\"#angular-cli\"></a> Angular CLI</h1>\n<p><a href=\"http://www.itnose.net/detail/6694827.html\" target=\"_blank\" rel=\"noopener\">http://www.itnose.net/detail/6694827.html</a></p>\n<p>Angular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布</p>\n<ol start=\"0\">\n<li>因为angular-cli是用typescript写的，所以要先装这两个:npm install -g typescript typings</li>\n<li>全局安装 :npm install -g @angular/cli</li>\n<li>创建新项目:ng new my-app</li>\n<li>启动开发服务器:cd my-app;ng serve --open</li>\n</ol>\n<ul>\n<li>问题1：/usr/local/lib/node_modules/angular-cli/node_modules/_@ngtools_json-schema@1.0.9@@ngtools/json-schema/src/schema-class-factory.js:34</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解决：node版本太低</span><br></pre></td></tr></table></figure>\n<ul>\n<li>问题2:Installing packages for tooling via npm.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">太耗时，强制停止后，通过cnpm下载依赖</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>使用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件Component</td>\n<td>ng generate component my-new-component</td>\n</tr>\n<tr>\n<td>指令Directive</td>\n<td>ng generate directive my-new-directive</td>\n</tr>\n<tr>\n<td>服务Service</td>\n<td>ng generate pipe my-new-service</td>\n</tr>\n<tr>\n<td>管道Pipe</td>\n<td>ng generate pipe my-new-pipe</td>\n</tr>\n<tr>\n<td>类Class</td>\n<td>ng generate class my-new-class</td>\n</tr>\n<tr>\n<td>接口Interface</td>\n<td>ng generate interface my-new-interface</td>\n</tr>\n<tr>\n<td>枚举对象Enum</td>\n<td>ng generate enum my-new-enum</td>\n</tr>\n<tr>\n<td>模块Module</td>\n<td>ng generate module my-module</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"架构\"><a class=\"markdownIt-Anchor\" href=\"#架构\"></a> 架构</h1>\n<p>Angular 应用使用方法：用 Angular 扩展语法编写 HTML 模板， 用组件类管理这些模板，用服务添加应用逻辑， 用模块打包发布组件与服务</p>\n<p>通过引导根模块来启动该应用。 Angular 在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEBbb5e44b6400e1044b8304cd17df748bc?method=download&amp;shareKey=1fb157c2334799e7329bcbb28240114b\" alt=\"image\"></p>\n<h2 id=\"模块-module\"><a class=\"markdownIt-Anchor\" href=\"#模块-module\"></a> 模块 (module)</h2>\n<h3 id=\"模块简介\"><a class=\"markdownIt-Anchor\" href=\"#模块简介\"></a> 模块简介</h3>\n<p>Angular 应用是模块化的，并且 Angular 有自己的模块系统，它被称为 Angular 模块或 NgModules</p>\n<p>每个 Angular 应用至少有一个模块（根模块），习惯上命名为AppModule。</p>\n<p>Angular 模块都是一个带有@NgModule装饰器的类。</p>\n<p>NgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是：</p>\n<ul>\n<li>declarations - 声明本模块中拥有的视图类。Angular 有三种视图类：组件、指令和管道。</li>\n<li>exports - declarations 的子集，可用于其它模块的组件模板。</li>\n<li>imports - 本模块声明的组件模板需要的类所在的其它模块。</li>\n<li>providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。</li>\n<li>bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/app/app.module.ts</span><br><span class=\"line\">import &#123; NgModule &#125;      from &apos;@angular/core&apos;;</span><br><span class=\"line\">import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:      [ BrowserModule ],</span><br><span class=\"line\">  providers:    [ Logger ],</span><br><span class=\"line\">  declarations: [ AppComponent ],</span><br><span class=\"line\">  exports:      [ AppComponent ],</span><br><span class=\"line\">  bootstrap:    [ AppComponent ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"angular-模块库\"><a class=\"markdownIt-Anchor\" href=\"#angular-模块库\"></a> Angular 模块库</h3>\n<p>Angular 提供了一组 JavaScript 模块。可以把它们看做库模块。每个 Angular 库的名字都带有@angular前缀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件-component\"><a class=\"markdownIt-Anchor\" href=\"#组件-component\"></a> 组件 (component)</h2>\n<p>组件负责控制屏幕上的一小块区域，我们称之为视图; 组件通过一些由属性和方法组成的 API 与视图交互</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class HeroListComponent implements OnInit &#123;</span><br><span class=\"line\">  heroes: Hero[];</span><br><span class=\"line\">  selectedHero: Hero;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(private service: HeroService) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    this.heroes = this.service.getHeroes();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  selectHero(hero: Hero) &#123; this.selectedHero = hero; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板-template\"><a class=\"markdownIt-Anchor\" href=\"#模板-template\"></a> 模板 (template)</h2>\n<p>通过组件的自带的模板来定义组件视图。模板以 HTML 形式存在，告诉 Angular 如何渲染组件</p>\n<h2 id=\"元数据-metadata\"><a class=\"markdownIt-Anchor\" href=\"#元数据-metadata\"></a> 元数据 (metadata)</h2>\n<p>元数据告诉 Angular 如何处理一个类;要告诉 Angular HeroListComponent是个组件，只要把元数据附加到这个类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector:    &apos;hero-list&apos;,</span><br><span class=\"line\">  templateUrl: &apos;./hero-list.component.html&apos;,</span><br><span class=\"line\">  providers:  [ HeroService ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class HeroListComponent implements OnInit &#123;</span><br><span class=\"line\">/* . . . */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据绑定-data-binding\"><a class=\"markdownIt-Anchor\" href=\"#数据绑定-data-binding\"></a> 数据绑定 (data binding)</h2>\n<p>数据绑定的语法有四种形式：<br>\n<img src=\"http://note.youdao.com/yws/api/personal/file/WEBa57b03e91f6bd4ed38e8c6b1e8caa70a?method=download&amp;shareKey=b3b585887d1a4e10af48b2acbd8367f2\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">&lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;</span><br><span class=\"line\">&lt;li (click)=&quot;selectHero(hero)&quot;&gt;&lt;/li&gt;</span><br><span class=\"line\">&lt;input [(ngModel)]=&quot;hero.name&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。</p>\n<h2 id=\"指令-directive\"><a class=\"markdownIt-Anchor\" href=\"#指令-directive\"></a> 指令 (directive)</h2>\n<p>Angular 模板是动态的。当 Angular 渲染它们时，它会根据指令提供的操作对 DOM 进行转换</p>\n<h2 id=\"服务-service\"><a class=\"markdownIt-Anchor\" href=\"#服务-service\"></a> 服务 (service)</h2>\n<p>组件是最大的服务消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//src/app/logger.service.ts</span><br><span class=\"line\">export class Logger &#123;</span><br><span class=\"line\">  log(msg: any)   &#123; console.log(msg); &#125;</span><br><span class=\"line\">  error(msg: any) &#123; console.error(msg); &#125;</span><br><span class=\"line\">  warn(msg: any)  &#123; console.warn(msg); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//src/app/hero.service.ts</span><br><span class=\"line\">export class HeroService &#123;</span><br><span class=\"line\">  private heroes: Hero[] = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(</span><br><span class=\"line\">    private backend: BackendService,</span><br><span class=\"line\">    private logger: Logger) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123;</span><br><span class=\"line\">      this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`);</span><br><span class=\"line\">      this.heroes.push(...heroes); // fill cache</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return this.heroes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"依赖注入-dependency-injection\"><a class=\"markdownIt-Anchor\" href=\"#依赖注入-dependency-injection\"></a> 依赖注入 (dependency injection)</h2>\n<p>Angular 使用依赖注入来提供新组件以及组件所需的服务</p>\n<ol>\n<li>当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。</li>\n<li>注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。</li>\n<li>当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。</li>\n</ol>\n<p>这就是依赖注入</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB74722e9c03ab05fe303782eb6e27172b?method=download&amp;shareKey=d698cb66bf2c3035e7b1ada6c2e255e0\" alt=\"image\"></p>\n<ul>\n<li>函数：参数由调用方决定</li>\n<li>依赖注入：参数由定于方决定</li>\n</ul>\n<h1 id=\"模版\"><a class=\"markdownIt-Anchor\" href=\"#模版\"></a> 模版</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;&#123;msg&#125;&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">*  $scope  Controller</span><br><span class=\"line\"></span><br><span class=\"line\">* filter    &#123;&#123;123|currency&#125;&#125; &#123;&#123;12321213|date:&quot;yyyy-MM-dd&quot;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">* ng-clack</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://angular.io/</span><br><span class=\"line\">https://www.angular.cn/</span><br><span class=\"line\">http://www.angularjs.cn/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Angular和JavaScript不互通（函数、变量、事件都不互通）</span><br><span class=\"line\">2. Angular的开发模式和传统开发模式完全不通：只需盯住数据，数据是核心</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介及入门\"><a class=\"markdownIt-Anchor\" href=\"#简介及入门\"></a> 简介及入门</h1>\n<p>Angular2是面向未来的科技，要求浏览器支持ES6+</p>\n<p>Angular 应用是由组件组成的。 组件由 HTML 模板和组件类组成，组件类控制视图</p>\n<p>每个组件都以@Component装饰器函数开始，它接受一个元数据对象参数。该元素对象描述了 HTML 模板和组件类是如何一起工作的</p>\n<p>selector属性为 Angular 指定了在index.html中的自定义<my-app>标签里显示该组件</my-app></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: &apos;my-app&apos;,</span><br><span class=\"line\">  template: `&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;`</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppComponent &#123; name = &apos;Angular&apos;; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">注️：template后面不是单引号</span><br></pre></td></tr></table></figure>\n<h2 id=\"网页版使用示例\"><a class=\"markdownIt-Anchor\" href=\"#网页版使用示例\"></a> 网页版使用示例</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;网页版使用示例&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div ng-app=&quot;&quot; ng-init=&quot;str=123&quot;&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; ng-model=&quot;str&quot;/&gt;</span><br><span class=\"line\">        &lt;div ng-bing=&quot;str&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>ng-app:表示此区域内由angular控制</li>\n</ul>\n<h1 id=\"angular-cli\"><a class=\"markdownIt-Anchor\" href=\"#angular-cli\"></a> Angular CLI</h1>\n<p><a href=\"http://www.itnose.net/detail/6694827.html\" target=\"_blank\" rel=\"noopener\">http://www.itnose.net/detail/6694827.html</a></p>\n<p>Angular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布</p>\n<ol start=\"0\">\n<li>因为angular-cli是用typescript写的，所以要先装这两个:npm install -g typescript typings</li>\n<li>全局安装 :npm install -g @angular/cli</li>\n<li>创建新项目:ng new my-app</li>\n<li>启动开发服务器:cd my-app;ng serve --open</li>\n</ol>\n<ul>\n<li>问题1：/usr/local/lib/node_modules/angular-cli/node_modules/_@ngtools_json-schema@1.0.9@@ngtools/json-schema/src/schema-class-factory.js:34</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解决：node版本太低</span><br></pre></td></tr></table></figure>\n<ul>\n<li>问题2:Installing packages for tooling via npm.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">太耗时，强制停止后，通过cnpm下载依赖</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>使用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件Component</td>\n<td>ng generate component my-new-component</td>\n</tr>\n<tr>\n<td>指令Directive</td>\n<td>ng generate directive my-new-directive</td>\n</tr>\n<tr>\n<td>服务Service</td>\n<td>ng generate pipe my-new-service</td>\n</tr>\n<tr>\n<td>管道Pipe</td>\n<td>ng generate pipe my-new-pipe</td>\n</tr>\n<tr>\n<td>类Class</td>\n<td>ng generate class my-new-class</td>\n</tr>\n<tr>\n<td>接口Interface</td>\n<td>ng generate interface my-new-interface</td>\n</tr>\n<tr>\n<td>枚举对象Enum</td>\n<td>ng generate enum my-new-enum</td>\n</tr>\n<tr>\n<td>模块Module</td>\n<td>ng generate module my-module</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"架构\"><a class=\"markdownIt-Anchor\" href=\"#架构\"></a> 架构</h1>\n<p>Angular 应用使用方法：用 Angular 扩展语法编写 HTML 模板， 用组件类管理这些模板，用服务添加应用逻辑， 用模块打包发布组件与服务</p>\n<p>通过引导根模块来启动该应用。 Angular 在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEBbb5e44b6400e1044b8304cd17df748bc?method=download&amp;shareKey=1fb157c2334799e7329bcbb28240114b\" alt=\"image\"></p>\n<h2 id=\"模块-module\"><a class=\"markdownIt-Anchor\" href=\"#模块-module\"></a> 模块 (module)</h2>\n<h3 id=\"模块简介\"><a class=\"markdownIt-Anchor\" href=\"#模块简介\"></a> 模块简介</h3>\n<p>Angular 应用是模块化的，并且 Angular 有自己的模块系统，它被称为 Angular 模块或 NgModules</p>\n<p>每个 Angular 应用至少有一个模块（根模块），习惯上命名为AppModule。</p>\n<p>Angular 模块都是一个带有@NgModule装饰器的类。</p>\n<p>NgModule是一个装饰器函数，它接收一个用来描述模块属性的元数据对象。其中最重要的属性是：</p>\n<ul>\n<li>declarations - 声明本模块中拥有的视图类。Angular 有三种视图类：组件、指令和管道。</li>\n<li>exports - declarations 的子集，可用于其它模块的组件模板。</li>\n<li>imports - 本模块声明的组件模板需要的类所在的其它模块。</li>\n<li>providers - 服务的创建者，并加入到全局服务列表中，可用于应用任何部分。</li>\n<li>bootstrap - 指定应用的主视图（称为根组件），它是所有其它视图的宿主。只有根模块才能设置bootstrap属性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/app/app.module.ts</span><br><span class=\"line\">import &#123; NgModule &#125;      from &apos;@angular/core&apos;;</span><br><span class=\"line\">import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:      [ BrowserModule ],</span><br><span class=\"line\">  providers:    [ Logger ],</span><br><span class=\"line\">  declarations: [ AppComponent ],</span><br><span class=\"line\">  exports:      [ AppComponent ],</span><br><span class=\"line\">  bootstrap:    [ AppComponent ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppModule &#123; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"angular-模块库\"><a class=\"markdownIt-Anchor\" href=\"#angular-模块库\"></a> Angular 模块库</h3>\n<p>Angular 提供了一组 JavaScript 模块。可以把它们看做库模块。每个 Angular 库的名字都带有@angular前缀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件-component\"><a class=\"markdownIt-Anchor\" href=\"#组件-component\"></a> 组件 (component)</h2>\n<p>组件负责控制屏幕上的一小块区域，我们称之为视图; 组件通过一些由属性和方法组成的 API 与视图交互</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class HeroListComponent implements OnInit &#123;</span><br><span class=\"line\">  heroes: Hero[];</span><br><span class=\"line\">  selectedHero: Hero;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(private service: HeroService) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    this.heroes = this.service.getHeroes();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  selectHero(hero: Hero) &#123; this.selectedHero = hero; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板-template\"><a class=\"markdownIt-Anchor\" href=\"#模板-template\"></a> 模板 (template)</h2>\n<p>通过组件的自带的模板来定义组件视图。模板以 HTML 形式存在，告诉 Angular 如何渲染组件</p>\n<h2 id=\"元数据-metadata\"><a class=\"markdownIt-Anchor\" href=\"#元数据-metadata\"></a> 元数据 (metadata)</h2>\n<p>元数据告诉 Angular 如何处理一个类;要告诉 Angular HeroListComponent是个组件，只要把元数据附加到这个类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector:    &apos;hero-list&apos;,</span><br><span class=\"line\">  templateUrl: &apos;./hero-list.component.html&apos;,</span><br><span class=\"line\">  providers:  [ HeroService ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class HeroListComponent implements OnInit &#123;</span><br><span class=\"line\">/* . . . */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据绑定-data-binding\"><a class=\"markdownIt-Anchor\" href=\"#数据绑定-data-binding\"></a> 数据绑定 (data binding)</h2>\n<p>数据绑定的语法有四种形式：<br>\n<img src=\"http://note.youdao.com/yws/api/personal/file/WEBa57b03e91f6bd4ed38e8c6b1e8caa70a?method=download&amp;shareKey=b3b585887d1a4e10af48b2acbd8367f2\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">&lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;</span><br><span class=\"line\">&lt;li (click)=&quot;selectHero(hero)&quot;&gt;&lt;/li&gt;</span><br><span class=\"line\">&lt;input [(ngModel)]=&quot;hero.name&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>每种形式都有一个方向 —— 绑定到 DOM 、绑定自 DOM 以及双向绑定。</p>\n<h2 id=\"指令-directive\"><a class=\"markdownIt-Anchor\" href=\"#指令-directive\"></a> 指令 (directive)</h2>\n<p>Angular 模板是动态的。当 Angular 渲染它们时，它会根据指令提供的操作对 DOM 进行转换</p>\n<h2 id=\"服务-service\"><a class=\"markdownIt-Anchor\" href=\"#服务-service\"></a> 服务 (service)</h2>\n<p>组件是最大的服务消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//src/app/logger.service.ts</span><br><span class=\"line\">export class Logger &#123;</span><br><span class=\"line\">  log(msg: any)   &#123; console.log(msg); &#125;</span><br><span class=\"line\">  error(msg: any) &#123; console.error(msg); &#125;</span><br><span class=\"line\">  warn(msg: any)  &#123; console.warn(msg); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//src/app/hero.service.ts</span><br><span class=\"line\">export class HeroService &#123;</span><br><span class=\"line\">  private heroes: Hero[] = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(</span><br><span class=\"line\">    private backend: BackendService,</span><br><span class=\"line\">    private logger: Logger) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123;</span><br><span class=\"line\">      this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`);</span><br><span class=\"line\">      this.heroes.push(...heroes); // fill cache</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return this.heroes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"依赖注入-dependency-injection\"><a class=\"markdownIt-Anchor\" href=\"#依赖注入-dependency-injection\"></a> 依赖注入 (dependency injection)</h2>\n<p>Angular 使用依赖注入来提供新组件以及组件所需的服务</p>\n<ol>\n<li>当 Angular 创建组件时，会首先为组件所需的服务请求一个注入器 (injector)。</li>\n<li>注入器维护了一个服务实例的容器，存放着以前创建的实例。 如果所请求的服务实例不在容器中，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular。</li>\n<li>当所有请求的服务都被解析完并返回时，Angular 会以这些服务为参数去调用组件的构造函数。</li>\n</ol>\n<p>这就是依赖注入</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB74722e9c03ab05fe303782eb6e27172b?method=download&amp;shareKey=d698cb66bf2c3035e7b1ada6c2e255e0\" alt=\"image\"></p>\n<ul>\n<li>函数：参数由调用方决定</li>\n<li>依赖注入：参数由定于方决定</li>\n</ul>\n<h1 id=\"模版\"><a class=\"markdownIt-Anchor\" href=\"#模版\"></a> 模版</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;&#123;msg&#125;&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">*  $scope  Controller</span><br><span class=\"line\"></span><br><span class=\"line\">* filter    &#123;&#123;123|currency&#125;&#125; &#123;&#123;12321213|date:&quot;yyyy-MM-dd&quot;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">* ng-clack</span><br></pre></td></tr></table></figure>"},{"title":"Ant Design of React+dva入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n# 简介\n是 Ant Design 的 React 实现，开发和服务于企业级后台产品\n\n# 安装使用Antd\n1. npm install antd --save\n2. 浏览器引入\n* 在浏览器中使用 script 和 link 标签直接引入文件，并使用全局变量 antd\n* 在 npm 发布包内的 antd/dist 目录下提供了 antd.js antd.css 以及 antd.min.js antd.min.css\n* 也可以通过 CDNJS https://cdnjs.com/libraries/antd 或 UNPKG https://unpkg.com/antd@3.0.2/dist/ 进行下载\n* 强烈不推荐使用已构建文件，这样无法按需加载，而且难以获得底层依赖模块的 bug 快速修复支持\n\n# 安装使用dva\ndva 是一个基于 React 和 Redux 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。\n~~~\nnpm install dva-cli -g\ndva -v\ndva new dva-quickstart\ncd dva-quickstart\nnpm start\n~~~\n在浏览器里打开 http://localhost:8000 ，你会看到 dva 的欢迎界面\n\n# dva项目中使用Antd\n1. npm install antd babel-plugin-import --save\n2. 编辑 .roadhogrc，使 babel-plugin-import 插件生效\n\n# 按需加载Antd\n使用 babel-plugin-import\n~~~\n// .babelrc or babel-loader option\n{\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" }] // `style: true` 会加载 less 文件\n  ]\n}\n~~~\n然后只需从 antd 引入模块即可，无需单独引入样式。等同于下面手动引入的方式。\n\n// babel-plugin-import 会帮助你加载 JS 和 CSS\nimport { DatePicker } from 'antd';\n\n# 在 create-react-app 中使用\n> create-react-app 是业界最优秀的 React 应用开发工具之一\n\n> 使用create-react-app只是创建出了react应用的基本架构，类似于dva-cli创建的架构，antd还是需要自己添加\n\n# dva的出现背景\nhttps://github.com/sorrycc/blog/issues/1\n ","source":"_posts/前端开发/Ant Design of React+dva入门.md","raw":"---\ntitle: Ant Design of React+dva入门\ntags:\n  - dva \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n# 简介\n是 Ant Design 的 React 实现，开发和服务于企业级后台产品\n\n# 安装使用Antd\n1. npm install antd --save\n2. 浏览器引入\n* 在浏览器中使用 script 和 link 标签直接引入文件，并使用全局变量 antd\n* 在 npm 发布包内的 antd/dist 目录下提供了 antd.js antd.css 以及 antd.min.js antd.min.css\n* 也可以通过 CDNJS https://cdnjs.com/libraries/antd 或 UNPKG https://unpkg.com/antd@3.0.2/dist/ 进行下载\n* 强烈不推荐使用已构建文件，这样无法按需加载，而且难以获得底层依赖模块的 bug 快速修复支持\n\n# 安装使用dva\ndva 是一个基于 React 和 Redux 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。\n~~~\nnpm install dva-cli -g\ndva -v\ndva new dva-quickstart\ncd dva-quickstart\nnpm start\n~~~\n在浏览器里打开 http://localhost:8000 ，你会看到 dva 的欢迎界面\n\n# dva项目中使用Antd\n1. npm install antd babel-plugin-import --save\n2. 编辑 .roadhogrc，使 babel-plugin-import 插件生效\n\n# 按需加载Antd\n使用 babel-plugin-import\n~~~\n// .babelrc or babel-loader option\n{\n  \"plugins\": [\n    [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" }] // `style: true` 会加载 less 文件\n  ]\n}\n~~~\n然后只需从 antd 引入模块即可，无需单独引入样式。等同于下面手动引入的方式。\n\n// babel-plugin-import 会帮助你加载 JS 和 CSS\nimport { DatePicker } from 'antd';\n\n# 在 create-react-app 中使用\n> create-react-app 是业界最优秀的 React 应用开发工具之一\n\n> 使用create-react-app只是创建出了react应用的基本架构，类似于dva-cli创建的架构，antd还是需要自己添加\n\n# dva的出现背景\nhttps://github.com/sorrycc/blog/issues/1\n ","slug":"前端开发-Ant-Design-of-React-dva入门","published":1,"updated":"2019-02-14T06:03:56.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudz3004d5b8hhpu7b6lo","content":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>是 Ant Design 的 React 实现，开发和服务于企业级后台产品</p>\n<h1 id=\"安装使用antd\"><a class=\"markdownIt-Anchor\" href=\"#安装使用antd\"></a> 安装使用Antd</h1>\n<ol>\n<li>npm install antd --save</li>\n<li>浏览器引入</li>\n</ol>\n<ul>\n<li>在浏览器中使用 script 和 link 标签直接引入文件，并使用全局变量 antd</li>\n<li>在 npm 发布包内的 antd/dist 目录下提供了 antd.js antd.css 以及 antd.min.js antd.min.css</li>\n<li>也可以通过 CDNJS <a href=\"https://cdnjs.com/libraries/antd\" target=\"_blank\" rel=\"noopener\">https://cdnjs.com/libraries/antd</a> 或 UNPKG <a href=\"https://unpkg.com/antd@3.0.2/dist/\" target=\"_blank\" rel=\"noopener\">https://unpkg.com/antd@3.0.2/dist/</a> 进行下载</li>\n<li>强烈不推荐使用已构建文件，这样无法按需加载，而且难以获得底层依赖模块的 bug 快速修复支持</li>\n</ul>\n<h1 id=\"安装使用dva\"><a class=\"markdownIt-Anchor\" href=\"#安装使用dva\"></a> 安装使用dva</h1>\n<p>dva 是一个基于 React 和 Redux 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install dva-cli -g</span><br><span class=\"line\">dva -v</span><br><span class=\"line\">dva new dva-quickstart</span><br><span class=\"line\">cd dva-quickstart</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>在浏览器里打开 <a href=\"http://localhost:8000\" target=\"_blank\" rel=\"noopener\">http://localhost:8000</a> ，你会看到 dva 的欢迎界面</p>\n<h1 id=\"dva项目中使用antd\"><a class=\"markdownIt-Anchor\" href=\"#dva项目中使用antd\"></a> dva项目中使用Antd</h1>\n<ol>\n<li>npm install antd babel-plugin-import --save</li>\n<li>编辑 .roadhogrc，使 babel-plugin-import 插件生效</li>\n</ol>\n<h1 id=\"按需加载antd\"><a class=\"markdownIt-Anchor\" href=\"#按需加载antd\"></a> 按需加载Antd</h1>\n<p>使用 babel-plugin-import</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// .babelrc or babel-loader option</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; &#125;] // `style: true` 会加载 less 文件</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后只需从 antd 引入模块即可，无需单独引入样式。等同于下面手动引入的方式。</p>\n<p>// babel-plugin-import 会帮助你加载 JS 和 CSS<br>\nimport { DatePicker } from ‘antd’;</p>\n<h1 id=\"在-create-react-app-中使用\"><a class=\"markdownIt-Anchor\" href=\"#在-create-react-app-中使用\"></a> 在 create-react-app 中使用</h1>\n<blockquote>\n<p>create-react-app 是业界最优秀的 React 应用开发工具之一</p>\n</blockquote>\n<blockquote>\n<p>使用create-react-app只是创建出了react应用的基本架构，类似于dva-cli创建的架构，antd还是需要自己添加</p>\n</blockquote>\n<h1 id=\"dva的出现背景\"><a class=\"markdownIt-Anchor\" href=\"#dva的出现背景\"></a> dva的出现背景</h1>\n<p><a href=\"https://github.com/sorrycc/blog/issues/1\" target=\"_blank\" rel=\"noopener\">https://github.com/sorrycc/blog/issues/1</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>是 Ant Design 的 React 实现，开发和服务于企业级后台产品</p>\n<h1 id=\"安装使用antd\"><a class=\"markdownIt-Anchor\" href=\"#安装使用antd\"></a> 安装使用Antd</h1>\n<ol>\n<li>npm install antd --save</li>\n<li>浏览器引入</li>\n</ol>\n<ul>\n<li>在浏览器中使用 script 和 link 标签直接引入文件，并使用全局变量 antd</li>\n<li>在 npm 发布包内的 antd/dist 目录下提供了 antd.js antd.css 以及 antd.min.js antd.min.css</li>\n<li>也可以通过 CDNJS <a href=\"https://cdnjs.com/libraries/antd\" target=\"_blank\" rel=\"noopener\">https://cdnjs.com/libraries/antd</a> 或 UNPKG <a href=\"https://unpkg.com/antd@3.0.2/dist/\" target=\"_blank\" rel=\"noopener\">https://unpkg.com/antd@3.0.2/dist/</a> 进行下载</li>\n<li>强烈不推荐使用已构建文件，这样无法按需加载，而且难以获得底层依赖模块的 bug 快速修复支持</li>\n</ul>\n<h1 id=\"安装使用dva\"><a class=\"markdownIt-Anchor\" href=\"#安装使用dva\"></a> 安装使用dva</h1>\n<p>dva 是一个基于 React 和 Redux 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install dva-cli -g</span><br><span class=\"line\">dva -v</span><br><span class=\"line\">dva new dva-quickstart</span><br><span class=\"line\">cd dva-quickstart</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>在浏览器里打开 <a href=\"http://localhost:8000\" target=\"_blank\" rel=\"noopener\">http://localhost:8000</a> ，你会看到 dva 的欢迎界面</p>\n<h1 id=\"dva项目中使用antd\"><a class=\"markdownIt-Anchor\" href=\"#dva项目中使用antd\"></a> dva项目中使用Antd</h1>\n<ol>\n<li>npm install antd babel-plugin-import --save</li>\n<li>编辑 .roadhogrc，使 babel-plugin-import 插件生效</li>\n</ol>\n<h1 id=\"按需加载antd\"><a class=\"markdownIt-Anchor\" href=\"#按需加载antd\"></a> 按需加载Antd</h1>\n<p>使用 babel-plugin-import</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// .babelrc or babel-loader option</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; &#125;] // `style: true` 会加载 less 文件</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后只需从 antd 引入模块即可，无需单独引入样式。等同于下面手动引入的方式。</p>\n<p>// babel-plugin-import 会帮助你加载 JS 和 CSS<br>\nimport { DatePicker } from ‘antd’;</p>\n<h1 id=\"在-create-react-app-中使用\"><a class=\"markdownIt-Anchor\" href=\"#在-create-react-app-中使用\"></a> 在 create-react-app 中使用</h1>\n<blockquote>\n<p>create-react-app 是业界最优秀的 React 应用开发工具之一</p>\n</blockquote>\n<blockquote>\n<p>使用create-react-app只是创建出了react应用的基本架构，类似于dva-cli创建的架构，antd还是需要自己添加</p>\n</blockquote>\n<h1 id=\"dva的出现背景\"><a class=\"markdownIt-Anchor\" href=\"#dva的出现背景\"></a> dva的出现背景</h1>\n<p><a href=\"https://github.com/sorrycc/blog/issues/1\" target=\"_blank\" rel=\"noopener\">https://github.com/sorrycc/blog/issues/1</a></p>\n"},{"title":"Antd PRO入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n# 网址\n* AntD官网：https://ant.design/index-cn\n* 脚手架市场：http://scaffold.ant.design/#/\n\nAntD Pro脚手架：（官方脚手架）\n* 中文：https://pro.ant.design/index-cn\n* e文：https://pro.ant.design/docs/getting-started\n* github：https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md\n\n# 简介\n开箱即用的中台前端/设计解决方案\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBab39c02da574c27d01258b07c812ef04?method=download&shareKey=2db6827dba6c579c7e1c59cdf608586a)\n\n# 安装使用\n~~~\n$ npm install ant-design-pro-cli -g\n$ mkdir my-project && cd my-project\n$ pro new  # 安装脚手架\n$ npm install\n$ npm start\n~~~\n\n# 布局\n* BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏\n* BlankLayout：空白的布局\n* PageHeaderLayout：带有标准 PageHeader 的布局\n* UserLayout：抽离出用于登陆注册页面的通用布局\n\n","source":"_posts/前端开发/Antd PRO入门.md","raw":"---\ntitle: Antd PRO入门\ntags:\n  - Antd \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n# 网址\n* AntD官网：https://ant.design/index-cn\n* 脚手架市场：http://scaffold.ant.design/#/\n\nAntD Pro脚手架：（官方脚手架）\n* 中文：https://pro.ant.design/index-cn\n* e文：https://pro.ant.design/docs/getting-started\n* github：https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md\n\n# 简介\n开箱即用的中台前端/设计解决方案\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBab39c02da574c27d01258b07c812ef04?method=download&shareKey=2db6827dba6c579c7e1c59cdf608586a)\n\n# 安装使用\n~~~\n$ npm install ant-design-pro-cli -g\n$ mkdir my-project && cd my-project\n$ pro new  # 安装脚手架\n$ npm install\n$ npm start\n~~~\n\n# 布局\n* BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏\n* BlankLayout：空白的布局\n* PageHeaderLayout：带有标准 PageHeader 的布局\n* UserLayout：抽离出用于登陆注册页面的通用布局\n\n","slug":"前端开发-Antd-PRO入门","published":1,"updated":"2019-02-14T06:04:36.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudz4004h5b8hrjg5jkue","content":"<p>[toc]</p>\n<h1 id=\"网址\"><a class=\"markdownIt-Anchor\" href=\"#网址\"></a> 网址</h1>\n<ul>\n<li>AntD官网：<a href=\"https://ant.design/index-cn\" target=\"_blank\" rel=\"noopener\">https://ant.design/index-cn</a></li>\n<li>脚手架市场：<a href=\"http://scaffold.ant.design/#/\" target=\"_blank\" rel=\"noopener\">http://scaffold.ant.design/#/</a></li>\n</ul>\n<p>AntD Pro脚手架：（官方脚手架）</p>\n<ul>\n<li>中文：<a href=\"https://pro.ant.design/index-cn\" target=\"_blank\" rel=\"noopener\">https://pro.ant.design/index-cn</a></li>\n<li>e文：<a href=\"https://pro.ant.design/docs/getting-started\" target=\"_blank\" rel=\"noopener\">https://pro.ant.design/docs/getting-started</a></li>\n<li>github：<a href=\"https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md\" target=\"_blank\" rel=\"noopener\">https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md</a></li>\n</ul>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>开箱即用的中台前端/设计解决方案</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBab39c02da574c27d01258b07c812ef04?method=download&amp;shareKey=2db6827dba6c579c7e1c59cdf608586a\" alt=\"image\"></p>\n<h1 id=\"安装使用\"><a class=\"markdownIt-Anchor\" href=\"#安装使用\"></a> 安装使用</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install ant-design-pro-cli -g</span><br><span class=\"line\">$ mkdir my-project &amp;&amp; cd my-project</span><br><span class=\"line\">$ pro new  # 安装脚手架</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure>\n<h1 id=\"布局\"><a class=\"markdownIt-Anchor\" href=\"#布局\"></a> 布局</h1>\n<ul>\n<li>BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏</li>\n<li>BlankLayout：空白的布局</li>\n<li>PageHeaderLayout：带有标准 PageHeader 的布局</li>\n<li>UserLayout：抽离出用于登陆注册页面的通用布局</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"网址\"><a class=\"markdownIt-Anchor\" href=\"#网址\"></a> 网址</h1>\n<ul>\n<li>AntD官网：<a href=\"https://ant.design/index-cn\" target=\"_blank\" rel=\"noopener\">https://ant.design/index-cn</a></li>\n<li>脚手架市场：<a href=\"http://scaffold.ant.design/#/\" target=\"_blank\" rel=\"noopener\">http://scaffold.ant.design/#/</a></li>\n</ul>\n<p>AntD Pro脚手架：（官方脚手架）</p>\n<ul>\n<li>中文：<a href=\"https://pro.ant.design/index-cn\" target=\"_blank\" rel=\"noopener\">https://pro.ant.design/index-cn</a></li>\n<li>e文：<a href=\"https://pro.ant.design/docs/getting-started\" target=\"_blank\" rel=\"noopener\">https://pro.ant.design/docs/getting-started</a></li>\n<li>github：<a href=\"https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md\" target=\"_blank\" rel=\"noopener\">https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md</a></li>\n</ul>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>开箱即用的中台前端/设计解决方案</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBab39c02da574c27d01258b07c812ef04?method=download&amp;shareKey=2db6827dba6c579c7e1c59cdf608586a\" alt=\"image\"></p>\n<h1 id=\"安装使用\"><a class=\"markdownIt-Anchor\" href=\"#安装使用\"></a> 安装使用</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install ant-design-pro-cli -g</span><br><span class=\"line\">$ mkdir my-project &amp;&amp; cd my-project</span><br><span class=\"line\">$ pro new  # 安装脚手架</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure>\n<h1 id=\"布局\"><a class=\"markdownIt-Anchor\" href=\"#布局\"></a> 布局</h1>\n<ul>\n<li>BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏</li>\n<li>BlankLayout：空白的布局</li>\n<li>PageHeaderLayout：带有标准 PageHeader 的布局</li>\n<li>UserLayout：抽离出用于登陆注册页面的通用布局</li>\n</ul>\n"},{"title":"CSS预处理技术","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\nCSS预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。最普遍的分别是 Sass、Less CSS、Stylus，本文以Less重点讲解。\n\nCSS预处理器\nCSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处\n\n1.Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码\n2.Less 可以通过 npm 在命令行上运行；在浏览器上作为脚本文件下载；或者集成在广大的第三方工具内\n3.在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），方法如下：npm install -g less\n4.安装 Less 后，就可以在命令行上调用 Less 编译器了，如：lessc styles.less或lessc styles.less > styles.css\n若要输出压缩过的 CSS，只需添加 -x 选项。如果希望获得更好的压缩效果，还可以通过 --clean-css 选项启用 Clean CSS 进行压缩\n5.在代码中调用 Less如下：\nvar less = require('less');\n\nless.render('.class { width: (1 + 1) }', function (e, css) {\n  console.log(css);\n});\n6.还可以手动调用分析器（paser）和编译器:\nvar parser = new(less.Parser);\n\nparser.parse('.class { width: (1 + 1) }', function (err, tree) {\n  if (err) {\n    return console.error(err)\n  }\n  console.log(tree.toCSS());\n});\n7.可以给编译器传递多个参数\nvar parser = new(less.Parser)({\n  paths: ['.', './lib'], // Specify search paths for @import directives\n  filename: 'style.less' // Specify a filename, for better error messages\n});\n\nparser.parse('.class { width: (1 + 1) }', function (e, tree) {\n  tree.toCSS({\n    // Minify CSS output\n    compress: true\n  });\n});\n8.Less 还和流行的 Grunt 构建工具进行了集成，可以参考 grunt-contrib-less 插件\n9.在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要，我们建议最好使用 node.js 或其它第三方工具进行预编译\n\n\n\n\nhttp://www.bootcss.com/p/lesscss/\n\nLESS 原理及使用方式\n本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性\n\nLESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用\n客户端：<link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\"> ==LESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析\n服务器端：目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译\n以通过这个关键字引入我们需要的 .less 或 .css 文件。 如：\n@import “variables.less”;\n.less 文件也可以省略后缀名，像这样：\n@import “variables”;\n引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略\n\n变量\n1.LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单\n2.ESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是作用域，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局\n@width : 20px; \n #homeDiv { \n   @width : 30px; \n   #centerDiv{ \n       width : @width;// 此处应该取最近定义的变量 width 的值 30px \n              } \n } \n\nMixins（混入）\n1.混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样\n// 定义一个样式选择器\n .roundedCorners(@radius:5px) { \n -moz-border-radius: @radius; \n -webkit-border-radius: @radius; \n border-radius: @radius; \n } \n // 在另外的样式选择器中使用\n #header { \n .roundedCorners; \n } \n #footer { \n .roundedCorners(10px); \n }\n2.Mixins中@arguments是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码\n.boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ \n -moz-box-shadow: @arguments; \n -webkit-box-shadow: @arguments; \n box-shadow: @arguments; \n } \n #header { \n .boxShadow(2px,2px,3px,#f36); \n }\n3.LESS也采用了命名空间的方法来避免重名问题\n #mynamespace { \n .home {...} \n .user {...} \n }\n如果我们要复用 user 这个选择器的时候，就可以了通过：#mynamespace > .user 的方式\n4.嵌套的规则\n在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写：\n HTML 片段\n <div id=\"home\"> \n\t <div id=\"top\">top</div> \n\t <div id=\"center\"> \n\t <div id=\"left\">left</div> \n\t <div id=\"right\">right</div> \n\t </div> \n </div>\n    对应LESS 文件\n #home{ \n   color : blue; \n   width : 600px; \n   height : 500px; \n   border:outset; \n   #top{ \n        border:outset; \n        width : 90%; \n   } \n   #center{ \n        border:outset; \n        height : 300px; \n        width : 90%; \n        #left{ \n          border:outset; \n          float : left; \n        width : 40%; \n        } \n        #right{ \n          border:outset; \n          float : left; \n          width : 40%; \n        } \n    } \n }\n\n运算及函数\n简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。\n下面是 LESS 提供的针对颜色操作的函数列表：\n lighten(@color, 10%); // return a color which is 10% *lighter* than @color \n darken(@color, 10%); // return a color which is 10% *darker* than @color \n saturate(@color, 10%); // return a color 10% *more* saturated than @color \n desaturate(@color, 10%);// return a color 10% *less* saturated than @color \n fadein(@color, 10%); // return a color 10% *less* transparent than @color \n fadeout(@color, 10%); // return a color 10% *more* transparent than @color \n spin(@color, 10); // return a color with a 10 degree larger in hue than @color \n spin(@color, -10); // return a color with a 10 degree smaller hue than @color\n变量使用示例：\n @init: #111111; \n @transition: @init*2; \n .switchColor { \n  color: @transition; \n }\n\nComments（注释）\n适当的注释是保证代码可读性的必要手段，LESS 对注释也提供了支持，主要有两种方式：单行注释和多行注释\nLESS 中单行注释 (// 单行注释 ) 是不能显示在编译后的 CSS 中，所以如果注释是针对样式说明的请使用多行注释\n","source":"_posts/前端开发/CSS预处理技术.md","raw":"---\ntitle: CSS预处理技术\ntags:\n  - CSS  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\nCSS预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。最普遍的分别是 Sass、Less CSS、Stylus，本文以Less重点讲解。\n\nCSS预处理器\nCSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处\n\n1.Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码\n2.Less 可以通过 npm 在命令行上运行；在浏览器上作为脚本文件下载；或者集成在广大的第三方工具内\n3.在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），方法如下：npm install -g less\n4.安装 Less 后，就可以在命令行上调用 Less 编译器了，如：lessc styles.less或lessc styles.less > styles.css\n若要输出压缩过的 CSS，只需添加 -x 选项。如果希望获得更好的压缩效果，还可以通过 --clean-css 选项启用 Clean CSS 进行压缩\n5.在代码中调用 Less如下：\nvar less = require('less');\n\nless.render('.class { width: (1 + 1) }', function (e, css) {\n  console.log(css);\n});\n6.还可以手动调用分析器（paser）和编译器:\nvar parser = new(less.Parser);\n\nparser.parse('.class { width: (1 + 1) }', function (err, tree) {\n  if (err) {\n    return console.error(err)\n  }\n  console.log(tree.toCSS());\n});\n7.可以给编译器传递多个参数\nvar parser = new(less.Parser)({\n  paths: ['.', './lib'], // Specify search paths for @import directives\n  filename: 'style.less' // Specify a filename, for better error messages\n});\n\nparser.parse('.class { width: (1 + 1) }', function (e, tree) {\n  tree.toCSS({\n    // Minify CSS output\n    compress: true\n  });\n});\n8.Less 还和流行的 Grunt 构建工具进行了集成，可以参考 grunt-contrib-less 插件\n9.在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要，我们建议最好使用 node.js 或其它第三方工具进行预编译\n\n\n\n\nhttp://www.bootcss.com/p/lesscss/\n\nLESS 原理及使用方式\n本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性\n\nLESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用\n客户端：<link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\"> ==LESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析\n服务器端：目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译\n以通过这个关键字引入我们需要的 .less 或 .css 文件。 如：\n@import “variables.less”;\n.less 文件也可以省略后缀名，像这样：\n@import “variables”;\n引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略\n\n变量\n1.LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单\n2.ESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是作用域，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局\n@width : 20px; \n #homeDiv { \n   @width : 30px; \n   #centerDiv{ \n       width : @width;// 此处应该取最近定义的变量 width 的值 30px \n              } \n } \n\nMixins（混入）\n1.混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样\n// 定义一个样式选择器\n .roundedCorners(@radius:5px) { \n -moz-border-radius: @radius; \n -webkit-border-radius: @radius; \n border-radius: @radius; \n } \n // 在另外的样式选择器中使用\n #header { \n .roundedCorners; \n } \n #footer { \n .roundedCorners(10px); \n }\n2.Mixins中@arguments是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码\n.boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ \n -moz-box-shadow: @arguments; \n -webkit-box-shadow: @arguments; \n box-shadow: @arguments; \n } \n #header { \n .boxShadow(2px,2px,3px,#f36); \n }\n3.LESS也采用了命名空间的方法来避免重名问题\n #mynamespace { \n .home {...} \n .user {...} \n }\n如果我们要复用 user 这个选择器的时候，就可以了通过：#mynamespace > .user 的方式\n4.嵌套的规则\n在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写：\n HTML 片段\n <div id=\"home\"> \n\t <div id=\"top\">top</div> \n\t <div id=\"center\"> \n\t <div id=\"left\">left</div> \n\t <div id=\"right\">right</div> \n\t </div> \n </div>\n    对应LESS 文件\n #home{ \n   color : blue; \n   width : 600px; \n   height : 500px; \n   border:outset; \n   #top{ \n        border:outset; \n        width : 90%; \n   } \n   #center{ \n        border:outset; \n        height : 300px; \n        width : 90%; \n        #left{ \n          border:outset; \n          float : left; \n        width : 40%; \n        } \n        #right{ \n          border:outset; \n          float : left; \n          width : 40%; \n        } \n    } \n }\n\n运算及函数\n简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。\n下面是 LESS 提供的针对颜色操作的函数列表：\n lighten(@color, 10%); // return a color which is 10% *lighter* than @color \n darken(@color, 10%); // return a color which is 10% *darker* than @color \n saturate(@color, 10%); // return a color 10% *more* saturated than @color \n desaturate(@color, 10%);// return a color 10% *less* saturated than @color \n fadein(@color, 10%); // return a color 10% *less* transparent than @color \n fadeout(@color, 10%); // return a color 10% *more* transparent than @color \n spin(@color, 10); // return a color with a 10 degree larger in hue than @color \n spin(@color, -10); // return a color with a 10 degree smaller hue than @color\n变量使用示例：\n @init: #111111; \n @transition: @init*2; \n .switchColor { \n  color: @transition; \n }\n\nComments（注释）\n适当的注释是保证代码可读性的必要手段，LESS 对注释也提供了支持，主要有两种方式：单行注释和多行注释\nLESS 中单行注释 (// 单行注释 ) 是不能显示在编译后的 CSS 中，所以如果注释是针对样式说明的请使用多行注释\n","slug":"前端开发-CSS预处理技术","published":1,"updated":"2019-02-14T06:18:31.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudz6004l5b8h0i3fcfqw","content":"<p>CSS预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。最普遍的分别是 Sass、Less CSS、Stylus，本文以Less重点讲解。</p>\n<p>CSS预处理器<br>\nCSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处</p>\n<p>1.Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码<br>\n2.Less 可以通过 npm 在命令行上运行；在浏览器上作为脚本文件下载；或者集成在广大的第三方工具内<br>\n3.在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），方法如下：npm install -g less<br>\n4.安装 Less 后，就可以在命令行上调用 Less 编译器了，如：lessc styles.less或lessc styles.less &gt; styles.css<br>\n若要输出压缩过的 CSS，只需添加 -x 选项。如果希望获得更好的压缩效果，还可以通过 --clean-css 选项启用 Clean CSS 进行压缩<br>\n5.在代码中调用 Less如下：<br>\nvar less = require(‘less’);</p>\n<p>less.render(’.class { width: (1 + 1) }’, function (e, css) {<br>\n  console.log(css);<br>\n});<br>\n6.还可以手动调用分析器（paser）和编译器:<br>\nvar parser = new(less.Parser);</p>\n<p>parser.parse(’.class { width: (1 + 1) }’, function (err, tree) {<br>\n  if (err) {<br>\n    return console.error(err)<br>\n  }<br>\n  console.log(tree.toCSS());<br>\n});<br>\n7.可以给编译器传递多个参数<br>\nvar parser = new(less.Parser)({<br>\n  paths: [’.’, ‘./lib’], // Specify search paths for @import directives<br>\n  filename: ‘style.less’ // Specify a filename, for better error messages<br>\n});</p>\n<p>parser.parse(’.class { width: (1 + 1) }’, function (e, tree) {<br>\n  tree.toCSS({<br>\n    // Minify CSS output<br>\n    compress: true<br>\n  });<br>\n});<br>\n8.Less 还和流行的 Grunt 构建工具进行了集成，可以参考 grunt-contrib-less 插件<br>\n9.在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要，我们建议最好使用 node.js 或其它第三方工具进行预编译</p>\n<p><a href=\"http://www.bootcss.com/p/lesscss/\" target=\"_blank\" rel=\"noopener\">http://www.bootcss.com/p/lesscss/</a></p>\n<p>LESS 原理及使用方式<br>\n本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性</p>\n<p>LESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用<br>\n客户端：<link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\"> ==LESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析<br>\n服务器端：目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译<br>\n以通过这个关键字引入我们需要的 .less 或 .css 文件。 如：<br>\n@import “variables.less”;<br>\n.less 文件也可以省略后缀名，像这样：<br>\n@import “variables”;<br>\n引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略</p>\n<p>变量<br>\n1.LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单<br>\n2.ESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是作用域，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局<br>\n@width : 20px; <br>\n #homeDiv { <br>\n   @width : 30px; <br>\n   #centerDiv{ <br>\n       width : @width;// 此处应该取最近定义的变量 width 的值 30px <br>\n              } <br>\n }</p>\n<p>Mixins（混入）<br>\n1.混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样<br>\n// 定义一个样式选择器<br>\n .roundedCorners(@radius:5px) { <br>\n -moz-border-radius: @radius; <br>\n -webkit-border-radius: @radius; <br>\n border-radius: @radius; <br>\n } <br>\n // 在另外的样式选择器中使用<br>\n #header { <br>\n .roundedCorners; <br>\n } <br>\n #footer { <br>\n .roundedCorners(10px); <br>\n }<br>\n2.Mixins中@arguments是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码<br>\n.boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ <br>\n -moz-box-shadow: @arguments; <br>\n -webkit-box-shadow: @arguments; <br>\n box-shadow: @arguments; <br>\n } <br>\n #header { <br>\n .boxShadow(2px,2px,3px,#f36); <br>\n }<br>\n3.LESS也采用了命名空间的方法来避免重名问题<br>\n #mynamespace { <br>\n .home {…} <br>\n .user {…} <br>\n }<br>\n如果我们要复用 user 这个选择器的时候，就可以了通过：#mynamespace &gt; .user 的方式<br>\n4.嵌套的规则<br>\n在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写：<br>\n HTML 片段<br>\n <div id=\"home\"> <br>\n <div id=\"top\">top</div> <br>\n <div id=\"center\"> <br>\n <div id=\"left\">left</div> <br>\n <div id=\"right\">right</div> <br>\n </div> <br>\n </div><br>\n    对应LESS 文件<br>\n #home{ <br>\n   color : blue; <br>\n   width : 600px; <br>\n   height : 500px; <br>\n   border:outset; <br>\n   #top{ <br>\n        border:outset; <br>\n        width : 90%; <br>\n   } <br>\n   #center{ <br>\n        border:outset; <br>\n        height : 300px; <br>\n        width : 90%; <br>\n        #left{ <br>\n          border:outset; <br>\n          float : left; <br>\n        width : 40%; <br>\n        } <br>\n        #right{ <br>\n          border:outset; <br>\n          float : left; <br>\n          width : 40%; <br>\n        } <br>\n    } <br>\n }</p>\n<p>运算及函数<br>\n简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。<br>\n下面是 LESS 提供的针对颜色操作的函数列表：<br>\n lighten(@color, 10%); // return a color which is 10% <em>lighter</em> than @color <br>\n darken(@color, 10%); // return a color which is 10% <em>darker</em> than @color <br>\n saturate(@color, 10%); // return a color 10% <em>more</em> saturated than @color <br>\n desaturate(@color, 10%);// return a color 10% <em>less</em> saturated than @color <br>\n fadein(@color, 10%); // return a color 10% <em>less</em> transparent than @color <br>\n fadeout(@color, 10%); // return a color 10% <em>more</em> transparent than @color <br>\n spin(@color, 10); // return a color with a 10 degree larger in hue than @color <br>\n spin(@color, -10); // return a color with a 10 degree smaller hue than @color<br>\n变量使用示例：<br>\n @init: #111111; <br>\n @transition: @init*2; <br>\n .switchColor { <br>\n  color: @transition; <br>\n }</p>\n<p>Comments（注释）<br>\n适当的注释是保证代码可读性的必要手段，LESS 对注释也提供了支持，主要有两种方式：单行注释和多行注释<br>\nLESS 中单行注释 (// 单行注释 ) 是不能显示在编译后的 CSS 中，所以如果注释是针对样式说明的请使用多行注释</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CSS预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。最普遍的分别是 Sass、Less CSS、Stylus，本文以Less重点讲解。</p>\n<p>CSS预处理器<br>\nCSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处</p>\n<p>1.Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码<br>\n2.Less 可以通过 npm 在命令行上运行；在浏览器上作为脚本文件下载；或者集成在广大的第三方工具内<br>\n3.在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），方法如下：npm install -g less<br>\n4.安装 Less 后，就可以在命令行上调用 Less 编译器了，如：lessc styles.less或lessc styles.less &gt; styles.css<br>\n若要输出压缩过的 CSS，只需添加 -x 选项。如果希望获得更好的压缩效果，还可以通过 --clean-css 选项启用 Clean CSS 进行压缩<br>\n5.在代码中调用 Less如下：<br>\nvar less = require(‘less’);</p>\n<p>less.render(’.class { width: (1 + 1) }’, function (e, css) {<br>\n  console.log(css);<br>\n});<br>\n6.还可以手动调用分析器（paser）和编译器:<br>\nvar parser = new(less.Parser);</p>\n<p>parser.parse(’.class { width: (1 + 1) }’, function (err, tree) {<br>\n  if (err) {<br>\n    return console.error(err)<br>\n  }<br>\n  console.log(tree.toCSS());<br>\n});<br>\n7.可以给编译器传递多个参数<br>\nvar parser = new(less.Parser)({<br>\n  paths: [’.’, ‘./lib’], // Specify search paths for @import directives<br>\n  filename: ‘style.less’ // Specify a filename, for better error messages<br>\n});</p>\n<p>parser.parse(’.class { width: (1 + 1) }’, function (e, tree) {<br>\n  tree.toCSS({<br>\n    // Minify CSS output<br>\n    compress: true<br>\n  });<br>\n});<br>\n8.Less 还和流行的 Grunt 构建工具进行了集成，可以参考 grunt-contrib-less 插件<br>\n9.在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要，我们建议最好使用 node.js 或其它第三方工具进行预编译</p>\n<p><a href=\"http://www.bootcss.com/p/lesscss/\" target=\"_blank\" rel=\"noopener\">http://www.bootcss.com/p/lesscss/</a></p>\n<p>LESS 原理及使用方式<br>\n本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性</p>\n<p>LESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用<br>\n客户端：<link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\"> ==LESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析<br>\n服务器端：目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译<br>\n以通过这个关键字引入我们需要的 .less 或 .css 文件。 如：<br>\n@import “variables.less”;<br>\n.less 文件也可以省略后缀名，像这样：<br>\n@import “variables”;<br>\n引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略</p>\n<p>变量<br>\n1.LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单<br>\n2.ESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是作用域，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局<br>\n@width : 20px; <br>\n #homeDiv { <br>\n   @width : 30px; <br>\n   #centerDiv{ <br>\n       width : @width;// 此处应该取最近定义的变量 width 的值 30px <br>\n              } <br>\n }</p>\n<p>Mixins（混入）<br>\n1.混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样<br>\n// 定义一个样式选择器<br>\n .roundedCorners(@radius:5px) { <br>\n -moz-border-radius: @radius; <br>\n -webkit-border-radius: @radius; <br>\n border-radius: @radius; <br>\n } <br>\n // 在另外的样式选择器中使用<br>\n #header { <br>\n .roundedCorners; <br>\n } <br>\n #footer { <br>\n .roundedCorners(10px); <br>\n }<br>\n2.Mixins中@arguments是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码<br>\n.boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ <br>\n -moz-box-shadow: @arguments; <br>\n -webkit-box-shadow: @arguments; <br>\n box-shadow: @arguments; <br>\n } <br>\n #header { <br>\n .boxShadow(2px,2px,3px,#f36); <br>\n }<br>\n3.LESS也采用了命名空间的方法来避免重名问题<br>\n #mynamespace { <br>\n .home {…} <br>\n .user {…} <br>\n }<br>\n如果我们要复用 user 这个选择器的时候，就可以了通过：#mynamespace &gt; .user 的方式<br>\n4.嵌套的规则<br>\n在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写：<br>\n HTML 片段<br>\n <div id=\"home\"> <br>\n <div id=\"top\">top</div> <br>\n <div id=\"center\"> <br>\n <div id=\"left\">left</div> <br>\n <div id=\"right\">right</div> <br>\n </div> <br>\n </div><br>\n    对应LESS 文件<br>\n #home{ <br>\n   color : blue; <br>\n   width : 600px; <br>\n   height : 500px; <br>\n   border:outset; <br>\n   #top{ <br>\n        border:outset; <br>\n        width : 90%; <br>\n   } <br>\n   #center{ <br>\n        border:outset; <br>\n        height : 300px; <br>\n        width : 90%; <br>\n        #left{ <br>\n          border:outset; <br>\n          float : left; <br>\n        width : 40%; <br>\n        } <br>\n        #right{ <br>\n          border:outset; <br>\n          float : left; <br>\n          width : 40%; <br>\n        } <br>\n    } <br>\n }</p>\n<p>运算及函数<br>\n简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。<br>\n下面是 LESS 提供的针对颜色操作的函数列表：<br>\n lighten(@color, 10%); // return a color which is 10% <em>lighter</em> than @color <br>\n darken(@color, 10%); // return a color which is 10% <em>darker</em> than @color <br>\n saturate(@color, 10%); // return a color 10% <em>more</em> saturated than @color <br>\n desaturate(@color, 10%);// return a color 10% <em>less</em> saturated than @color <br>\n fadein(@color, 10%); // return a color 10% <em>less</em> transparent than @color <br>\n fadeout(@color, 10%); // return a color 10% <em>more</em> transparent than @color <br>\n spin(@color, 10); // return a color with a 10 degree larger in hue than @color <br>\n spin(@color, -10); // return a color with a 10 degree smaller hue than @color<br>\n变量使用示例：<br>\n @init: #111111; <br>\n @transition: @init*2; <br>\n .switchColor { <br>\n  color: @transition; <br>\n }</p>\n<p>Comments（注释）<br>\n适当的注释是保证代码可读性的必要手段，LESS 对注释也提供了支持，主要有两种方式：单行注释和多行注释<br>\nLESS 中单行注释 (// 单行注释 ) 是不能显示在编译后的 CSS 中，所以如果注释是针对样式说明的请使用多行注释</p>\n"},{"title":"ejs模版引擎基本使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\nhttp://www.360doc.com/content/16/0115/10/597197_528136785.shtml\n\n# express中使用ejs\n~~~\nvar express = require('express');//需要安装 express\nvar app = express();\n\napp.set(\"view engine\",\"ejs\");//模版引擎设置为 ejs\n~~~\n\n# 文件组织\n在express中使用ejs，文件组织遵循express。\n* views-------放置动态模版\n* public------放置静态网页\n* layouts-----放置布局文件\n\n# EJS成员函数：\n* Render(str,data,[option]):直接渲染字符串并生成html\n~~~\nstr：需要解析的字符串模板\ndata：数据\noption：配置选项\n~~~\n* Compile(str,[option]):编译字符串得到模板函数\n~~~\nstr：需要解析的字符串模板\noption：配置选项\n~~~\n\n# 基本语法\n1. <% code %>:无缓冲的条件语句元素\n2. <%= code %>:转义HTML，该code并且会打印出来\n3. <%- code %>:非转义的buffering，该code并且会打印出来\n4. <% include file %>:内嵌别的文件\n5. <% layout(file) -%>:指定布局文件\n6. <% script(file) -%>:包含js脚本文件\n7. <% stylesheet(file) -%>:包含css文件\n8. <% block(code, code) -%>:指定块内容 \n9. <%# %>:注释标签\n\n# 基本对象\n1. scripts:包含的脚本\n2. stylesheets:包含的css\n3. blocks:包含的块","source":"_posts/前端开发/ejs模版引擎基本使用.md","raw":"---\ntitle: ejs模版引擎基本使用\ntags:\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\nhttp://www.360doc.com/content/16/0115/10/597197_528136785.shtml\n\n# express中使用ejs\n~~~\nvar express = require('express');//需要安装 express\nvar app = express();\n\napp.set(\"view engine\",\"ejs\");//模版引擎设置为 ejs\n~~~\n\n# 文件组织\n在express中使用ejs，文件组织遵循express。\n* views-------放置动态模版\n* public------放置静态网页\n* layouts-----放置布局文件\n\n# EJS成员函数：\n* Render(str,data,[option]):直接渲染字符串并生成html\n~~~\nstr：需要解析的字符串模板\ndata：数据\noption：配置选项\n~~~\n* Compile(str,[option]):编译字符串得到模板函数\n~~~\nstr：需要解析的字符串模板\noption：配置选项\n~~~\n\n# 基本语法\n1. <% code %>:无缓冲的条件语句元素\n2. <%= code %>:转义HTML，该code并且会打印出来\n3. <%- code %>:非转义的buffering，该code并且会打印出来\n4. <% include file %>:内嵌别的文件\n5. <% layout(file) -%>:指定布局文件\n6. <% script(file) -%>:包含js脚本文件\n7. <% stylesheet(file) -%>:包含css文件\n8. <% block(code, code) -%>:指定块内容 \n9. <%# %>:注释标签\n\n# 基本对象\n1. scripts:包含的脚本\n2. stylesheets:包含的css\n3. blocks:包含的块","slug":"前端开发-ejs模版引擎基本使用","published":1,"updated":"2019-02-14T06:07:48.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudz8004p5b8hv0gcstxq","content":"<p><a href=\"http://www.360doc.com/content/16/0115/10/597197_528136785.shtml\" target=\"_blank\" rel=\"noopener\">http://www.360doc.com/content/16/0115/10/597197_528136785.shtml</a></p>\n<h1 id=\"express中使用ejs\"><a class=\"markdownIt-Anchor\" href=\"#express中使用ejs\"></a> express中使用ejs</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);//需要安装 express</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.set(&quot;view engine&quot;,&quot;ejs&quot;);//模版引擎设置为 ejs</span><br></pre></td></tr></table></figure>\n<h1 id=\"文件组织\"><a class=\"markdownIt-Anchor\" href=\"#文件组织\"></a> 文件组织</h1>\n<p>在express中使用ejs，文件组织遵循express。</p>\n<ul>\n<li>views-------放置动态模版</li>\n<li>public------放置静态网页</li>\n<li>layouts-----放置布局文件</li>\n</ul>\n<h1 id=\"ejs成员函数\"><a class=\"markdownIt-Anchor\" href=\"#ejs成员函数\"></a> EJS成员函数：</h1>\n<ul>\n<li>Render(str,data,[option]):直接渲染字符串并生成html</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str：需要解析的字符串模板</span><br><span class=\"line\">data：数据</span><br><span class=\"line\">option：配置选项</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Compile(str,[option]):编译字符串得到模板函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str：需要解析的字符串模板</span><br><span class=\"line\">option：配置选项</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本语法\"><a class=\"markdownIt-Anchor\" href=\"#基本语法\"></a> 基本语法</h1>\n<ol>\n<li>&lt;% code %&gt;:无缓冲的条件语句元素</li>\n<li>&lt;%= code %&gt;:转义HTML，该code并且会打印出来</li>\n<li>&lt;%- code %&gt;:非转义的buffering，该code并且会打印出来</li>\n<li>&lt;% include file %&gt;:内嵌别的文件</li>\n<li>&lt;% layout(file) -%&gt;:指定布局文件</li>\n<li>&lt;% script(file) -%&gt;:包含js脚本文件</li>\n<li>&lt;% stylesheet(file) -%&gt;:包含css文件</li>\n<li>&lt;% block(code, code) -%&gt;:指定块内容</li>\n<li>&lt;%# %&gt;:注释标签</li>\n</ol>\n<h1 id=\"基本对象\"><a class=\"markdownIt-Anchor\" href=\"#基本对象\"></a> 基本对象</h1>\n<ol>\n<li>scripts:包含的脚本</li>\n<li>stylesheets:包含的css</li>\n<li>blocks:包含的块</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.360doc.com/content/16/0115/10/597197_528136785.shtml\" target=\"_blank\" rel=\"noopener\">http://www.360doc.com/content/16/0115/10/597197_528136785.shtml</a></p>\n<h1 id=\"express中使用ejs\"><a class=\"markdownIt-Anchor\" href=\"#express中使用ejs\"></a> express中使用ejs</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);//需要安装 express</span><br><span class=\"line\">var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.set(&quot;view engine&quot;,&quot;ejs&quot;);//模版引擎设置为 ejs</span><br></pre></td></tr></table></figure>\n<h1 id=\"文件组织\"><a class=\"markdownIt-Anchor\" href=\"#文件组织\"></a> 文件组织</h1>\n<p>在express中使用ejs，文件组织遵循express。</p>\n<ul>\n<li>views-------放置动态模版</li>\n<li>public------放置静态网页</li>\n<li>layouts-----放置布局文件</li>\n</ul>\n<h1 id=\"ejs成员函数\"><a class=\"markdownIt-Anchor\" href=\"#ejs成员函数\"></a> EJS成员函数：</h1>\n<ul>\n<li>Render(str,data,[option]):直接渲染字符串并生成html</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str：需要解析的字符串模板</span><br><span class=\"line\">data：数据</span><br><span class=\"line\">option：配置选项</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Compile(str,[option]):编译字符串得到模板函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str：需要解析的字符串模板</span><br><span class=\"line\">option：配置选项</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本语法\"><a class=\"markdownIt-Anchor\" href=\"#基本语法\"></a> 基本语法</h1>\n<ol>\n<li>&lt;% code %&gt;:无缓冲的条件语句元素</li>\n<li>&lt;%= code %&gt;:转义HTML，该code并且会打印出来</li>\n<li>&lt;%- code %&gt;:非转义的buffering，该code并且会打印出来</li>\n<li>&lt;% include file %&gt;:内嵌别的文件</li>\n<li>&lt;% layout(file) -%&gt;:指定布局文件</li>\n<li>&lt;% script(file) -%&gt;:包含js脚本文件</li>\n<li>&lt;% stylesheet(file) -%&gt;:包含css文件</li>\n<li>&lt;% block(code, code) -%&gt;:指定块内容</li>\n<li>&lt;%# %&gt;:注释标签</li>\n</ol>\n<h1 id=\"基本对象\"><a class=\"markdownIt-Anchor\" href=\"#基本对象\"></a> 基本对象</h1>\n<ol>\n<li>scripts:包含的脚本</li>\n<li>stylesheets:包含的css</li>\n<li>blocks:包含的块</li>\n</ol>\n"},{"title":"TypeScript入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n~~~\nhttps://www.tslang.cn/\nhttp://www.typescriptlang.org/\n~~~\n\n# 简介\n微软出品，2012\n1. 编译型语言\n2. 强类型语言\n3. 真面向对象\n4. AMD方式\n\ncnpm install -g typescript\n\n\n扩展名：.ts／.tsx/.d.ts\n编译： tsc 1.ts //1.js\n\nnumber\\string\\boolean\\symbol\\void\\null\\undefined\\enum\\any\n\nany:变体变量\n\nvar a:any;\na=12;\na=\"abc\";\n\n\nvar a:any; 等同于 var a;//类型推测（隐式类型声明）\n\n冲突检测：编译器会自动排除掉无用的选项\n\n\n联合类型：\nvar a:number|string;\na=12;\na='abc';\na=false;//报错\n\n数组也有类型\n\n外部声明declare，window等都内部声明过了\ndeclare var 名字；\n\nfunction sum(a:number,b:number):number{\n    return  a+b;\n}\n\nfunction ajax(url:string,success:(res:string,code:number)=>void,error:(code:number)=>void){\n    \n}\n\n对象类型：ObjectType\nvar a:{x:number,y:number}\n可选声明：var a:{x:number,y:number,z?:number},调用或赋值的时候，z可有可无\n\n接口：约定、限制\ninterface Point{\n    x:number,\n    y:number,\n    z?:number\n}\n\n泛型：\n\nclass  Calc<T>{\n    a:T;\n    b:T;\n}\n\nvar obj=new Calc<number>();\nobj.a=12;\nobj.b='123';//报错\n\n\ntsconfig.json","source":"_posts/前端开发/TypeScript入门.md","raw":"---\ntitle: TypeScript入门\ntags:\n  - TypeScript \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n~~~\nhttps://www.tslang.cn/\nhttp://www.typescriptlang.org/\n~~~\n\n# 简介\n微软出品，2012\n1. 编译型语言\n2. 强类型语言\n3. 真面向对象\n4. AMD方式\n\ncnpm install -g typescript\n\n\n扩展名：.ts／.tsx/.d.ts\n编译： tsc 1.ts //1.js\n\nnumber\\string\\boolean\\symbol\\void\\null\\undefined\\enum\\any\n\nany:变体变量\n\nvar a:any;\na=12;\na=\"abc\";\n\n\nvar a:any; 等同于 var a;//类型推测（隐式类型声明）\n\n冲突检测：编译器会自动排除掉无用的选项\n\n\n联合类型：\nvar a:number|string;\na=12;\na='abc';\na=false;//报错\n\n数组也有类型\n\n外部声明declare，window等都内部声明过了\ndeclare var 名字；\n\nfunction sum(a:number,b:number):number{\n    return  a+b;\n}\n\nfunction ajax(url:string,success:(res:string,code:number)=>void,error:(code:number)=>void){\n    \n}\n\n对象类型：ObjectType\nvar a:{x:number,y:number}\n可选声明：var a:{x:number,y:number,z?:number},调用或赋值的时候，z可有可无\n\n接口：约定、限制\ninterface Point{\n    x:number,\n    y:number,\n    z?:number\n}\n\n泛型：\n\nclass  Calc<T>{\n    a:T;\n    b:T;\n}\n\nvar obj=new Calc<number>();\nobj.a=12;\nobj.b='123';//报错\n\n\ntsconfig.json","slug":"前端开发-TypeScript入门","published":1,"updated":"2019-02-14T06:22:45.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudza004t5b8hj8a5bd36","content":"<p>[toc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.tslang.cn/</span><br><span class=\"line\">http://www.typescriptlang.org/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>微软出品，2012</p>\n<ol>\n<li>编译型语言</li>\n<li>强类型语言</li>\n<li>真面向对象</li>\n<li>AMD方式</li>\n</ol>\n<p>cnpm install -g typescript</p>\n<p>扩展名：.ts／.tsx/.d.ts<br>\n编译： tsc 1.ts <a href=\"//1.js\">//1.js</a></p>\n<p>number\\string\\boolean\\symbol\\void\\null\\undefined\\enum\\any</p>\n<p>any:变体变量</p>\n<p>var a:any;<br>\na=12;<br>\na=“abc”;</p>\n<p>var a:any; 等同于 var a;//类型推测（隐式类型声明）</p>\n<p>冲突检测：编译器会自动排除掉无用的选项</p>\n<p>联合类型：<br>\nvar a:number|string;<br>\na=12;<br>\na=‘abc’;<br>\na=false;//报错</p>\n<p>数组也有类型</p>\n<p>外部声明declare，window等都内部声明过了<br>\ndeclare var 名字；</p>\n<p>function sum(a:number,b:number):number{<br>\nreturn  a+b;<br>\n}</p>\n<p>function ajax(url:string,success:(res:string,code:number)=&gt;void,error:(code:number)=&gt;void){</p>\n<p>}</p>\n<p>对象类型：ObjectType<br>\nvar a:{x:number,y:number}<br>\n可选声明：var a:{x:number,y:number,z?:number},调用或赋值的时候，z可有可无</p>\n<p>接口：约定、限制<br>\ninterface Point{<br>\nx:number,<br>\ny:number,<br>\nz?:number<br>\n}</p>\n<p>泛型：</p>\n<p>class  Calc<t>{<br>\na:T;<br>\nb:T;<br>\n}</t></p>\n<p>var obj=new Calc<number>();<br>\nobj.a=12;<br>\nobj.b=‘123’;//报错</number></p>\n<p>tsconfig.json</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.tslang.cn/</span><br><span class=\"line\">http://www.typescriptlang.org/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>微软出品，2012</p>\n<ol>\n<li>编译型语言</li>\n<li>强类型语言</li>\n<li>真面向对象</li>\n<li>AMD方式</li>\n</ol>\n<p>cnpm install -g typescript</p>\n<p>扩展名：.ts／.tsx/.d.ts<br>\n编译： tsc 1.ts <a href=\"//1.js\">//1.js</a></p>\n<p>number\\string\\boolean\\symbol\\void\\null\\undefined\\enum\\any</p>\n<p>any:变体变量</p>\n<p>var a:any;<br>\na=12;<br>\na=“abc”;</p>\n<p>var a:any; 等同于 var a;//类型推测（隐式类型声明）</p>\n<p>冲突检测：编译器会自动排除掉无用的选项</p>\n<p>联合类型：<br>\nvar a:number|string;<br>\na=12;<br>\na=‘abc’;<br>\na=false;//报错</p>\n<p>数组也有类型</p>\n<p>外部声明declare，window等都内部声明过了<br>\ndeclare var 名字；</p>\n<p>function sum(a:number,b:number):number{<br>\nreturn  a+b;<br>\n}</p>\n<p>function ajax(url:string,success:(res:string,code:number)=&gt;void,error:(code:number)=&gt;void){</p>\n<p>}</p>\n<p>对象类型：ObjectType<br>\nvar a:{x:number,y:number}<br>\n可选声明：var a:{x:number,y:number,z?:number},调用或赋值的时候，z可有可无</p>\n<p>接口：约定、限制<br>\ninterface Point{<br>\nx:number,<br>\ny:number,<br>\nz?:number<br>\n}</p>\n<p>泛型：</p>\n<p>class  Calc<t>{<br>\na:T;<br>\nb:T;<br>\n}</t></p>\n<p>var obj=new Calc<number>();<br>\nobj.a=12;<br>\nobj.b=‘123’;//报错</number></p>\n<p>tsconfig.json</p>\n"},{"title":"js测试分类","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\nhttp://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html\n\n在实际的项目中，我们可能随时面对各种不同的需求，它的各个方面的要素决定了我们所采用的开发模式。\n比如，它的复杂度如何？所有的需求是否足够清晰？开发人员对相关的业务是否足够了解？项目的工期是否合理？种种问题，不一而足。这也决定了我们可能面对不同的需求可能需要采用不同的开发模式。下面大概说几种：\n1. TDD\nTDD指的是Test Drive Development，很明显的意思是测试驱动开发，也就是说我们可以从测试的角度来检验整个项目。大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口，运行单元测试代码，循环此过程，直到整个单元测试都通过。这一点和敏捷开发有类似之处。\n\nTDD的好处自然不用多说，它能让你减少程序逻辑方面的错误，尽可能的减少项目中的bug，开始接触编程的时候我们大都有过这样的体验，可能你觉得完成得很完美，自我感觉良好，但是实际测试或者应用的时候才发现里面可能存在一堆bug，或者存在设计问题，或者更严重的逻辑问题，而TDD正好可以帮助我们尽量减少类似事件的发生。而且现在大行其道的一些模式对TDD的支持都非常不错，比如MVC和MVP等。\n\n但是并不是所有的项目都适合TDD这种模式的，我觉得必须具备以下几个条件：\n首先，项目的需求必须足够清晰，而且程序员对整个需求有足够的了解，如果这个条件不满足，那么执行的过程中难免失控。当然，要达到这个目标也是需要做一定功课的，这要求我们前期的需求分析以及HLD和LLD都要做得足够的细致和完善。\n\n其次，取决于项目的复杂度和依赖性，对于一个业务模型及其复杂、内部模块之间的相互依赖性非常强的项目，采用TDD反而会得不尝失，这会导致程序员在拆分接口和写测试代码的时候工作量非常大。另外，由于模块之间的依赖性太强，我们在写测试代码的时候可能不采取一些桥接模式来实现，这样势必加大了程序员的工作量。\n\n2. BDD\nBDD指的是Behavior Drive Development，也就是行为驱动开发。这里的B并非指的是Business，实际上BDD可以看作是对TDD的一种补充，当然你也可以把它看作TDD的一个分支。因为在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。因为测试优先的概念并不是每个人都能接受的，可能有人觉得系统太复杂而难以测试，有人认为不存在的东西无法测试。所以，我们在这里试图转换一种观念，那便是考虑它的行为，也就是说它应该如何运行，然后抽象出能达成共识的规范。如果你用过JBehave之类的BDD框架，你将会更好的理解其中具体的流程。这里我推荐一篇具体阐述的文章。亲身体验行为驱动开发。\n另外，关于TDD和BDD之间的关系，还可以参考这篇文章: 虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发\n\n3. DDD\nDDD指的是Domain Drive Design，也就是领域驱动开发。这是一种非常好的思想，在我们刚开始学习程序，甚至刚开始学习三层架构的时候，我们曾经面临过很多疑惑，比如如何来实现我们的数据层？后来我们开始学习MVC，MVP等架构，如何设计Model层又成了我们的新问题。我们见过太多这种情况，Model变成了单纯的数据容器，也就是我们经常说的贫血模式。DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现，因此不可避免的以贫血模式为基础而存在。但是它最大的特别是将分析和设计结合起来，不再使他们处于分裂的状态，这对于我们正确完整的实现客户的需求，以及建立一个具有业务伸缩性的模型，是有很大帮助的。\n","source":"_posts/前端开发/js测试分类.md","raw":"---\ntitle: js测试分类\ntags:\n  - Express\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\nhttp://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html\n\n在实际的项目中，我们可能随时面对各种不同的需求，它的各个方面的要素决定了我们所采用的开发模式。\n比如，它的复杂度如何？所有的需求是否足够清晰？开发人员对相关的业务是否足够了解？项目的工期是否合理？种种问题，不一而足。这也决定了我们可能面对不同的需求可能需要采用不同的开发模式。下面大概说几种：\n1. TDD\nTDD指的是Test Drive Development，很明显的意思是测试驱动开发，也就是说我们可以从测试的角度来检验整个项目。大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口，运行单元测试代码，循环此过程，直到整个单元测试都通过。这一点和敏捷开发有类似之处。\n\nTDD的好处自然不用多说，它能让你减少程序逻辑方面的错误，尽可能的减少项目中的bug，开始接触编程的时候我们大都有过这样的体验，可能你觉得完成得很完美，自我感觉良好，但是实际测试或者应用的时候才发现里面可能存在一堆bug，或者存在设计问题，或者更严重的逻辑问题，而TDD正好可以帮助我们尽量减少类似事件的发生。而且现在大行其道的一些模式对TDD的支持都非常不错，比如MVC和MVP等。\n\n但是并不是所有的项目都适合TDD这种模式的，我觉得必须具备以下几个条件：\n首先，项目的需求必须足够清晰，而且程序员对整个需求有足够的了解，如果这个条件不满足，那么执行的过程中难免失控。当然，要达到这个目标也是需要做一定功课的，这要求我们前期的需求分析以及HLD和LLD都要做得足够的细致和完善。\n\n其次，取决于项目的复杂度和依赖性，对于一个业务模型及其复杂、内部模块之间的相互依赖性非常强的项目，采用TDD反而会得不尝失，这会导致程序员在拆分接口和写测试代码的时候工作量非常大。另外，由于模块之间的依赖性太强，我们在写测试代码的时候可能不采取一些桥接模式来实现，这样势必加大了程序员的工作量。\n\n2. BDD\nBDD指的是Behavior Drive Development，也就是行为驱动开发。这里的B并非指的是Business，实际上BDD可以看作是对TDD的一种补充，当然你也可以把它看作TDD的一个分支。因为在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。因为测试优先的概念并不是每个人都能接受的，可能有人觉得系统太复杂而难以测试，有人认为不存在的东西无法测试。所以，我们在这里试图转换一种观念，那便是考虑它的行为，也就是说它应该如何运行，然后抽象出能达成共识的规范。如果你用过JBehave之类的BDD框架，你将会更好的理解其中具体的流程。这里我推荐一篇具体阐述的文章。亲身体验行为驱动开发。\n另外，关于TDD和BDD之间的关系，还可以参考这篇文章: 虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发\n\n3. DDD\nDDD指的是Domain Drive Design，也就是领域驱动开发。这是一种非常好的思想，在我们刚开始学习程序，甚至刚开始学习三层架构的时候，我们曾经面临过很多疑惑，比如如何来实现我们的数据层？后来我们开始学习MVC，MVP等架构，如何设计Model层又成了我们的新问题。我们见过太多这种情况，Model变成了单纯的数据容器，也就是我们经常说的贫血模式。DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现，因此不可避免的以贫血模式为基础而存在。但是它最大的特别是将分析和设计结合起来，不再使他们处于分裂的状态，这对于我们正确完整的实现客户的需求，以及建立一个具有业务伸缩性的模型，是有很大帮助的。\n","slug":"前端开发-js测试分类","published":1,"updated":"2019-02-14T06:17:29.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzc004w5b8h5hvfedez","content":"<p><a href=\"http://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html</a></p>\n<p>在实际的项目中，我们可能随时面对各种不同的需求，它的各个方面的要素决定了我们所采用的开发模式。<br>\n比如，它的复杂度如何？所有的需求是否足够清晰？开发人员对相关的业务是否足够了解？项目的工期是否合理？种种问题，不一而足。这也决定了我们可能面对不同的需求可能需要采用不同的开发模式。下面大概说几种：</p>\n<ol>\n<li>TDD<br>\nTDD指的是Test Drive Development，很明显的意思是测试驱动开发，也就是说我们可以从测试的角度来检验整个项目。大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口，运行单元测试代码，循环此过程，直到整个单元测试都通过。这一点和敏捷开发有类似之处。</li>\n</ol>\n<p>TDD的好处自然不用多说，它能让你减少程序逻辑方面的错误，尽可能的减少项目中的bug，开始接触编程的时候我们大都有过这样的体验，可能你觉得完成得很完美，自我感觉良好，但是实际测试或者应用的时候才发现里面可能存在一堆bug，或者存在设计问题，或者更严重的逻辑问题，而TDD正好可以帮助我们尽量减少类似事件的发生。而且现在大行其道的一些模式对TDD的支持都非常不错，比如MVC和MVP等。</p>\n<p>但是并不是所有的项目都适合TDD这种模式的，我觉得必须具备以下几个条件：<br>\n首先，项目的需求必须足够清晰，而且程序员对整个需求有足够的了解，如果这个条件不满足，那么执行的过程中难免失控。当然，要达到这个目标也是需要做一定功课的，这要求我们前期的需求分析以及HLD和LLD都要做得足够的细致和完善。</p>\n<p>其次，取决于项目的复杂度和依赖性，对于一个业务模型及其复杂、内部模块之间的相互依赖性非常强的项目，采用TDD反而会得不尝失，这会导致程序员在拆分接口和写测试代码的时候工作量非常大。另外，由于模块之间的依赖性太强，我们在写测试代码的时候可能不采取一些桥接模式来实现，这样势必加大了程序员的工作量。</p>\n<ol start=\"2\">\n<li>\n<p>BDD<br>\nBDD指的是Behavior Drive Development，也就是行为驱动开发。这里的B并非指的是Business，实际上BDD可以看作是对TDD的一种补充，当然你也可以把它看作TDD的一个分支。因为在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。因为测试优先的概念并不是每个人都能接受的，可能有人觉得系统太复杂而难以测试，有人认为不存在的东西无法测试。所以，我们在这里试图转换一种观念，那便是考虑它的行为，也就是说它应该如何运行，然后抽象出能达成共识的规范。如果你用过JBehave之类的BDD框架，你将会更好的理解其中具体的流程。这里我推荐一篇具体阐述的文章。亲身体验行为驱动开发。<br>\n另外，关于TDD和BDD之间的关系，还可以参考这篇文章: 虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发</p>\n</li>\n<li>\n<p>DDD<br>\nDDD指的是Domain Drive Design，也就是领域驱动开发。这是一种非常好的思想，在我们刚开始学习程序，甚至刚开始学习三层架构的时候，我们曾经面临过很多疑惑，比如如何来实现我们的数据层？后来我们开始学习MVC，MVP等架构，如何设计Model层又成了我们的新问题。我们见过太多这种情况，Model变成了单纯的数据容器，也就是我们经常说的贫血模式。DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现，因此不可避免的以贫血模式为基础而存在。但是它最大的特别是将分析和设计结合起来，不再使他们处于分裂的状态，这对于我们正确完整的实现客户的需求，以及建立一个具有业务伸缩性的模型，是有很大帮助的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html</a></p>\n<p>在实际的项目中，我们可能随时面对各种不同的需求，它的各个方面的要素决定了我们所采用的开发模式。<br>\n比如，它的复杂度如何？所有的需求是否足够清晰？开发人员对相关的业务是否足够了解？项目的工期是否合理？种种问题，不一而足。这也决定了我们可能面对不同的需求可能需要采用不同的开发模式。下面大概说几种：</p>\n<ol>\n<li>TDD<br>\nTDD指的是Test Drive Development，很明显的意思是测试驱动开发，也就是说我们可以从测试的角度来检验整个项目。大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口，运行单元测试代码，循环此过程，直到整个单元测试都通过。这一点和敏捷开发有类似之处。</li>\n</ol>\n<p>TDD的好处自然不用多说，它能让你减少程序逻辑方面的错误，尽可能的减少项目中的bug，开始接触编程的时候我们大都有过这样的体验，可能你觉得完成得很完美，自我感觉良好，但是实际测试或者应用的时候才发现里面可能存在一堆bug，或者存在设计问题，或者更严重的逻辑问题，而TDD正好可以帮助我们尽量减少类似事件的发生。而且现在大行其道的一些模式对TDD的支持都非常不错，比如MVC和MVP等。</p>\n<p>但是并不是所有的项目都适合TDD这种模式的，我觉得必须具备以下几个条件：<br>\n首先，项目的需求必须足够清晰，而且程序员对整个需求有足够的了解，如果这个条件不满足，那么执行的过程中难免失控。当然，要达到这个目标也是需要做一定功课的，这要求我们前期的需求分析以及HLD和LLD都要做得足够的细致和完善。</p>\n<p>其次，取决于项目的复杂度和依赖性，对于一个业务模型及其复杂、内部模块之间的相互依赖性非常强的项目，采用TDD反而会得不尝失，这会导致程序员在拆分接口和写测试代码的时候工作量非常大。另外，由于模块之间的依赖性太强，我们在写测试代码的时候可能不采取一些桥接模式来实现，这样势必加大了程序员的工作量。</p>\n<ol start=\"2\">\n<li>\n<p>BDD<br>\nBDD指的是Behavior Drive Development，也就是行为驱动开发。这里的B并非指的是Business，实际上BDD可以看作是对TDD的一种补充，当然你也可以把它看作TDD的一个分支。因为在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。因为测试优先的概念并不是每个人都能接受的，可能有人觉得系统太复杂而难以测试，有人认为不存在的东西无法测试。所以，我们在这里试图转换一种观念，那便是考虑它的行为，也就是说它应该如何运行，然后抽象出能达成共识的规范。如果你用过JBehave之类的BDD框架，你将会更好的理解其中具体的流程。这里我推荐一篇具体阐述的文章。亲身体验行为驱动开发。<br>\n另外，关于TDD和BDD之间的关系，还可以参考这篇文章: 虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发</p>\n</li>\n<li>\n<p>DDD<br>\nDDD指的是Domain Drive Design，也就是领域驱动开发。这是一种非常好的思想，在我们刚开始学习程序，甚至刚开始学习三层架构的时候，我们曾经面临过很多疑惑，比如如何来实现我们的数据层？后来我们开始学习MVC，MVP等架构，如何设计Model层又成了我们的新问题。我们见过太多这种情况，Model变成了单纯的数据容器，也就是我们经常说的贫血模式。DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现，因此不可避免的以贫血模式为基础而存在。但是它最大的特别是将分析和设计结合起来，不再使他们处于分裂的状态，这对于我们正确完整的实现客户的需求，以及建立一个具有业务伸缩性的模型，是有很大帮助的。</p>\n</li>\n</ol>\n"},{"title":"pug模版引擎基本使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n# 安装\n1. npm install -g pug\n2. npm install -g pug-cli\n3. pug index.pug\n \n# webstorm添加pug文件自动编译\n1. WebStorm下，File->settings，在左上角搜索watcher，选择Tools->fileWatcher\n2. 添加一个watcher，选择类型为Jade（pug支持安装了，但是不知道怎样使用，发现全部用Jade也能使用）\n3. 在Program下，选择pug的安装路径，如我的为：/usr/local/bin/pug,在Arguments的默认值前面添加-P可以让编译后的文件格式化显示 \n4. 编写pug文件，编写后，会自动生成相应的编译后文件\n\n# 在 Express 中调用 jade 模板引擎\n~~~\napp.set('view engine', 'jade'); // 设置模板引擎\napp.set('views', __dirname);  // 设置模板相对路径(相对当前目录)\n\napp.get('/', function(req, res) {\n    res.render('test'); // 调用当前路径下的 test.jade 模板\n})\n~~~\n\n# 基本语法及支持\n## 类名和ID名\n* a.class名称,如：a.button,翻译为：<a class=\"button\"></a>\n* a#id名称，如：a#button，翻译为：<a class=\"button\"></a>\n## 属性\n属性可以使用()包裹起来,属性值之间用逗号隔开，如：a(href=\"google.com\",title=\"google\")\n## 文本内容\n在html标签后空格直接书写\n## 多行文本内容\n~~~\np.\n    asdfasdfa\n    asdfasd \n~~~\n或者\n~~~\np\n    | dfas <strong>hey</strong>\n        strong hey man\n    | dfas\n~~~\n## 注释\n1. 单行注释\n* 普通方式：// just some paragraphs，翻译为：<!-- just some paragraphs-->\n* 非缓冲注释，不会被编译到HTML：//- will not output within markup\n2. 多行注释\n~~~\n//\n    As much text as you want\n    can go here.\n~~~\n## 变量\njade 的变量调用有 3 种方式:\n1. #{表达式}  //此方式可以自由的嵌入各个地方\n2. =表达式    //返回的是表达式的值,会编码字符串\n3. !=表达式   //返回的是表达式的值,不会编码字符串\n\n注意：符号 - 开头在 jade 中属于服务端执行的代码\n~~~\n- console.log('hello'); // 这段代码在服务端执行\n- var s = 'hello world' // 在服务端空间中定义变量\np #{s}          //<p>hello world</p>\np= s            //<p>hello world</p>\n~~~\n\n使用：\n1. 直接在 jade 模板中定义变量\n2. 在 express 中调用 res.render 方法的时候将变量一起传递进模板的空间中,调用模板的时候，在 jade 模板中也可以如上方那样直接调用 s 这个变量\n~~~\nres.render(test, {\n    s: 'hello world'\n});\n~~~\n\n## 流程代码\n### if判断\n方式1:\n~~~\n- var user = { description: '我喜欢猫' }\n- if (user.description)\n    h2 描述\n    p.description= user.description\n- else\n    h1 描述\n    p.description 用户无描述\n~~~\n方式2:\n~~~\n- var user = { description: '我喜欢猫' }\n#user\n  if user.description\n    h2 描述\n    p.description= user.description\n  else\n    h1 描述\n    p.description 用户无描述\n~~~\n方式1、方式2执行结果：\n~~~\n<div id=\"user\">\n  <h2>描述</h2>\n  <p class=\"description\">我喜欢猫</p>\n</div\n~~~\n方式3:\n使用 Unless 类似于 if 后的表达式加上了 ! 取反;这个 unless 是 jade 提供的关键字，不是运行的 js 代码\n~~~\n- var user = { name: 'Alan', isVip: false }\nunless user.isVip\n  p 亲爱的 #{user.name} 您并不是 VIP\n~~~\n\n### 循环\n1. for 循环\n~~~\n- var array = [1,2,3]\nul\n  - for (var i = 0; i < array.length; ++i) {\n    li hello #{array[i]}\n  - }\n~~~\n2. each:in后的循环目标支持数组、json\n~~~\nul\n  each val, index in ['西瓜', '苹果', '梨子']\n    li= index + ': ' + val\n~~~\n\n### Case选择\ncase 不支持case 穿透，如果 case 穿透的话会报错\n~~~\n- var friends = 1\ncase friends\n  when 0: p you have no friends\n  when 1: p you have a friend\n  default: p you have #{friends} friends\n~~~\n或\n~~~\n- var friends = 10\ncase friends\n  when 0\n    p you have no friends\n  when 1\n    p you have a friend\n  default\n    p you have #{friends} friends\n\n~~~\n\n## 模板中调用Markdown语言\n~~~\n:markdown\n  # Markdown 标题\n  \n//翻译后：\n<h1>Markdown 标题</h1>\n~~~\n\n## 可重用的 jade 块 (Mixins)\n~~~\nmixin article(title)\n  .article\n    .article-wrapper\n      h1= title\n      //- block 为 jade 关键字代表外部传入的块\n      if block\n        block\n      else\n        p 该文章没有内容\n        \n+article('Hello world')\n+article('Hello Jade') \n~~~\n结果：\n~~~\n<div class=\"article\">\n  <div class=\"article-wrapper\">\n    <h1>Hello world</h1>\n    <p>该文章没有内容</p>\n  </div>\n</div>\n<div class=\"article\">\n  <div class=\"article-wrapper\">\n    <h1>Hello Jade</h1> \n  </div>\n</div>\n~~~\n\nMixins 同时也可以从外部获取属性:\n~~~\nmixin link(href, name)\n  a(class!=attributes.class, href=href)= name\n   \n+link('/foo', 'foo')(class=\"btn\")\n\n//编译后\n<a href=\"/foo\" class=\"btn\">foo</a>\n~~~\n\n## 模板包含 (Includes)\n可以使用 Includes 在模板中包含其他模板的内容\n\n## 模板继承 (Extends)\nlayout.jade\n~~~\ndoctype html\nhtml\n  head\n    title 我的网站\n    meta(http-equiv=\"Content-Type\",content=\"text/html; charset=utf-8\")\n    link(type=\"text/css\",rel=\"stylesheet\",href=\"/css/style.css\")\n    script(src=\"/js/lib/jquery-1.8.0.min.js\",type=\"text/javascript\")\n  body\n    block content\n~~~\narticle.jade\n~~~\n//- extends 拓展调用 layout.jade\nextends ../layout\nblock content\n  h1 文章列表\n  p 习近平忆贾大山 李克强:将启动新核电项目 \n~~~\nres.render(‘article’) 的结果：\n~~~\n<html>\n  <head>\n    <title>我的网站</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"></head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/style.css\"></head>\n    <script src=\"/js/lib/jquery-1.8.0.min.js\" type=\"text/javascript\"></script>\n  </head>\n  <body>\n    <h1>文章列表</h1>\n    <p>习近平忆贾大山 李克强:将启动新核电项目</p> \n  </body>\n</html>\n~~~","source":"_posts/前端开发/pug模版引擎基本使用.md","raw":"---\ntitle: pug模版引擎基本使用\ntags:\n  - Angular \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n# 安装\n1. npm install -g pug\n2. npm install -g pug-cli\n3. pug index.pug\n \n# webstorm添加pug文件自动编译\n1. WebStorm下，File->settings，在左上角搜索watcher，选择Tools->fileWatcher\n2. 添加一个watcher，选择类型为Jade（pug支持安装了，但是不知道怎样使用，发现全部用Jade也能使用）\n3. 在Program下，选择pug的安装路径，如我的为：/usr/local/bin/pug,在Arguments的默认值前面添加-P可以让编译后的文件格式化显示 \n4. 编写pug文件，编写后，会自动生成相应的编译后文件\n\n# 在 Express 中调用 jade 模板引擎\n~~~\napp.set('view engine', 'jade'); // 设置模板引擎\napp.set('views', __dirname);  // 设置模板相对路径(相对当前目录)\n\napp.get('/', function(req, res) {\n    res.render('test'); // 调用当前路径下的 test.jade 模板\n})\n~~~\n\n# 基本语法及支持\n## 类名和ID名\n* a.class名称,如：a.button,翻译为：<a class=\"button\"></a>\n* a#id名称，如：a#button，翻译为：<a class=\"button\"></a>\n## 属性\n属性可以使用()包裹起来,属性值之间用逗号隔开，如：a(href=\"google.com\",title=\"google\")\n## 文本内容\n在html标签后空格直接书写\n## 多行文本内容\n~~~\np.\n    asdfasdfa\n    asdfasd \n~~~\n或者\n~~~\np\n    | dfas <strong>hey</strong>\n        strong hey man\n    | dfas\n~~~\n## 注释\n1. 单行注释\n* 普通方式：// just some paragraphs，翻译为：<!-- just some paragraphs-->\n* 非缓冲注释，不会被编译到HTML：//- will not output within markup\n2. 多行注释\n~~~\n//\n    As much text as you want\n    can go here.\n~~~\n## 变量\njade 的变量调用有 3 种方式:\n1. #{表达式}  //此方式可以自由的嵌入各个地方\n2. =表达式    //返回的是表达式的值,会编码字符串\n3. !=表达式   //返回的是表达式的值,不会编码字符串\n\n注意：符号 - 开头在 jade 中属于服务端执行的代码\n~~~\n- console.log('hello'); // 这段代码在服务端执行\n- var s = 'hello world' // 在服务端空间中定义变量\np #{s}          //<p>hello world</p>\np= s            //<p>hello world</p>\n~~~\n\n使用：\n1. 直接在 jade 模板中定义变量\n2. 在 express 中调用 res.render 方法的时候将变量一起传递进模板的空间中,调用模板的时候，在 jade 模板中也可以如上方那样直接调用 s 这个变量\n~~~\nres.render(test, {\n    s: 'hello world'\n});\n~~~\n\n## 流程代码\n### if判断\n方式1:\n~~~\n- var user = { description: '我喜欢猫' }\n- if (user.description)\n    h2 描述\n    p.description= user.description\n- else\n    h1 描述\n    p.description 用户无描述\n~~~\n方式2:\n~~~\n- var user = { description: '我喜欢猫' }\n#user\n  if user.description\n    h2 描述\n    p.description= user.description\n  else\n    h1 描述\n    p.description 用户无描述\n~~~\n方式1、方式2执行结果：\n~~~\n<div id=\"user\">\n  <h2>描述</h2>\n  <p class=\"description\">我喜欢猫</p>\n</div\n~~~\n方式3:\n使用 Unless 类似于 if 后的表达式加上了 ! 取反;这个 unless 是 jade 提供的关键字，不是运行的 js 代码\n~~~\n- var user = { name: 'Alan', isVip: false }\nunless user.isVip\n  p 亲爱的 #{user.name} 您并不是 VIP\n~~~\n\n### 循环\n1. for 循环\n~~~\n- var array = [1,2,3]\nul\n  - for (var i = 0; i < array.length; ++i) {\n    li hello #{array[i]}\n  - }\n~~~\n2. each:in后的循环目标支持数组、json\n~~~\nul\n  each val, index in ['西瓜', '苹果', '梨子']\n    li= index + ': ' + val\n~~~\n\n### Case选择\ncase 不支持case 穿透，如果 case 穿透的话会报错\n~~~\n- var friends = 1\ncase friends\n  when 0: p you have no friends\n  when 1: p you have a friend\n  default: p you have #{friends} friends\n~~~\n或\n~~~\n- var friends = 10\ncase friends\n  when 0\n    p you have no friends\n  when 1\n    p you have a friend\n  default\n    p you have #{friends} friends\n\n~~~\n\n## 模板中调用Markdown语言\n~~~\n:markdown\n  # Markdown 标题\n  \n//翻译后：\n<h1>Markdown 标题</h1>\n~~~\n\n## 可重用的 jade 块 (Mixins)\n~~~\nmixin article(title)\n  .article\n    .article-wrapper\n      h1= title\n      //- block 为 jade 关键字代表外部传入的块\n      if block\n        block\n      else\n        p 该文章没有内容\n        \n+article('Hello world')\n+article('Hello Jade') \n~~~\n结果：\n~~~\n<div class=\"article\">\n  <div class=\"article-wrapper\">\n    <h1>Hello world</h1>\n    <p>该文章没有内容</p>\n  </div>\n</div>\n<div class=\"article\">\n  <div class=\"article-wrapper\">\n    <h1>Hello Jade</h1> \n  </div>\n</div>\n~~~\n\nMixins 同时也可以从外部获取属性:\n~~~\nmixin link(href, name)\n  a(class!=attributes.class, href=href)= name\n   \n+link('/foo', 'foo')(class=\"btn\")\n\n//编译后\n<a href=\"/foo\" class=\"btn\">foo</a>\n~~~\n\n## 模板包含 (Includes)\n可以使用 Includes 在模板中包含其他模板的内容\n\n## 模板继承 (Extends)\nlayout.jade\n~~~\ndoctype html\nhtml\n  head\n    title 我的网站\n    meta(http-equiv=\"Content-Type\",content=\"text/html; charset=utf-8\")\n    link(type=\"text/css\",rel=\"stylesheet\",href=\"/css/style.css\")\n    script(src=\"/js/lib/jquery-1.8.0.min.js\",type=\"text/javascript\")\n  body\n    block content\n~~~\narticle.jade\n~~~\n//- extends 拓展调用 layout.jade\nextends ../layout\nblock content\n  h1 文章列表\n  p 习近平忆贾大山 李克强:将启动新核电项目 \n~~~\nres.render(‘article’) 的结果：\n~~~\n<html>\n  <head>\n    <title>我的网站</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"></head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/style.css\"></head>\n    <script src=\"/js/lib/jquery-1.8.0.min.js\" type=\"text/javascript\"></script>\n  </head>\n  <body>\n    <h1>文章列表</h1>\n    <p>习近平忆贾大山 李克强:将启动新核电项目</p> \n  </body>\n</html>\n~~~","slug":"前端开发-pug模版引擎基本使用","published":1,"updated":"2019-02-14T06:06:55.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzd004z5b8hvq54y5x9","content":"<p>[toc]</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<ol>\n<li>npm install -g pug</li>\n<li>npm install -g pug-cli</li>\n<li>pug index.pug</li>\n</ol>\n<h1 id=\"webstorm添加pug文件自动编译\"><a class=\"markdownIt-Anchor\" href=\"#webstorm添加pug文件自动编译\"></a> webstorm添加pug文件自动编译</h1>\n<ol>\n<li>WebStorm下，File-&gt;settings，在左上角搜索watcher，选择Tools-&gt;fileWatcher</li>\n<li>添加一个watcher，选择类型为Jade（pug支持安装了，但是不知道怎样使用，发现全部用Jade也能使用）</li>\n<li>在Program下，选择pug的安装路径，如我的为：/usr/local/bin/pug,在Arguments的默认值前面添加-P可以让编译后的文件格式化显示</li>\n<li>编写pug文件，编写后，会自动生成相应的编译后文件</li>\n</ol>\n<h1 id=\"在-express-中调用-jade-模板引擎\"><a class=\"markdownIt-Anchor\" href=\"#在-express-中调用-jade-模板引擎\"></a> 在 Express 中调用 jade 模板引擎</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.set(&apos;view engine&apos;, &apos;jade&apos;); // 设置模板引擎</span><br><span class=\"line\">app.set(&apos;views&apos;, __dirname);  // 设置模板相对路径(相对当前目录)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res) &#123;</span><br><span class=\"line\">    res.render(&apos;test&apos;); // 调用当前路径下的 test.jade 模板</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本语法及支持\"><a class=\"markdownIt-Anchor\" href=\"#基本语法及支持\"></a> 基本语法及支持</h1>\n<h2 id=\"类名和id名\"><a class=\"markdownIt-Anchor\" href=\"#类名和id名\"></a> 类名和ID名</h2>\n<ul>\n<li>a.class名称,如：a.button,翻译为：<a class=\"button\"></a></li>\n<li>a#id名称，如：a#button，翻译为：<a class=\"button\"></a></li>\n</ul>\n<h2 id=\"属性\"><a class=\"markdownIt-Anchor\" href=\"#属性\"></a> 属性</h2>\n<p>属性可以使用()包裹起来,属性值之间用逗号隔开，如：a(href=“<a href=\"http://google.com\" target=\"_blank\" rel=\"noopener\">google.com</a>”,title=“google”)</p>\n<h2 id=\"文本内容\"><a class=\"markdownIt-Anchor\" href=\"#文本内容\"></a> 文本内容</h2>\n<p>在html标签后空格直接书写</p>\n<h2 id=\"多行文本内容\"><a class=\"markdownIt-Anchor\" href=\"#多行文本内容\"></a> 多行文本内容</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.</span><br><span class=\"line\">    asdfasdfa</span><br><span class=\"line\">    asdfasd</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p</span><br><span class=\"line\">    | dfas &lt;strong&gt;hey&lt;/strong&gt;</span><br><span class=\"line\">        strong hey man</span><br><span class=\"line\">    | dfas</span><br></pre></td></tr></table></figure>\n<h2 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\"></a> 注释</h2>\n<ol>\n<li>单行注释</li>\n</ol>\n<ul>\n<li>普通方式：// just some paragraphs，翻译为：<!-- just some paragraphs--></li>\n<li>非缓冲注释，不会被编译到HTML：//- will not output within markup</li>\n</ul>\n<ol start=\"2\">\n<li>多行注释</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">    As much text as you want</span><br><span class=\"line\">    can go here.</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a class=\"markdownIt-Anchor\" href=\"#变量\"></a> 变量</h2>\n<p>jade 的变量调用有 3 种方式:</p>\n<ol>\n<li>#{表达式}  //此方式可以自由的嵌入各个地方</li>\n<li>=表达式    //返回的是表达式的值,会编码字符串</li>\n<li>!=表达式   //返回的是表达式的值,不会编码字符串</li>\n</ol>\n<p>注意：符号 - 开头在 jade 中属于服务端执行的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- console.log(&apos;hello&apos;); // 这段代码在服务端执行</span><br><span class=\"line\">- var s = &apos;hello world&apos; // 在服务端空间中定义变量</span><br><span class=\"line\">p #&#123;s&#125;          //&lt;p&gt;hello world&lt;/p&gt;</span><br><span class=\"line\">p= s            //&lt;p&gt;hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<ol>\n<li>直接在 jade 模板中定义变量</li>\n<li>在 express 中调用 res.render 方法的时候将变量一起传递进模板的空间中,调用模板的时候，在 jade 模板中也可以如上方那样直接调用 s 这个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.render(test, &#123;</span><br><span class=\"line\">    s: &apos;hello world&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"流程代码\"><a class=\"markdownIt-Anchor\" href=\"#流程代码\"></a> 流程代码</h2>\n<h3 id=\"if判断\"><a class=\"markdownIt-Anchor\" href=\"#if判断\"></a> if判断</h3>\n<p>方式1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var user = &#123; description: &apos;我喜欢猫&apos; &#125;</span><br><span class=\"line\">- if (user.description)</span><br><span class=\"line\">    h2 描述</span><br><span class=\"line\">    p.description= user.description</span><br><span class=\"line\">- else</span><br><span class=\"line\">    h1 描述</span><br><span class=\"line\">    p.description 用户无描述</span><br></pre></td></tr></table></figure>\n<p>方式2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var user = &#123; description: &apos;我喜欢猫&apos; &#125;</span><br><span class=\"line\">#user</span><br><span class=\"line\">  if user.description</span><br><span class=\"line\">    h2 描述</span><br><span class=\"line\">    p.description= user.description</span><br><span class=\"line\">  else</span><br><span class=\"line\">    h1 描述</span><br><span class=\"line\">    p.description 用户无描述</span><br></pre></td></tr></table></figure>\n<p>方式1、方式2执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;user&quot;&gt;</span><br><span class=\"line\">  &lt;h2&gt;描述&lt;/h2&gt;</span><br><span class=\"line\">  &lt;p class=&quot;description&quot;&gt;我喜欢猫&lt;/p&gt;</span><br><span class=\"line\">&lt;/div</span><br></pre></td></tr></table></figure>\n<p>方式3:<br>\n使用 Unless 类似于 if 后的表达式加上了 ! 取反;这个 unless 是 jade 提供的关键字，不是运行的 js 代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var user = &#123; name: &apos;Alan&apos;, isVip: false &#125;</span><br><span class=\"line\">unless user.isVip</span><br><span class=\"line\">  p 亲爱的 #&#123;user.name&#125; 您并不是 VIP</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h3>\n<ol>\n<li>for 循环</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var array = [1,2,3]</span><br><span class=\"line\">ul</span><br><span class=\"line\">  - for (var i = 0; i &lt; array.length; ++i) &#123;</span><br><span class=\"line\">    li hello #&#123;array[i]&#125;</span><br><span class=\"line\">  - &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>each:in后的循环目标支持数组、json</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ul</span><br><span class=\"line\">  each val, index in [&apos;西瓜&apos;, &apos;苹果&apos;, &apos;梨子&apos;]</span><br><span class=\"line\">    li= index + &apos;: &apos; + val</span><br></pre></td></tr></table></figure>\n<h3 id=\"case选择\"><a class=\"markdownIt-Anchor\" href=\"#case选择\"></a> Case选择</h3>\n<p>case 不支持case 穿透，如果 case 穿透的话会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var friends = 1</span><br><span class=\"line\">case friends</span><br><span class=\"line\">  when 0: p you have no friends</span><br><span class=\"line\">  when 1: p you have a friend</span><br><span class=\"line\">  default: p you have #&#123;friends&#125; friends</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var friends = 10</span><br><span class=\"line\">case friends</span><br><span class=\"line\">  when 0</span><br><span class=\"line\">    p you have no friends</span><br><span class=\"line\">  when 1</span><br><span class=\"line\">    p you have a friend</span><br><span class=\"line\">  default</span><br><span class=\"line\">    p you have #&#123;friends&#125; friends</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板中调用markdown语言\"><a class=\"markdownIt-Anchor\" href=\"#模板中调用markdown语言\"></a> 模板中调用Markdown语言</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:markdown</span><br><span class=\"line\">  # Markdown 标题</span><br><span class=\"line\">  </span><br><span class=\"line\">//翻译后：</span><br><span class=\"line\">&lt;h1&gt;Markdown 标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可重用的-jade-块-mixins\"><a class=\"markdownIt-Anchor\" href=\"#可重用的-jade-块-mixins\"></a> 可重用的 jade 块 (Mixins)</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin article(title)</span><br><span class=\"line\">  .article</span><br><span class=\"line\">    .article-wrapper</span><br><span class=\"line\">      h1= title</span><br><span class=\"line\">      //- block 为 jade 关键字代表外部传入的块</span><br><span class=\"line\">      if block</span><br><span class=\"line\">        block</span><br><span class=\"line\">      else</span><br><span class=\"line\">        p 该文章没有内容</span><br><span class=\"line\">        </span><br><span class=\"line\">+article(&apos;Hello world&apos;)</span><br><span class=\"line\">+article(&apos;Hello Jade&apos;)</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;article&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;article-wrapper&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello world&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;该文章没有内容&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;article&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;article-wrapper&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello Jade&lt;/h1&gt; </span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>Mixins 同时也可以从外部获取属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin link(href, name)</span><br><span class=\"line\">  a(class!=attributes.class, href=href)= name</span><br><span class=\"line\">   </span><br><span class=\"line\">+link(&apos;/foo&apos;, &apos;foo&apos;)(class=&quot;btn&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">&lt;a href=&quot;/foo&quot; class=&quot;btn&quot;&gt;foo&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板包含-includes\"><a class=\"markdownIt-Anchor\" href=\"#模板包含-includes\"></a> 模板包含 (Includes)</h2>\n<p>可以使用 Includes 在模板中包含其他模板的内容</p>\n<h2 id=\"模板继承-extends\"><a class=\"markdownIt-Anchor\" href=\"#模板继承-extends\"></a> 模板继承 (Extends)</h2>\n<p>layout.jade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doctype html</span><br><span class=\"line\">html</span><br><span class=\"line\">  head</span><br><span class=\"line\">    title 我的网站</span><br><span class=\"line\">    meta(http-equiv=&quot;Content-Type&quot;,content=&quot;text/html; charset=utf-8&quot;)</span><br><span class=\"line\">    link(type=&quot;text/css&quot;,rel=&quot;stylesheet&quot;,href=&quot;/css/style.css&quot;)</span><br><span class=\"line\">    script(src=&quot;/js/lib/jquery-1.8.0.min.js&quot;,type=&quot;text/javascript&quot;)</span><br><span class=\"line\">  body</span><br><span class=\"line\">    block content</span><br></pre></td></tr></table></figure>\n<p>article.jade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//- extends 拓展调用 layout.jade</span><br><span class=\"line\">extends ../layout</span><br><span class=\"line\">block content</span><br><span class=\"line\">  h1 文章列表</span><br><span class=\"line\">  p 习近平忆贾大山 李克强:将启动新核电项目</span><br></pre></td></tr></table></figure>\n<p>res.render(‘article’) 的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;我的网站&lt;/title&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;/head&gt;</span><br><span class=\"line\">    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;</span><br><span class=\"line\">    &lt;script src=&quot;/js/lib/jquery-1.8.0.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;文章列表&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;习近平忆贾大山 李克强:将启动新核电项目&lt;/p&gt; </span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<ol>\n<li>npm install -g pug</li>\n<li>npm install -g pug-cli</li>\n<li>pug index.pug</li>\n</ol>\n<h1 id=\"webstorm添加pug文件自动编译\"><a class=\"markdownIt-Anchor\" href=\"#webstorm添加pug文件自动编译\"></a> webstorm添加pug文件自动编译</h1>\n<ol>\n<li>WebStorm下，File-&gt;settings，在左上角搜索watcher，选择Tools-&gt;fileWatcher</li>\n<li>添加一个watcher，选择类型为Jade（pug支持安装了，但是不知道怎样使用，发现全部用Jade也能使用）</li>\n<li>在Program下，选择pug的安装路径，如我的为：/usr/local/bin/pug,在Arguments的默认值前面添加-P可以让编译后的文件格式化显示</li>\n<li>编写pug文件，编写后，会自动生成相应的编译后文件</li>\n</ol>\n<h1 id=\"在-express-中调用-jade-模板引擎\"><a class=\"markdownIt-Anchor\" href=\"#在-express-中调用-jade-模板引擎\"></a> 在 Express 中调用 jade 模板引擎</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.set(&apos;view engine&apos;, &apos;jade&apos;); // 设置模板引擎</span><br><span class=\"line\">app.set(&apos;views&apos;, __dirname);  // 设置模板相对路径(相对当前目录)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function(req, res) &#123;</span><br><span class=\"line\">    res.render(&apos;test&apos;); // 调用当前路径下的 test.jade 模板</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本语法及支持\"><a class=\"markdownIt-Anchor\" href=\"#基本语法及支持\"></a> 基本语法及支持</h1>\n<h2 id=\"类名和id名\"><a class=\"markdownIt-Anchor\" href=\"#类名和id名\"></a> 类名和ID名</h2>\n<ul>\n<li>a.class名称,如：a.button,翻译为：<a class=\"button\"></a></li>\n<li>a#id名称，如：a#button，翻译为：<a class=\"button\"></a></li>\n</ul>\n<h2 id=\"属性\"><a class=\"markdownIt-Anchor\" href=\"#属性\"></a> 属性</h2>\n<p>属性可以使用()包裹起来,属性值之间用逗号隔开，如：a(href=“<a href=\"http://google.com\" target=\"_blank\" rel=\"noopener\">google.com</a>”,title=“google”)</p>\n<h2 id=\"文本内容\"><a class=\"markdownIt-Anchor\" href=\"#文本内容\"></a> 文本内容</h2>\n<p>在html标签后空格直接书写</p>\n<h2 id=\"多行文本内容\"><a class=\"markdownIt-Anchor\" href=\"#多行文本内容\"></a> 多行文本内容</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.</span><br><span class=\"line\">    asdfasdfa</span><br><span class=\"line\">    asdfasd</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p</span><br><span class=\"line\">    | dfas &lt;strong&gt;hey&lt;/strong&gt;</span><br><span class=\"line\">        strong hey man</span><br><span class=\"line\">    | dfas</span><br></pre></td></tr></table></figure>\n<h2 id=\"注释\"><a class=\"markdownIt-Anchor\" href=\"#注释\"></a> 注释</h2>\n<ol>\n<li>单行注释</li>\n</ol>\n<ul>\n<li>普通方式：// just some paragraphs，翻译为：<!-- just some paragraphs--></li>\n<li>非缓冲注释，不会被编译到HTML：//- will not output within markup</li>\n</ul>\n<ol start=\"2\">\n<li>多行注释</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">    As much text as you want</span><br><span class=\"line\">    can go here.</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a class=\"markdownIt-Anchor\" href=\"#变量\"></a> 变量</h2>\n<p>jade 的变量调用有 3 种方式:</p>\n<ol>\n<li>#{表达式}  //此方式可以自由的嵌入各个地方</li>\n<li>=表达式    //返回的是表达式的值,会编码字符串</li>\n<li>!=表达式   //返回的是表达式的值,不会编码字符串</li>\n</ol>\n<p>注意：符号 - 开头在 jade 中属于服务端执行的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- console.log(&apos;hello&apos;); // 这段代码在服务端执行</span><br><span class=\"line\">- var s = &apos;hello world&apos; // 在服务端空间中定义变量</span><br><span class=\"line\">p #&#123;s&#125;          //&lt;p&gt;hello world&lt;/p&gt;</span><br><span class=\"line\">p= s            //&lt;p&gt;hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<ol>\n<li>直接在 jade 模板中定义变量</li>\n<li>在 express 中调用 res.render 方法的时候将变量一起传递进模板的空间中,调用模板的时候，在 jade 模板中也可以如上方那样直接调用 s 这个变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.render(test, &#123;</span><br><span class=\"line\">    s: &apos;hello world&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"流程代码\"><a class=\"markdownIt-Anchor\" href=\"#流程代码\"></a> 流程代码</h2>\n<h3 id=\"if判断\"><a class=\"markdownIt-Anchor\" href=\"#if判断\"></a> if判断</h3>\n<p>方式1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var user = &#123; description: &apos;我喜欢猫&apos; &#125;</span><br><span class=\"line\">- if (user.description)</span><br><span class=\"line\">    h2 描述</span><br><span class=\"line\">    p.description= user.description</span><br><span class=\"line\">- else</span><br><span class=\"line\">    h1 描述</span><br><span class=\"line\">    p.description 用户无描述</span><br></pre></td></tr></table></figure>\n<p>方式2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var user = &#123; description: &apos;我喜欢猫&apos; &#125;</span><br><span class=\"line\">#user</span><br><span class=\"line\">  if user.description</span><br><span class=\"line\">    h2 描述</span><br><span class=\"line\">    p.description= user.description</span><br><span class=\"line\">  else</span><br><span class=\"line\">    h1 描述</span><br><span class=\"line\">    p.description 用户无描述</span><br></pre></td></tr></table></figure>\n<p>方式1、方式2执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;user&quot;&gt;</span><br><span class=\"line\">  &lt;h2&gt;描述&lt;/h2&gt;</span><br><span class=\"line\">  &lt;p class=&quot;description&quot;&gt;我喜欢猫&lt;/p&gt;</span><br><span class=\"line\">&lt;/div</span><br></pre></td></tr></table></figure>\n<p>方式3:<br>\n使用 Unless 类似于 if 后的表达式加上了 ! 取反;这个 unless 是 jade 提供的关键字，不是运行的 js 代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var user = &#123; name: &apos;Alan&apos;, isVip: false &#125;</span><br><span class=\"line\">unless user.isVip</span><br><span class=\"line\">  p 亲爱的 #&#123;user.name&#125; 您并不是 VIP</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环\"><a class=\"markdownIt-Anchor\" href=\"#循环\"></a> 循环</h3>\n<ol>\n<li>for 循环</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var array = [1,2,3]</span><br><span class=\"line\">ul</span><br><span class=\"line\">  - for (var i = 0; i &lt; array.length; ++i) &#123;</span><br><span class=\"line\">    li hello #&#123;array[i]&#125;</span><br><span class=\"line\">  - &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>each:in后的循环目标支持数组、json</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ul</span><br><span class=\"line\">  each val, index in [&apos;西瓜&apos;, &apos;苹果&apos;, &apos;梨子&apos;]</span><br><span class=\"line\">    li= index + &apos;: &apos; + val</span><br></pre></td></tr></table></figure>\n<h3 id=\"case选择\"><a class=\"markdownIt-Anchor\" href=\"#case选择\"></a> Case选择</h3>\n<p>case 不支持case 穿透，如果 case 穿透的话会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var friends = 1</span><br><span class=\"line\">case friends</span><br><span class=\"line\">  when 0: p you have no friends</span><br><span class=\"line\">  when 1: p you have a friend</span><br><span class=\"line\">  default: p you have #&#123;friends&#125; friends</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- var friends = 10</span><br><span class=\"line\">case friends</span><br><span class=\"line\">  when 0</span><br><span class=\"line\">    p you have no friends</span><br><span class=\"line\">  when 1</span><br><span class=\"line\">    p you have a friend</span><br><span class=\"line\">  default</span><br><span class=\"line\">    p you have #&#123;friends&#125; friends</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板中调用markdown语言\"><a class=\"markdownIt-Anchor\" href=\"#模板中调用markdown语言\"></a> 模板中调用Markdown语言</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:markdown</span><br><span class=\"line\">  # Markdown 标题</span><br><span class=\"line\">  </span><br><span class=\"line\">//翻译后：</span><br><span class=\"line\">&lt;h1&gt;Markdown 标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可重用的-jade-块-mixins\"><a class=\"markdownIt-Anchor\" href=\"#可重用的-jade-块-mixins\"></a> 可重用的 jade 块 (Mixins)</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin article(title)</span><br><span class=\"line\">  .article</span><br><span class=\"line\">    .article-wrapper</span><br><span class=\"line\">      h1= title</span><br><span class=\"line\">      //- block 为 jade 关键字代表外部传入的块</span><br><span class=\"line\">      if block</span><br><span class=\"line\">        block</span><br><span class=\"line\">      else</span><br><span class=\"line\">        p 该文章没有内容</span><br><span class=\"line\">        </span><br><span class=\"line\">+article(&apos;Hello world&apos;)</span><br><span class=\"line\">+article(&apos;Hello Jade&apos;)</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;article&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;article-wrapper&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello world&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;该文章没有内容&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;article&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;article-wrapper&quot;&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello Jade&lt;/h1&gt; </span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>Mixins 同时也可以从外部获取属性:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin link(href, name)</span><br><span class=\"line\">  a(class!=attributes.class, href=href)= name</span><br><span class=\"line\">   </span><br><span class=\"line\">+link(&apos;/foo&apos;, &apos;foo&apos;)(class=&quot;btn&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//编译后</span><br><span class=\"line\">&lt;a href=&quot;/foo&quot; class=&quot;btn&quot;&gt;foo&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板包含-includes\"><a class=\"markdownIt-Anchor\" href=\"#模板包含-includes\"></a> 模板包含 (Includes)</h2>\n<p>可以使用 Includes 在模板中包含其他模板的内容</p>\n<h2 id=\"模板继承-extends\"><a class=\"markdownIt-Anchor\" href=\"#模板继承-extends\"></a> 模板继承 (Extends)</h2>\n<p>layout.jade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doctype html</span><br><span class=\"line\">html</span><br><span class=\"line\">  head</span><br><span class=\"line\">    title 我的网站</span><br><span class=\"line\">    meta(http-equiv=&quot;Content-Type&quot;,content=&quot;text/html; charset=utf-8&quot;)</span><br><span class=\"line\">    link(type=&quot;text/css&quot;,rel=&quot;stylesheet&quot;,href=&quot;/css/style.css&quot;)</span><br><span class=\"line\">    script(src=&quot;/js/lib/jquery-1.8.0.min.js&quot;,type=&quot;text/javascript&quot;)</span><br><span class=\"line\">  body</span><br><span class=\"line\">    block content</span><br></pre></td></tr></table></figure>\n<p>article.jade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//- extends 拓展调用 layout.jade</span><br><span class=\"line\">extends ../layout</span><br><span class=\"line\">block content</span><br><span class=\"line\">  h1 文章列表</span><br><span class=\"line\">  p 习近平忆贾大山 李克强:将启动新核电项目</span><br></pre></td></tr></table></figure>\n<p>res.render(‘article’) 的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;我的网站&lt;/title&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;/head&gt;</span><br><span class=\"line\">    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;</span><br><span class=\"line\">    &lt;script src=&quot;/js/lib/jquery-1.8.0.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;文章列表&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;习近平忆贾大山 李克强:将启动新核电项目&lt;/p&gt; </span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>"},{"title":"readline模块的使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\nAPI: http://nodejs.cn/api/readline\n\n# 简介\nReadline是Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。使用require(“readline”)可以引用模块\n\n# 创建Readline实例\nreadline.createInterface(options)\n~~~\n创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:\n\ninput - 要监听的可读流 (必需)\noutput - 要写入 readline 的可写流 (必须).\ncompleter - 用于 Tab 自动补全的可选函数。(不常用)\nterminal - 如果希望 input 和 output 流像 TTY 一样对待，那么传递参数 true ，并且经由 ANSI/VT100 转码。 默认情况下检查 isTTY 是否在 output 流上实例化。(不常用)\n\nvar readline = require(‘readline’); \nvar rl = readline.createInterface({ \n    input: process.stdin, \n    output: process.stdout \n});\n~~~\n\n# 接口\n* rl.close()：关闭接口实例 (Interface instance), 放弃控制输入输出流。”close” 事件会被触发\n* rl.pause()：暂停 readline 的输入流 (input stream), 如果有需要稍后还可以恢复\n* rl.prompt([preserveCursor])：为用户输入准备好readline，将现有的setPrompt选项放到新的一行，让用户有一个新的地方开始输入。将preserveCursor设为true来防止光标位置被重新设定成0\n* rl.question(query, callback)：预先提示指定的query，然后用户应答后触发指定的callback。 显示指定的query给用户后，当用户的应答被输入后，就触发了指定的callback\n* rl.resume()：恢复 readline 的输入流 (input stream)\n* rl.setPrompt(prompt)：设置提示符，例如当你在命令行运行 node 时，你会看到(prompt)\n\n# 示例\n~~~\nvar readline = require('readline');\nvar rl = readline.createInterface(process.stdin,process.stdout);\n\n// question方法\nrl.question('what is you name? ',function(answer){\n  console.log('my name is ' + answer);\n  //不加close，则不会结束\n  rl.close();\n});\n// close事件监听\nrl.on('close',function(){\n  console.log('欢迎下次再来');\n  process.exit(0);\n});\n~~~","source":"_posts/前端开发/readline模块的使用.md","raw":"---\ntitle: readline模块的使用\ntags:\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\nAPI: http://nodejs.cn/api/readline\n\n# 简介\nReadline是Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。使用require(“readline”)可以引用模块\n\n# 创建Readline实例\nreadline.createInterface(options)\n~~~\n创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:\n\ninput - 要监听的可读流 (必需)\noutput - 要写入 readline 的可写流 (必须).\ncompleter - 用于 Tab 自动补全的可选函数。(不常用)\nterminal - 如果希望 input 和 output 流像 TTY 一样对待，那么传递参数 true ，并且经由 ANSI/VT100 转码。 默认情况下检查 isTTY 是否在 output 流上实例化。(不常用)\n\nvar readline = require(‘readline’); \nvar rl = readline.createInterface({ \n    input: process.stdin, \n    output: process.stdout \n});\n~~~\n\n# 接口\n* rl.close()：关闭接口实例 (Interface instance), 放弃控制输入输出流。”close” 事件会被触发\n* rl.pause()：暂停 readline 的输入流 (input stream), 如果有需要稍后还可以恢复\n* rl.prompt([preserveCursor])：为用户输入准备好readline，将现有的setPrompt选项放到新的一行，让用户有一个新的地方开始输入。将preserveCursor设为true来防止光标位置被重新设定成0\n* rl.question(query, callback)：预先提示指定的query，然后用户应答后触发指定的callback。 显示指定的query给用户后，当用户的应答被输入后，就触发了指定的callback\n* rl.resume()：恢复 readline 的输入流 (input stream)\n* rl.setPrompt(prompt)：设置提示符，例如当你在命令行运行 node 时，你会看到(prompt)\n\n# 示例\n~~~\nvar readline = require('readline');\nvar rl = readline.createInterface(process.stdin,process.stdout);\n\n// question方法\nrl.question('what is you name? ',function(answer){\n  console.log('my name is ' + answer);\n  //不加close，则不会结束\n  rl.close();\n});\n// close事件监听\nrl.on('close',function(){\n  console.log('欢迎下次再来');\n  process.exit(0);\n});\n~~~","slug":"前端开发-readline模块的使用","published":1,"updated":"2019-02-14T06:44:55.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzi00525b8hk642a8a6","content":"<p>[toc]</p>\n<p>API: <a href=\"http://nodejs.cn/api/readline\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/readline</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Readline是Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。使用require(“readline”)可以引用模块</p>\n<h1 id=\"创建readline实例\"><a class=\"markdownIt-Anchor\" href=\"#创建readline实例\"></a> 创建Readline实例</h1>\n<p>readline.createInterface(options)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:</span><br><span class=\"line\"></span><br><span class=\"line\">input - 要监听的可读流 (必需)</span><br><span class=\"line\">output - 要写入 readline 的可写流 (必须).</span><br><span class=\"line\">completer - 用于 Tab 自动补全的可选函数。(不常用)</span><br><span class=\"line\">terminal - 如果希望 input 和 output 流像 TTY 一样对待，那么传递参数 true ，并且经由 ANSI/VT100 转码。 默认情况下检查 isTTY 是否在 output 流上实例化。(不常用)</span><br><span class=\"line\"></span><br><span class=\"line\">var readline = require(‘readline’); </span><br><span class=\"line\">var rl = readline.createInterface(&#123; </span><br><span class=\"line\">    input: process.stdin, </span><br><span class=\"line\">    output: process.stdout </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"接口\"><a class=\"markdownIt-Anchor\" href=\"#接口\"></a> 接口</h1>\n<ul>\n<li>rl.close()：关闭接口实例 (Interface instance), 放弃控制输入输出流。”close” 事件会被触发</li>\n<li>rl.pause()：暂停 readline 的输入流 (input stream), 如果有需要稍后还可以恢复</li>\n<li>rl.prompt([preserveCursor])：为用户输入准备好readline，将现有的setPrompt选项放到新的一行，让用户有一个新的地方开始输入。将preserveCursor设为true来防止光标位置被重新设定成0</li>\n<li>rl.question(query, callback)：预先提示指定的query，然后用户应答后触发指定的callback。 显示指定的query给用户后，当用户的应答被输入后，就触发了指定的callback</li>\n<li>rl.resume()：恢复 readline 的输入流 (input stream)</li>\n<li>rl.setPrompt(prompt)：设置提示符，例如当你在命令行运行 node 时，你会看到(prompt)</li>\n</ul>\n<h1 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\"></a> 示例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var readline = require(&apos;readline&apos;);</span><br><span class=\"line\">var rl = readline.createInterface(process.stdin,process.stdout);</span><br><span class=\"line\"></span><br><span class=\"line\">// question方法</span><br><span class=\"line\">rl.question(&apos;what is you name? &apos;,function(answer)&#123;</span><br><span class=\"line\">  console.log(&apos;my name is &apos; + answer);</span><br><span class=\"line\">  //不加close，则不会结束</span><br><span class=\"line\">  rl.close();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// close事件监听</span><br><span class=\"line\">rl.on(&apos;close&apos;,function()&#123;</span><br><span class=\"line\">  console.log(&apos;欢迎下次再来&apos;);</span><br><span class=\"line\">  process.exit(0);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p>API: <a href=\"http://nodejs.cn/api/readline\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/readline</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Readline是Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。使用require(“readline”)可以引用模块</p>\n<h1 id=\"创建readline实例\"><a class=\"markdownIt-Anchor\" href=\"#创建readline实例\"></a> 创建Readline实例</h1>\n<p>readline.createInterface(options)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:</span><br><span class=\"line\"></span><br><span class=\"line\">input - 要监听的可读流 (必需)</span><br><span class=\"line\">output - 要写入 readline 的可写流 (必须).</span><br><span class=\"line\">completer - 用于 Tab 自动补全的可选函数。(不常用)</span><br><span class=\"line\">terminal - 如果希望 input 和 output 流像 TTY 一样对待，那么传递参数 true ，并且经由 ANSI/VT100 转码。 默认情况下检查 isTTY 是否在 output 流上实例化。(不常用)</span><br><span class=\"line\"></span><br><span class=\"line\">var readline = require(‘readline’); </span><br><span class=\"line\">var rl = readline.createInterface(&#123; </span><br><span class=\"line\">    input: process.stdin, </span><br><span class=\"line\">    output: process.stdout </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"接口\"><a class=\"markdownIt-Anchor\" href=\"#接口\"></a> 接口</h1>\n<ul>\n<li>rl.close()：关闭接口实例 (Interface instance), 放弃控制输入输出流。”close” 事件会被触发</li>\n<li>rl.pause()：暂停 readline 的输入流 (input stream), 如果有需要稍后还可以恢复</li>\n<li>rl.prompt([preserveCursor])：为用户输入准备好readline，将现有的setPrompt选项放到新的一行，让用户有一个新的地方开始输入。将preserveCursor设为true来防止光标位置被重新设定成0</li>\n<li>rl.question(query, callback)：预先提示指定的query，然后用户应答后触发指定的callback。 显示指定的query给用户后，当用户的应答被输入后，就触发了指定的callback</li>\n<li>rl.resume()：恢复 readline 的输入流 (input stream)</li>\n<li>rl.setPrompt(prompt)：设置提示符，例如当你在命令行运行 node 时，你会看到(prompt)</li>\n</ul>\n<h1 id=\"示例\"><a class=\"markdownIt-Anchor\" href=\"#示例\"></a> 示例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var readline = require(&apos;readline&apos;);</span><br><span class=\"line\">var rl = readline.createInterface(process.stdin,process.stdout);</span><br><span class=\"line\"></span><br><span class=\"line\">// question方法</span><br><span class=\"line\">rl.question(&apos;what is you name? &apos;,function(answer)&#123;</span><br><span class=\"line\">  console.log(&apos;my name is &apos; + answer);</span><br><span class=\"line\">  //不加close，则不会结束</span><br><span class=\"line\">  rl.close();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// close事件监听</span><br><span class=\"line\">rl.on(&apos;close&apos;,function()&#123;</span><br><span class=\"line\">  console.log(&apos;欢迎下次再来&apos;);</span><br><span class=\"line\">  process.exit(0);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"异步编程及Async模块的使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n~~~\n汇智网-异步编程：http://cw.hubwiz.com/card/c/543e1a4f032c7816c0d5dfa1/1/3/6/\n~~~\n\n# 简介\n> github网址：https://github.com/caolan/async\n* 异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等\n* 使用Asycn模块需要安装，它不是node自带的\n~~~\n安装：npm install async \n引用：var async = require('async');\n~~~\n* 异常捕获：异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常\n\n# 函数式编程\n## 高阶函数\n* 高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值\n* 函数作为参数；函数作为返回值；\n~~~\n//高阶函数test的返回值是一个匿名函数\nfunction test(v){\n  return function(){\n    return v;\n  }\n}\n~~~\n## 偏函数\n* 一个创建函数的工厂函数；通过指定部分参数，定制新的函数\n* 假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数\n~~~\n//isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数\nvar isType = function(type){\n  return function(obj){\n    return toString.call(obj)=='[object '+type+']';\n  }\n};\nvar isString = isType('String');\nvar isFunction = isType('Function');\n~~~\n编写偏函数\n~~~\nvar say =function(name){\n    return function(text){\n        console.log(name+' say '+text);\n    }\n};\nvar tomSay = say('tom');\n\ntomSay ('hello');\n~~~\n# 方法说明\n## series\n> 它是控制异步函数按照串行顺序执行，只有前一个执行完毕，才能执行下一个异步调用\n~~~\nasync.series([function(cb){\n    setTimeout(function(){\n        cb(null,1);\n    },1000)\n},function(cb){\n    setTimeout(cb,1000,null,2); \n}],function(err,result){  //result是每个回调函数传进来的data参数，result=[1,2]\n    if (err) \n        console.error(err);\n    else \n        console.log(result);\n})\n~~~\n\n## parallel\n> parallel的用法和series类似。只是数组中的函数是并行执行，parallel的总时间取决于运行时间最长的函数。而最终的回调函数里result的值是按照数组中函数的顺序排列的\n\n## waterfall\n> 和series函数有很多相似之处，都是按照顺序执行。\n不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能\n~~~\nasync.waterfall([function(cb){\n    setTimeout(function(){\n        cb(null,1);\n    },1000)\n},function(data,cb){\n    setTimeout(cb,1000,null,data+\"+\"+\"2\");\n}],function(err,result){  //result = \"1+2\"\n    if (err) \n        console.error(err);\n    else \n        console.log(result);\n})\n~~~ \n\n## parallelLimit(tasks, limit, [callback])\nparallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发\n\n## whilst(test, fn, callback)\n相当于while，但其中的异步调用将在完成后才会进行下一次循环;test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件\n~~~\nvar count = 0;\nasync.whilst(\n    function () { return count < 5; },\n    function (callback) {\n        count++;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n\n    }\n);\n~~~\n\n## doWhilst(fn, test, callback)\n相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断\n\n## until(test, fn, callback)\nuntil与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致\n~~~\nvar count = 5;\nasync.until(\n    function () { return count < 0; },\n    function (callback) {\n        count--;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n\n    }\n);\n~~~\n\n## doUntil(fn, test, callback)\ndoUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致\n\n## forever(fn, errback)\nforever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用\n\n## compose(fn1, fn2...)\n使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值\n\n==注意==：从内层到外层的执行的顺序；从右往左执行\n~~~\nvar async = require('async');\nfunction fn1(n, callback) {\n    setTimeout(function () {\n        callback(null, n + 1);\n    }, 1000);\n}\nfunction fn2(n, callback) {\n    setTimeout(function () {\n        callback(null, n * 3);\n    }, 1000);\n}\nvar demo = async.compose(fn2, fn1);\ndemo(4, function (err, result) {\n    console.log(result);            //结果15\n});\ndemo = async.compose(fn1, fn2);\ndemo(4, function (err, result) {\n    console.log(result);            //结果13\n});\n~~~\n\n## auto(tasks, [callback])\n* 用来处理有依赖关系的多个任务的执行\n* async.auto的强大是在于，你定义好相互之间的dependencies，他来帮你决定用parallel还是waterfull\n~~~\nasync.auto({\n    getData: function(callback){\n        callback(null, 'data', 'converted to array');\n    },\n    makeFolder: function(callback){        \n        callback(null, 'folder');\n    },\n    writeFile: ['getData', 'makeFolder', function(callback, results){        \n        callback(null, 'filename');\n    }],\n    emailLink: ['writeFile', function(callback, results){\n        callback(null, {'file':results.writeFile, 'email':'user@example.com'});\n    }]\n}, function(err, results) { \n    console.log('err = ', err);\n    console.log('results = ', results);\n});\n~~~\n\n## queue(worker, concurrency)\nqueue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用\n\n## apply(function, arguments..)\napply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码\n~~~\nfunction(callback) { \n    test(3, callback); \n};\n用apply改写：\nasync.apply(test, 3);\n~~~\n\n## iterator(tasks)\n* 将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它\n* 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator\n* 对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null\n~~~\nvar iter = async.iterator([\n    function() { console.log('111') },\n    function() { console.log('222') },\n    function() { console.log('333') }\n]);\niter();\n~~~","source":"_posts/前端开发/异步编程及Async模块的使用.md","raw":"---\ntitle: 异步编程及Async模块的使用\ntags:\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n~~~\n汇智网-异步编程：http://cw.hubwiz.com/card/c/543e1a4f032c7816c0d5dfa1/1/3/6/\n~~~\n\n# 简介\n> github网址：https://github.com/caolan/async\n* 异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等\n* 使用Asycn模块需要安装，它不是node自带的\n~~~\n安装：npm install async \n引用：var async = require('async');\n~~~\n* 异常捕获：异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常\n\n# 函数式编程\n## 高阶函数\n* 高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值\n* 函数作为参数；函数作为返回值；\n~~~\n//高阶函数test的返回值是一个匿名函数\nfunction test(v){\n  return function(){\n    return v;\n  }\n}\n~~~\n## 偏函数\n* 一个创建函数的工厂函数；通过指定部分参数，定制新的函数\n* 假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数\n~~~\n//isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数\nvar isType = function(type){\n  return function(obj){\n    return toString.call(obj)=='[object '+type+']';\n  }\n};\nvar isString = isType('String');\nvar isFunction = isType('Function');\n~~~\n编写偏函数\n~~~\nvar say =function(name){\n    return function(text){\n        console.log(name+' say '+text);\n    }\n};\nvar tomSay = say('tom');\n\ntomSay ('hello');\n~~~\n# 方法说明\n## series\n> 它是控制异步函数按照串行顺序执行，只有前一个执行完毕，才能执行下一个异步调用\n~~~\nasync.series([function(cb){\n    setTimeout(function(){\n        cb(null,1);\n    },1000)\n},function(cb){\n    setTimeout(cb,1000,null,2); \n}],function(err,result){  //result是每个回调函数传进来的data参数，result=[1,2]\n    if (err) \n        console.error(err);\n    else \n        console.log(result);\n})\n~~~\n\n## parallel\n> parallel的用法和series类似。只是数组中的函数是并行执行，parallel的总时间取决于运行时间最长的函数。而最终的回调函数里result的值是按照数组中函数的顺序排列的\n\n## waterfall\n> 和series函数有很多相似之处，都是按照顺序执行。\n不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能\n~~~\nasync.waterfall([function(cb){\n    setTimeout(function(){\n        cb(null,1);\n    },1000)\n},function(data,cb){\n    setTimeout(cb,1000,null,data+\"+\"+\"2\");\n}],function(err,result){  //result = \"1+2\"\n    if (err) \n        console.error(err);\n    else \n        console.log(result);\n})\n~~~ \n\n## parallelLimit(tasks, limit, [callback])\nparallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发\n\n## whilst(test, fn, callback)\n相当于while，但其中的异步调用将在完成后才会进行下一次循环;test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件\n~~~\nvar count = 0;\nasync.whilst(\n    function () { return count < 5; },\n    function (callback) {\n        count++;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n\n    }\n);\n~~~\n\n## doWhilst(fn, test, callback)\n相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断\n\n## until(test, fn, callback)\nuntil与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致\n~~~\nvar count = 5;\nasync.until(\n    function () { return count < 0; },\n    function (callback) {\n        count--;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n\n    }\n);\n~~~\n\n## doUntil(fn, test, callback)\ndoUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致\n\n## forever(fn, errback)\nforever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用\n\n## compose(fn1, fn2...)\n使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值\n\n==注意==：从内层到外层的执行的顺序；从右往左执行\n~~~\nvar async = require('async');\nfunction fn1(n, callback) {\n    setTimeout(function () {\n        callback(null, n + 1);\n    }, 1000);\n}\nfunction fn2(n, callback) {\n    setTimeout(function () {\n        callback(null, n * 3);\n    }, 1000);\n}\nvar demo = async.compose(fn2, fn1);\ndemo(4, function (err, result) {\n    console.log(result);            //结果15\n});\ndemo = async.compose(fn1, fn2);\ndemo(4, function (err, result) {\n    console.log(result);            //结果13\n});\n~~~\n\n## auto(tasks, [callback])\n* 用来处理有依赖关系的多个任务的执行\n* async.auto的强大是在于，你定义好相互之间的dependencies，他来帮你决定用parallel还是waterfull\n~~~\nasync.auto({\n    getData: function(callback){\n        callback(null, 'data', 'converted to array');\n    },\n    makeFolder: function(callback){        \n        callback(null, 'folder');\n    },\n    writeFile: ['getData', 'makeFolder', function(callback, results){        \n        callback(null, 'filename');\n    }],\n    emailLink: ['writeFile', function(callback, results){\n        callback(null, {'file':results.writeFile, 'email':'user@example.com'});\n    }]\n}, function(err, results) { \n    console.log('err = ', err);\n    console.log('results = ', results);\n});\n~~~\n\n## queue(worker, concurrency)\nqueue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用\n\n## apply(function, arguments..)\napply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码\n~~~\nfunction(callback) { \n    test(3, callback); \n};\n用apply改写：\nasync.apply(test, 3);\n~~~\n\n## iterator(tasks)\n* 将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它\n* 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator\n* 对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null\n~~~\nvar iter = async.iterator([\n    function() { console.log('111') },\n    function() { console.log('222') },\n    function() { console.log('333') }\n]);\niter();\n~~~","slug":"前端开发-异步编程及Async模块的使用","published":1,"updated":"2019-02-14T06:45:36.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzj00565b8hbfo6ayrw","content":"<p>[toc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">汇智网-异步编程：http://cw.hubwiz.com/card/c/543e1a4f032c7816c0d5dfa1/1/3/6/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>github网址：<a href=\"https://github.com/caolan/async\" target=\"_blank\" rel=\"noopener\">https://github.com/caolan/async</a></p>\n</blockquote>\n<ul>\n<li>异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等</li>\n<li>使用Asycn模块需要安装，它不是node自带的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装：npm install async </span><br><span class=\"line\">引用：var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>异常捕获：异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常</li>\n</ul>\n<h1 id=\"函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程\"></a> 函数式编程</h1>\n<h2 id=\"高阶函数\"><a class=\"markdownIt-Anchor\" href=\"#高阶函数\"></a> 高阶函数</h2>\n<ul>\n<li>高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值</li>\n<li>函数作为参数；函数作为返回值；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//高阶函数test的返回值是一个匿名函数</span><br><span class=\"line\">function test(v)&#123;</span><br><span class=\"line\">  return function()&#123;</span><br><span class=\"line\">    return v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"偏函数\"><a class=\"markdownIt-Anchor\" href=\"#偏函数\"></a> 偏函数</h2>\n<ul>\n<li>一个创建函数的工厂函数；通过指定部分参数，定制新的函数</li>\n<li>假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数</span><br><span class=\"line\">var isType = function(type)&#123;</span><br><span class=\"line\">  return function(obj)&#123;</span><br><span class=\"line\">    return toString.call(obj)==&apos;[object &apos;+type+&apos;]&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var isString = isType(&apos;String&apos;);</span><br><span class=\"line\">var isFunction = isType(&apos;Function&apos;);</span><br></pre></td></tr></table></figure>\n<p>编写偏函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var say =function(name)&#123;</span><br><span class=\"line\">    return function(text)&#123;</span><br><span class=\"line\">        console.log(name+&apos; say &apos;+text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var tomSay = say(&apos;tom&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">tomSay (&apos;hello&apos;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"方法说明\"><a class=\"markdownIt-Anchor\" href=\"#方法说明\"></a> 方法说明</h1>\n<h2 id=\"series\"><a class=\"markdownIt-Anchor\" href=\"#series\"></a> series</h2>\n<blockquote>\n<p>它是控制异步函数按照串行顺序执行，只有前一个执行完毕，才能执行下一个异步调用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async.series([function(cb)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        cb(null,1);</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;,function(cb)&#123;</span><br><span class=\"line\">    setTimeout(cb,1000,null,2); </span><br><span class=\"line\">&#125;],function(err,result)&#123;  //result是每个回调函数传进来的data参数，result=[1,2]</span><br><span class=\"line\">    if (err) </span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    else </span><br><span class=\"line\">        console.log(result);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"parallel\"><a class=\"markdownIt-Anchor\" href=\"#parallel\"></a> parallel</h2>\n<blockquote>\n<p>parallel的用法和series类似。只是数组中的函数是并行执行，parallel的总时间取决于运行时间最长的函数。而最终的回调函数里result的值是按照数组中函数的顺序排列的</p>\n</blockquote>\n<h2 id=\"waterfall\"><a class=\"markdownIt-Anchor\" href=\"#waterfall\"></a> waterfall</h2>\n<blockquote>\n<p>和series函数有很多相似之处，都是按照顺序执行。<br>\n不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async.waterfall([function(cb)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        cb(null,1);</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;,function(data,cb)&#123;</span><br><span class=\"line\">    setTimeout(cb,1000,null,data+&quot;+&quot;+&quot;2&quot;);</span><br><span class=\"line\">&#125;],function(err,result)&#123;  //result = &quot;1+2&quot;</span><br><span class=\"line\">    if (err) </span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    else </span><br><span class=\"line\">        console.log(result);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\">## parallelLimit(tasks, limit, [callback])</span><br><span class=\"line\">parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发</span><br><span class=\"line\"></span><br><span class=\"line\">## whilst(test, fn, callback)</span><br><span class=\"line\">相当于while，但其中的异步调用将在完成后才会进行下一次循环;test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件</span><br></pre></td></tr></table></figure>\n<p>var count = 0;<br>\nasync.whilst(<br>\nfunction () { return count &lt; 5; },<br>\nfunction (callback) {<br>\ncount++;<br>\nsetTimeout(callback, 1000);<br>\n},<br>\nfunction (err) {</p>\n<pre><code>}\n</code></pre>\n<p>);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## doWhilst(fn, test, callback)</span><br><span class=\"line\">相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断</span><br><span class=\"line\"></span><br><span class=\"line\">## until(test, fn, callback)</span><br><span class=\"line\">until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致</span><br></pre></td></tr></table></figure>\n<p>var count = 5;<br>\nasync.until(<br>\nfunction () { return count &lt; 0; },<br>\nfunction (callback) {<br>\ncount–;<br>\nsetTimeout(callback, 1000);<br>\n},<br>\nfunction (err) {</p>\n<pre><code>}\n</code></pre>\n<p>);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## doUntil(fn, test, callback)</span><br><span class=\"line\">doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致</span><br><span class=\"line\"></span><br><span class=\"line\">## forever(fn, errback)</span><br><span class=\"line\">forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用</span><br><span class=\"line\"></span><br><span class=\"line\">## compose(fn1, fn2...)</span><br><span class=\"line\">使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值</span><br><span class=\"line\"></span><br><span class=\"line\">==注意==：从内层到外层的执行的顺序；从右往左执行</span><br></pre></td></tr></table></figure>\n<p>var async = require(‘async’);<br>\nfunction fn1(n, callback) {<br>\nsetTimeout(function () {<br>\ncallback(null, n + 1);<br>\n}, 1000);<br>\n}<br>\nfunction fn2(n, callback) {<br>\nsetTimeout(function () {<br>\ncallback(null, n * 3);<br>\n}, 1000);<br>\n}<br>\nvar demo = async.compose(fn2, fn1);<br>\ndemo(4, function (err, result) {<br>\nconsole.log(result);            //结果15<br>\n});<br>\ndemo = async.compose(fn1, fn2);<br>\ndemo(4, function (err, result) {<br>\nconsole.log(result);            //结果13<br>\n});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## auto(tasks, [callback])</span><br><span class=\"line\">* 用来处理有依赖关系的多个任务的执行</span><br><span class=\"line\">* async.auto的强大是在于，你定义好相互之间的dependencies，他来帮你决定用parallel还是waterfull</span><br></pre></td></tr></table></figure>\n<p>async.auto({<br>\ngetData: function(callback){<br>\ncallback(null, ‘data’, ‘converted to array’);<br>\n},<br>\nmakeFolder: function(callback){<br>\ncallback(null, ‘folder’);<br>\n},<br>\nwriteFile: [‘getData’, ‘makeFolder’, function(callback, results){<br>\ncallback(null, ‘filename’);<br>\n}],<br>\nemailLink: [‘writeFile’, function(callback, results){<br>\ncallback(null, {‘file’:results.writeFile, ‘email’:‘user@example.com’});<br>\n}]<br>\n}, function(err, results) {<br>\nconsole.log('err = ', err);<br>\nconsole.log('results = ', results);<br>\n});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## queue(worker, concurrency)</span><br><span class=\"line\">queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用</span><br><span class=\"line\"></span><br><span class=\"line\">## apply(function, arguments..)</span><br><span class=\"line\">apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码</span><br></pre></td></tr></table></figure>\n<p>function(callback) {<br>\ntest(3, callback);<br>\n};<br>\n用apply改写：<br>\nasync.apply(test, 3);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iterator(tasks)</span><br><span class=\"line\">* 将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它</span><br><span class=\"line\">* 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator</span><br><span class=\"line\">* 对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null</span><br></pre></td></tr></table></figure>\n<p>var iter = async.iterator([<br>\nfunction() { console.log(‘111’) },<br>\nfunction() { console.log(‘222’) },<br>\nfunction() { console.log(‘333’) }<br>\n]);<br>\niter();</p>\n<pre class=\"highlight\"><code class=\"\"></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">汇智网-异步编程：http://cw.hubwiz.com/card/c/543e1a4f032c7816c0d5dfa1/1/3/6/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>github网址：<a href=\"https://github.com/caolan/async\" target=\"_blank\" rel=\"noopener\">https://github.com/caolan/async</a></p>\n</blockquote>\n<ul>\n<li>异步编程是指由于异步I/O等因素，无法同步获得执行结果时，在回调函数中进行下一步操作的代码编写风格,常见的如setTimeout函数、ajax请求等等</li>\n<li>使用Asycn模块需要安装，它不是node自带的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装：npm install async </span><br><span class=\"line\">引用：var async = require(&apos;async&apos;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>异常捕获：异步I/O的实现主要有两个阶段，①提交请求；②处理结果； 这两个阶段彼此不关联，而异常并不一定发生在请求提交（即调用函数）时，平常的try/catch并不能有效的捕捉到程序的异常</li>\n</ul>\n<h1 id=\"函数式编程\"><a class=\"markdownIt-Anchor\" href=\"#函数式编程\"></a> 函数式编程</h1>\n<h2 id=\"高阶函数\"><a class=\"markdownIt-Anchor\" href=\"#高阶函数\"></a> 高阶函数</h2>\n<ul>\n<li>高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值</li>\n<li>函数作为参数；函数作为返回值；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//高阶函数test的返回值是一个匿名函数</span><br><span class=\"line\">function test(v)&#123;</span><br><span class=\"line\">  return function()&#123;</span><br><span class=\"line\">    return v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"偏函数\"><a class=\"markdownIt-Anchor\" href=\"#偏函数\"></a> 偏函数</h2>\n<ul>\n<li>一个创建函数的工厂函数；通过指定部分参数，定制新的函数</li>\n<li>假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString和isFunction就是偏函数</span><br><span class=\"line\">var isType = function(type)&#123;</span><br><span class=\"line\">  return function(obj)&#123;</span><br><span class=\"line\">    return toString.call(obj)==&apos;[object &apos;+type+&apos;]&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var isString = isType(&apos;String&apos;);</span><br><span class=\"line\">var isFunction = isType(&apos;Function&apos;);</span><br></pre></td></tr></table></figure>\n<p>编写偏函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var say =function(name)&#123;</span><br><span class=\"line\">    return function(text)&#123;</span><br><span class=\"line\">        console.log(name+&apos; say &apos;+text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var tomSay = say(&apos;tom&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">tomSay (&apos;hello&apos;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"方法说明\"><a class=\"markdownIt-Anchor\" href=\"#方法说明\"></a> 方法说明</h1>\n<h2 id=\"series\"><a class=\"markdownIt-Anchor\" href=\"#series\"></a> series</h2>\n<blockquote>\n<p>它是控制异步函数按照串行顺序执行，只有前一个执行完毕，才能执行下一个异步调用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async.series([function(cb)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        cb(null,1);</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;,function(cb)&#123;</span><br><span class=\"line\">    setTimeout(cb,1000,null,2); </span><br><span class=\"line\">&#125;],function(err,result)&#123;  //result是每个回调函数传进来的data参数，result=[1,2]</span><br><span class=\"line\">    if (err) </span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    else </span><br><span class=\"line\">        console.log(result);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"parallel\"><a class=\"markdownIt-Anchor\" href=\"#parallel\"></a> parallel</h2>\n<blockquote>\n<p>parallel的用法和series类似。只是数组中的函数是并行执行，parallel的总时间取决于运行时间最长的函数。而最终的回调函数里result的值是按照数组中函数的顺序排列的</p>\n</blockquote>\n<h2 id=\"waterfall\"><a class=\"markdownIt-Anchor\" href=\"#waterfall\"></a> waterfall</h2>\n<blockquote>\n<p>和series函数有很多相似之处，都是按照顺序执行。<br>\n不同之处是waterfall每个函数产生的值，都将传给下一个函数，而series则没有这个功能</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async.waterfall([function(cb)&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        cb(null,1);</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;,function(data,cb)&#123;</span><br><span class=\"line\">    setTimeout(cb,1000,null,data+&quot;+&quot;+&quot;2&quot;);</span><br><span class=\"line\">&#125;],function(err,result)&#123;  //result = &quot;1+2&quot;</span><br><span class=\"line\">    if (err) </span><br><span class=\"line\">        console.error(err);</span><br><span class=\"line\">    else </span><br><span class=\"line\">        console.log(result);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\">## parallelLimit(tasks, limit, [callback])</span><br><span class=\"line\">parallelLimit函数和parallel类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发</span><br><span class=\"line\"></span><br><span class=\"line\">## whilst(test, fn, callback)</span><br><span class=\"line\">相当于while，但其中的异步调用将在完成后才会进行下一次循环;test参数是一个返回布尔值结果的函数，通过返回值来决定循环是否继续，作用等同于while循环停止的条件</span><br></pre></td></tr></table></figure>\n<p>var count = 0;<br>\nasync.whilst(<br>\nfunction () { return count &lt; 5; },<br>\nfunction (callback) {<br>\ncount++;<br>\nsetTimeout(callback, 1000);<br>\n},<br>\nfunction (err) {</p>\n<pre><code>}\n</code></pre>\n<p>);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## doWhilst(fn, test, callback)</span><br><span class=\"line\">相当于do…while,较whilst而言，doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断</span><br><span class=\"line\"></span><br><span class=\"line\">## until(test, fn, callback)</span><br><span class=\"line\">until与whilst正好相反，当test条件函数返回值为false时继续循环，与true时跳出。其它特性一致</span><br></pre></td></tr></table></figure>\n<p>var count = 5;<br>\nasync.until(<br>\nfunction () { return count &lt; 0; },<br>\nfunction (callback) {<br>\ncount–;<br>\nsetTimeout(callback, 1000);<br>\n},<br>\nfunction (err) {</p>\n<pre><code>}\n</code></pre>\n<p>);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## doUntil(fn, test, callback)</span><br><span class=\"line\">doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致</span><br><span class=\"line\"></span><br><span class=\"line\">## forever(fn, errback)</span><br><span class=\"line\">forever函数比较特殊，它的功能是无论条件如何，函数都一直循环执行，只有出现程序执行的过程中出现错误时循环才会停止，callback才会被调用</span><br><span class=\"line\"></span><br><span class=\"line\">## compose(fn1, fn2...)</span><br><span class=\"line\">使用compose可以创建一个异步函数的集合函数，将传入的多个异步函数包含在其中，当我们执行这个集合函数时，会依次执行每一个异步函数，每个函数会消费上一次函数的返回值</span><br><span class=\"line\"></span><br><span class=\"line\">==注意==：从内层到外层的执行的顺序；从右往左执行</span><br></pre></td></tr></table></figure>\n<p>var async = require(‘async’);<br>\nfunction fn1(n, callback) {<br>\nsetTimeout(function () {<br>\ncallback(null, n + 1);<br>\n}, 1000);<br>\n}<br>\nfunction fn2(n, callback) {<br>\nsetTimeout(function () {<br>\ncallback(null, n * 3);<br>\n}, 1000);<br>\n}<br>\nvar demo = async.compose(fn2, fn1);<br>\ndemo(4, function (err, result) {<br>\nconsole.log(result);            //结果15<br>\n});<br>\ndemo = async.compose(fn1, fn2);<br>\ndemo(4, function (err, result) {<br>\nconsole.log(result);            //结果13<br>\n});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## auto(tasks, [callback])</span><br><span class=\"line\">* 用来处理有依赖关系的多个任务的执行</span><br><span class=\"line\">* async.auto的强大是在于，你定义好相互之间的dependencies，他来帮你决定用parallel还是waterfull</span><br></pre></td></tr></table></figure>\n<p>async.auto({<br>\ngetData: function(callback){<br>\ncallback(null, ‘data’, ‘converted to array’);<br>\n},<br>\nmakeFolder: function(callback){<br>\ncallback(null, ‘folder’);<br>\n},<br>\nwriteFile: [‘getData’, ‘makeFolder’, function(callback, results){<br>\ncallback(null, ‘filename’);<br>\n}],<br>\nemailLink: [‘writeFile’, function(callback, results){<br>\ncallback(null, {‘file’:results.writeFile, ‘email’:‘user@example.com’});<br>\n}]<br>\n}, function(err, results) {<br>\nconsole.log('err = ', err);<br>\nconsole.log('results = ', results);<br>\n});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## queue(worker, concurrency)</span><br><span class=\"line\">queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用</span><br><span class=\"line\"></span><br><span class=\"line\">## apply(function, arguments..)</span><br><span class=\"line\">apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码</span><br></pre></td></tr></table></figure>\n<p>function(callback) {<br>\ntest(3, callback);<br>\n};<br>\n用apply改写：<br>\nasync.apply(test, 3);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iterator(tasks)</span><br><span class=\"line\">* 将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它</span><br><span class=\"line\">* 直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator</span><br><span class=\"line\">* 对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null</span><br></pre></td></tr></table></figure>\n<p>var iter = async.iterator([<br>\nfunction() { console.log(‘111’) },<br>\nfunction() { console.log(‘222’) },<br>\nfunction() { console.log(‘333’) }<br>\n]);<br>\niter();</p>\n<pre class=\"highlight\"><code class=\"\"></code></pre>\n"},{"title":"微信公众平台使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"# 官方文档\nhttps://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432\n\n# 接口整体介绍\n微信接口请求返回格式介绍：\n\n微信接口是通过GET方式请求\n返回数据格式为JSON\n\n# 测试号配置\n无需公众账号，可直接体验和测试公众平台所有高级接口。\n\n配置：\n1. 登录公众账号\n2. 开发>开发者工具>公众平台测试账号\n3. 微信扫一扫登录\n4. 配置URL、TOKEN、JS接口安全域名\n\n# 注意事项\n1. 接口频率限制说明\n2. 全局返回码说明\n\n网页授权登录：\n如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。\n\n两种scope模式：\n1. snsapi_base时只能获取到openid，静默授权，\n2. snsapi_userinfo时可获取到其他信息，需要用户手动同意授权的\n\n微信公众平台（互斥）\n1. 编辑模式\n2. 开发者模式-openid\n\n接入开发者模式步骤\n\n\n为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID\n如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID\n\n公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储\n公众平台接口调用仅支持80端口。\n\n网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）\n\n微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。\n\n\n调试接口可能需要取消关注之后才能看到最新的效果\n\n\nhttps://blog.csdn.net/z496007165/article/details/73239971\nhttp://www.php.cn/xiaochengxu-405121.html\n\n网页授权接口：\n授权回调页面域名：没有http，如：http://89495c4f.ngrok.io是错误的，应该是： 89495c4f.ngrok.io\n\n\n\nhttp://www.106jiekou.com/\n\n\nhttps://blog.csdn.net/kingmax54212008/article/details/50811885\n\nhttps://www.cnblogs.com/hoobey/p/6078584.html\n\nhttps://blog.csdn.net/qianxing111/article/details/79884527\n\nhttp://www.it165.net/pro/html/201606/70831.html","source":"_posts/微信开发/2018-10-06-微信公众平台.md","raw":"---\ntitle: 微信公众平台使用\ntags:\n  - 微信公众平台 \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 微信\npassword:\n---\n# 官方文档\nhttps://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432\n\n# 接口整体介绍\n微信接口请求返回格式介绍：\n\n微信接口是通过GET方式请求\n返回数据格式为JSON\n\n# 测试号配置\n无需公众账号，可直接体验和测试公众平台所有高级接口。\n\n配置：\n1. 登录公众账号\n2. 开发>开发者工具>公众平台测试账号\n3. 微信扫一扫登录\n4. 配置URL、TOKEN、JS接口安全域名\n\n# 注意事项\n1. 接口频率限制说明\n2. 全局返回码说明\n\n网页授权登录：\n如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。\n\n两种scope模式：\n1. snsapi_base时只能获取到openid，静默授权，\n2. snsapi_userinfo时可获取到其他信息，需要用户手动同意授权的\n\n微信公众平台（互斥）\n1. 编辑模式\n2. 开发者模式-openid\n\n接入开发者模式步骤\n\n\n为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID\n如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID\n\n公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储\n公众平台接口调用仅支持80端口。\n\n网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）\n\n微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。\n\n\n调试接口可能需要取消关注之后才能看到最新的效果\n\n\nhttps://blog.csdn.net/z496007165/article/details/73239971\nhttp://www.php.cn/xiaochengxu-405121.html\n\n网页授权接口：\n授权回调页面域名：没有http，如：http://89495c4f.ngrok.io是错误的，应该是： 89495c4f.ngrok.io\n\n\n\nhttp://www.106jiekou.com/\n\n\nhttps://blog.csdn.net/kingmax54212008/article/details/50811885\n\nhttps://www.cnblogs.com/hoobey/p/6078584.html\n\nhttps://blog.csdn.net/qianxing111/article/details/79884527\n\nhttp://www.it165.net/pro/html/201606/70831.html","slug":"微信开发-2018-10-06-微信公众平台","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzq00595b8hahopbu78","content":"<h1 id=\"官方文档\"><a class=\"markdownIt-Anchor\" href=\"#官方文档\"></a> 官方文档</h1>\n<p><a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432</a></p>\n<h1 id=\"接口整体介绍\"><a class=\"markdownIt-Anchor\" href=\"#接口整体介绍\"></a> 接口整体介绍</h1>\n<p>微信接口请求返回格式介绍：</p>\n<p>微信接口是通过GET方式请求<br>\n返回数据格式为JSON</p>\n<h1 id=\"测试号配置\"><a class=\"markdownIt-Anchor\" href=\"#测试号配置\"></a> 测试号配置</h1>\n<p>无需公众账号，可直接体验和测试公众平台所有高级接口。</p>\n<p>配置：</p>\n<ol>\n<li>登录公众账号</li>\n<li>开发&gt;开发者工具&gt;公众平台测试账号</li>\n<li>微信扫一扫登录</li>\n<li>配置URL、TOKEN、JS接口安全域名</li>\n</ol>\n<h1 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h1>\n<ol>\n<li>接口频率限制说明</li>\n<li>全局返回码说明</li>\n</ol>\n<p>网页授权登录：<br>\n如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。</p>\n<p>两种scope模式：</p>\n<ol>\n<li>snsapi_base时只能获取到openid，静默授权，</li>\n<li>snsapi_userinfo时可获取到其他信息，需要用户手动同意授权的</li>\n</ol>\n<p>微信公众平台（互斥）</p>\n<ol>\n<li>编辑模式</li>\n<li>开发者模式-openid</li>\n</ol>\n<p>接入开发者模式步骤</p>\n<p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID<br>\n如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID</p>\n<p>公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储<br>\n公众平台接口调用仅支持80端口。</p>\n<p>网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）</p>\n<p>微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。</p>\n<p>调试接口可能需要取消关注之后才能看到最新的效果</p>\n<p><a href=\"https://blog.csdn.net/z496007165/article/details/73239971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/z496007165/article/details/73239971</a><br>\n<a href=\"http://www.php.cn/xiaochengxu-405121.html\" target=\"_blank\" rel=\"noopener\">http://www.php.cn/xiaochengxu-405121.html</a></p>\n<p>网页授权接口：<br>\n授权回调页面域名：没有http，如：<a href=\"http://89495c4f.ngrok.xn--io-k07di11djizfrl\" target=\"_blank\" rel=\"noopener\">http://89495c4f.ngrok.io是错误的</a>，应该是： <a href=\"http://89495c4f.ngrok.io\" target=\"_blank\" rel=\"noopener\">89495c4f.ngrok.io</a></p>\n<p><a href=\"http://www.106jiekou.com/\" target=\"_blank\" rel=\"noopener\">http://www.106jiekou.com/</a></p>\n<p><a href=\"https://blog.csdn.net/kingmax54212008/article/details/50811885\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kingmax54212008/article/details/50811885</a></p>\n<p><a href=\"https://www.cnblogs.com/hoobey/p/6078584.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hoobey/p/6078584.html</a></p>\n<p><a href=\"https://blog.csdn.net/qianxing111/article/details/79884527\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qianxing111/article/details/79884527</a></p>\n<p><a href=\"http://www.it165.net/pro/html/201606/70831.html\" target=\"_blank\" rel=\"noopener\">http://www.it165.net/pro/html/201606/70831.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"官方文档\"><a class=\"markdownIt-Anchor\" href=\"#官方文档\"></a> 官方文档</h1>\n<p><a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432</a></p>\n<h1 id=\"接口整体介绍\"><a class=\"markdownIt-Anchor\" href=\"#接口整体介绍\"></a> 接口整体介绍</h1>\n<p>微信接口请求返回格式介绍：</p>\n<p>微信接口是通过GET方式请求<br>\n返回数据格式为JSON</p>\n<h1 id=\"测试号配置\"><a class=\"markdownIt-Anchor\" href=\"#测试号配置\"></a> 测试号配置</h1>\n<p>无需公众账号，可直接体验和测试公众平台所有高级接口。</p>\n<p>配置：</p>\n<ol>\n<li>登录公众账号</li>\n<li>开发&gt;开发者工具&gt;公众平台测试账号</li>\n<li>微信扫一扫登录</li>\n<li>配置URL、TOKEN、JS接口安全域名</li>\n</ol>\n<h1 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h1>\n<ol>\n<li>接口频率限制说明</li>\n<li>全局返回码说明</li>\n</ol>\n<p>网页授权登录：<br>\n如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息。</p>\n<p>两种scope模式：</p>\n<ol>\n<li>snsapi_base时只能获取到openid，静默授权，</li>\n<li>snsapi_userinfo时可获取到其他信息，需要用户手动同意授权的</li>\n</ol>\n<p>微信公众平台（互斥）</p>\n<ol>\n<li>编辑模式</li>\n<li>开发者模式-openid</li>\n</ol>\n<p>接入开发者模式步骤</p>\n<p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID<br>\n如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID</p>\n<p>公众平台以access_token为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储<br>\n公众平台接口调用仅支持80端口。</p>\n<p>网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）</p>\n<p>微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。</p>\n<p>调试接口可能需要取消关注之后才能看到最新的效果</p>\n<p><a href=\"https://blog.csdn.net/z496007165/article/details/73239971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/z496007165/article/details/73239971</a><br>\n<a href=\"http://www.php.cn/xiaochengxu-405121.html\" target=\"_blank\" rel=\"noopener\">http://www.php.cn/xiaochengxu-405121.html</a></p>\n<p>网页授权接口：<br>\n授权回调页面域名：没有http，如：<a href=\"http://89495c4f.ngrok.xn--io-k07di11djizfrl\" target=\"_blank\" rel=\"noopener\">http://89495c4f.ngrok.io是错误的</a>，应该是： <a href=\"http://89495c4f.ngrok.io\" target=\"_blank\" rel=\"noopener\">89495c4f.ngrok.io</a></p>\n<p><a href=\"http://www.106jiekou.com/\" target=\"_blank\" rel=\"noopener\">http://www.106jiekou.com/</a></p>\n<p><a href=\"https://blog.csdn.net/kingmax54212008/article/details/50811885\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kingmax54212008/article/details/50811885</a></p>\n<p><a href=\"https://www.cnblogs.com/hoobey/p/6078584.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hoobey/p/6078584.html</a></p>\n<p><a href=\"https://blog.csdn.net/qianxing111/article/details/79884527\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qianxing111/article/details/79884527</a></p>\n<p><a href=\"http://www.it165.net/pro/html/201606/70831.html\" target=\"_blank\" rel=\"noopener\">http://www.it165.net/pro/html/201606/70831.html</a></p>\n"},{"title":"微信第三方登录","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T03:08:33.000Z","password":null,"_content":"\nhttps://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842\n\n用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。\n\nopen id：在关注者与公众号产生消息交互后，公众号可获得关注者的open id， 同一个用户，在不同公众号或移动应用下对应有不同open id标识；\nunion id：同一个用户，在不同公众号或移动应用下unionID相同；前提是，如若需要做多个公众号以及移动应用账户互通，得到唯一身份标识union id，则需要将多个公众号或移动应用在微信开放平台进行绑定，然后我们才能给拿到union id；\n\n微信联合登录；也就是我们常用的微信移动端/PC端之间的扫码登录，PC端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的open id或union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联；\n授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。\n\n\n","source":"_posts/微信开发/2018-10-06-微信第三方登录.md","raw":"---\ntitle: 微信第三方登录\ntags:\n  - 微信 \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 11:08:33\ncategories: 微信\npassword:\n---\n\nhttps://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842\n\n用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。\n\nopen id：在关注者与公众号产生消息交互后，公众号可获得关注者的open id， 同一个用户，在不同公众号或移动应用下对应有不同open id标识；\nunion id：同一个用户，在不同公众号或移动应用下unionID相同；前提是，如若需要做多个公众号以及移动应用账户互通，得到唯一身份标识union id，则需要将多个公众号或移动应用在微信开放平台进行绑定，然后我们才能给拿到union id；\n\n微信联合登录；也就是我们常用的微信移动端/PC端之间的扫码登录，PC端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的open id或union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联；\n授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。\n\n\n","slug":"微信开发-2018-10-06-微信第三方登录","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzv005d5b8hk5dv11n1","content":"<p><a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842</a></p>\n<p>用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>\n<p>open id：在关注者与公众号产生消息交互后，公众号可获得关注者的open id， 同一个用户，在不同公众号或移动应用下对应有不同open id标识；<br>\nunion id：同一个用户，在不同公众号或移动应用下unionID相同；前提是，如若需要做多个公众号以及移动应用账户互通，得到唯一身份标识union id，则需要将多个公众号或移动应用在微信开放平台进行绑定，然后我们才能给拿到union id；</p>\n<p>微信联合登录；也就是我们常用的微信移动端/PC端之间的扫码登录，PC端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的open id或union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联；<br>\n授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842</a></p>\n<p>用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>\n<p>open id：在关注者与公众号产生消息交互后，公众号可获得关注者的open id， 同一个用户，在不同公众号或移动应用下对应有不同open id标识；<br>\nunion id：同一个用户，在不同公众号或移动应用下unionID相同；前提是，如若需要做多个公众号以及移动应用账户互通，得到唯一身份标识union id，则需要将多个公众号或移动应用在微信开放平台进行绑定，然后我们才能给拿到union id；</p>\n<p>微信联合登录；也就是我们常用的微信移动端/PC端之间的扫码登录，PC端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的open id或union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联；<br>\n授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。</p>\n"},{"title":"AndroidStudio代码注释及Javadoc生成","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n[toc]\n\nhttps://www.jetbrains.com/help/idea/meet-intellij-idea.html\n\n# AS注释设置\n## 新建的类自动生成的注释\nFile–>Settings–>Editor–>File and code Template\n\n点击includes->File Header,修改内容为：\n~~~\n/**\n * @author ${USER}\n * @version ${VERSION}  \n * @description:   TODO (必填)\n * @date ${DATE}\n */\n~~~\n\n## 自定义注释模板\nFile–>Setting–>Editor–>LiveTemplate\n1. 新建一个Live Group\n2. 新建一个LIve Template\n3. 添加你的注释\n4. 点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值\n5. 选择你要运用的地方\n6. 点击Apply\n\n\n\n# Javadoc文档生成\nTools->Generate JavaDoc...\n\n1. 设置输出路径\n2. 设置Othere command line arguments参数： -encoding utf-8 -charset utf-8支持中文\n3. 其他设置参看设置界面","source":"_posts/微信开发/AndroidStudio代码注释及Javadoc生成.md","raw":"---\ntitle: AndroidStudio代码注释及Javadoc生成\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n[toc]\n\nhttps://www.jetbrains.com/help/idea/meet-intellij-idea.html\n\n# AS注释设置\n## 新建的类自动生成的注释\nFile–>Settings–>Editor–>File and code Template\n\n点击includes->File Header,修改内容为：\n~~~\n/**\n * @author ${USER}\n * @version ${VERSION}  \n * @description:   TODO (必填)\n * @date ${DATE}\n */\n~~~\n\n## 自定义注释模板\nFile–>Setting–>Editor–>LiveTemplate\n1. 新建一个Live Group\n2. 新建一个LIve Template\n3. 添加你的注释\n4. 点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值\n5. 选择你要运用的地方\n6. 点击Apply\n\n\n\n# Javadoc文档生成\nTools->Generate JavaDoc...\n\n1. 设置输出路径\n2. 设置Othere command line arguments参数： -encoding utf-8 -charset utf-8支持中文\n3. 其他设置参看设置界面","slug":"微信开发-AndroidStudio代码注释及Javadoc生成","published":1,"updated":"2019-02-14T09:05:58.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eudzz005f5b8h5awwvmba","content":"<p>[toc]</p>\n<p><a href=\"https://www.jetbrains.com/help/idea/meet-intellij-idea.html\" target=\"_blank\" rel=\"noopener\">https://www.jetbrains.com/help/idea/meet-intellij-idea.html</a></p>\n<h1 id=\"as注释设置\"><a class=\"markdownIt-Anchor\" href=\"#as注释设置\"></a> AS注释设置</h1>\n<h2 id=\"新建的类自动生成的注释\"><a class=\"markdownIt-Anchor\" href=\"#新建的类自动生成的注释\"></a> 新建的类自动生成的注释</h2>\n<p>File–&gt;Settings–&gt;Editor–&gt;File and code Template</p>\n<p>点击includes-&gt;File Header,修改内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author $&#123;USER&#125;</span><br><span class=\"line\"> * @version $&#123;VERSION&#125;  </span><br><span class=\"line\"> * @description:   TODO (必填)</span><br><span class=\"line\"> * @date $&#123;DATE&#125;</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义注释模板\"><a class=\"markdownIt-Anchor\" href=\"#自定义注释模板\"></a> 自定义注释模板</h2>\n<p>File–&gt;Setting–&gt;Editor–&gt;LiveTemplate</p>\n<ol>\n<li>新建一个Live Group</li>\n<li>新建一个LIve Template</li>\n<li>添加你的注释</li>\n<li>点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值</li>\n<li>选择你要运用的地方</li>\n<li>点击Apply</li>\n</ol>\n<h1 id=\"javadoc文档生成\"><a class=\"markdownIt-Anchor\" href=\"#javadoc文档生成\"></a> Javadoc文档生成</h1>\n<p>Tools-&gt;Generate JavaDoc…</p>\n<ol>\n<li>设置输出路径</li>\n<li>设置Othere command line arguments参数： -encoding utf-8 -charset utf-8支持中文</li>\n<li>其他设置参看设置界面</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p><a href=\"https://www.jetbrains.com/help/idea/meet-intellij-idea.html\" target=\"_blank\" rel=\"noopener\">https://www.jetbrains.com/help/idea/meet-intellij-idea.html</a></p>\n<h1 id=\"as注释设置\"><a class=\"markdownIt-Anchor\" href=\"#as注释设置\"></a> AS注释设置</h1>\n<h2 id=\"新建的类自动生成的注释\"><a class=\"markdownIt-Anchor\" href=\"#新建的类自动生成的注释\"></a> 新建的类自动生成的注释</h2>\n<p>File–&gt;Settings–&gt;Editor–&gt;File and code Template</p>\n<p>点击includes-&gt;File Header,修改内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author $&#123;USER&#125;</span><br><span class=\"line\"> * @version $&#123;VERSION&#125;  </span><br><span class=\"line\"> * @description:   TODO (必填)</span><br><span class=\"line\"> * @date $&#123;DATE&#125;</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义注释模板\"><a class=\"markdownIt-Anchor\" href=\"#自定义注释模板\"></a> 自定义注释模板</h2>\n<p>File–&gt;Setting–&gt;Editor–&gt;LiveTemplate</p>\n<ol>\n<li>新建一个Live Group</li>\n<li>新建一个LIve Template</li>\n<li>添加你的注释</li>\n<li>点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值</li>\n<li>选择你要运用的地方</li>\n<li>点击Apply</li>\n</ol>\n<h1 id=\"javadoc文档生成\"><a class=\"markdownIt-Anchor\" href=\"#javadoc文档生成\"></a> Javadoc文档生成</h1>\n<p>Tools-&gt;Generate JavaDoc…</p>\n<ol>\n<li>设置输出路径</li>\n<li>设置Othere command line arguments参数： -encoding utf-8 -charset utf-8支持中文</li>\n<li>其他设置参看设置界面</li>\n</ol>\n"},{"_content":"---\ntitle: Android中主题(Theme)和样式(Style)使用\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n--- \n\n[toc]\n\n# Theme和Style说明\n* Theme是全局的设计风格。style是局部的设计风格\n* Theme是一套UI控件和Activity的样式。可以给Application 和 activity 设置主题。来设置显示界面的样式\n* style是针对view来说的，比如 TextView，EditText这些，而Theme必须针对整个activity或者 整个application，你必须在AndroidManifest.xml中 的<application>或者<activity>中定义\n* Style的xml文件要求：\n~~~\n1. 他的根节点必须 是<resources>\n2. 给<style> 增加一个全局唯一的名字，也可以选择增加一个parent父类属性\n3. 使用时只要在写我们的view时，加入style标签就可以了\n    <TextView\n        style=\"@style/CodeFont\"\n        android:text=\"@string/hello\" />\n~~~\n\n# Theme设置\n## Theme设置\n~~~\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.jude.test.education\" >\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        <!--这里设置的是整个APP的主题，所有activiy和view都会默认为这个主题-->\n        android:theme=\"@style/AppTheme\" >\n        <activity\n            android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            <!--这里设置的是这个Activity的主题，Activity所有view都会默认为这个主题-->\n            android:theme=\"@style/AppTheme\"\n            >\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n~~~\n## Theme继承并重写\n在value->style里定义主题。可以继承并重写属性\n~~~\n<!-- 兼容主题 深色主题 activity背景默认黑色，字体默认白色-->\n<style name=\"AppTheme\" parent=\"Theme.AppCompat\">\n</style>\n\n<!-- 兼容主题 浅色主题 activity背景默认白色 字体默认黑色 -->\n<style name=\"AppTheme2\" parent=\"Theme.AppCompat.Light\">\n</style>\n\n<!-- 兼容主题 深色主题 无Actionbar-->\n<style name=\"AppTheme3\" parent=\"Theme.AppCompat.NoActionBar\">\n</style>\n\n<!-- 兼容主题 浅色主题 无Actionbar-->\n<style name=\"AppTheme4\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n</style>\n~~~\n\n## 代码中设置Activity主题\n* Activity 是 ContextThemeWrapper的子类。而ContextThemeWrapper一个很重要的属性就是Theme\n* 实例化一个View必须要 new View(Context context) 。因为View需要把Attributes交给Context的Theme来确定一堆属性(在一个叫TypedArray的容器里)\n\n## Theme设置注意事项\n* 如果使用 android.support.v7.app.ActionBarActivity 就必须要用兼容主题Theme.AppCompat。\n~~~\nActionBarActivity 的存在就是为了兼容低API。让他们用上高API的东西。比如Toolbar\n~~~\n* Holo主题是Android4.0开始谷歌极力推行的Android Design的主题\n~~~\n<style name=\"AppTheme5\" parent=\"android:Theme.Holo\">\n</style>\n~~~\n* Android5.0谷歌又推出了Material Design来取代Android Design\n~~~\n <style name=\"AppTheme5\" parent=\"android:Theme.Material\">\n</style>\n~~~\n\n# Theme来源\n在Android Studio中书写主题时都会有自动提示\n\n1. 来自Android系统自带的。自带的主题要加上“android:”，如：android:Theme.Black\n2. 来自兼容包的(比如v7兼容包)。使用v7兼容包中的主题不需要前缀，直接：Theme.AppCompat\n3. 自己写一个主题\n\n# Theme种类\n* 所有能应用于应用程序主题都是以“Theme.”开头\n* 在v7中有很多以“Base”开头的主题，是一些父主题，不建议直接使用\n~~~\n系统自带主题：\nAPI 1:\nandroid:Theme 根主题\nandroid:Theme.Black 背景黑色\nandroid:Theme.Light 背景白色\nandroid:Theme.Wallpaper 以桌面墙纸为背景\nandroid:Theme.Translucent 透明背景\nandroid:Theme.Panel 平板风格\nandroid:Theme.Dialog 对话框风格\n\nAPI 11:\nandroid:Theme.Holo Holo根主题\nandroid:Theme.Holo.Black Holo黑主题\nandroid:Theme.Holo.Light Holo白主题\n\nAPI 14:\nTheme.DeviceDefault 设备默认根主题\nTheme.DeviceDefault.Black 设备默认黑主题\nTheme.DeviceDefault.Light 设备默认白主题\n\nAPI 21: (网上常说的 Android Material Design 就是要用这种主题)\nTheme.Material Material根主题\nTheme.Material.Light Material白主题\n\n================================================================\n兼容包v7中带的主题：\nTheme.AppCompat 兼容主题的根主题\nTheme.AppCompat.Black 兼容主题的黑色主题\nTheme.AppCompat.Light 兼容主题的白色主题\n\n...\n~~~\n\n# Theme风格种类\n~~~\nBlack 黑色风格\nLight 光明风格\nDark 黑暗风格\nDayNight 白昼风格\nWallpaper 墙纸为背景\nTranslucent 透明背景\nPanel 平板风格\nDialog 对话框风格\nNoTitleBar 没有TitleBar\nNoActionBar 没有ActionBar\nFullscreen 全屏风格\nMinWidth 对话框或者ActionBar的宽度根据内容变化，而不是充满全屏\nWhenLarge 对话框充满全屏\nTranslucentDecor 半透明风格\nNoDisplay 不显示，也就是隐藏了\nWithActionBar 在旧版主题上显示ActionBar\n~~~\n\n# 每个主题中定义item分类\nhttps://yq.aliyun.com/articles/72108\n\n颜色、字体、按钮、list、window、Dialog、AlertDialog、Panel、滚动条、文字选中（Text Selection）、Widget样式、Preference样式、search控件样式、ActionBar样式、其他样式\n ","source":"_posts/微信开发/Android中主题(Theme)和样式(Style)使用.md","raw":"---\ntitle: Android中主题(Theme)和样式(Style)使用\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n--- \n\n[toc]\n\n# Theme和Style说明\n* Theme是全局的设计风格。style是局部的设计风格\n* Theme是一套UI控件和Activity的样式。可以给Application 和 activity 设置主题。来设置显示界面的样式\n* style是针对view来说的，比如 TextView，EditText这些，而Theme必须针对整个activity或者 整个application，你必须在AndroidManifest.xml中 的<application>或者<activity>中定义\n* Style的xml文件要求：\n~~~\n1. 他的根节点必须 是<resources>\n2. 给<style> 增加一个全局唯一的名字，也可以选择增加一个parent父类属性\n3. 使用时只要在写我们的view时，加入style标签就可以了\n    <TextView\n        style=\"@style/CodeFont\"\n        android:text=\"@string/hello\" />\n~~~\n\n# Theme设置\n## Theme设置\n~~~\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.jude.test.education\" >\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        <!--这里设置的是整个APP的主题，所有activiy和view都会默认为这个主题-->\n        android:theme=\"@style/AppTheme\" >\n        <activity\n            android:name=\".MainActivity\"\n            android:label=\"@string/app_name\"\n            <!--这里设置的是这个Activity的主题，Activity所有view都会默认为这个主题-->\n            android:theme=\"@style/AppTheme\"\n            >\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n~~~\n## Theme继承并重写\n在value->style里定义主题。可以继承并重写属性\n~~~\n<!-- 兼容主题 深色主题 activity背景默认黑色，字体默认白色-->\n<style name=\"AppTheme\" parent=\"Theme.AppCompat\">\n</style>\n\n<!-- 兼容主题 浅色主题 activity背景默认白色 字体默认黑色 -->\n<style name=\"AppTheme2\" parent=\"Theme.AppCompat.Light\">\n</style>\n\n<!-- 兼容主题 深色主题 无Actionbar-->\n<style name=\"AppTheme3\" parent=\"Theme.AppCompat.NoActionBar\">\n</style>\n\n<!-- 兼容主题 浅色主题 无Actionbar-->\n<style name=\"AppTheme4\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n</style>\n~~~\n\n## 代码中设置Activity主题\n* Activity 是 ContextThemeWrapper的子类。而ContextThemeWrapper一个很重要的属性就是Theme\n* 实例化一个View必须要 new View(Context context) 。因为View需要把Attributes交给Context的Theme来确定一堆属性(在一个叫TypedArray的容器里)\n\n## Theme设置注意事项\n* 如果使用 android.support.v7.app.ActionBarActivity 就必须要用兼容主题Theme.AppCompat。\n~~~\nActionBarActivity 的存在就是为了兼容低API。让他们用上高API的东西。比如Toolbar\n~~~\n* Holo主题是Android4.0开始谷歌极力推行的Android Design的主题\n~~~\n<style name=\"AppTheme5\" parent=\"android:Theme.Holo\">\n</style>\n~~~\n* Android5.0谷歌又推出了Material Design来取代Android Design\n~~~\n <style name=\"AppTheme5\" parent=\"android:Theme.Material\">\n</style>\n~~~\n\n# Theme来源\n在Android Studio中书写主题时都会有自动提示\n\n1. 来自Android系统自带的。自带的主题要加上“android:”，如：android:Theme.Black\n2. 来自兼容包的(比如v7兼容包)。使用v7兼容包中的主题不需要前缀，直接：Theme.AppCompat\n3. 自己写一个主题\n\n# Theme种类\n* 所有能应用于应用程序主题都是以“Theme.”开头\n* 在v7中有很多以“Base”开头的主题，是一些父主题，不建议直接使用\n~~~\n系统自带主题：\nAPI 1:\nandroid:Theme 根主题\nandroid:Theme.Black 背景黑色\nandroid:Theme.Light 背景白色\nandroid:Theme.Wallpaper 以桌面墙纸为背景\nandroid:Theme.Translucent 透明背景\nandroid:Theme.Panel 平板风格\nandroid:Theme.Dialog 对话框风格\n\nAPI 11:\nandroid:Theme.Holo Holo根主题\nandroid:Theme.Holo.Black Holo黑主题\nandroid:Theme.Holo.Light Holo白主题\n\nAPI 14:\nTheme.DeviceDefault 设备默认根主题\nTheme.DeviceDefault.Black 设备默认黑主题\nTheme.DeviceDefault.Light 设备默认白主题\n\nAPI 21: (网上常说的 Android Material Design 就是要用这种主题)\nTheme.Material Material根主题\nTheme.Material.Light Material白主题\n\n================================================================\n兼容包v7中带的主题：\nTheme.AppCompat 兼容主题的根主题\nTheme.AppCompat.Black 兼容主题的黑色主题\nTheme.AppCompat.Light 兼容主题的白色主题\n\n...\n~~~\n\n# Theme风格种类\n~~~\nBlack 黑色风格\nLight 光明风格\nDark 黑暗风格\nDayNight 白昼风格\nWallpaper 墙纸为背景\nTranslucent 透明背景\nPanel 平板风格\nDialog 对话框风格\nNoTitleBar 没有TitleBar\nNoActionBar 没有ActionBar\nFullscreen 全屏风格\nMinWidth 对话框或者ActionBar的宽度根据内容变化，而不是充满全屏\nWhenLarge 对话框充满全屏\nTranslucentDecor 半透明风格\nNoDisplay 不显示，也就是隐藏了\nWithActionBar 在旧版主题上显示ActionBar\n~~~\n\n# 每个主题中定义item分类\nhttps://yq.aliyun.com/articles/72108\n\n颜色、字体、按钮、list、window、Dialog、AlertDialog、Panel、滚动条、文字选中（Text Selection）、Widget样式、Preference样式、search控件样式、ActionBar样式、其他样式\n ","slug":"微信开发-Android中主题-Theme-和样式-Style-使用","published":1,"date":"2019-02-14T09:04:41.000Z","updated":"2019-02-14T09:04:41.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs4eue01005j5b8hl0hk6adg","content":"<hr>\n<p>title: Android中主题(Theme)和样式(Style)使用<br>\ntags:</p>\n<ul>\n<li>android<br>\ncopyright: true<br>\ncomments: true<br>\ntoc: true<br>\ndate: 2018-10-06 12:13:04<br>\ncategories: 移动开发<br>\npassword:</li>\n</ul>\n<hr>\n<p>[toc]</p>\n<h1 id=\"theme和style说明\"><a class=\"markdownIt-Anchor\" href=\"#theme和style说明\"></a> Theme和Style说明</h1>\n<ul>\n<li>Theme是全局的设计风格。style是局部的设计风格</li>\n<li>Theme是一套UI控件和Activity的样式。可以给Application 和 activity 设置主题。来设置显示界面的样式</li>\n<li>style是针对view来说的，比如 TextView，EditText这些，而Theme必须针对整个activity或者 整个application，你必须在AndroidManifest.xml中 的<application>或者<activity>中定义</activity></application></li>\n<li>Style的xml文件要求：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 他的根节点必须 是&lt;resources&gt;</span><br><span class=\"line\">2. 给&lt;style&gt; 增加一个全局唯一的名字，也可以选择增加一个parent父类属性</span><br><span class=\"line\">3. 使用时只要在写我们的view时，加入style标签就可以了</span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        style=&quot;@style/CodeFont&quot;</span><br><span class=\"line\">        android:text=&quot;@string/hello&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"theme设置\"><a class=\"markdownIt-Anchor\" href=\"#theme设置\"></a> Theme设置</h1>\n<h2 id=\"theme设置-2\"><a class=\"markdownIt-Anchor\" href=\"#theme设置-2\"></a> Theme设置</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    package=&quot;com.jude.test.education&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;application</span><br><span class=\"line\">        android:allowBackup=&quot;true&quot;</span><br><span class=\"line\">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class=\"line\">        android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">        &lt;!--这里设置的是整个APP的主题，所有activiy和view都会默认为这个主题--&gt;</span><br><span class=\"line\">        android:theme=&quot;@style/AppTheme&quot; &gt;</span><br><span class=\"line\">        &lt;activity</span><br><span class=\"line\">            android:name=&quot;.MainActivity&quot;</span><br><span class=\"line\">            android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">            &lt;!--这里设置的是这个Activity的主题，Activity所有view都会默认为这个主题--&gt;</span><br><span class=\"line\">            android:theme=&quot;@style/AppTheme&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"theme继承并重写\"><a class=\"markdownIt-Anchor\" href=\"#theme继承并重写\"></a> Theme继承并重写</h2>\n<p>在value-&gt;style里定义主题。可以继承并重写属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 兼容主题 深色主题 activity背景默认黑色，字体默认白色--&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 兼容主题 浅色主题 activity背景默认白色 字体默认黑色 --&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme2&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 兼容主题 深色主题 无Actionbar--&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme3&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 兼容主题 浅色主题 无Actionbar--&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme4&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码中设置activity主题\"><a class=\"markdownIt-Anchor\" href=\"#代码中设置activity主题\"></a> 代码中设置Activity主题</h2>\n<ul>\n<li>Activity 是 ContextThemeWrapper的子类。而ContextThemeWrapper一个很重要的属性就是Theme</li>\n<li>实例化一个View必须要 new View(Context context) 。因为View需要把Attributes交给Context的Theme来确定一堆属性(在一个叫TypedArray的容器里)</li>\n</ul>\n<h2 id=\"theme设置注意事项\"><a class=\"markdownIt-Anchor\" href=\"#theme设置注意事项\"></a> Theme设置注意事项</h2>\n<ul>\n<li>如果使用 android.support.v7.app.ActionBarActivity 就必须要用兼容主题Theme.AppCompat。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActionBarActivity 的存在就是为了兼容低API。让他们用上高API的东西。比如Toolbar</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Holo主题是Android4.0开始谷歌极力推行的Android Design的主题</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style name=&quot;AppTheme5&quot; parent=&quot;android:Theme.Holo&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Android5.0谷歌又推出了Material Design来取代Android Design</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;style name=&quot;AppTheme5&quot; parent=&quot;android:Theme.Material&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"theme来源\"><a class=\"markdownIt-Anchor\" href=\"#theme来源\"></a> Theme来源</h1>\n<p>在Android Studio中书写主题时都会有自动提示</p>\n<ol>\n<li>来自Android系统自带的。自带的主题要加上“android:”，如：android:Theme.Black</li>\n<li>来自兼容包的(比如v7兼容包)。使用v7兼容包中的主题不需要前缀，直接：Theme.AppCompat</li>\n<li>自己写一个主题</li>\n</ol>\n<h1 id=\"theme种类\"><a class=\"markdownIt-Anchor\" href=\"#theme种类\"></a> Theme种类</h1>\n<ul>\n<li>所有能应用于应用程序主题都是以“Theme.”开头</li>\n<li>在v7中有很多以“Base”开头的主题，是一些父主题，不建议直接使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统自带主题：</span><br><span class=\"line\">API 1:</span><br><span class=\"line\">android:Theme 根主题</span><br><span class=\"line\">android:Theme.Black 背景黑色</span><br><span class=\"line\">android:Theme.Light 背景白色</span><br><span class=\"line\">android:Theme.Wallpaper 以桌面墙纸为背景</span><br><span class=\"line\">android:Theme.Translucent 透明背景</span><br><span class=\"line\">android:Theme.Panel 平板风格</span><br><span class=\"line\">android:Theme.Dialog 对话框风格</span><br><span class=\"line\"></span><br><span class=\"line\">API 11:</span><br><span class=\"line\">android:Theme.Holo Holo根主题</span><br><span class=\"line\">android:Theme.Holo.Black Holo黑主题</span><br><span class=\"line\">android:Theme.Holo.Light Holo白主题</span><br><span class=\"line\"></span><br><span class=\"line\">API 14:</span><br><span class=\"line\">Theme.DeviceDefault 设备默认根主题</span><br><span class=\"line\">Theme.DeviceDefault.Black 设备默认黑主题</span><br><span class=\"line\">Theme.DeviceDefault.Light 设备默认白主题</span><br><span class=\"line\"></span><br><span class=\"line\">API 21: (网上常说的 Android Material Design 就是要用这种主题)</span><br><span class=\"line\">Theme.Material Material根主题</span><br><span class=\"line\">Theme.Material.Light Material白主题</span><br><span class=\"line\"></span><br><span class=\"line\">================================================================</span><br><span class=\"line\">兼容包v7中带的主题：</span><br><span class=\"line\">Theme.AppCompat 兼容主题的根主题</span><br><span class=\"line\">Theme.AppCompat.Black 兼容主题的黑色主题</span><br><span class=\"line\">Theme.AppCompat.Light 兼容主题的白色主题</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h1 id=\"theme风格种类\"><a class=\"markdownIt-Anchor\" href=\"#theme风格种类\"></a> Theme风格种类</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Black 黑色风格</span><br><span class=\"line\">Light 光明风格</span><br><span class=\"line\">Dark 黑暗风格</span><br><span class=\"line\">DayNight 白昼风格</span><br><span class=\"line\">Wallpaper 墙纸为背景</span><br><span class=\"line\">Translucent 透明背景</span><br><span class=\"line\">Panel 平板风格</span><br><span class=\"line\">Dialog 对话框风格</span><br><span class=\"line\">NoTitleBar 没有TitleBar</span><br><span class=\"line\">NoActionBar 没有ActionBar</span><br><span class=\"line\">Fullscreen 全屏风格</span><br><span class=\"line\">MinWidth 对话框或者ActionBar的宽度根据内容变化，而不是充满全屏</span><br><span class=\"line\">WhenLarge 对话框充满全屏</span><br><span class=\"line\">TranslucentDecor 半透明风格</span><br><span class=\"line\">NoDisplay 不显示，也就是隐藏了</span><br><span class=\"line\">WithActionBar 在旧版主题上显示ActionBar</span><br></pre></td></tr></table></figure>\n<h1 id=\"每个主题中定义item分类\"><a class=\"markdownIt-Anchor\" href=\"#每个主题中定义item分类\"></a> 每个主题中定义item分类</h1>\n<p><a href=\"https://yq.aliyun.com/articles/72108\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/72108</a></p>\n<p>颜色、字体、按钮、list、window、Dialog、AlertDialog、Panel、滚动条、文字选中（Text Selection）、Widget样式、Preference样式、search控件样式、ActionBar样式、其他样式</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>title: Android中主题(Theme)和样式(Style)使用<br>\ntags:</p>\n<ul>\n<li>android<br>\ncopyright: true<br>\ncomments: true<br>\ntoc: true<br>\ndate: 2018-10-06 12:13:04<br>\ncategories: 移动开发<br>\npassword:</li>\n</ul>\n<hr>\n<p>[toc]</p>\n<h1 id=\"theme和style说明\"><a class=\"markdownIt-Anchor\" href=\"#theme和style说明\"></a> Theme和Style说明</h1>\n<ul>\n<li>Theme是全局的设计风格。style是局部的设计风格</li>\n<li>Theme是一套UI控件和Activity的样式。可以给Application 和 activity 设置主题。来设置显示界面的样式</li>\n<li>style是针对view来说的，比如 TextView，EditText这些，而Theme必须针对整个activity或者 整个application，你必须在AndroidManifest.xml中 的<application>或者<activity>中定义</activity></application></li>\n<li>Style的xml文件要求：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 他的根节点必须 是&lt;resources&gt;</span><br><span class=\"line\">2. 给&lt;style&gt; 增加一个全局唯一的名字，也可以选择增加一个parent父类属性</span><br><span class=\"line\">3. 使用时只要在写我们的view时，加入style标签就可以了</span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        style=&quot;@style/CodeFont&quot;</span><br><span class=\"line\">        android:text=&quot;@string/hello&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"theme设置\"><a class=\"markdownIt-Anchor\" href=\"#theme设置\"></a> Theme设置</h1>\n<h2 id=\"theme设置-2\"><a class=\"markdownIt-Anchor\" href=\"#theme设置-2\"></a> Theme设置</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    package=&quot;com.jude.test.education&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;application</span><br><span class=\"line\">        android:allowBackup=&quot;true&quot;</span><br><span class=\"line\">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class=\"line\">        android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">        &lt;!--这里设置的是整个APP的主题，所有activiy和view都会默认为这个主题--&gt;</span><br><span class=\"line\">        android:theme=&quot;@style/AppTheme&quot; &gt;</span><br><span class=\"line\">        &lt;activity</span><br><span class=\"line\">            android:name=&quot;.MainActivity&quot;</span><br><span class=\"line\">            android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">            &lt;!--这里设置的是这个Activity的主题，Activity所有view都会默认为这个主题--&gt;</span><br><span class=\"line\">            android:theme=&quot;@style/AppTheme&quot;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"theme继承并重写\"><a class=\"markdownIt-Anchor\" href=\"#theme继承并重写\"></a> Theme继承并重写</h2>\n<p>在value-&gt;style里定义主题。可以继承并重写属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 兼容主题 深色主题 activity背景默认黑色，字体默认白色--&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 兼容主题 浅色主题 activity背景默认白色 字体默认黑色 --&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme2&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 兼容主题 深色主题 无Actionbar--&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme3&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 兼容主题 浅色主题 无Actionbar--&gt;</span><br><span class=\"line\">&lt;style name=&quot;AppTheme4&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码中设置activity主题\"><a class=\"markdownIt-Anchor\" href=\"#代码中设置activity主题\"></a> 代码中设置Activity主题</h2>\n<ul>\n<li>Activity 是 ContextThemeWrapper的子类。而ContextThemeWrapper一个很重要的属性就是Theme</li>\n<li>实例化一个View必须要 new View(Context context) 。因为View需要把Attributes交给Context的Theme来确定一堆属性(在一个叫TypedArray的容器里)</li>\n</ul>\n<h2 id=\"theme设置注意事项\"><a class=\"markdownIt-Anchor\" href=\"#theme设置注意事项\"></a> Theme设置注意事项</h2>\n<ul>\n<li>如果使用 android.support.v7.app.ActionBarActivity 就必须要用兼容主题Theme.AppCompat。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActionBarActivity 的存在就是为了兼容低API。让他们用上高API的东西。比如Toolbar</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Holo主题是Android4.0开始谷歌极力推行的Android Design的主题</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style name=&quot;AppTheme5&quot; parent=&quot;android:Theme.Holo&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Android5.0谷歌又推出了Material Design来取代Android Design</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;style name=&quot;AppTheme5&quot; parent=&quot;android:Theme.Material&quot;&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"theme来源\"><a class=\"markdownIt-Anchor\" href=\"#theme来源\"></a> Theme来源</h1>\n<p>在Android Studio中书写主题时都会有自动提示</p>\n<ol>\n<li>来自Android系统自带的。自带的主题要加上“android:”，如：android:Theme.Black</li>\n<li>来自兼容包的(比如v7兼容包)。使用v7兼容包中的主题不需要前缀，直接：Theme.AppCompat</li>\n<li>自己写一个主题</li>\n</ol>\n<h1 id=\"theme种类\"><a class=\"markdownIt-Anchor\" href=\"#theme种类\"></a> Theme种类</h1>\n<ul>\n<li>所有能应用于应用程序主题都是以“Theme.”开头</li>\n<li>在v7中有很多以“Base”开头的主题，是一些父主题，不建议直接使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统自带主题：</span><br><span class=\"line\">API 1:</span><br><span class=\"line\">android:Theme 根主题</span><br><span class=\"line\">android:Theme.Black 背景黑色</span><br><span class=\"line\">android:Theme.Light 背景白色</span><br><span class=\"line\">android:Theme.Wallpaper 以桌面墙纸为背景</span><br><span class=\"line\">android:Theme.Translucent 透明背景</span><br><span class=\"line\">android:Theme.Panel 平板风格</span><br><span class=\"line\">android:Theme.Dialog 对话框风格</span><br><span class=\"line\"></span><br><span class=\"line\">API 11:</span><br><span class=\"line\">android:Theme.Holo Holo根主题</span><br><span class=\"line\">android:Theme.Holo.Black Holo黑主题</span><br><span class=\"line\">android:Theme.Holo.Light Holo白主题</span><br><span class=\"line\"></span><br><span class=\"line\">API 14:</span><br><span class=\"line\">Theme.DeviceDefault 设备默认根主题</span><br><span class=\"line\">Theme.DeviceDefault.Black 设备默认黑主题</span><br><span class=\"line\">Theme.DeviceDefault.Light 设备默认白主题</span><br><span class=\"line\"></span><br><span class=\"line\">API 21: (网上常说的 Android Material Design 就是要用这种主题)</span><br><span class=\"line\">Theme.Material Material根主题</span><br><span class=\"line\">Theme.Material.Light Material白主题</span><br><span class=\"line\"></span><br><span class=\"line\">================================================================</span><br><span class=\"line\">兼容包v7中带的主题：</span><br><span class=\"line\">Theme.AppCompat 兼容主题的根主题</span><br><span class=\"line\">Theme.AppCompat.Black 兼容主题的黑色主题</span><br><span class=\"line\">Theme.AppCompat.Light 兼容主题的白色主题</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h1 id=\"theme风格种类\"><a class=\"markdownIt-Anchor\" href=\"#theme风格种类\"></a> Theme风格种类</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Black 黑色风格</span><br><span class=\"line\">Light 光明风格</span><br><span class=\"line\">Dark 黑暗风格</span><br><span class=\"line\">DayNight 白昼风格</span><br><span class=\"line\">Wallpaper 墙纸为背景</span><br><span class=\"line\">Translucent 透明背景</span><br><span class=\"line\">Panel 平板风格</span><br><span class=\"line\">Dialog 对话框风格</span><br><span class=\"line\">NoTitleBar 没有TitleBar</span><br><span class=\"line\">NoActionBar 没有ActionBar</span><br><span class=\"line\">Fullscreen 全屏风格</span><br><span class=\"line\">MinWidth 对话框或者ActionBar的宽度根据内容变化，而不是充满全屏</span><br><span class=\"line\">WhenLarge 对话框充满全屏</span><br><span class=\"line\">TranslucentDecor 半透明风格</span><br><span class=\"line\">NoDisplay 不显示，也就是隐藏了</span><br><span class=\"line\">WithActionBar 在旧版主题上显示ActionBar</span><br></pre></td></tr></table></figure>\n<h1 id=\"每个主题中定义item分类\"><a class=\"markdownIt-Anchor\" href=\"#每个主题中定义item分类\"></a> 每个主题中定义item分类</h1>\n<p><a href=\"https://yq.aliyun.com/articles/72108\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/72108</a></p>\n<p>颜色、字体、按钮、list、window、Dialog、AlertDialog、Panel、滚动条、文字选中（Text Selection）、Widget样式、Preference样式、search控件样式、ActionBar样式、其他样式</p>\n"},{"title":"Android res文件夹解析","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"[toc]\n\nhttps://blog.csdn.net/ws00801526/article/details/10449621\n\n# 说明\nAS中Gradle默认不创建asserts文件夹，但他的路径已经存在于main 文件夹下面了，也可通过sourceSets属性在gradle中配置工程结构\nhttps://github.com/ShinChven/MigrateToGradle\n\n# 自定义文件夹\nandroid项目中的资源文件支持拓展:定义资源文件夹名-拓展属性,拓展属性包括以下内容\n\n* 语言   -en -es\n* 区域   -rCN\n* 屏幕方向  -port  -land  -square\n* 屏幕密度 -92dpi \n* 用户是否可以使用键盘  -keysexposed,-keyshidden\n* 默认的文字输入方法  -nokeys,-qwerty\n* 默认的非触摸导航方法  -notouch,-dpad\n* 屏幕尺寸  -324x240,-640x480 较大尺寸必须首先声明\n* 触摸屏类型  -notouch ,-finger,-stylus\n* 版本号   -V4  ,-V7\n\n注意事项:值之间-号连接,大小写敏感,同一类型只能有一个值 \n \n# valuse资源文件\n## 文件说明\n~~~\nstrings.xml\n\t\t\t作用:定义字符串\n\t\t\t定义格式:<string name=\"xxx\">字符串值</string>\n\t\t\t支持占用符  例子:  <string name=\"xxx\">今天%1$s,温度%2$d</string>\n\t\t\t%1 %2---代表参数所在位置\n\t\t\t$s,$d代表参数,s,d为参数类型\n\t\t\tgetString(R.string.xxx,\"星期一\",20) = 今天星期一,温度20\n\t\t\t使用方法:资源文件中   @string/xxx\n\t\t\t代码中   getString(R.string.xxx)\n\t\tarrays.xml\n\t\t\t作用:定义数组,可以是int,string,char\n\t\t\t定义格式:<type-array name=\"xxx\">\n\t\t\t<item>数组元素值</item>\n\t\t\t</type-array>\n\t\t\t使用方法:资源文件中   不支持引用\n\t\t\t代码中   type s[] = getResource.getTypeArray(R.array.xxx)\n\t\tcolors.xml\n\t\t\t作用:定义颜色\n\t\t\t定义格式:<color name=\"xxx\">#color值</color>\n\t\t\t使用方法:资源文件中 @color/xxx\n\t\t\t代码中getResource.getColor(R.color.xxx) 或者\n\t\t\tgetresource.getDrawable(R.color.xxx)\n\t\tdimens.xml\n\t\t\t作用:定义尺寸大小\n\t\t\t定义格式:<dimen name=\"xxx\">值</dimen>\n\t\t\t使用方法:资源文件中 @dimen/xxx\n\t\t\t代码中  getResource.getDimension(R.dimen.xxx)\n\t\tstyles.xml\n\t\t\t作用:定义试图样式\n\t\t\t定义格式:<style name=\"xxx\"  parent=\"yyy\">\n            \t\t\t<item name=\"xxx2\">元素值</item>\n            \t\t</style>\n~~~\n## 适配API\nAS的Project视图时，会有valuse与valuse-V(XX)文件夹；Android视图时，有时valuse资源文件下的xml文件会有多个，如多个strings.xml文件，其使用规则如下：\n* values: 是缺省的文件夹且最后被匹配的，它包含在value是-X中没有包含的API水平。一般缺省都使用这个文件夹\n* value-11: 针对API在11以上和13以上的，如果values-14存在的话。如果values-14不存在，则API 11以上都要使用该文件夹。另外API在11以下则无法使用该文件夹\n* 开发中只需要在VXX中指定特殊的，其他的全放在values即可\n\n# drawable文件夹\n* 作用:存放各种图片类型,不能纯数字定义文件名,另可以新建.xml文件类型  通常自定义控件样式时会在此文件夹中新建个.xml格式文件作为背景图\n* 使用方法:\n~~~\ngetDrawable(R.drawable.xxx)\n~~~\n\n# layout文件夹\n## 基本使用\n* 作用:存放各种布局文件\n* 使用方法:\n~~~\nsetcontentView(R.layout.xxx) ;\nView view = LayoutInflater.from(context).inflate(R.layout.xxx,null)\n~~~\n\n## 建立子文件夹\n* AS中layout只能在project视图下有效，android目录下无效\n* 'src/main/res/layout','src/main/res'为必写项，必须放到最后\n\n在这个module的build.gradle文件下添加以下代码:\n~~~\nsourceSets {\n    main {\n        res.srcDirs =\n                [\n                    'src/main/res/layout/main', \n                    'src/main/res/layout/dialog',\n                    ...\n                //下面两个是固定兼容写法，必须放到最后\n                    'src/main/res/layout',\n                    'src/main/res'\n                ]\n    }\n}\n~~~\n\n# xml文件夹\n* 作用:存放各种xml文件,例如使用PreferenceFragment时需要在此xml文件夹中建立个preferenceFragment使用的.xml文件\n* 使用方法:\n~~~\nXmlResoutceParser xml = getResources().getXml(R.xml.xxx)\n~~~\n\n# assets文件夹\n* 创建：右键new-->Folder-->AssetsFolder\n* assets目录是Android的一种特殊目录，用于放置APP所需的固定文件，且该文件被打包到APK中时，不会被编码到二进制文件\n* assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取\n* assets下可以有多级目录\n* assets目录下资源不会被二进制编码\n* 使用方法:\n~~~\nInputStream read =getAssets().open(R.assets.xxx)\nOutputStream write = getAssets().open(R.assets.xxx)\n~~~\n\n# raw文件夹\n需自行创建\n* res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源\n* res/raw下不可以有多级目录\n* res/raw不会被编码\n* 使用方法:\n~~~\nInputStream read = getResources().openRawResource(R.raw.xxx)\nOutputStream write = getResources().openRawResource(R.raw.xxx)\n~~~\n\n# anim文件夹\n需自行创建\n* 作用:存放各种自定义动画格式\n* 使用方法\n~~~\ngetResources().getAnimation(R.anim.xxx)\n~~~\n\n ","source":"_posts/微信开发/Android res文件夹解析.md","raw":"---\ntitle: Android res文件夹解析\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n[toc]\n\nhttps://blog.csdn.net/ws00801526/article/details/10449621\n\n# 说明\nAS中Gradle默认不创建asserts文件夹，但他的路径已经存在于main 文件夹下面了，也可通过sourceSets属性在gradle中配置工程结构\nhttps://github.com/ShinChven/MigrateToGradle\n\n# 自定义文件夹\nandroid项目中的资源文件支持拓展:定义资源文件夹名-拓展属性,拓展属性包括以下内容\n\n* 语言   -en -es\n* 区域   -rCN\n* 屏幕方向  -port  -land  -square\n* 屏幕密度 -92dpi \n* 用户是否可以使用键盘  -keysexposed,-keyshidden\n* 默认的文字输入方法  -nokeys,-qwerty\n* 默认的非触摸导航方法  -notouch,-dpad\n* 屏幕尺寸  -324x240,-640x480 较大尺寸必须首先声明\n* 触摸屏类型  -notouch ,-finger,-stylus\n* 版本号   -V4  ,-V7\n\n注意事项:值之间-号连接,大小写敏感,同一类型只能有一个值 \n \n# valuse资源文件\n## 文件说明\n~~~\nstrings.xml\n\t\t\t作用:定义字符串\n\t\t\t定义格式:<string name=\"xxx\">字符串值</string>\n\t\t\t支持占用符  例子:  <string name=\"xxx\">今天%1$s,温度%2$d</string>\n\t\t\t%1 %2---代表参数所在位置\n\t\t\t$s,$d代表参数,s,d为参数类型\n\t\t\tgetString(R.string.xxx,\"星期一\",20) = 今天星期一,温度20\n\t\t\t使用方法:资源文件中   @string/xxx\n\t\t\t代码中   getString(R.string.xxx)\n\t\tarrays.xml\n\t\t\t作用:定义数组,可以是int,string,char\n\t\t\t定义格式:<type-array name=\"xxx\">\n\t\t\t<item>数组元素值</item>\n\t\t\t</type-array>\n\t\t\t使用方法:资源文件中   不支持引用\n\t\t\t代码中   type s[] = getResource.getTypeArray(R.array.xxx)\n\t\tcolors.xml\n\t\t\t作用:定义颜色\n\t\t\t定义格式:<color name=\"xxx\">#color值</color>\n\t\t\t使用方法:资源文件中 @color/xxx\n\t\t\t代码中getResource.getColor(R.color.xxx) 或者\n\t\t\tgetresource.getDrawable(R.color.xxx)\n\t\tdimens.xml\n\t\t\t作用:定义尺寸大小\n\t\t\t定义格式:<dimen name=\"xxx\">值</dimen>\n\t\t\t使用方法:资源文件中 @dimen/xxx\n\t\t\t代码中  getResource.getDimension(R.dimen.xxx)\n\t\tstyles.xml\n\t\t\t作用:定义试图样式\n\t\t\t定义格式:<style name=\"xxx\"  parent=\"yyy\">\n            \t\t\t<item name=\"xxx2\">元素值</item>\n            \t\t</style>\n~~~\n## 适配API\nAS的Project视图时，会有valuse与valuse-V(XX)文件夹；Android视图时，有时valuse资源文件下的xml文件会有多个，如多个strings.xml文件，其使用规则如下：\n* values: 是缺省的文件夹且最后被匹配的，它包含在value是-X中没有包含的API水平。一般缺省都使用这个文件夹\n* value-11: 针对API在11以上和13以上的，如果values-14存在的话。如果values-14不存在，则API 11以上都要使用该文件夹。另外API在11以下则无法使用该文件夹\n* 开发中只需要在VXX中指定特殊的，其他的全放在values即可\n\n# drawable文件夹\n* 作用:存放各种图片类型,不能纯数字定义文件名,另可以新建.xml文件类型  通常自定义控件样式时会在此文件夹中新建个.xml格式文件作为背景图\n* 使用方法:\n~~~\ngetDrawable(R.drawable.xxx)\n~~~\n\n# layout文件夹\n## 基本使用\n* 作用:存放各种布局文件\n* 使用方法:\n~~~\nsetcontentView(R.layout.xxx) ;\nView view = LayoutInflater.from(context).inflate(R.layout.xxx,null)\n~~~\n\n## 建立子文件夹\n* AS中layout只能在project视图下有效，android目录下无效\n* 'src/main/res/layout','src/main/res'为必写项，必须放到最后\n\n在这个module的build.gradle文件下添加以下代码:\n~~~\nsourceSets {\n    main {\n        res.srcDirs =\n                [\n                    'src/main/res/layout/main', \n                    'src/main/res/layout/dialog',\n                    ...\n                //下面两个是固定兼容写法，必须放到最后\n                    'src/main/res/layout',\n                    'src/main/res'\n                ]\n    }\n}\n~~~\n\n# xml文件夹\n* 作用:存放各种xml文件,例如使用PreferenceFragment时需要在此xml文件夹中建立个preferenceFragment使用的.xml文件\n* 使用方法:\n~~~\nXmlResoutceParser xml = getResources().getXml(R.xml.xxx)\n~~~\n\n# assets文件夹\n* 创建：右键new-->Folder-->AssetsFolder\n* assets目录是Android的一种特殊目录，用于放置APP所需的固定文件，且该文件被打包到APK中时，不会被编码到二进制文件\n* assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取\n* assets下可以有多级目录\n* assets目录下资源不会被二进制编码\n* 使用方法:\n~~~\nInputStream read =getAssets().open(R.assets.xxx)\nOutputStream write = getAssets().open(R.assets.xxx)\n~~~\n\n# raw文件夹\n需自行创建\n* res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源\n* res/raw下不可以有多级目录\n* res/raw不会被编码\n* 使用方法:\n~~~\nInputStream read = getResources().openRawResource(R.raw.xxx)\nOutputStream write = getResources().openRawResource(R.raw.xxx)\n~~~\n\n# anim文件夹\n需自行创建\n* 作用:存放各种自定义动画格式\n* 使用方法\n~~~\ngetResources().getAnimation(R.anim.xxx)\n~~~\n\n ","slug":"微信开发-Android-res文件夹解析","published":1,"updated":"2019-02-14T09:04:15.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue03005l5b8hcun0318t","content":"<p>[toc]</p>\n<p><a href=\"https://blog.csdn.net/ws00801526/article/details/10449621\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ws00801526/article/details/10449621</a></p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>AS中Gradle默认不创建asserts文件夹，但他的路径已经存在于main 文件夹下面了，也可通过sourceSets属性在gradle中配置工程结构<br>\n<a href=\"https://github.com/ShinChven/MigrateToGradle\" target=\"_blank\" rel=\"noopener\">https://github.com/ShinChven/MigrateToGradle</a></p>\n<h1 id=\"自定义文件夹\"><a class=\"markdownIt-Anchor\" href=\"#自定义文件夹\"></a> 自定义文件夹</h1>\n<p>android项目中的资源文件支持拓展:定义资源文件夹名-拓展属性,拓展属性包括以下内容</p>\n<ul>\n<li>语言   -en -es</li>\n<li>区域   -rCN</li>\n<li>屏幕方向  -port  -land  -square</li>\n<li>屏幕密度 -92dpi</li>\n<li>用户是否可以使用键盘  -keysexposed,-keyshidden</li>\n<li>默认的文字输入方法  -nokeys,-qwerty</li>\n<li>默认的非触摸导航方法  -notouch,-dpad</li>\n<li>屏幕尺寸  -324x240,-640x480 较大尺寸必须首先声明</li>\n<li>触摸屏类型  -notouch ,-finger,-stylus</li>\n<li>版本号   -V4  ,-V7</li>\n</ul>\n<p>注意事项:值之间-号连接,大小写敏感,同一类型只能有一个值</p>\n<h1 id=\"valuse资源文件\"><a class=\"markdownIt-Anchor\" href=\"#valuse资源文件\"></a> valuse资源文件</h1>\n<h2 id=\"文件说明\"><a class=\"markdownIt-Anchor\" href=\"#文件说明\"></a> 文件说明</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.xml</span><br><span class=\"line\">\t\t\t作用:定义字符串</span><br><span class=\"line\">\t\t\t定义格式:&lt;string name=&quot;xxx&quot;&gt;字符串值&lt;/string&gt;</span><br><span class=\"line\">\t\t\t支持占用符  例子:  &lt;string name=&quot;xxx&quot;&gt;今天%1$s,温度%2$d&lt;/string&gt;</span><br><span class=\"line\">\t\t\t%1 %2---代表参数所在位置</span><br><span class=\"line\">\t\t\t$s,$d代表参数,s,d为参数类型</span><br><span class=\"line\">\t\t\tgetString(R.string.xxx,&quot;星期一&quot;,20) = 今天星期一,温度20</span><br><span class=\"line\">\t\t\t使用方法:资源文件中   @string/xxx</span><br><span class=\"line\">\t\t\t代码中   getString(R.string.xxx)</span><br><span class=\"line\">\t\tarrays.xml</span><br><span class=\"line\">\t\t\t作用:定义数组,可以是int,string,char</span><br><span class=\"line\">\t\t\t定义格式:&lt;type-array name=&quot;xxx&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;item&gt;数组元素值&lt;/item&gt;</span><br><span class=\"line\">\t\t\t&lt;/type-array&gt;</span><br><span class=\"line\">\t\t\t使用方法:资源文件中   不支持引用</span><br><span class=\"line\">\t\t\t代码中   type s[] = getResource.getTypeArray(R.array.xxx)</span><br><span class=\"line\">\t\tcolors.xml</span><br><span class=\"line\">\t\t\t作用:定义颜色</span><br><span class=\"line\">\t\t\t定义格式:&lt;color name=&quot;xxx&quot;&gt;#color值&lt;/color&gt;</span><br><span class=\"line\">\t\t\t使用方法:资源文件中 @color/xxx</span><br><span class=\"line\">\t\t\t代码中getResource.getColor(R.color.xxx) 或者</span><br><span class=\"line\">\t\t\tgetresource.getDrawable(R.color.xxx)</span><br><span class=\"line\">\t\tdimens.xml</span><br><span class=\"line\">\t\t\t作用:定义尺寸大小</span><br><span class=\"line\">\t\t\t定义格式:&lt;dimen name=&quot;xxx&quot;&gt;值&lt;/dimen&gt;</span><br><span class=\"line\">\t\t\t使用方法:资源文件中 @dimen/xxx</span><br><span class=\"line\">\t\t\t代码中  getResource.getDimension(R.dimen.xxx)</span><br><span class=\"line\">\t\tstyles.xml</span><br><span class=\"line\">\t\t\t作用:定义试图样式</span><br><span class=\"line\">\t\t\t定义格式:&lt;style name=&quot;xxx&quot;  parent=&quot;yyy&quot;&gt;</span><br><span class=\"line\">            \t\t\t&lt;item name=&quot;xxx2&quot;&gt;元素值&lt;/item&gt;</span><br><span class=\"line\">            \t\t&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"适配api\"><a class=\"markdownIt-Anchor\" href=\"#适配api\"></a> 适配API</h2>\n<p>AS的Project视图时，会有valuse与valuse-V(XX)文件夹；Android视图时，有时valuse资源文件下的xml文件会有多个，如多个strings.xml文件，其使用规则如下：</p>\n<ul>\n<li>values: 是缺省的文件夹且最后被匹配的，它包含在value是-X中没有包含的API水平。一般缺省都使用这个文件夹</li>\n<li>value-11: 针对API在11以上和13以上的，如果values-14存在的话。如果values-14不存在，则API 11以上都要使用该文件夹。另外API在11以下则无法使用该文件夹</li>\n<li>开发中只需要在VXX中指定特殊的，其他的全放在values即可</li>\n</ul>\n<h1 id=\"drawable文件夹\"><a class=\"markdownIt-Anchor\" href=\"#drawable文件夹\"></a> drawable文件夹</h1>\n<ul>\n<li>作用:存放各种图片类型,不能纯数字定义文件名,另可以新建.xml文件类型  通常自定义控件样式时会在此文件夹中新建个.xml格式文件作为背景图</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getDrawable(R.drawable.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"layout文件夹\"><a class=\"markdownIt-Anchor\" href=\"#layout文件夹\"></a> layout文件夹</h1>\n<h2 id=\"基本使用\"><a class=\"markdownIt-Anchor\" href=\"#基本使用\"></a> 基本使用</h2>\n<ul>\n<li>作用:存放各种布局文件</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setcontentView(R.layout.xxx) ;</span><br><span class=\"line\">View view = LayoutInflater.from(context).inflate(R.layout.xxx,null)</span><br></pre></td></tr></table></figure>\n<h2 id=\"建立子文件夹\"><a class=\"markdownIt-Anchor\" href=\"#建立子文件夹\"></a> 建立子文件夹</h2>\n<ul>\n<li>AS中layout只能在project视图下有效，android目录下无效</li>\n<li>‘src/main/res/layout’,'src/main/res’为必写项，必须放到最后</li>\n</ul>\n<p>在这个module的build.gradle文件下添加以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sourceSets &#123;</span><br><span class=\"line\">    main &#123;</span><br><span class=\"line\">        res.srcDirs =</span><br><span class=\"line\">                [</span><br><span class=\"line\">                    &apos;src/main/res/layout/main&apos;, </span><br><span class=\"line\">                    &apos;src/main/res/layout/dialog&apos;,</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                //下面两个是固定兼容写法，必须放到最后</span><br><span class=\"line\">                    &apos;src/main/res/layout&apos;,</span><br><span class=\"line\">                    &apos;src/main/res&apos;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"xml文件夹\"><a class=\"markdownIt-Anchor\" href=\"#xml文件夹\"></a> xml文件夹</h1>\n<ul>\n<li>作用:存放各种xml文件,例如使用PreferenceFragment时需要在此xml文件夹中建立个preferenceFragment使用的.xml文件</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XmlResoutceParser xml = getResources().getXml(R.xml.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"assets文件夹\"><a class=\"markdownIt-Anchor\" href=\"#assets文件夹\"></a> assets文件夹</h1>\n<ul>\n<li>创建：右键new–&gt;Folder–&gt;AssetsFolder</li>\n<li>assets目录是Android的一种特殊目录，用于放置APP所需的固定文件，且该文件被打包到APK中时，不会被编码到二进制文件</li>\n<li>assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取</li>\n<li>assets下可以有多级目录</li>\n<li>assets目录下资源不会被二进制编码</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream read =getAssets().open(R.assets.xxx)</span><br><span class=\"line\">OutputStream write = getAssets().open(R.assets.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"raw文件夹\"><a class=\"markdownIt-Anchor\" href=\"#raw文件夹\"></a> raw文件夹</h1>\n<p>需自行创建</p>\n<ul>\n<li>res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源</li>\n<li>res/raw下不可以有多级目录</li>\n<li>res/raw不会被编码</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream read = getResources().openRawResource(R.raw.xxx)</span><br><span class=\"line\">OutputStream write = getResources().openRawResource(R.raw.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"anim文件夹\"><a class=\"markdownIt-Anchor\" href=\"#anim文件夹\"></a> anim文件夹</h1>\n<p>需自行创建</p>\n<ul>\n<li>作用:存放各种自定义动画格式</li>\n<li>使用方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getResources().getAnimation(R.anim.xxx)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p><a href=\"https://blog.csdn.net/ws00801526/article/details/10449621\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ws00801526/article/details/10449621</a></p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>AS中Gradle默认不创建asserts文件夹，但他的路径已经存在于main 文件夹下面了，也可通过sourceSets属性在gradle中配置工程结构<br>\n<a href=\"https://github.com/ShinChven/MigrateToGradle\" target=\"_blank\" rel=\"noopener\">https://github.com/ShinChven/MigrateToGradle</a></p>\n<h1 id=\"自定义文件夹\"><a class=\"markdownIt-Anchor\" href=\"#自定义文件夹\"></a> 自定义文件夹</h1>\n<p>android项目中的资源文件支持拓展:定义资源文件夹名-拓展属性,拓展属性包括以下内容</p>\n<ul>\n<li>语言   -en -es</li>\n<li>区域   -rCN</li>\n<li>屏幕方向  -port  -land  -square</li>\n<li>屏幕密度 -92dpi</li>\n<li>用户是否可以使用键盘  -keysexposed,-keyshidden</li>\n<li>默认的文字输入方法  -nokeys,-qwerty</li>\n<li>默认的非触摸导航方法  -notouch,-dpad</li>\n<li>屏幕尺寸  -324x240,-640x480 较大尺寸必须首先声明</li>\n<li>触摸屏类型  -notouch ,-finger,-stylus</li>\n<li>版本号   -V4  ,-V7</li>\n</ul>\n<p>注意事项:值之间-号连接,大小写敏感,同一类型只能有一个值</p>\n<h1 id=\"valuse资源文件\"><a class=\"markdownIt-Anchor\" href=\"#valuse资源文件\"></a> valuse资源文件</h1>\n<h2 id=\"文件说明\"><a class=\"markdownIt-Anchor\" href=\"#文件说明\"></a> 文件说明</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.xml</span><br><span class=\"line\">\t\t\t作用:定义字符串</span><br><span class=\"line\">\t\t\t定义格式:&lt;string name=&quot;xxx&quot;&gt;字符串值&lt;/string&gt;</span><br><span class=\"line\">\t\t\t支持占用符  例子:  &lt;string name=&quot;xxx&quot;&gt;今天%1$s,温度%2$d&lt;/string&gt;</span><br><span class=\"line\">\t\t\t%1 %2---代表参数所在位置</span><br><span class=\"line\">\t\t\t$s,$d代表参数,s,d为参数类型</span><br><span class=\"line\">\t\t\tgetString(R.string.xxx,&quot;星期一&quot;,20) = 今天星期一,温度20</span><br><span class=\"line\">\t\t\t使用方法:资源文件中   @string/xxx</span><br><span class=\"line\">\t\t\t代码中   getString(R.string.xxx)</span><br><span class=\"line\">\t\tarrays.xml</span><br><span class=\"line\">\t\t\t作用:定义数组,可以是int,string,char</span><br><span class=\"line\">\t\t\t定义格式:&lt;type-array name=&quot;xxx&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;item&gt;数组元素值&lt;/item&gt;</span><br><span class=\"line\">\t\t\t&lt;/type-array&gt;</span><br><span class=\"line\">\t\t\t使用方法:资源文件中   不支持引用</span><br><span class=\"line\">\t\t\t代码中   type s[] = getResource.getTypeArray(R.array.xxx)</span><br><span class=\"line\">\t\tcolors.xml</span><br><span class=\"line\">\t\t\t作用:定义颜色</span><br><span class=\"line\">\t\t\t定义格式:&lt;color name=&quot;xxx&quot;&gt;#color值&lt;/color&gt;</span><br><span class=\"line\">\t\t\t使用方法:资源文件中 @color/xxx</span><br><span class=\"line\">\t\t\t代码中getResource.getColor(R.color.xxx) 或者</span><br><span class=\"line\">\t\t\tgetresource.getDrawable(R.color.xxx)</span><br><span class=\"line\">\t\tdimens.xml</span><br><span class=\"line\">\t\t\t作用:定义尺寸大小</span><br><span class=\"line\">\t\t\t定义格式:&lt;dimen name=&quot;xxx&quot;&gt;值&lt;/dimen&gt;</span><br><span class=\"line\">\t\t\t使用方法:资源文件中 @dimen/xxx</span><br><span class=\"line\">\t\t\t代码中  getResource.getDimension(R.dimen.xxx)</span><br><span class=\"line\">\t\tstyles.xml</span><br><span class=\"line\">\t\t\t作用:定义试图样式</span><br><span class=\"line\">\t\t\t定义格式:&lt;style name=&quot;xxx&quot;  parent=&quot;yyy&quot;&gt;</span><br><span class=\"line\">            \t\t\t&lt;item name=&quot;xxx2&quot;&gt;元素值&lt;/item&gt;</span><br><span class=\"line\">            \t\t&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"适配api\"><a class=\"markdownIt-Anchor\" href=\"#适配api\"></a> 适配API</h2>\n<p>AS的Project视图时，会有valuse与valuse-V(XX)文件夹；Android视图时，有时valuse资源文件下的xml文件会有多个，如多个strings.xml文件，其使用规则如下：</p>\n<ul>\n<li>values: 是缺省的文件夹且最后被匹配的，它包含在value是-X中没有包含的API水平。一般缺省都使用这个文件夹</li>\n<li>value-11: 针对API在11以上和13以上的，如果values-14存在的话。如果values-14不存在，则API 11以上都要使用该文件夹。另外API在11以下则无法使用该文件夹</li>\n<li>开发中只需要在VXX中指定特殊的，其他的全放在values即可</li>\n</ul>\n<h1 id=\"drawable文件夹\"><a class=\"markdownIt-Anchor\" href=\"#drawable文件夹\"></a> drawable文件夹</h1>\n<ul>\n<li>作用:存放各种图片类型,不能纯数字定义文件名,另可以新建.xml文件类型  通常自定义控件样式时会在此文件夹中新建个.xml格式文件作为背景图</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getDrawable(R.drawable.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"layout文件夹\"><a class=\"markdownIt-Anchor\" href=\"#layout文件夹\"></a> layout文件夹</h1>\n<h2 id=\"基本使用\"><a class=\"markdownIt-Anchor\" href=\"#基本使用\"></a> 基本使用</h2>\n<ul>\n<li>作用:存放各种布局文件</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setcontentView(R.layout.xxx) ;</span><br><span class=\"line\">View view = LayoutInflater.from(context).inflate(R.layout.xxx,null)</span><br></pre></td></tr></table></figure>\n<h2 id=\"建立子文件夹\"><a class=\"markdownIt-Anchor\" href=\"#建立子文件夹\"></a> 建立子文件夹</h2>\n<ul>\n<li>AS中layout只能在project视图下有效，android目录下无效</li>\n<li>‘src/main/res/layout’,'src/main/res’为必写项，必须放到最后</li>\n</ul>\n<p>在这个module的build.gradle文件下添加以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sourceSets &#123;</span><br><span class=\"line\">    main &#123;</span><br><span class=\"line\">        res.srcDirs =</span><br><span class=\"line\">                [</span><br><span class=\"line\">                    &apos;src/main/res/layout/main&apos;, </span><br><span class=\"line\">                    &apos;src/main/res/layout/dialog&apos;,</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                //下面两个是固定兼容写法，必须放到最后</span><br><span class=\"line\">                    &apos;src/main/res/layout&apos;,</span><br><span class=\"line\">                    &apos;src/main/res&apos;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"xml文件夹\"><a class=\"markdownIt-Anchor\" href=\"#xml文件夹\"></a> xml文件夹</h1>\n<ul>\n<li>作用:存放各种xml文件,例如使用PreferenceFragment时需要在此xml文件夹中建立个preferenceFragment使用的.xml文件</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XmlResoutceParser xml = getResources().getXml(R.xml.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"assets文件夹\"><a class=\"markdownIt-Anchor\" href=\"#assets文件夹\"></a> assets文件夹</h1>\n<ul>\n<li>创建：右键new–&gt;Folder–&gt;AssetsFolder</li>\n<li>assets目录是Android的一种特殊目录，用于放置APP所需的固定文件，且该文件被打包到APK中时，不会被编码到二进制文件</li>\n<li>assets目录不会被映射到R中，因此，资源无法通过R.id方式获取，必须要通过AssetManager进行操作与获取</li>\n<li>assets下可以有多级目录</li>\n<li>assets目录下资源不会被二进制编码</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream read =getAssets().open(R.assets.xxx)</span><br><span class=\"line\">OutputStream write = getAssets().open(R.assets.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"raw文件夹\"><a class=\"markdownIt-Anchor\" href=\"#raw文件夹\"></a> raw文件夹</h1>\n<p>需自行创建</p>\n<ul>\n<li>res/raw目录下的资源会被映射到R中，可以通过getResource()方法获取资源</li>\n<li>res/raw下不可以有多级目录</li>\n<li>res/raw不会被编码</li>\n<li>使用方法:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream read = getResources().openRawResource(R.raw.xxx)</span><br><span class=\"line\">OutputStream write = getResources().openRawResource(R.raw.xxx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"anim文件夹\"><a class=\"markdownIt-Anchor\" href=\"#anim文件夹\"></a> anim文件夹</h1>\n<p>需自行创建</p>\n<ul>\n<li>作用:存放各种自定义动画格式</li>\n<li>使用方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getResources().getAnimation(R.anim.xxx)</span><br></pre></td></tr></table></figure>\n"},{"title":"Android应用坐标系及栏目","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n[toc]\n\nhttp://www.jb51.net/article/96226.htm\n\n# Android应用坐标系\nAndroid坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图\n\n# 屏幕区域划分\n* 状态栏：是指手机左上最顶上，显示中国移动、安全卫士、电量、网速等等，在手机的顶部\n* 通知栏：下拉就会出现通知栏，4G、蓝牙等设置界面\n* 标题栏：是指一个APP程序最上部的titleBar，从名字就知道它显然就是一个应用程序一个页面的标题了，例如打开QQ消息主页，最上面显示消息那一栏就是标题栏。\n* 导航栏：是手机最下面的返回，HOME，主页三个键，有些是一个按钮。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBa36cd0e5d359381bcdd1f8624252f98a?method=download&shareKey=f445f246913291c3d0bba4be4f64ee40)\n\n~~~\n//获取屏幕区域的宽高等尺寸获取\nDisplayMetrics metrics = new DisplayMetrics();\ngetWindowManager().getDefaultDisplay().getMetrics(metrics);\nint widthPixels = metrics.widthPixels;\nint heightPixels = metrics.heightPixels;\n//应用程序App区域宽高等尺寸获取\nRect rect = new Rect();\ngetWindow().getDecorView().getWindowVisibleDisplayFrame(rect);\n//获取状态栏高度\nRect rect= new Rect();\ngetWindow().getDecorView().getWindowVisibleDisplayFrame(rect);\nint statusBarHeight = rectangle.top;\n//View布局区域宽高等尺寸获取\nRect rect = new Rect(); \ngetWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect); \n~~~\n\n# ActionBar／ToolBar\n* ActionBar：Action Bar取代了传统的tittle bar和menu\n* ToolBar是替代ActionBar的控件\n* 由于ActionBar在各个安卓版本和定制Rom中的效果表现不一，导致严重的碎片化问题，ToolBar应运而生\n* ToolBar与ActionBar区别显示效果并没有区别\n* ToolBar优点：自定义视图的操作更加简单，状态栏的颜色可以调（Android 4.4以上）\n* ToolBar在 material design 也对之做了名称的定义：App bar\n\nhttps://blog.csdn.net/guolin_blog/article/details/18234477\nhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html\n\n# TitleBar\nhttps://www.jianshu.com/p/3474a4cc7108\n\n# StatusBar\nhttps://blog.csdn.net/qq_33689414/article/details/73330643\nhttps://blog.csdn.net/u012102504/article/details/53406646\n\n# Navigation Bar\nhttps://blog.csdn.net/weixin_37077539/article/details/59110273\n\nAndroid手机可分为有导航栏以及没导航栏两种，一般有物理按键的机器不会带有导航栏，而没有物理按键的机器则基本会带，比如华为的手机基本都是带导航栏的\n ","source":"_posts/微信开发/Android应用坐标系及栏目.md","raw":"---\ntitle: Android应用坐标系及栏目\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n[toc]\n\nhttp://www.jb51.net/article/96226.htm\n\n# Android应用坐标系\nAndroid坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图\n\n# 屏幕区域划分\n* 状态栏：是指手机左上最顶上，显示中国移动、安全卫士、电量、网速等等，在手机的顶部\n* 通知栏：下拉就会出现通知栏，4G、蓝牙等设置界面\n* 标题栏：是指一个APP程序最上部的titleBar，从名字就知道它显然就是一个应用程序一个页面的标题了，例如打开QQ消息主页，最上面显示消息那一栏就是标题栏。\n* 导航栏：是手机最下面的返回，HOME，主页三个键，有些是一个按钮。\n\n![image](https://note.youdao.com/yws/api/personal/file/WEBa36cd0e5d359381bcdd1f8624252f98a?method=download&shareKey=f445f246913291c3d0bba4be4f64ee40)\n\n~~~\n//获取屏幕区域的宽高等尺寸获取\nDisplayMetrics metrics = new DisplayMetrics();\ngetWindowManager().getDefaultDisplay().getMetrics(metrics);\nint widthPixels = metrics.widthPixels;\nint heightPixels = metrics.heightPixels;\n//应用程序App区域宽高等尺寸获取\nRect rect = new Rect();\ngetWindow().getDecorView().getWindowVisibleDisplayFrame(rect);\n//获取状态栏高度\nRect rect= new Rect();\ngetWindow().getDecorView().getWindowVisibleDisplayFrame(rect);\nint statusBarHeight = rectangle.top;\n//View布局区域宽高等尺寸获取\nRect rect = new Rect(); \ngetWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect); \n~~~\n\n# ActionBar／ToolBar\n* ActionBar：Action Bar取代了传统的tittle bar和menu\n* ToolBar是替代ActionBar的控件\n* 由于ActionBar在各个安卓版本和定制Rom中的效果表现不一，导致严重的碎片化问题，ToolBar应运而生\n* ToolBar与ActionBar区别显示效果并没有区别\n* ToolBar优点：自定义视图的操作更加简单，状态栏的颜色可以调（Android 4.4以上）\n* ToolBar在 material design 也对之做了名称的定义：App bar\n\nhttps://blog.csdn.net/guolin_blog/article/details/18234477\nhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html\n\n# TitleBar\nhttps://www.jianshu.com/p/3474a4cc7108\n\n# StatusBar\nhttps://blog.csdn.net/qq_33689414/article/details/73330643\nhttps://blog.csdn.net/u012102504/article/details/53406646\n\n# Navigation Bar\nhttps://blog.csdn.net/weixin_37077539/article/details/59110273\n\nAndroid手机可分为有导航栏以及没导航栏两种，一般有物理按键的机器不会带有导航栏，而没有物理按键的机器则基本会带，比如华为的手机基本都是带导航栏的\n ","slug":"微信开发-Android应用坐标系及栏目","published":1,"updated":"2019-02-14T09:05:10.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue04005n5b8hl9q04d0x","content":"<p>[toc]</p>\n<p><a href=\"http://www.jb51.net/article/96226.htm\" target=\"_blank\" rel=\"noopener\">http://www.jb51.net/article/96226.htm</a></p>\n<h1 id=\"android应用坐标系\"><a class=\"markdownIt-Anchor\" href=\"#android应用坐标系\"></a> Android应用坐标系</h1>\n<p>Android坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图</p>\n<h1 id=\"屏幕区域划分\"><a class=\"markdownIt-Anchor\" href=\"#屏幕区域划分\"></a> 屏幕区域划分</h1>\n<ul>\n<li>状态栏：是指手机左上最顶上，显示中国移动、安全卫士、电量、网速等等，在手机的顶部</li>\n<li>通知栏：下拉就会出现通知栏，4G、蓝牙等设置界面</li>\n<li>标题栏：是指一个APP程序最上部的titleBar，从名字就知道它显然就是一个应用程序一个页面的标题了，例如打开QQ消息主页，最上面显示消息那一栏就是标题栏。</li>\n<li>导航栏：是手机最下面的返回，HOME，主页三个键，有些是一个按钮。</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBa36cd0e5d359381bcdd1f8624252f98a?method=download&amp;shareKey=f445f246913291c3d0bba4be4f64ee40\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取屏幕区域的宽高等尺寸获取</span><br><span class=\"line\">DisplayMetrics metrics = new DisplayMetrics();</span><br><span class=\"line\">getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class=\"line\">int widthPixels = metrics.widthPixels;</span><br><span class=\"line\">int heightPixels = metrics.heightPixels;</span><br><span class=\"line\">//应用程序App区域宽高等尺寸获取</span><br><span class=\"line\">Rect rect = new Rect();</span><br><span class=\"line\">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class=\"line\">//获取状态栏高度</span><br><span class=\"line\">Rect rect= new Rect();</span><br><span class=\"line\">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class=\"line\">int statusBarHeight = rectangle.top;</span><br><span class=\"line\">//View布局区域宽高等尺寸获取</span><br><span class=\"line\">Rect rect = new Rect(); </span><br><span class=\"line\">getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect);</span><br></pre></td></tr></table></figure>\n<h1 id=\"actionbartoolbar\"><a class=\"markdownIt-Anchor\" href=\"#actionbartoolbar\"></a> ActionBar／ToolBar</h1>\n<ul>\n<li>ActionBar：Action Bar取代了传统的tittle bar和menu</li>\n<li>ToolBar是替代ActionBar的控件</li>\n<li>由于ActionBar在各个安卓版本和定制Rom中的效果表现不一，导致严重的碎片化问题，ToolBar应运而生</li>\n<li>ToolBar与ActionBar区别显示效果并没有区别</li>\n<li>ToolBar优点：自定义视图的操作更加简单，状态栏的颜色可以调（Android 4.4以上）</li>\n<li>ToolBar在 material design 也对之做了名称的定义：App bar</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/guolin_blog/article/details/18234477\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/guolin_blog/article/details/18234477</a><br>\n<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html</a></p>\n<h1 id=\"titlebar\"><a class=\"markdownIt-Anchor\" href=\"#titlebar\"></a> TitleBar</h1>\n<p><a href=\"https://www.jianshu.com/p/3474a4cc7108\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3474a4cc7108</a></p>\n<h1 id=\"statusbar\"><a class=\"markdownIt-Anchor\" href=\"#statusbar\"></a> StatusBar</h1>\n<p><a href=\"https://blog.csdn.net/qq_33689414/article/details/73330643\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_33689414/article/details/73330643</a><br>\n<a href=\"https://blog.csdn.net/u012102504/article/details/53406646\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012102504/article/details/53406646</a></p>\n<h1 id=\"navigation-bar\"><a class=\"markdownIt-Anchor\" href=\"#navigation-bar\"></a> Navigation Bar</h1>\n<p><a href=\"https://blog.csdn.net/weixin_37077539/article/details/59110273\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_37077539/article/details/59110273</a></p>\n<p>Android手机可分为有导航栏以及没导航栏两种，一般有物理按键的机器不会带有导航栏，而没有物理按键的机器则基本会带，比如华为的手机基本都是带导航栏的</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p><a href=\"http://www.jb51.net/article/96226.htm\" target=\"_blank\" rel=\"noopener\">http://www.jb51.net/article/96226.htm</a></p>\n<h1 id=\"android应用坐标系\"><a class=\"markdownIt-Anchor\" href=\"#android应用坐标系\"></a> Android应用坐标系</h1>\n<p>Android坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图</p>\n<h1 id=\"屏幕区域划分\"><a class=\"markdownIt-Anchor\" href=\"#屏幕区域划分\"></a> 屏幕区域划分</h1>\n<ul>\n<li>状态栏：是指手机左上最顶上，显示中国移动、安全卫士、电量、网速等等，在手机的顶部</li>\n<li>通知栏：下拉就会出现通知栏，4G、蓝牙等设置界面</li>\n<li>标题栏：是指一个APP程序最上部的titleBar，从名字就知道它显然就是一个应用程序一个页面的标题了，例如打开QQ消息主页，最上面显示消息那一栏就是标题栏。</li>\n<li>导航栏：是手机最下面的返回，HOME，主页三个键，有些是一个按钮。</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBa36cd0e5d359381bcdd1f8624252f98a?method=download&amp;shareKey=f445f246913291c3d0bba4be4f64ee40\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取屏幕区域的宽高等尺寸获取</span><br><span class=\"line\">DisplayMetrics metrics = new DisplayMetrics();</span><br><span class=\"line\">getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class=\"line\">int widthPixels = metrics.widthPixels;</span><br><span class=\"line\">int heightPixels = metrics.heightPixels;</span><br><span class=\"line\">//应用程序App区域宽高等尺寸获取</span><br><span class=\"line\">Rect rect = new Rect();</span><br><span class=\"line\">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class=\"line\">//获取状态栏高度</span><br><span class=\"line\">Rect rect= new Rect();</span><br><span class=\"line\">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class=\"line\">int statusBarHeight = rectangle.top;</span><br><span class=\"line\">//View布局区域宽高等尺寸获取</span><br><span class=\"line\">Rect rect = new Rect(); </span><br><span class=\"line\">getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect);</span><br></pre></td></tr></table></figure>\n<h1 id=\"actionbartoolbar\"><a class=\"markdownIt-Anchor\" href=\"#actionbartoolbar\"></a> ActionBar／ToolBar</h1>\n<ul>\n<li>ActionBar：Action Bar取代了传统的tittle bar和menu</li>\n<li>ToolBar是替代ActionBar的控件</li>\n<li>由于ActionBar在各个安卓版本和定制Rom中的效果表现不一，导致严重的碎片化问题，ToolBar应运而生</li>\n<li>ToolBar与ActionBar区别显示效果并没有区别</li>\n<li>ToolBar优点：自定义视图的操作更加简单，状态栏的颜色可以调（Android 4.4以上）</li>\n<li>ToolBar在 material design 也对之做了名称的定义：App bar</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/guolin_blog/article/details/18234477\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/guolin_blog/article/details/18234477</a><br>\n<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html</a></p>\n<h1 id=\"titlebar\"><a class=\"markdownIt-Anchor\" href=\"#titlebar\"></a> TitleBar</h1>\n<p><a href=\"https://www.jianshu.com/p/3474a4cc7108\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3474a4cc7108</a></p>\n<h1 id=\"statusbar\"><a class=\"markdownIt-Anchor\" href=\"#statusbar\"></a> StatusBar</h1>\n<p><a href=\"https://blog.csdn.net/qq_33689414/article/details/73330643\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_33689414/article/details/73330643</a><br>\n<a href=\"https://blog.csdn.net/u012102504/article/details/53406646\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012102504/article/details/53406646</a></p>\n<h1 id=\"navigation-bar\"><a class=\"markdownIt-Anchor\" href=\"#navigation-bar\"></a> Navigation Bar</h1>\n<p><a href=\"https://blog.csdn.net/weixin_37077539/article/details/59110273\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_37077539/article/details/59110273</a></p>\n<p>Android手机可分为有导航栏以及没导航栏两种，一般有物理按键的机器不会带有导航栏，而没有物理按键的机器则基本会带，比如华为的手机基本都是带导航栏的</p>\n"},{"title":"Retrofit","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n[toc]\n\n官网说明：http://square.github.io/retrofit/\n\n推荐教程1：https://www.jianshu.com/p/86e5cddcc753\n\n推荐教程2：https://www.jianshu.com/p/308f3c54abdd\n\n大名鼎鼎的Retrofit库内置了对RxJava的支持\n\n# 创建Retrofit实例\n~~~\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"http://localhost:8080/\")\n        .build();\n~~~\n\nURL注意事件:\n1. Base Ulr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException\n2. @Url（@GET,@POST）: 不要在开始位置加 /\n3. URL类似 https://www.baidu.com?key=value 用来作为baseUrl其实是可行的，因为这个URL隐含的路径就是 /（斜线，代表根目录） ，而后面的?key=value在拼装请求时会被丢掉所以写上也没用 \n\n# 接口定义\n~~~\npublic interface BlogService {\n    @GET(\"blog/{id}\")\n    Call<ResponseBody> getBlog(@Path(\"id\") int id);\n}\n~~~\n注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象\n~~~\nBlogService service = retrofit.create(BlogService.class);\n~~~\n\n# 接口调用\n~~~\nCall<ResponseBody> call = service.getBlog(2);\n// 用法和OkHttp的call如出一辙,\n// 不同的是如果是Android系统回调方法执行在主线程\ncall.enqueue(new Callback<ResponseBody>() {\n    @Override\n    public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\n        try {\n            System.out.println(response.body().string());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onFailure(Call<ResponseBody> call, Throwable t) {\n        t.printStackTrace();\n    }\n}); \n~~~\n\n# Converter\n在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,\n即返回值都是 Call<ResponseBody>,而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，如：\n~~~\npublic interface BlogService {\n  @GET(\"blog/{id}\")\n  Call<Result<Blog>> getBlog(@Path(\"id\") int id);\n}\n~~~\n\n# 引入Gson支持\n~~~\ncompile 'com.squareup.retrofit2:converter-gson:2.0.2'\n~~~\n通过GsonConverterFactory为Retrofit添加Gson支持\n~~~\nGson gson = new GsonBuilder()\n      //配置你的Gson\n      .setDateFormat(\"yyyy-MM-dd hh:mm:ss\")\n      .create();\n\nRetrofit retrofit = new Retrofit.Builder()\n      .baseUrl(\"http://localhost:4567/\")\n      //可以接收自定义的Gson，当然也可以不传\n      .addConverterFactory(GsonConverterFactory.create(gson))\n      .build();  \n~~~\n这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。\n\n示例：\n~~~\n@POST(\"blog\")\nCall<Result<Blog>> createBlog(@Body Blog blog);\n~~~\n被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。\n~~~\nBlogService service = retrofit.create(BlogService.class);\nBlog blog = new Blog();\nblog.content = \"新建的Blog\";\nblog.title = \"测试\";\nblog.author = \"怪盗kidou\";\nCall<Result<Blog>> call = service.createBlog(blog);  \n~~~\n\n# RxJava与CallAdapter\nConverter是对于Call<T>中T的转换，而CallAdapter则可以对Call转换，这样的话Call<T>中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call：\n~~~\n引入RxJava支持:\ncompile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'\n~~~\n通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：\n~~~\nRetrofit retrofit = new Retrofit.Builder()\n      .baseUrl(\"http://localhost:4567/\")\n      .addConverterFactory(GsonConverterFactory.create())\n      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n      // 针对rxjava2.x\n      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) \n      .build(); \n~~~\n接口设计：\n~~~\npublic interface BlogService {\n  @POST(\"/blog\")\n  Observable<Result<List<Blog>>> getBlogs();\n}\n~~~\n使用：\n~~~\nBlogService service = retrofit.create(BlogService.class);\nservice.getBlogs(1)\n  .subscribeOn(Schedulers.io())\n  .subscribe(new Subscriber<Result<List<Blog>>>() {\n      @Override\n      public void onCompleted() {\n        System.out.println(\"onCompleted\");\n      }\n\n      @Override\n      public void onError(Throwable e) {\n        System.err.println(\"onError\");\n      }\n\n      @Override\n      public void onNext(Result<List<Blog>> blogsResult) {\n        System.out.println(blogsResult);\n      }\n  });\n~~~\n像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：\n\n1. 用Observable<Response<T>> 代替 Observable<T> ,这里的Response指retrofit2.Response \n2. 用Observable<Result<T>> 代替 Observable<T>，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例 \n~~~","source":"_posts/微信开发/Retrofit.md","raw":"---\ntitle: Retrofit\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n[toc]\n\n官网说明：http://square.github.io/retrofit/\n\n推荐教程1：https://www.jianshu.com/p/86e5cddcc753\n\n推荐教程2：https://www.jianshu.com/p/308f3c54abdd\n\n大名鼎鼎的Retrofit库内置了对RxJava的支持\n\n# 创建Retrofit实例\n~~~\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"http://localhost:8080/\")\n        .build();\n~~~\n\nURL注意事件:\n1. Base Ulr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException\n2. @Url（@GET,@POST）: 不要在开始位置加 /\n3. URL类似 https://www.baidu.com?key=value 用来作为baseUrl其实是可行的，因为这个URL隐含的路径就是 /（斜线，代表根目录） ，而后面的?key=value在拼装请求时会被丢掉所以写上也没用 \n\n# 接口定义\n~~~\npublic interface BlogService {\n    @GET(\"blog/{id}\")\n    Call<ResponseBody> getBlog(@Path(\"id\") int id);\n}\n~~~\n注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象\n~~~\nBlogService service = retrofit.create(BlogService.class);\n~~~\n\n# 接口调用\n~~~\nCall<ResponseBody> call = service.getBlog(2);\n// 用法和OkHttp的call如出一辙,\n// 不同的是如果是Android系统回调方法执行在主线程\ncall.enqueue(new Callback<ResponseBody>() {\n    @Override\n    public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\n        try {\n            System.out.println(response.body().string());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onFailure(Call<ResponseBody> call, Throwable t) {\n        t.printStackTrace();\n    }\n}); \n~~~\n\n# Converter\n在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,\n即返回值都是 Call<ResponseBody>,而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，如：\n~~~\npublic interface BlogService {\n  @GET(\"blog/{id}\")\n  Call<Result<Blog>> getBlog(@Path(\"id\") int id);\n}\n~~~\n\n# 引入Gson支持\n~~~\ncompile 'com.squareup.retrofit2:converter-gson:2.0.2'\n~~~\n通过GsonConverterFactory为Retrofit添加Gson支持\n~~~\nGson gson = new GsonBuilder()\n      //配置你的Gson\n      .setDateFormat(\"yyyy-MM-dd hh:mm:ss\")\n      .create();\n\nRetrofit retrofit = new Retrofit.Builder()\n      .baseUrl(\"http://localhost:4567/\")\n      //可以接收自定义的Gson，当然也可以不传\n      .addConverterFactory(GsonConverterFactory.create(gson))\n      .build();  \n~~~\n这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。\n\n示例：\n~~~\n@POST(\"blog\")\nCall<Result<Blog>> createBlog(@Body Blog blog);\n~~~\n被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。\n~~~\nBlogService service = retrofit.create(BlogService.class);\nBlog blog = new Blog();\nblog.content = \"新建的Blog\";\nblog.title = \"测试\";\nblog.author = \"怪盗kidou\";\nCall<Result<Blog>> call = service.createBlog(blog);  \n~~~\n\n# RxJava与CallAdapter\nConverter是对于Call<T>中T的转换，而CallAdapter则可以对Call转换，这样的话Call<T>中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call：\n~~~\n引入RxJava支持:\ncompile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'\n~~~\n通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：\n~~~\nRetrofit retrofit = new Retrofit.Builder()\n      .baseUrl(\"http://localhost:4567/\")\n      .addConverterFactory(GsonConverterFactory.create())\n      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n      // 针对rxjava2.x\n      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) \n      .build(); \n~~~\n接口设计：\n~~~\npublic interface BlogService {\n  @POST(\"/blog\")\n  Observable<Result<List<Blog>>> getBlogs();\n}\n~~~\n使用：\n~~~\nBlogService service = retrofit.create(BlogService.class);\nservice.getBlogs(1)\n  .subscribeOn(Schedulers.io())\n  .subscribe(new Subscriber<Result<List<Blog>>>() {\n      @Override\n      public void onCompleted() {\n        System.out.println(\"onCompleted\");\n      }\n\n      @Override\n      public void onError(Throwable e) {\n        System.err.println(\"onError\");\n      }\n\n      @Override\n      public void onNext(Result<List<Blog>> blogsResult) {\n        System.out.println(blogsResult);\n      }\n  });\n~~~\n像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：\n\n1. 用Observable<Response<T>> 代替 Observable<T> ,这里的Response指retrofit2.Response \n2. 用Observable<Result<T>> 代替 Observable<T>，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例 \n~~~","slug":"微信开发-Retrofit","published":1,"updated":"2019-02-14T08:57:57.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue05005q5b8h1geufi8v","content":"<p>[toc]</p>\n<p>官网说明：<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">http://square.github.io/retrofit/</a></p>\n<p>推荐教程1：<a href=\"https://www.jianshu.com/p/86e5cddcc753\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/86e5cddcc753</a></p>\n<p>推荐教程2：<a href=\"https://www.jianshu.com/p/308f3c54abdd\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/308f3c54abdd</a></p>\n<p>大名鼎鼎的Retrofit库内置了对RxJava的支持</p>\n<h1 id=\"创建retrofit实例\"><a class=\"markdownIt-Anchor\" href=\"#创建retrofit实例\"></a> 创建Retrofit实例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = new Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(&quot;http://localhost:8080/&quot;)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<p>URL注意事件:</p>\n<ol>\n<li>Base Ulr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException</li>\n<li>@Url（@GET,@POST）: 不要在开始位置加 /</li>\n<li>URL类似 <a href=\"https://www.baidu.com?key=value\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com?key=value</a> 用来作为baseUrl其实是可行的，因为这个URL隐含的路径就是 /（斜线，代表根目录） ，而后面的?key=value在拼装请求时会被丢掉所以写上也没用</li>\n</ol>\n<h1 id=\"接口定义\"><a class=\"markdownIt-Anchor\" href=\"#接口定义\"></a> 接口定义</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BlogService &#123;</span><br><span class=\"line\">    @GET(&quot;blog/&#123;id&#125;&quot;)</span><br><span class=\"line\">    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogService service = retrofit.create(BlogService.class);</span><br></pre></td></tr></table></figure>\n<h1 id=\"接口调用\"><a class=\"markdownIt-Anchor\" href=\"#接口调用\"></a> 接口调用</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Call&lt;ResponseBody&gt; call = service.getBlog(2);</span><br><span class=\"line\">// 用法和OkHttp的call如出一辙,</span><br><span class=\"line\">// 不同的是如果是Android系统回调方法执行在主线程</span><br><span class=\"line\">call.enqueue(new Callback&lt;ResponseBody&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(response.body().string());</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123;</span><br><span class=\"line\">        t.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"converter\"><a class=\"markdownIt-Anchor\" href=\"#converter\"></a> Converter</h1>\n<p>在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,<br>\n即返回值都是 Call<responsebody>,而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，如：</responsebody></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BlogService &#123;</span><br><span class=\"line\">  @GET(&quot;blog/&#123;id&#125;&quot;)</span><br><span class=\"line\">  Call&lt;Result&lt;Blog&gt;&gt; getBlog(@Path(&quot;id&quot;) int id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"引入gson支持\"><a class=\"markdownIt-Anchor\" href=\"#引入gson支持\"></a> 引入Gson支持</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;</span><br></pre></td></tr></table></figure>\n<p>通过GsonConverterFactory为Retrofit添加Gson支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gson gson = new GsonBuilder()</span><br><span class=\"line\">      //配置你的Gson</span><br><span class=\"line\">      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)</span><br><span class=\"line\">      .create();</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = new Retrofit.Builder()</span><br><span class=\"line\">      .baseUrl(&quot;http://localhost:4567/&quot;)</span><br><span class=\"line\">      //可以接收自定义的Gson，当然也可以不传</span><br><span class=\"line\">      .addConverterFactory(GsonConverterFactory.create(gson))</span><br><span class=\"line\">      .build();</span><br></pre></td></tr></table></figure>\n<p>这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@POST(&quot;blog&quot;)</span><br><span class=\"line\">Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);</span><br></pre></td></tr></table></figure>\n<p>被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogService service = retrofit.create(BlogService.class);</span><br><span class=\"line\">Blog blog = new Blog();</span><br><span class=\"line\">blog.content = &quot;新建的Blog&quot;;</span><br><span class=\"line\">blog.title = &quot;测试&quot;;</span><br><span class=\"line\">blog.author = &quot;怪盗kidou&quot;;</span><br><span class=\"line\">Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);</span><br></pre></td></tr></table></figure>\n<h1 id=\"rxjava与calladapter\"><a class=\"markdownIt-Anchor\" href=\"#rxjava与calladapter\"></a> RxJava与CallAdapter</h1>\n<p>Converter是对于Call<t>中T的转换，而CallAdapter则可以对Call转换，这样的话Call<t>中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call：</t></t></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引入RxJava支持:</span><br><span class=\"line\">compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</span><br></pre></td></tr></table></figure>\n<p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = new Retrofit.Builder()</span><br><span class=\"line\">      .baseUrl(&quot;http://localhost:4567/&quot;)</span><br><span class=\"line\">      .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class=\"line\">      // 针对rxjava2.x</span><br><span class=\"line\">      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) </span><br><span class=\"line\">      .build();</span><br></pre></td></tr></table></figure>\n<p>接口设计：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BlogService &#123;</span><br><span class=\"line\">  @POST(&quot;/blog&quot;)</span><br><span class=\"line\">  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogService service = retrofit.create(BlogService.class);</span><br><span class=\"line\">service.getBlogs(1)</span><br><span class=\"line\">  .subscribeOn(Schedulers.io())</span><br><span class=\"line\">  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void onCompleted() &#123;</span><br><span class=\"line\">        System.out.println(&quot;onCompleted&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void onError(Throwable e) &#123;</span><br><span class=\"line\">        System.err.println(&quot;onError&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) &#123;</span><br><span class=\"line\">        System.out.println(blogsResult);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：</p>\n<ol>\n<li>用Observable&lt;Response<t>&gt; 代替 Observable<t> ,这里的Response指retrofit2.Response</t></t></li>\n<li>用Observable&lt;Result<t>&gt; 代替 Observable<t>，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例</t></t></li>\n</ol>\n<pre class=\"highlight\"><code class=\"\"></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p>官网说明：<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">http://square.github.io/retrofit/</a></p>\n<p>推荐教程1：<a href=\"https://www.jianshu.com/p/86e5cddcc753\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/86e5cddcc753</a></p>\n<p>推荐教程2：<a href=\"https://www.jianshu.com/p/308f3c54abdd\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/308f3c54abdd</a></p>\n<p>大名鼎鼎的Retrofit库内置了对RxJava的支持</p>\n<h1 id=\"创建retrofit实例\"><a class=\"markdownIt-Anchor\" href=\"#创建retrofit实例\"></a> 创建Retrofit实例</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = new Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(&quot;http://localhost:8080/&quot;)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<p>URL注意事件:</p>\n<ol>\n<li>Base Ulr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException</li>\n<li>@Url（@GET,@POST）: 不要在开始位置加 /</li>\n<li>URL类似 <a href=\"https://www.baidu.com?key=value\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com?key=value</a> 用来作为baseUrl其实是可行的，因为这个URL隐含的路径就是 /（斜线，代表根目录） ，而后面的?key=value在拼装请求时会被丢掉所以写上也没用</li>\n</ol>\n<h1 id=\"接口定义\"><a class=\"markdownIt-Anchor\" href=\"#接口定义\"></a> 接口定义</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BlogService &#123;</span><br><span class=\"line\">    @GET(&quot;blog/&#123;id&#125;&quot;)</span><br><span class=\"line\">    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogService service = retrofit.create(BlogService.class);</span><br></pre></td></tr></table></figure>\n<h1 id=\"接口调用\"><a class=\"markdownIt-Anchor\" href=\"#接口调用\"></a> 接口调用</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Call&lt;ResponseBody&gt; call = service.getBlog(2);</span><br><span class=\"line\">// 用法和OkHttp的call如出一辙,</span><br><span class=\"line\">// 不同的是如果是Android系统回调方法执行在主线程</span><br><span class=\"line\">call.enqueue(new Callback&lt;ResponseBody&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(response.body().string());</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123;</span><br><span class=\"line\">        t.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"converter\"><a class=\"markdownIt-Anchor\" href=\"#converter\"></a> Converter</h1>\n<p>在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,<br>\n即返回值都是 Call<responsebody>,而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，如：</responsebody></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BlogService &#123;</span><br><span class=\"line\">  @GET(&quot;blog/&#123;id&#125;&quot;)</span><br><span class=\"line\">  Call&lt;Result&lt;Blog&gt;&gt; getBlog(@Path(&quot;id&quot;) int id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"引入gson支持\"><a class=\"markdownIt-Anchor\" href=\"#引入gson支持\"></a> 引入Gson支持</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;</span><br></pre></td></tr></table></figure>\n<p>通过GsonConverterFactory为Retrofit添加Gson支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gson gson = new GsonBuilder()</span><br><span class=\"line\">      //配置你的Gson</span><br><span class=\"line\">      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)</span><br><span class=\"line\">      .create();</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = new Retrofit.Builder()</span><br><span class=\"line\">      .baseUrl(&quot;http://localhost:4567/&quot;)</span><br><span class=\"line\">      //可以接收自定义的Gson，当然也可以不传</span><br><span class=\"line\">      .addConverterFactory(GsonConverterFactory.create(gson))</span><br><span class=\"line\">      .build();</span><br></pre></td></tr></table></figure>\n<p>这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@POST(&quot;blog&quot;)</span><br><span class=\"line\">Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);</span><br></pre></td></tr></table></figure>\n<p>被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogService service = retrofit.create(BlogService.class);</span><br><span class=\"line\">Blog blog = new Blog();</span><br><span class=\"line\">blog.content = &quot;新建的Blog&quot;;</span><br><span class=\"line\">blog.title = &quot;测试&quot;;</span><br><span class=\"line\">blog.author = &quot;怪盗kidou&quot;;</span><br><span class=\"line\">Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);</span><br></pre></td></tr></table></figure>\n<h1 id=\"rxjava与calladapter\"><a class=\"markdownIt-Anchor\" href=\"#rxjava与calladapter\"></a> RxJava与CallAdapter</h1>\n<p>Converter是对于Call<t>中T的转换，而CallAdapter则可以对Call转换，这样的话Call<t>中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call：</t></t></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引入RxJava支持:</span><br><span class=\"line\">compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</span><br></pre></td></tr></table></figure>\n<p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = new Retrofit.Builder()</span><br><span class=\"line\">      .baseUrl(&quot;http://localhost:4567/&quot;)</span><br><span class=\"line\">      .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class=\"line\">      // 针对rxjava2.x</span><br><span class=\"line\">      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) </span><br><span class=\"line\">      .build();</span><br></pre></td></tr></table></figure>\n<p>接口设计：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface BlogService &#123;</span><br><span class=\"line\">  @POST(&quot;/blog&quot;)</span><br><span class=\"line\">  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogService service = retrofit.create(BlogService.class);</span><br><span class=\"line\">service.getBlogs(1)</span><br><span class=\"line\">  .subscribeOn(Schedulers.io())</span><br><span class=\"line\">  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void onCompleted() &#123;</span><br><span class=\"line\">        System.out.println(&quot;onCompleted&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void onError(Throwable e) &#123;</span><br><span class=\"line\">        System.err.println(&quot;onError&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) &#123;</span><br><span class=\"line\">        System.out.println(blogsResult);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：</p>\n<ol>\n<li>用Observable&lt;Response<t>&gt; 代替 Observable<t> ,这里的Response指retrofit2.Response</t></t></li>\n<li>用Observable&lt;Result<t>&gt; 代替 Observable<t>，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例</t></t></li>\n</ol>\n<pre class=\"highlight\"><code class=\"\"></code></pre>\n"},{"title":"Rxjava和lambda语法","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n[toc]\n\n# 简介\nJava8 lambda表达式官网：https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\n\n翻译：https://blog.csdn.net/future234/article/details/51919545\n\n语法糖：也译为糖衣语法，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。\n\nlambda表达式其实就是实现SAM接口的语法糖。lambda写的好可以极大的减少代码冗余，同时可读性也好过冗长的内部类，匿名类\n\n可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表\n\n\n参考文章：\nhttps://www.cnblogs.com/aoeiuv/p/5911692.html\n\n# AndroidStudio配置使用lambda\n1. 更新 Android 插件到 3.0.0（或更高版本）\n2. 针对使用（包括在源代码中或通过依赖项使用）Java 8 语言功能的每个模块，在其 build.gradle 文件中添加以下代码：\n~~~\nandroid {\n  ...\n  // Configure only for each module that uses Java 8\n  // language features (either in its source code or\n  // through dependencies).\n  compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n~~~\n\n# lambda表达式语法\n~~~\n(Type1 param1, Type2 param2, ..., TypeN paramN) -> {\n  statment1;\n  statment2;\n  //.............\n  return statmentM;\n}\n~~~\n1. 当lambda表达式的参数个数只有一个，可以省略小括号\n2. 当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号\n3. lambda表达式可以访问给它传递的变量，访问自己内部定义的变量，同时也能访问它外部的变量。\n不过lambda表达式访问外部变量有一个非常重要的限制：变量不可变（只是引用不可变，而不是真正的不可变）\n4. 在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象\n\n# 函数式接口\n* 函数式接口：Functional Interface. \n* 定义的一个接口，接口里面必须 有且只有一个抽象方法 ，这样的接口就成为函数式接口\n* 在可以使用lambda表达式的地方，方法声明时必须包含一个函数式的接口\n* lambda表达式只能出现在目标类型为函数式接口的上下文中,意味着如果我们提供的这个接口包含一个以上的Abstract Method，那么使用lambda表达式则会报错\n\n# 常见写法\n## 替代匿名内部类\n~~~\npublic void oldRunable() {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"The old runable now is using!\");\n        }\n    }).start();\n}\n    \npublic void runable() {\n    new Thread(() -> System.out.println(\"It's a lambda function!\")).start();\n}    \n~~~\n## 对集合进行迭代\n~~~\npublic void iterTest() {\n    List<String> languages = Arrays.asList(\"java\",\"scala\",\"python\");\n    //before java8\n    for(String each:languages) {\n        System.out.println(each);\n    }\n    //after java8\n    languages.forEach(x -> System.out.println(x));\n    languages.forEach(System.out::println);\n}\n~~~\n## 用lambda表达式实现map\nmap函数可以说是函数式编程里最重要的一个方法了,map的作用是将一个对象变换为另外一个\n~~~\npublic void mapTest() {\n    List<Double> cost = Arrays.asList(10.0, 20.0,30.0);\n    cost.stream().map(x -> x + x*0.05).forEach(x -> System.out.println(x));\n}\n~~~\n## 用lambda表达式实现map与reduce\neduce与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个\n~~~\npublic void mapReduceTest() {\n    List<Double> cost = Arrays.asList(10.0, 20.0,30.0);\n    double allCost = cost.stream().map(x -> x+x*0.05).reduce((sum,x) -> sum + x).get();\n    System.out.println(allCost);\n}\n~~~","source":"_posts/微信开发/Rxjava和lambda语法.md","raw":"---\ntitle: Rxjava和lambda语法\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n[toc]\n\n# 简介\nJava8 lambda表达式官网：https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\n\n翻译：https://blog.csdn.net/future234/article/details/51919545\n\n语法糖：也译为糖衣语法，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。\n\nlambda表达式其实就是实现SAM接口的语法糖。lambda写的好可以极大的减少代码冗余，同时可读性也好过冗长的内部类，匿名类\n\n可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表\n\n\n参考文章：\nhttps://www.cnblogs.com/aoeiuv/p/5911692.html\n\n# AndroidStudio配置使用lambda\n1. 更新 Android 插件到 3.0.0（或更高版本）\n2. 针对使用（包括在源代码中或通过依赖项使用）Java 8 语言功能的每个模块，在其 build.gradle 文件中添加以下代码：\n~~~\nandroid {\n  ...\n  // Configure only for each module that uses Java 8\n  // language features (either in its source code or\n  // through dependencies).\n  compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n~~~\n\n# lambda表达式语法\n~~~\n(Type1 param1, Type2 param2, ..., TypeN paramN) -> {\n  statment1;\n  statment2;\n  //.............\n  return statmentM;\n}\n~~~\n1. 当lambda表达式的参数个数只有一个，可以省略小括号\n2. 当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号\n3. lambda表达式可以访问给它传递的变量，访问自己内部定义的变量，同时也能访问它外部的变量。\n不过lambda表达式访问外部变量有一个非常重要的限制：变量不可变（只是引用不可变，而不是真正的不可变）\n4. 在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象\n\n# 函数式接口\n* 函数式接口：Functional Interface. \n* 定义的一个接口，接口里面必须 有且只有一个抽象方法 ，这样的接口就成为函数式接口\n* 在可以使用lambda表达式的地方，方法声明时必须包含一个函数式的接口\n* lambda表达式只能出现在目标类型为函数式接口的上下文中,意味着如果我们提供的这个接口包含一个以上的Abstract Method，那么使用lambda表达式则会报错\n\n# 常见写法\n## 替代匿名内部类\n~~~\npublic void oldRunable() {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"The old runable now is using!\");\n        }\n    }).start();\n}\n    \npublic void runable() {\n    new Thread(() -> System.out.println(\"It's a lambda function!\")).start();\n}    \n~~~\n## 对集合进行迭代\n~~~\npublic void iterTest() {\n    List<String> languages = Arrays.asList(\"java\",\"scala\",\"python\");\n    //before java8\n    for(String each:languages) {\n        System.out.println(each);\n    }\n    //after java8\n    languages.forEach(x -> System.out.println(x));\n    languages.forEach(System.out::println);\n}\n~~~\n## 用lambda表达式实现map\nmap函数可以说是函数式编程里最重要的一个方法了,map的作用是将一个对象变换为另外一个\n~~~\npublic void mapTest() {\n    List<Double> cost = Arrays.asList(10.0, 20.0,30.0);\n    cost.stream().map(x -> x + x*0.05).forEach(x -> System.out.println(x));\n}\n~~~\n## 用lambda表达式实现map与reduce\neduce与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个\n~~~\npublic void mapReduceTest() {\n    List<Double> cost = Arrays.asList(10.0, 20.0,30.0);\n    double allCost = cost.stream().map(x -> x+x*0.05).reduce((sum,x) -> sum + x).get();\n    System.out.println(allCost);\n}\n~~~","slug":"微信开发-Rxjava和lambda语法","published":1,"updated":"2019-02-14T08:57:29.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue06005s5b8h4xzts8gh","content":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Java8 lambda表达式官网：<a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p>\n<p>翻译：<a href=\"https://blog.csdn.net/future234/article/details/51919545\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/future234/article/details/51919545</a></p>\n<p>语法糖：也译为糖衣语法，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>\n<p>lambda表达式其实就是实现SAM接口的语法糖。lambda写的好可以极大的减少代码冗余，同时可读性也好过冗长的内部类，匿名类</p>\n<p>可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表</p>\n<p>参考文章：<br>\n<a href=\"https://www.cnblogs.com/aoeiuv/p/5911692.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/aoeiuv/p/5911692.html</a></p>\n<h1 id=\"androidstudio配置使用lambda\"><a class=\"markdownIt-Anchor\" href=\"#androidstudio配置使用lambda\"></a> AndroidStudio配置使用lambda</h1>\n<ol>\n<li>更新 Android 插件到 3.0.0（或更高版本）</li>\n<li>针对使用（包括在源代码中或通过依赖项使用）Java 8 语言功能的每个模块，在其 build.gradle 文件中添加以下代码：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  // Configure only for each module that uses Java 8</span><br><span class=\"line\">  // language features (either in its source code or</span><br><span class=\"line\">  // through dependencies).</span><br><span class=\"line\">  compileOptions &#123;</span><br><span class=\"line\">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"lambda表达式语法\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式语法\"></a> lambda表达式语法</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123;</span><br><span class=\"line\">  statment1;</span><br><span class=\"line\">  statment2;</span><br><span class=\"line\">  //.............</span><br><span class=\"line\">  return statmentM;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当lambda表达式的参数个数只有一个，可以省略小括号</li>\n<li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号</li>\n<li>lambda表达式可以访问给它传递的变量，访问自己内部定义的变量，同时也能访问它外部的变量。<br>\n不过lambda表达式访问外部变量有一个非常重要的限制：变量不可变（只是引用不可变，而不是真正的不可变）</li>\n<li>在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象</li>\n</ol>\n<h1 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\"></a> 函数式接口</h1>\n<ul>\n<li>函数式接口：Functional Interface.</li>\n<li>定义的一个接口，接口里面必须 有且只有一个抽象方法 ，这样的接口就成为函数式接口</li>\n<li>在可以使用lambda表达式的地方，方法声明时必须包含一个函数式的接口</li>\n<li>lambda表达式只能出现在目标类型为函数式接口的上下文中,意味着如果我们提供的这个接口包含一个以上的Abstract Method，那么使用lambda表达式则会报错</li>\n</ul>\n<h1 id=\"常见写法\"><a class=\"markdownIt-Anchor\" href=\"#常见写法\"></a> 常见写法</h1>\n<h2 id=\"替代匿名内部类\"><a class=\"markdownIt-Anchor\" href=\"#替代匿名内部类\"></a> 替代匿名内部类</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void oldRunable() &#123;</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.out.println(&quot;The old runable now is using!&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">public void runable() &#123;</span><br><span class=\"line\">    new Thread(() -&gt; System.out.println(&quot;It&apos;s a lambda function!&quot;)).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对集合进行迭代\"><a class=\"markdownIt-Anchor\" href=\"#对集合进行迭代\"></a> 对集合进行迭代</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void iterTest() &#123;</span><br><span class=\"line\">    List&lt;String&gt; languages = Arrays.asList(&quot;java&quot;,&quot;scala&quot;,&quot;python&quot;);</span><br><span class=\"line\">    //before java8</span><br><span class=\"line\">    for(String each:languages) &#123;</span><br><span class=\"line\">        System.out.println(each);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //after java8</span><br><span class=\"line\">    languages.forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    languages.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用lambda表达式实现map\"><a class=\"markdownIt-Anchor\" href=\"#用lambda表达式实现map\"></a> 用lambda表达式实现map</h2>\n<p>map函数可以说是函数式编程里最重要的一个方法了,map的作用是将一个对象变换为另外一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void mapTest() &#123;</span><br><span class=\"line\">    List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0);</span><br><span class=\"line\">    cost.stream().map(x -&gt; x + x*0.05).forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用lambda表达式实现map与reduce\"><a class=\"markdownIt-Anchor\" href=\"#用lambda表达式实现map与reduce\"></a> 用lambda表达式实现map与reduce</h2>\n<p>educe与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void mapReduceTest() &#123;</span><br><span class=\"line\">    List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0);</span><br><span class=\"line\">    double allCost = cost.stream().map(x -&gt; x+x*0.05).reduce((sum,x) -&gt; sum + x).get();</span><br><span class=\"line\">    System.out.println(allCost);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Java8 lambda表达式官网：<a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p>\n<p>翻译：<a href=\"https://blog.csdn.net/future234/article/details/51919545\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/future234/article/details/51919545</a></p>\n<p>语法糖：也译为糖衣语法，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>\n<p>lambda表达式其实就是实现SAM接口的语法糖。lambda写的好可以极大的减少代码冗余，同时可读性也好过冗长的内部类，匿名类</p>\n<p>可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表</p>\n<p>参考文章：<br>\n<a href=\"https://www.cnblogs.com/aoeiuv/p/5911692.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/aoeiuv/p/5911692.html</a></p>\n<h1 id=\"androidstudio配置使用lambda\"><a class=\"markdownIt-Anchor\" href=\"#androidstudio配置使用lambda\"></a> AndroidStudio配置使用lambda</h1>\n<ol>\n<li>更新 Android 插件到 3.0.0（或更高版本）</li>\n<li>针对使用（包括在源代码中或通过依赖项使用）Java 8 语言功能的每个模块，在其 build.gradle 文件中添加以下代码：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  // Configure only for each module that uses Java 8</span><br><span class=\"line\">  // language features (either in its source code or</span><br><span class=\"line\">  // through dependencies).</span><br><span class=\"line\">  compileOptions &#123;</span><br><span class=\"line\">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"lambda表达式语法\"><a class=\"markdownIt-Anchor\" href=\"#lambda表达式语法\"></a> lambda表达式语法</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123;</span><br><span class=\"line\">  statment1;</span><br><span class=\"line\">  statment2;</span><br><span class=\"line\">  //.............</span><br><span class=\"line\">  return statmentM;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当lambda表达式的参数个数只有一个，可以省略小括号</li>\n<li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号</li>\n<li>lambda表达式可以访问给它传递的变量，访问自己内部定义的变量，同时也能访问它外部的变量。<br>\n不过lambda表达式访问外部变量有一个非常重要的限制：变量不可变（只是引用不可变，而不是真正的不可变）</li>\n<li>在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象</li>\n</ol>\n<h1 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\"></a> 函数式接口</h1>\n<ul>\n<li>函数式接口：Functional Interface.</li>\n<li>定义的一个接口，接口里面必须 有且只有一个抽象方法 ，这样的接口就成为函数式接口</li>\n<li>在可以使用lambda表达式的地方，方法声明时必须包含一个函数式的接口</li>\n<li>lambda表达式只能出现在目标类型为函数式接口的上下文中,意味着如果我们提供的这个接口包含一个以上的Abstract Method，那么使用lambda表达式则会报错</li>\n</ul>\n<h1 id=\"常见写法\"><a class=\"markdownIt-Anchor\" href=\"#常见写法\"></a> 常见写法</h1>\n<h2 id=\"替代匿名内部类\"><a class=\"markdownIt-Anchor\" href=\"#替代匿名内部类\"></a> 替代匿名内部类</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void oldRunable() &#123;</span><br><span class=\"line\">    new Thread(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.out.println(&quot;The old runable now is using!&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">public void runable() &#123;</span><br><span class=\"line\">    new Thread(() -&gt; System.out.println(&quot;It&apos;s a lambda function!&quot;)).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"对集合进行迭代\"><a class=\"markdownIt-Anchor\" href=\"#对集合进行迭代\"></a> 对集合进行迭代</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void iterTest() &#123;</span><br><span class=\"line\">    List&lt;String&gt; languages = Arrays.asList(&quot;java&quot;,&quot;scala&quot;,&quot;python&quot;);</span><br><span class=\"line\">    //before java8</span><br><span class=\"line\">    for(String each:languages) &#123;</span><br><span class=\"line\">        System.out.println(each);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //after java8</span><br><span class=\"line\">    languages.forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    languages.forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用lambda表达式实现map\"><a class=\"markdownIt-Anchor\" href=\"#用lambda表达式实现map\"></a> 用lambda表达式实现map</h2>\n<p>map函数可以说是函数式编程里最重要的一个方法了,map的作用是将一个对象变换为另外一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void mapTest() &#123;</span><br><span class=\"line\">    List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0);</span><br><span class=\"line\">    cost.stream().map(x -&gt; x + x*0.05).forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用lambda表达式实现map与reduce\"><a class=\"markdownIt-Anchor\" href=\"#用lambda表达式实现map与reduce\"></a> 用lambda表达式实现map与reduce</h2>\n<p>educe与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void mapReduceTest() &#123;</span><br><span class=\"line\">    List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0);</span><br><span class=\"line\">    double allCost = cost.stream().map(x -&gt; x+x*0.05).reduce((sum,x) -&gt; sum + x).get();</span><br><span class=\"line\">    System.out.println(allCost);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"android中MVP模式简介","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n[toc]\n\nhttps://github.com/googlesamples\n\nhttps://github.com/googlesamples/android-architecture\n\n# 简介\n* MVP作为MVC的演化版本，那么类似的MVP所对应的意义：M-Model-模型、V-View-视图、P-Presenter-表示器\n* Android本身就采用的是MVC（Model View Controllor）模式、其中Model指的是数据逻辑和实体模型；View指的是布局文件、Controllor指的是Activity\n* 从MVC和MVP两者结合来看，Controlller/Presenter在MVC/MVP中都起着逻辑控制处理的角色，起着控制各业务流程的作用\n* MVP与MVC最不同的一点是M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层，其负责调控 View与Model之间的间接交互\n* 在 Android中很重要的一点就是对UI的操作基本上需要异步进行也就是在MainThread中才能操作UI，所以对View与Model的切断分离是 合理的\n* Presenter与View、Model的交互使用接口定义交互操作可以进一步达到松耦合也可以通过接口更加方便地进行单元测试\n\n# 具体使用\n参考：\n1. https://www.jianshu.com/p/1f91cfd68d48\n2. https://github.com/LJYcoder/DevRing\n3. http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926\n4. https://www.jianshu.com/p/364f14c76874\n\n需要写四个部分：Model层，View层，Presenter层，接口\n\n## 接口\n负责“连接”MVP三层，以便方法调用、数据流动。同时也便于进行单元测试。\n\n### IView\nView层接口，定义View层需实现的方法，P层通过该接口回调通知View层\n~~~\npublic interface IMovieView {\n    //成功获取到电影数据\n    void getMovieSuccess(List<MovieRes> list, int type);\n    //获取电影数据失败\n    void getMovieFail(int status, String desc, int type);\n}\n~~~\n\n### IModel/IService\nModel层接口，定义Model层需实现的方法，P层通过该接口调用M层获取/处理数据的方法;有些项目把这块也拆分未Service层，叫法不同而已\n~~~\npublic interface IMovieMoel{\n    //请求正在上映的电影数据\n    Observable getPlayingMovie(int start, int count);\n    ...\n}\n~~~\n\n## Model层／Service\n实现IModel／IService接口中的方法，负责数据的获取/处理\n~~~\npublic class MovieModel implements IMovieMoel{\n\n    @Override\n    public Observable getPlayingMovie(int start,int count) {\n        //提供数据源\n        return DevRing.httpManager().getService(MovieApiService.class).getPlayingMovie(start, count);\n    }\n    ...\n}\n~~~\n\n## Presenter层\n* Presenter处理业务逻辑，调用M层获取数据，调用V层传递展示数据\n* Presenter持有一个IView接口，是为了能够通过View接口通知Activity进行更新界面等操作 \n~~~\npublic class MoviePresenter {\n    private IMovieView mIView;\n    private IMovieModel mIModel;\n\n    public MoviePresenter(IMovieView iMovieView, IMovieMoel iMovieMoel) {\n        mIView = iMovieView;\n        mIModel = iMovieModel;\n    }\n\n    /**\n     * 获取正在上映的电影\n     *\n     * @param start 请求电影的起始位置\n     * @param count 获取的电影数量\n     * @param type  类型：初始化数据INIT、刷新数据REFRESH、加载更多数据LOADMORE\n     */\n    public void getPlayingMovie(int start, int count, final int type) {\n        DevRing.httpManager().commonRequest( mIModel.getPlayingMovie(start, count),\n         new CommonObserver<HttpResult<List<MovieRes>>>() {\n            @Override\n            public void onResult(HttpResult<List<MovieRes>> result) {\n                if (mIView != null) {\n                    mIView.getMovieSuccess(result.getSubjects(), type);\n                }\n            }\n\n            @Override\n            public void onError(int errType, String errMessage) {\n                if (mIView != null) {\n                    mIView.getMovieFail(errType, errMessage, type);\n                }\n            }\n        }, RxLifecycleUtil.bindUntilDestroy(mIView)); \n    }\n\n    ...\n\n     /**\n     * 释放引用，防止内存泄露\n     */\n    public void destroy() {\n        mIView = null;\n    }\n}\n~~~\n\n## View层\n实现IView接口中的方法，对获取到的数据进行展示。对应日常的Activity／Fragement类，实现Iview接口\n~~~\npublic class MovieActivity extends Activity implements IMovieView {\n    //获取电影数据成功的网络请求回调\n    @Override\n    public void getMovieSuccess(List<MovieRes> list, int type) {\n        //成功，对数据进行展示\n        ....\n    }\n\n    //获取电影数据失败的网络请求回调\n    @Override\n    public void getMovieFail(int status, String desc, int type) {\n        //失败，界面上做出相应提示\n        ...\n    }\n\n    ...\n}\n~~~\n或者匿名类对象关联：\n~~~\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ...\n        mBookPresenter.onCreate();\n        mBookPresenter.attachView(mBookView);\n    }\n\nprivate BookView mBookView = new BookView() {\n    @Override\n    public void onSuccess(Book mBook) {\n        text.setText(mBook.toString());\n    }\n\n    @Override\n    public void onError(String result) {\n        Toast.makeText(MainActivity.this,result, Toast.LENGTH_SHORT).show();\n    }\n};\n~~~\n\n## 调用\n1. 在View层初始化时，调用Presenter层方法即可\n~~~\n@Override\nprotected void onCreate(Bundle saveInstanceState) {\n      ...\n      mPresenter = new MoviePresenter(this, new MovieModel());\n      mPresenter.getPlayingMovie(start, mCount, type);\n}\n~~~\n2. 如果Presenter层持有了View层的引用，那么记得在V层销毁时，把Presenter层中对View层的引用置null，避免View层回收失败导致内存泄漏\n~~~\n@Override\npublic void onDestroy() {\n     super.onDestroy();\n     if (mPresenter != null) {\n          mPresenter.destroy();\n          mPresenter = null;\n     }\n }\n~~~\n\n ","source":"_posts/微信开发/android中MVP模式简介.md","raw":"---\ntitle: android中MVP模式简介\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n[toc]\n\nhttps://github.com/googlesamples\n\nhttps://github.com/googlesamples/android-architecture\n\n# 简介\n* MVP作为MVC的演化版本，那么类似的MVP所对应的意义：M-Model-模型、V-View-视图、P-Presenter-表示器\n* Android本身就采用的是MVC（Model View Controllor）模式、其中Model指的是数据逻辑和实体模型；View指的是布局文件、Controllor指的是Activity\n* 从MVC和MVP两者结合来看，Controlller/Presenter在MVC/MVP中都起着逻辑控制处理的角色，起着控制各业务流程的作用\n* MVP与MVC最不同的一点是M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层，其负责调控 View与Model之间的间接交互\n* 在 Android中很重要的一点就是对UI的操作基本上需要异步进行也就是在MainThread中才能操作UI，所以对View与Model的切断分离是 合理的\n* Presenter与View、Model的交互使用接口定义交互操作可以进一步达到松耦合也可以通过接口更加方便地进行单元测试\n\n# 具体使用\n参考：\n1. https://www.jianshu.com/p/1f91cfd68d48\n2. https://github.com/LJYcoder/DevRing\n3. http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926\n4. https://www.jianshu.com/p/364f14c76874\n\n需要写四个部分：Model层，View层，Presenter层，接口\n\n## 接口\n负责“连接”MVP三层，以便方法调用、数据流动。同时也便于进行单元测试。\n\n### IView\nView层接口，定义View层需实现的方法，P层通过该接口回调通知View层\n~~~\npublic interface IMovieView {\n    //成功获取到电影数据\n    void getMovieSuccess(List<MovieRes> list, int type);\n    //获取电影数据失败\n    void getMovieFail(int status, String desc, int type);\n}\n~~~\n\n### IModel/IService\nModel层接口，定义Model层需实现的方法，P层通过该接口调用M层获取/处理数据的方法;有些项目把这块也拆分未Service层，叫法不同而已\n~~~\npublic interface IMovieMoel{\n    //请求正在上映的电影数据\n    Observable getPlayingMovie(int start, int count);\n    ...\n}\n~~~\n\n## Model层／Service\n实现IModel／IService接口中的方法，负责数据的获取/处理\n~~~\npublic class MovieModel implements IMovieMoel{\n\n    @Override\n    public Observable getPlayingMovie(int start,int count) {\n        //提供数据源\n        return DevRing.httpManager().getService(MovieApiService.class).getPlayingMovie(start, count);\n    }\n    ...\n}\n~~~\n\n## Presenter层\n* Presenter处理业务逻辑，调用M层获取数据，调用V层传递展示数据\n* Presenter持有一个IView接口，是为了能够通过View接口通知Activity进行更新界面等操作 \n~~~\npublic class MoviePresenter {\n    private IMovieView mIView;\n    private IMovieModel mIModel;\n\n    public MoviePresenter(IMovieView iMovieView, IMovieMoel iMovieMoel) {\n        mIView = iMovieView;\n        mIModel = iMovieModel;\n    }\n\n    /**\n     * 获取正在上映的电影\n     *\n     * @param start 请求电影的起始位置\n     * @param count 获取的电影数量\n     * @param type  类型：初始化数据INIT、刷新数据REFRESH、加载更多数据LOADMORE\n     */\n    public void getPlayingMovie(int start, int count, final int type) {\n        DevRing.httpManager().commonRequest( mIModel.getPlayingMovie(start, count),\n         new CommonObserver<HttpResult<List<MovieRes>>>() {\n            @Override\n            public void onResult(HttpResult<List<MovieRes>> result) {\n                if (mIView != null) {\n                    mIView.getMovieSuccess(result.getSubjects(), type);\n                }\n            }\n\n            @Override\n            public void onError(int errType, String errMessage) {\n                if (mIView != null) {\n                    mIView.getMovieFail(errType, errMessage, type);\n                }\n            }\n        }, RxLifecycleUtil.bindUntilDestroy(mIView)); \n    }\n\n    ...\n\n     /**\n     * 释放引用，防止内存泄露\n     */\n    public void destroy() {\n        mIView = null;\n    }\n}\n~~~\n\n## View层\n实现IView接口中的方法，对获取到的数据进行展示。对应日常的Activity／Fragement类，实现Iview接口\n~~~\npublic class MovieActivity extends Activity implements IMovieView {\n    //获取电影数据成功的网络请求回调\n    @Override\n    public void getMovieSuccess(List<MovieRes> list, int type) {\n        //成功，对数据进行展示\n        ....\n    }\n\n    //获取电影数据失败的网络请求回调\n    @Override\n    public void getMovieFail(int status, String desc, int type) {\n        //失败，界面上做出相应提示\n        ...\n    }\n\n    ...\n}\n~~~\n或者匿名类对象关联：\n~~~\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ...\n        mBookPresenter.onCreate();\n        mBookPresenter.attachView(mBookView);\n    }\n\nprivate BookView mBookView = new BookView() {\n    @Override\n    public void onSuccess(Book mBook) {\n        text.setText(mBook.toString());\n    }\n\n    @Override\n    public void onError(String result) {\n        Toast.makeText(MainActivity.this,result, Toast.LENGTH_SHORT).show();\n    }\n};\n~~~\n\n## 调用\n1. 在View层初始化时，调用Presenter层方法即可\n~~~\n@Override\nprotected void onCreate(Bundle saveInstanceState) {\n      ...\n      mPresenter = new MoviePresenter(this, new MovieModel());\n      mPresenter.getPlayingMovie(start, mCount, type);\n}\n~~~\n2. 如果Presenter层持有了View层的引用，那么记得在V层销毁时，把Presenter层中对View层的引用置null，避免View层回收失败导致内存泄漏\n~~~\n@Override\npublic void onDestroy() {\n     super.onDestroy();\n     if (mPresenter != null) {\n          mPresenter.destroy();\n          mPresenter = null;\n     }\n }\n~~~\n\n ","slug":"微信开发-android中MVP模式简介","published":1,"updated":"2019-02-14T08:58:45.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue08005x5b8hw65ukmsv","content":"<p>[toc]</p>\n<p><a href=\"https://github.com/googlesamples\" target=\"_blank\" rel=\"noopener\">https://github.com/googlesamples</a></p>\n<p><a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"noopener\">https://github.com/googlesamples/android-architecture</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>MVP作为MVC的演化版本，那么类似的MVP所对应的意义：M-Model-模型、V-View-视图、P-Presenter-表示器</li>\n<li>Android本身就采用的是MVC（Model View Controllor）模式、其中Model指的是数据逻辑和实体模型；View指的是布局文件、Controllor指的是Activity</li>\n<li>从MVC和MVP两者结合来看，Controlller/Presenter在MVC/MVP中都起着逻辑控制处理的角色，起着控制各业务流程的作用</li>\n<li>MVP与MVC最不同的一点是M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层，其负责调控 View与Model之间的间接交互</li>\n<li>在 Android中很重要的一点就是对UI的操作基本上需要异步进行也就是在MainThread中才能操作UI，所以对View与Model的切断分离是 合理的</li>\n<li>Presenter与View、Model的交互使用接口定义交互操作可以进一步达到松耦合也可以通过接口更加方便地进行单元测试</li>\n</ul>\n<h1 id=\"具体使用\"><a class=\"markdownIt-Anchor\" href=\"#具体使用\"></a> 具体使用</h1>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/1f91cfd68d48\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1f91cfd68d48</a></li>\n<li><a href=\"https://github.com/LJYcoder/DevRing\" target=\"_blank\" rel=\"noopener\">https://github.com/LJYcoder/DevRing</a></li>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926</a></li>\n<li><a href=\"https://www.jianshu.com/p/364f14c76874\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/364f14c76874</a></li>\n</ol>\n<p>需要写四个部分：Model层，View层，Presenter层，接口</p>\n<h2 id=\"接口\"><a class=\"markdownIt-Anchor\" href=\"#接口\"></a> 接口</h2>\n<p>负责“连接”MVP三层，以便方法调用、数据流动。同时也便于进行单元测试。</p>\n<h3 id=\"iview\"><a class=\"markdownIt-Anchor\" href=\"#iview\"></a> IView</h3>\n<p>View层接口，定义View层需实现的方法，P层通过该接口回调通知View层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IMovieView &#123;</span><br><span class=\"line\">    //成功获取到电影数据</span><br><span class=\"line\">    void getMovieSuccess(List&lt;MovieRes&gt; list, int type);</span><br><span class=\"line\">    //获取电影数据失败</span><br><span class=\"line\">    void getMovieFail(int status, String desc, int type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"imodeliservice\"><a class=\"markdownIt-Anchor\" href=\"#imodeliservice\"></a> IModel/IService</h3>\n<p>Model层接口，定义Model层需实现的方法，P层通过该接口调用M层获取/处理数据的方法;有些项目把这块也拆分未Service层，叫法不同而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IMovieMoel&#123;</span><br><span class=\"line\">    //请求正在上映的电影数据</span><br><span class=\"line\">    Observable getPlayingMovie(int start, int count);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"model层service\"><a class=\"markdownIt-Anchor\" href=\"#model层service\"></a> Model层／Service</h2>\n<p>实现IModel／IService接口中的方法，负责数据的获取/处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MovieModel implements IMovieMoel&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Observable getPlayingMovie(int start,int count) &#123;</span><br><span class=\"line\">        //提供数据源</span><br><span class=\"line\">        return DevRing.httpManager().getService(MovieApiService.class).getPlayingMovie(start, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"presenter层\"><a class=\"markdownIt-Anchor\" href=\"#presenter层\"></a> Presenter层</h2>\n<ul>\n<li>Presenter处理业务逻辑，调用M层获取数据，调用V层传递展示数据</li>\n<li>Presenter持有一个IView接口，是为了能够通过View接口通知Activity进行更新界面等操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MoviePresenter &#123;</span><br><span class=\"line\">    private IMovieView mIView;</span><br><span class=\"line\">    private IMovieModel mIModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MoviePresenter(IMovieView iMovieView, IMovieMoel iMovieMoel) &#123;</span><br><span class=\"line\">        mIView = iMovieView;</span><br><span class=\"line\">        mIModel = iMovieModel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取正在上映的电影</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param start 请求电影的起始位置</span><br><span class=\"line\">     * @param count 获取的电影数量</span><br><span class=\"line\">     * @param type  类型：初始化数据INIT、刷新数据REFRESH、加载更多数据LOADMORE</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void getPlayingMovie(int start, int count, final int type) &#123;</span><br><span class=\"line\">        DevRing.httpManager().commonRequest( mIModel.getPlayingMovie(start, count),</span><br><span class=\"line\">         new CommonObserver&lt;HttpResult&lt;List&lt;MovieRes&gt;&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onResult(HttpResult&lt;List&lt;MovieRes&gt;&gt; result) &#123;</span><br><span class=\"line\">                if (mIView != null) &#123;</span><br><span class=\"line\">                    mIView.getMovieSuccess(result.getSubjects(), type);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onError(int errType, String errMessage) &#123;</span><br><span class=\"line\">                if (mIView != null) &#123;</span><br><span class=\"line\">                    mIView.getMovieFail(errType, errMessage, type);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, RxLifecycleUtil.bindUntilDestroy(mIView)); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">     /**</span><br><span class=\"line\">     * 释放引用，防止内存泄露</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void destroy() &#123;</span><br><span class=\"line\">        mIView = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"view层\"><a class=\"markdownIt-Anchor\" href=\"#view层\"></a> View层</h2>\n<p>实现IView接口中的方法，对获取到的数据进行展示。对应日常的Activity／Fragement类，实现Iview接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MovieActivity extends Activity implements IMovieView &#123;</span><br><span class=\"line\">    //获取电影数据成功的网络请求回调</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void getMovieSuccess(List&lt;MovieRes&gt; list, int type) &#123;</span><br><span class=\"line\">        //成功，对数据进行展示</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //获取电影数据失败的网络请求回调</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void getMovieFail(int status, String desc, int type) &#123;</span><br><span class=\"line\">        //失败，界面上做出相应提示</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者匿名类对象关联：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mBookPresenter.onCreate();</span><br><span class=\"line\">        mBookPresenter.attachView(mBookView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private BookView mBookView = new BookView() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onSuccess(Book mBook) &#123;</span><br><span class=\"line\">        text.setText(mBook.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onError(String result) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this,result, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用\"><a class=\"markdownIt-Anchor\" href=\"#调用\"></a> 调用</h2>\n<ol>\n<li>在View层初始化时，调用Presenter层方法即可</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle saveInstanceState) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      mPresenter = new MoviePresenter(this, new MovieModel());</span><br><span class=\"line\">      mPresenter.getPlayingMovie(start, mCount, type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>如果Presenter层持有了View层的引用，那么记得在V层销毁时，把Presenter层中对View层的引用置null，避免View层回收失败导致内存泄漏</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onDestroy() &#123;</span><br><span class=\"line\">     super.onDestroy();</span><br><span class=\"line\">     if (mPresenter != null) &#123;</span><br><span class=\"line\">          mPresenter.destroy();</span><br><span class=\"line\">          mPresenter = null;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p><a href=\"https://github.com/googlesamples\" target=\"_blank\" rel=\"noopener\">https://github.com/googlesamples</a></p>\n<p><a href=\"https://github.com/googlesamples/android-architecture\" target=\"_blank\" rel=\"noopener\">https://github.com/googlesamples/android-architecture</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>MVP作为MVC的演化版本，那么类似的MVP所对应的意义：M-Model-模型、V-View-视图、P-Presenter-表示器</li>\n<li>Android本身就采用的是MVC（Model View Controllor）模式、其中Model指的是数据逻辑和实体模型；View指的是布局文件、Controllor指的是Activity</li>\n<li>从MVC和MVP两者结合来看，Controlller/Presenter在MVC/MVP中都起着逻辑控制处理的角色，起着控制各业务流程的作用</li>\n<li>MVP与MVC最不同的一点是M与V是不直接关联的也是就Model与View不存在直接关系，这两者之间间隔着的是Presenter层，其负责调控 View与Model之间的间接交互</li>\n<li>在 Android中很重要的一点就是对UI的操作基本上需要异步进行也就是在MainThread中才能操作UI，所以对View与Model的切断分离是 合理的</li>\n<li>Presenter与View、Model的交互使用接口定义交互操作可以进一步达到松耦合也可以通过接口更加方便地进行单元测试</li>\n</ul>\n<h1 id=\"具体使用\"><a class=\"markdownIt-Anchor\" href=\"#具体使用\"></a> 具体使用</h1>\n<p>参考：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/1f91cfd68d48\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1f91cfd68d48</a></li>\n<li><a href=\"https://github.com/LJYcoder/DevRing\" target=\"_blank\" rel=\"noopener\">https://github.com/LJYcoder/DevRing</a></li>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926</a></li>\n<li><a href=\"https://www.jianshu.com/p/364f14c76874\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/364f14c76874</a></li>\n</ol>\n<p>需要写四个部分：Model层，View层，Presenter层，接口</p>\n<h2 id=\"接口\"><a class=\"markdownIt-Anchor\" href=\"#接口\"></a> 接口</h2>\n<p>负责“连接”MVP三层，以便方法调用、数据流动。同时也便于进行单元测试。</p>\n<h3 id=\"iview\"><a class=\"markdownIt-Anchor\" href=\"#iview\"></a> IView</h3>\n<p>View层接口，定义View层需实现的方法，P层通过该接口回调通知View层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IMovieView &#123;</span><br><span class=\"line\">    //成功获取到电影数据</span><br><span class=\"line\">    void getMovieSuccess(List&lt;MovieRes&gt; list, int type);</span><br><span class=\"line\">    //获取电影数据失败</span><br><span class=\"line\">    void getMovieFail(int status, String desc, int type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"imodeliservice\"><a class=\"markdownIt-Anchor\" href=\"#imodeliservice\"></a> IModel/IService</h3>\n<p>Model层接口，定义Model层需实现的方法，P层通过该接口调用M层获取/处理数据的方法;有些项目把这块也拆分未Service层，叫法不同而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IMovieMoel&#123;</span><br><span class=\"line\">    //请求正在上映的电影数据</span><br><span class=\"line\">    Observable getPlayingMovie(int start, int count);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"model层service\"><a class=\"markdownIt-Anchor\" href=\"#model层service\"></a> Model层／Service</h2>\n<p>实现IModel／IService接口中的方法，负责数据的获取/处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MovieModel implements IMovieMoel&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Observable getPlayingMovie(int start,int count) &#123;</span><br><span class=\"line\">        //提供数据源</span><br><span class=\"line\">        return DevRing.httpManager().getService(MovieApiService.class).getPlayingMovie(start, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"presenter层\"><a class=\"markdownIt-Anchor\" href=\"#presenter层\"></a> Presenter层</h2>\n<ul>\n<li>Presenter处理业务逻辑，调用M层获取数据，调用V层传递展示数据</li>\n<li>Presenter持有一个IView接口，是为了能够通过View接口通知Activity进行更新界面等操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MoviePresenter &#123;</span><br><span class=\"line\">    private IMovieView mIView;</span><br><span class=\"line\">    private IMovieModel mIModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MoviePresenter(IMovieView iMovieView, IMovieMoel iMovieMoel) &#123;</span><br><span class=\"line\">        mIView = iMovieView;</span><br><span class=\"line\">        mIModel = iMovieModel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取正在上映的电影</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param start 请求电影的起始位置</span><br><span class=\"line\">     * @param count 获取的电影数量</span><br><span class=\"line\">     * @param type  类型：初始化数据INIT、刷新数据REFRESH、加载更多数据LOADMORE</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void getPlayingMovie(int start, int count, final int type) &#123;</span><br><span class=\"line\">        DevRing.httpManager().commonRequest( mIModel.getPlayingMovie(start, count),</span><br><span class=\"line\">         new CommonObserver&lt;HttpResult&lt;List&lt;MovieRes&gt;&gt;&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onResult(HttpResult&lt;List&lt;MovieRes&gt;&gt; result) &#123;</span><br><span class=\"line\">                if (mIView != null) &#123;</span><br><span class=\"line\">                    mIView.getMovieSuccess(result.getSubjects(), type);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onError(int errType, String errMessage) &#123;</span><br><span class=\"line\">                if (mIView != null) &#123;</span><br><span class=\"line\">                    mIView.getMovieFail(errType, errMessage, type);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, RxLifecycleUtil.bindUntilDestroy(mIView)); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">     /**</span><br><span class=\"line\">     * 释放引用，防止内存泄露</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void destroy() &#123;</span><br><span class=\"line\">        mIView = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"view层\"><a class=\"markdownIt-Anchor\" href=\"#view层\"></a> View层</h2>\n<p>实现IView接口中的方法，对获取到的数据进行展示。对应日常的Activity／Fragement类，实现Iview接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MovieActivity extends Activity implements IMovieView &#123;</span><br><span class=\"line\">    //获取电影数据成功的网络请求回调</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void getMovieSuccess(List&lt;MovieRes&gt; list, int type) &#123;</span><br><span class=\"line\">        //成功，对数据进行展示</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //获取电影数据失败的网络请求回调</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void getMovieFail(int status, String desc, int type) &#123;</span><br><span class=\"line\">        //失败，界面上做出相应提示</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者匿名类对象关联：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mBookPresenter.onCreate();</span><br><span class=\"line\">        mBookPresenter.attachView(mBookView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private BookView mBookView = new BookView() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onSuccess(Book mBook) &#123;</span><br><span class=\"line\">        text.setText(mBook.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onError(String result) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this,result, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用\"><a class=\"markdownIt-Anchor\" href=\"#调用\"></a> 调用</h2>\n<ol>\n<li>在View层初始化时，调用Presenter层方法即可</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle saveInstanceState) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      mPresenter = new MoviePresenter(this, new MovieModel());</span><br><span class=\"line\">      mPresenter.getPlayingMovie(start, mCount, type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>如果Presenter层持有了View层的引用，那么记得在V层销毁时，把Presenter层中对View层的引用置null，避免View层回收失败导致内存泄漏</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onDestroy() &#123;</span><br><span class=\"line\">     super.onDestroy();</span><br><span class=\"line\">     if (mPresenter != null) &#123;</span><br><span class=\"line\">          mPresenter.destroy();</span><br><span class=\"line\">          mPresenter = null;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"android中handler的使用","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n[toc]\n\n# 简介\nhandler是android提供的用来更新UI的一套机制，也是一套消息处理机制，我们可以发送消息，也可以通过它处理消息\n\nandroid在设计的时候，就封装了一套消息创建、传递、处理机制，如果不遵循这样的机制就没有办法更新UI信息\n\n# 使用\n* sendMessage\n* sendMessageDelayed\n* post(Runnable)\n* postDelayed(Runable,long)\n\nhandler.obtainMessage();\nSendToTarget\n拦截MEssage\n\n# 原理\n1. Handler分装了消息的发送（主要包括消息发送给谁）\n~~~\nLooper\n* 内部包含一个消息队列也就是MessageQueue，所有的Handler发送的消息都走向这个消息队列\n* Looper.Looper方法，就是一个死循环，不断的从MessageQueue去消息，如果有消息就处理消息，没有消息就阻塞\n~~~\n2. MessageQueue，就是一个消息队列，可以添加消息，并处理消息\n3. Handler很简单，内部会跟Looper进行关联，也就说在Handler的内部可以找到Looper，找到了Looper也就找到了MessageQueue，在Handler中发送消息，其实就是想MessageQueue队列中发送消息\n\n总结：Handler负责发送消息，Looper负责接收Handler发送的消息，并直接把消息回传给Handler自己，MessageQueue就是一个存储消息的容器\n\n","source":"_posts/微信开发/android中handler的使用.md","raw":"---\ntitle: android中handler的使用\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n[toc]\n\n# 简介\nhandler是android提供的用来更新UI的一套机制，也是一套消息处理机制，我们可以发送消息，也可以通过它处理消息\n\nandroid在设计的时候，就封装了一套消息创建、传递、处理机制，如果不遵循这样的机制就没有办法更新UI信息\n\n# 使用\n* sendMessage\n* sendMessageDelayed\n* post(Runnable)\n* postDelayed(Runable,long)\n\nhandler.obtainMessage();\nSendToTarget\n拦截MEssage\n\n# 原理\n1. Handler分装了消息的发送（主要包括消息发送给谁）\n~~~\nLooper\n* 内部包含一个消息队列也就是MessageQueue，所有的Handler发送的消息都走向这个消息队列\n* Looper.Looper方法，就是一个死循环，不断的从MessageQueue去消息，如果有消息就处理消息，没有消息就阻塞\n~~~\n2. MessageQueue，就是一个消息队列，可以添加消息，并处理消息\n3. Handler很简单，内部会跟Looper进行关联，也就说在Handler的内部可以找到Looper，找到了Looper也就找到了MessageQueue，在Handler中发送消息，其实就是想MessageQueue队列中发送消息\n\n总结：Handler负责发送消息，Looper负责接收Handler发送的消息，并直接把消息回传给Handler自己，MessageQueue就是一个存储消息的容器\n\n","slug":"微信开发-android中handler的使用","published":1,"updated":"2019-02-14T08:50:01.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue09005y5b8hr46tatjr","content":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>handler是android提供的用来更新UI的一套机制，也是一套消息处理机制，我们可以发送消息，也可以通过它处理消息</p>\n<p>android在设计的时候，就封装了一套消息创建、传递、处理机制，如果不遵循这样的机制就没有办法更新UI信息</p>\n<h1 id=\"使用\"><a class=\"markdownIt-Anchor\" href=\"#使用\"></a> 使用</h1>\n<ul>\n<li>sendMessage</li>\n<li>sendMessageDelayed</li>\n<li>post(Runnable)</li>\n<li>postDelayed(Runable,long)</li>\n</ul>\n<p>handler.obtainMessage();<br>\nSendToTarget<br>\n拦截MEssage</p>\n<h1 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h1>\n<ol>\n<li>Handler分装了消息的发送（主要包括消息发送给谁）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper</span><br><span class=\"line\">* 内部包含一个消息队列也就是MessageQueue，所有的Handler发送的消息都走向这个消息队列</span><br><span class=\"line\">* Looper.Looper方法，就是一个死循环，不断的从MessageQueue去消息，如果有消息就处理消息，没有消息就阻塞</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>MessageQueue，就是一个消息队列，可以添加消息，并处理消息</li>\n<li>Handler很简单，内部会跟Looper进行关联，也就说在Handler的内部可以找到Looper，找到了Looper也就找到了MessageQueue，在Handler中发送消息，其实就是想MessageQueue队列中发送消息</li>\n</ol>\n<p>总结：Handler负责发送消息，Looper负责接收Handler发送的消息，并直接把消息回传给Handler自己，MessageQueue就是一个存储消息的容器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>handler是android提供的用来更新UI的一套机制，也是一套消息处理机制，我们可以发送消息，也可以通过它处理消息</p>\n<p>android在设计的时候，就封装了一套消息创建、传递、处理机制，如果不遵循这样的机制就没有办法更新UI信息</p>\n<h1 id=\"使用\"><a class=\"markdownIt-Anchor\" href=\"#使用\"></a> 使用</h1>\n<ul>\n<li>sendMessage</li>\n<li>sendMessageDelayed</li>\n<li>post(Runnable)</li>\n<li>postDelayed(Runable,long)</li>\n</ul>\n<p>handler.obtainMessage();<br>\nSendToTarget<br>\n拦截MEssage</p>\n<h1 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h1>\n<ol>\n<li>Handler分装了消息的发送（主要包括消息发送给谁）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper</span><br><span class=\"line\">* 内部包含一个消息队列也就是MessageQueue，所有的Handler发送的消息都走向这个消息队列</span><br><span class=\"line\">* Looper.Looper方法，就是一个死循环，不断的从MessageQueue去消息，如果有消息就处理消息，没有消息就阻塞</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>MessageQueue，就是一个消息队列，可以添加消息，并处理消息</li>\n<li>Handler很简单，内部会跟Looper进行关联，也就说在Handler的内部可以找到Looper，找到了Looper也就找到了MessageQueue，在Handler中发送消息，其实就是想MessageQueue队列中发送消息</li>\n</ol>\n<p>总结：Handler负责发送消息，Looper负责接收Handler发送的消息，并直接把消息回传给Handler自己，MessageQueue就是一个存储消息的容器</p>\n"},{"title":"android权限介绍","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n\n[toc]\n\nhttps://blog.csdn.net/u013553529/article/details/68948971\n\n# 简介\nAndroid 6.0 （API level 23）中，将权限分成了两类。一类是Install权限（称之为安装时权限），另一类是Runtime权限（称之为运行时权限）\n\nInstall权限\n~~~\n* 在安装app时，就赋予该app的权限，即安装后立即获取到的权限\n* normal和signature级别的权限都是安装时权限\n* 赋予app normal和signature权限时，不会给用户提示界面，系统自动决定权限的赋予\n* 对于signature权限，如果使用权限的app与声明权限的app的签名不一致，则系统拒绝赋予该signature权限\n~~~\n\nRuntime权限\n~~~\n* 指在app运行过程中，赋予app的权限,会显示明显的权限授予界面，让用户决定是否授予权限\n* 如果一个app的targetSdkVersion是23及以上，那么该app所申请的所有dangerous权限都是运行时权限\n* Android 6及以上的环境中，该app在运行时必须主动申请这些dangerous权限（调用requestPermissions()），否则该app没有获取到dangerous权限\n~~~\n\nRxPermissions是帮助开发者简化requestPermissions()相关的处理\n\n官网：https://github.com/tbruyelle/RxPermissions\n\n1. 如果系统是Android 6之前的版本，RxPermissions返回的结果是，app请求的每个权限都被允许（granted）\n2. 使用RxPermissions申请权限，必须在Activity.onCreate()或者View.onFinishInflate()中处理\n\n ","source":"_posts/微信开发/android权限介绍.md","raw":"---\ntitle: android权限介绍\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n\n[toc]\n\nhttps://blog.csdn.net/u013553529/article/details/68948971\n\n# 简介\nAndroid 6.0 （API level 23）中，将权限分成了两类。一类是Install权限（称之为安装时权限），另一类是Runtime权限（称之为运行时权限）\n\nInstall权限\n~~~\n* 在安装app时，就赋予该app的权限，即安装后立即获取到的权限\n* normal和signature级别的权限都是安装时权限\n* 赋予app normal和signature权限时，不会给用户提示界面，系统自动决定权限的赋予\n* 对于signature权限，如果使用权限的app与声明权限的app的签名不一致，则系统拒绝赋予该signature权限\n~~~\n\nRuntime权限\n~~~\n* 指在app运行过程中，赋予app的权限,会显示明显的权限授予界面，让用户决定是否授予权限\n* 如果一个app的targetSdkVersion是23及以上，那么该app所申请的所有dangerous权限都是运行时权限\n* Android 6及以上的环境中，该app在运行时必须主动申请这些dangerous权限（调用requestPermissions()），否则该app没有获取到dangerous权限\n~~~\n\nRxPermissions是帮助开发者简化requestPermissions()相关的处理\n\n官网：https://github.com/tbruyelle/RxPermissions\n\n1. 如果系统是Android 6之前的版本，RxPermissions返回的结果是，app请求的每个权限都被允许（granted）\n2. 使用RxPermissions申请权限，必须在Activity.onCreate()或者View.onFinishInflate()中处理\n\n ","slug":"微信开发-android权限介绍","published":1,"updated":"2019-02-14T09:06:29.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0a00615b8hcif7yllf","content":"<p>[toc]</p>\n<p><a href=\"https://blog.csdn.net/u013553529/article/details/68948971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013553529/article/details/68948971</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Android 6.0 （API level 23）中，将权限分成了两类。一类是Install权限（称之为安装时权限），另一类是Runtime权限（称之为运行时权限）</p>\n<p>Install权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 在安装app时，就赋予该app的权限，即安装后立即获取到的权限</span><br><span class=\"line\">* normal和signature级别的权限都是安装时权限</span><br><span class=\"line\">* 赋予app normal和signature权限时，不会给用户提示界面，系统自动决定权限的赋予</span><br><span class=\"line\">* 对于signature权限，如果使用权限的app与声明权限的app的签名不一致，则系统拒绝赋予该signature权限</span><br></pre></td></tr></table></figure>\n<p>Runtime权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 指在app运行过程中，赋予app的权限,会显示明显的权限授予界面，让用户决定是否授予权限</span><br><span class=\"line\">* 如果一个app的targetSdkVersion是23及以上，那么该app所申请的所有dangerous权限都是运行时权限</span><br><span class=\"line\">* Android 6及以上的环境中，该app在运行时必须主动申请这些dangerous权限（调用requestPermissions()），否则该app没有获取到dangerous权限</span><br></pre></td></tr></table></figure>\n<p>RxPermissions是帮助开发者简化requestPermissions()相关的处理</p>\n<p>官网：<a href=\"https://github.com/tbruyelle/RxPermissions\" target=\"_blank\" rel=\"noopener\">https://github.com/tbruyelle/RxPermissions</a></p>\n<ol>\n<li>如果系统是Android 6之前的版本，RxPermissions返回的结果是，app请求的每个权限都被允许（granted）</li>\n<li>使用RxPermissions申请权限，必须在Activity.onCreate()或者View.onFinishInflate()中处理</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p><a href=\"https://blog.csdn.net/u013553529/article/details/68948971\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013553529/article/details/68948971</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Android 6.0 （API level 23）中，将权限分成了两类。一类是Install权限（称之为安装时权限），另一类是Runtime权限（称之为运行时权限）</p>\n<p>Install权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 在安装app时，就赋予该app的权限，即安装后立即获取到的权限</span><br><span class=\"line\">* normal和signature级别的权限都是安装时权限</span><br><span class=\"line\">* 赋予app normal和signature权限时，不会给用户提示界面，系统自动决定权限的赋予</span><br><span class=\"line\">* 对于signature权限，如果使用权限的app与声明权限的app的签名不一致，则系统拒绝赋予该signature权限</span><br></pre></td></tr></table></figure>\n<p>Runtime权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 指在app运行过程中，赋予app的权限,会显示明显的权限授予界面，让用户决定是否授予权限</span><br><span class=\"line\">* 如果一个app的targetSdkVersion是23及以上，那么该app所申请的所有dangerous权限都是运行时权限</span><br><span class=\"line\">* Android 6及以上的环境中，该app在运行时必须主动申请这些dangerous权限（调用requestPermissions()），否则该app没有获取到dangerous权限</span><br></pre></td></tr></table></figure>\n<p>RxPermissions是帮助开发者简化requestPermissions()相关的处理</p>\n<p>官网：<a href=\"https://github.com/tbruyelle/RxPermissions\" target=\"_blank\" rel=\"noopener\">https://github.com/tbruyelle/RxPermissions</a></p>\n<ol>\n<li>如果系统是Android 6之前的版本，RxPermissions返回的结果是，app请求的每个权限都被允许（granted）</li>\n<li>使用RxPermissions申请权限，必须在Activity.onCreate()或者View.onFinishInflate()中处理</li>\n</ol>\n"},{"title":"命令行启动模拟器","copyright":true,"comments":1,"toc":true,"date":"2018-10-06T04:13:04.000Z","password":null,"_content":"\n* emulator -avd MyNexusAPI24，其中MyNexusAPI24为模拟器名称\n* 需在PATH中配置：\nexport PATH=\"$PATH:~/Library/Android/sdk/emulator\"，以前配置为export PATH=\"$PATH:~/Library/Android/sdk/tools\"，新版中添加了emulator文件夹","source":"_posts/微信开发/命令行启动模拟器.md","raw":"---\ntitle: 命令行启动模拟器\ntags:\n  - android \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-06 12:13:04\ncategories: 移动开发\npassword:\n---\n\n* emulator -avd MyNexusAPI24，其中MyNexusAPI24为模拟器名称\n* 需在PATH中配置：\nexport PATH=\"$PATH:~/Library/Android/sdk/emulator\"，以前配置为export PATH=\"$PATH:~/Library/Android/sdk/tools\"，新版中添加了emulator文件夹","slug":"微信开发-命令行启动模拟器","published":1,"updated":"2019-02-14T09:07:40.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0b00645b8h3sce7xid","content":"<ul>\n<li>emulator -avd MyNexusAPI24，其中MyNexusAPI24为模拟器名称</li>\n<li>需在PATH中配置：<br>\nexport PATH=“<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>:</mo><mtext> </mtext><mi mathvariant=\"normal\">/</mi><mi>L</mi><mi>i</mi><mi>b</mi><mi>r</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi><mi>n</mi><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>d</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi><mi>d</mi><mi>k</mi><mi mathvariant=\"normal\">/</mi><mi>e</mi><mi>m</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">前</mi><mi mathvariant=\"normal\">配</mi><mi mathvariant=\"normal\">置</mi><mi mathvariant=\"normal\">为</mi><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>=</mo><mi mathvariant=\"normal\">&quot;</mi></mrow><annotation encoding=\"application/x-tex\">PATH:~/Library/Android/sdk/emulator&quot;，以前配置为export PATH=&quot;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace nobreak\"> </span><span class=\"mord\">/</span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">b</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">d</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">前</span><span class=\"mord cjk_fallback\">配</span><span class=\"mord cjk_fallback\">置</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&quot;</span></span></span></span>PATH:~/Library/Android/sdk/tools”，新版中添加了emulator文件夹</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>emulator -avd MyNexusAPI24，其中MyNexusAPI24为模拟器名称</li>\n<li>需在PATH中配置：<br>\nexport PATH=“<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>:</mo><mtext> </mtext><mi mathvariant=\"normal\">/</mi><mi>L</mi><mi>i</mi><mi>b</mi><mi>r</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi><mi>n</mi><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>d</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi><mi>d</mi><mi>k</mi><mi mathvariant=\"normal\">/</mi><mi>e</mi><mi>m</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">前</mi><mi mathvariant=\"normal\">配</mi><mi mathvariant=\"normal\">置</mi><mi mathvariant=\"normal\">为</mi><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>=</mo><mi mathvariant=\"normal\">&quot;</mi></mrow><annotation encoding=\"application/x-tex\">PATH:~/Library/Android/sdk/emulator&quot;，以前配置为export PATH=&quot;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace nobreak\"> </span><span class=\"mord\">/</span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">b</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">d</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">/</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">前</span><span class=\"mord cjk_fallback\">配</span><span class=\"mord cjk_fallback\">置</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">&quot;</span></span></span></span>PATH:~/Library/Android/sdk/tools”，新版中添加了emulator文件夹</li>\n</ul>\n"},{"title":"MySQL安装_Windows","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T02:04:03.000Z","password":null,"_content":"\n\n下载页面：https://dev.mysql.com/downloads/mysql/\n\n* 选择\"Microsoft Windows\",下载免安装版的zip文件;\n* 将zip文件解压到本地\n* 新建一个配置文件（my.ini）用于配置字符集、端口等信息，用以覆盖原始的配置文件（my-default.ini），当然也可以修改这个默认的配置文件\n\n~~~\n[mysql]\n # 设置mysql客户端默认字符集\n default-character-set=utf8 \n [mysqld]\n #设置3306端口\n port = 3306 \n # 设置mysql的安装目录\n\n basedir=D:\\\\softwares\\\\mysql-5.7.14-winx64\n # 设置mysql数据库的数据的存放目录\n datadir=D:\\\\softwares\\\\mysql-5.7.14-winx64\\\\data\n\n # 允许最大连接数\n max_connections=200\n # 服务端使用的字符集默认为UTF8\n character-set-server=utf8\n # 创建新表时将使用的默认存储引擎\n default-storage-engine=INNODB\n~~~\n\n\n输入cmd，以管理员身份运行控制台\n\n\n\nS C:\\Windows\\system32> cd\nS C:\\Windows\\system32> cd ..\nS C:\\Windows> cd ..\nS C:\\> cd .\\mysql-8.0.12-winx64\\\nS C:\\mysql-8.0.12-winx64> cd .\\bin\\\n\n\n\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe -install\nervice successfully installed.\nS C:\\mysql-8.0.12-winx64\\bin> net start mysql\nySQL 服务正在启动 .\nySQL 服务无法启动。\n\n服务没有报告任何错误。\n\n请键入 NET HELPMSG 3534 以获得更多的帮助。\n\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe -remove\nervice successfully removed.\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe --initialize\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe -install\nervice successfully installed.\nS C:\\mysql-8.0.12-winx64\\bin> net start mysql\nySQL 服务正在启动 .\nySQL 服务已经启动成功。\n\n\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqladmin.exe -u root password \"axn7Og=ve;+2\"\nysqladmin: connect to server at 'localhost' failed\n\nalter user user() identified by \"root\";\nalter user user() identified by \"新密码\";\n\nmysql -u root -p \n\nysql> use mysql\natabase changed\nysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';\nuery OK, 0 rows affected (0.04 sec)\n\nysql> flush privileges;\nuery OK, 0 rows affected (0.00 sec)\n\n \nuse mysql\n\n4.ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';\n\n5.flush privileges;\n\n6.可以用navicat登陆了\n\n\nhttps://www.cnblogs.com/anstoner/p/6414440.html\n\nnet stop mysql\n\nhttps://blog.csdn.net/czhilovely/article/details/80360146\n\nhttps://blog.csdn.net/qq_42923798/article/details/81540122\n\nhttps://blog.csdn.net/u012561176/article/details/78557320","source":"_posts/数据库/2018-10-05-MySQL安装-Windows.md","raw":"---\ntitle: MySQL安装_Windows\ntags:\n  - MySQL\n  - 数据库\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 10:04:03\ncategories: 数据库\npassword:\n---\n\n\n下载页面：https://dev.mysql.com/downloads/mysql/\n\n* 选择\"Microsoft Windows\",下载免安装版的zip文件;\n* 将zip文件解压到本地\n* 新建一个配置文件（my.ini）用于配置字符集、端口等信息，用以覆盖原始的配置文件（my-default.ini），当然也可以修改这个默认的配置文件\n\n~~~\n[mysql]\n # 设置mysql客户端默认字符集\n default-character-set=utf8 \n [mysqld]\n #设置3306端口\n port = 3306 \n # 设置mysql的安装目录\n\n basedir=D:\\\\softwares\\\\mysql-5.7.14-winx64\n # 设置mysql数据库的数据的存放目录\n datadir=D:\\\\softwares\\\\mysql-5.7.14-winx64\\\\data\n\n # 允许最大连接数\n max_connections=200\n # 服务端使用的字符集默认为UTF8\n character-set-server=utf8\n # 创建新表时将使用的默认存储引擎\n default-storage-engine=INNODB\n~~~\n\n\n输入cmd，以管理员身份运行控制台\n\n\n\nS C:\\Windows\\system32> cd\nS C:\\Windows\\system32> cd ..\nS C:\\Windows> cd ..\nS C:\\> cd .\\mysql-8.0.12-winx64\\\nS C:\\mysql-8.0.12-winx64> cd .\\bin\\\n\n\n\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe -install\nervice successfully installed.\nS C:\\mysql-8.0.12-winx64\\bin> net start mysql\nySQL 服务正在启动 .\nySQL 服务无法启动。\n\n服务没有报告任何错误。\n\n请键入 NET HELPMSG 3534 以获得更多的帮助。\n\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe -remove\nervice successfully removed.\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe --initialize\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqld.exe -install\nervice successfully installed.\nS C:\\mysql-8.0.12-winx64\\bin> net start mysql\nySQL 服务正在启动 .\nySQL 服务已经启动成功。\n\n\nS C:\\mysql-8.0.12-winx64\\bin> .\\mysqladmin.exe -u root password \"axn7Og=ve;+2\"\nysqladmin: connect to server at 'localhost' failed\n\nalter user user() identified by \"root\";\nalter user user() identified by \"新密码\";\n\nmysql -u root -p \n\nysql> use mysql\natabase changed\nysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';\nuery OK, 0 rows affected (0.04 sec)\n\nysql> flush privileges;\nuery OK, 0 rows affected (0.00 sec)\n\n \nuse mysql\n\n4.ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';\n\n5.flush privileges;\n\n6.可以用navicat登陆了\n\n\nhttps://www.cnblogs.com/anstoner/p/6414440.html\n\nnet stop mysql\n\nhttps://blog.csdn.net/czhilovely/article/details/80360146\n\nhttps://blog.csdn.net/qq_42923798/article/details/81540122\n\nhttps://blog.csdn.net/u012561176/article/details/78557320","slug":"数据库-2018-10-05-MySQL安装-Windows","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0c00685b8h9bebzb8o","content":"<p>下载页面：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/mysql/</a></p>\n<ul>\n<li>选择&quot;Microsoft Windows&quot;,下载免安装版的zip文件;</li>\n<li>将zip文件解压到本地</li>\n<li>新建一个配置文件（my.ini）用于配置字符集、端口等信息，用以覆盖原始的配置文件（my-default.ini），当然也可以修改这个默认的配置文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysql]</span><br><span class=\"line\"> # 设置mysql客户端默认字符集</span><br><span class=\"line\"> default-character-set=utf8 </span><br><span class=\"line\"> [mysqld]</span><br><span class=\"line\"> #设置3306端口</span><br><span class=\"line\"> port = 3306 </span><br><span class=\"line\"> # 设置mysql的安装目录</span><br><span class=\"line\"></span><br><span class=\"line\"> basedir=D:\\\\softwares\\\\mysql-5.7.14-winx64</span><br><span class=\"line\"> # 设置mysql数据库的数据的存放目录</span><br><span class=\"line\"> datadir=D:\\\\softwares\\\\mysql-5.7.14-winx64\\\\data</span><br><span class=\"line\"></span><br><span class=\"line\"> # 允许最大连接数</span><br><span class=\"line\"> max_connections=200</span><br><span class=\"line\"> # 服务端使用的字符集默认为UTF8</span><br><span class=\"line\"> character-set-server=utf8</span><br><span class=\"line\"> # 创建新表时将使用的默认存储引擎</span><br><span class=\"line\"> default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>\n<p>输入cmd，以管理员身份运行控制台</p>\n<p>S C:\\Windows\\system32&gt; cd<br>\nS C:\\Windows\\system32&gt; cd …<br>\nS C:\\Windows&gt; cd …<br>\nS C:&gt; cd .\\mysql-8.0.12-winx64<br>\nS C:\\mysql-8.0.12-winx64&gt; cd .\\bin\\</p>\n<p>S C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe -install<br>\nervice successfully installed.<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; net start mysql<br>\nySQL 服务正在启动 .<br>\nySQL 服务无法启动。</p>\n<p>服务没有报告任何错误。</p>\n<p>请键入 NET HELPMSG 3534 以获得更多的帮助。</p>\n<p>S C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe -remove<br>\nervice successfully removed.<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe --initialize<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe -install<br>\nervice successfully installed.<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; net start mysql<br>\nySQL 服务正在启动 .<br>\nySQL 服务已经启动成功。</p>\n<p>S C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqladmin.exe -u root password “axn7Og=ve;+2”<br>\nysqladmin: connect to server at ‘localhost’ failed</p>\n<p>alter user user() identified by “root”;<br>\nalter user user() identified by “新密码”;</p>\n<p>mysql -u root -p</p>\n<p>ysql&gt; use mysql<br>\natabase changed<br>\nysql&gt; ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;<br>\nuery OK, 0 rows affected (0.04 sec)</p>\n<p>ysql&gt; flush privileges;<br>\nuery OK, 0 rows affected (0.00 sec)</p>\n<p>use mysql</p>\n<p>4.ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;</p>\n<p>5.flush privileges;</p>\n<p>6.可以用navicat登陆了</p>\n<p><a href=\"https://www.cnblogs.com/anstoner/p/6414440.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/anstoner/p/6414440.html</a></p>\n<p>net stop mysql</p>\n<p><a href=\"https://blog.csdn.net/czhilovely/article/details/80360146\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/czhilovely/article/details/80360146</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42923798/article/details/81540122\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_42923798/article/details/81540122</a></p>\n<p><a href=\"https://blog.csdn.net/u012561176/article/details/78557320\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012561176/article/details/78557320</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>下载页面：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/mysql/</a></p>\n<ul>\n<li>选择&quot;Microsoft Windows&quot;,下载免安装版的zip文件;</li>\n<li>将zip文件解压到本地</li>\n<li>新建一个配置文件（my.ini）用于配置字符集、端口等信息，用以覆盖原始的配置文件（my-default.ini），当然也可以修改这个默认的配置文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysql]</span><br><span class=\"line\"> # 设置mysql客户端默认字符集</span><br><span class=\"line\"> default-character-set=utf8 </span><br><span class=\"line\"> [mysqld]</span><br><span class=\"line\"> #设置3306端口</span><br><span class=\"line\"> port = 3306 </span><br><span class=\"line\"> # 设置mysql的安装目录</span><br><span class=\"line\"></span><br><span class=\"line\"> basedir=D:\\\\softwares\\\\mysql-5.7.14-winx64</span><br><span class=\"line\"> # 设置mysql数据库的数据的存放目录</span><br><span class=\"line\"> datadir=D:\\\\softwares\\\\mysql-5.7.14-winx64\\\\data</span><br><span class=\"line\"></span><br><span class=\"line\"> # 允许最大连接数</span><br><span class=\"line\"> max_connections=200</span><br><span class=\"line\"> # 服务端使用的字符集默认为UTF8</span><br><span class=\"line\"> character-set-server=utf8</span><br><span class=\"line\"> # 创建新表时将使用的默认存储引擎</span><br><span class=\"line\"> default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>\n<p>输入cmd，以管理员身份运行控制台</p>\n<p>S C:\\Windows\\system32&gt; cd<br>\nS C:\\Windows\\system32&gt; cd …<br>\nS C:\\Windows&gt; cd …<br>\nS C:&gt; cd .\\mysql-8.0.12-winx64<br>\nS C:\\mysql-8.0.12-winx64&gt; cd .\\bin\\</p>\n<p>S C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe -install<br>\nervice successfully installed.<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; net start mysql<br>\nySQL 服务正在启动 .<br>\nySQL 服务无法启动。</p>\n<p>服务没有报告任何错误。</p>\n<p>请键入 NET HELPMSG 3534 以获得更多的帮助。</p>\n<p>S C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe -remove<br>\nervice successfully removed.<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe --initialize<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqld.exe -install<br>\nervice successfully installed.<br>\nS C:\\mysql-8.0.12-winx64\\bin&gt; net start mysql<br>\nySQL 服务正在启动 .<br>\nySQL 服务已经启动成功。</p>\n<p>S C:\\mysql-8.0.12-winx64\\bin&gt; .\\mysqladmin.exe -u root password “axn7Og=ve;+2”<br>\nysqladmin: connect to server at ‘localhost’ failed</p>\n<p>alter user user() identified by “root”;<br>\nalter user user() identified by “新密码”;</p>\n<p>mysql -u root -p</p>\n<p>ysql&gt; use mysql<br>\natabase changed<br>\nysql&gt; ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;<br>\nuery OK, 0 rows affected (0.04 sec)</p>\n<p>ysql&gt; flush privileges;<br>\nuery OK, 0 rows affected (0.00 sec)</p>\n<p>use mysql</p>\n<p>4.ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;</p>\n<p>5.flush privileges;</p>\n<p>6.可以用navicat登陆了</p>\n<p><a href=\"https://www.cnblogs.com/anstoner/p/6414440.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/anstoner/p/6414440.html</a></p>\n<p>net stop mysql</p>\n<p><a href=\"https://blog.csdn.net/czhilovely/article/details/80360146\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/czhilovely/article/details/80360146</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42923798/article/details/81540122\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_42923798/article/details/81540122</a></p>\n<p><a href=\"https://blog.csdn.net/u012561176/article/details/78557320\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012561176/article/details/78557320</a></p>\n"},{"title":"MongoDB安装","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n\n\n### (1).解压安装文件\n\n\t[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n\n### (2).将mongoDB文件移动到/usr/local/mongodb目录下\n\n\t[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /usr/local/mongodb\n\texport PATH=/usr/local/mongodb/bin:$PATH\n\n### (3).数据存储目录\n\n\t[root@gsunis bin]# mkdir -p /home/gsunis/data/db\n\tmkdir -p /data/conf \n\tmkdir -p /data/data1  \n    mkdir -p /data/data2  \n    mkdir -p /data/data3  \n    mkdir -p /data/data4  \n    mkdir -p /data/data5  \n\tmkdir -p /data/data6 \n\n### (4).启动mongod服务\n\n\t[root@gsunis Desktop]# cd /usr/local/mongodb/bin\n\t[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n\n### (5).启动mongo客户端\n\n\t打开新的Terminal\n\t[gsunis@gsunis Desktop]$ su \n\t查看mongod服务启动情况\n\t[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n\t[root@gsunis Desktop]# cd /usr/local/mongodb/bin/\n\t[root@gsunis bin]# ./mongo\n\t\n\n### (6).编辑mongo配置文件\n\n\tsudo vi conf.cnf\n\n    //conf.cnf  \n    rest=true  \n    port=37017  \n    dbpath=/home/gsunis/data/conf  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/conf/mongodb.log  \n    nojournal=false  \n    configsvr=true  \n    profile=1 \n\n    sudo vi db1.cnf\n\n    //db1.cnf  \n    replSet=shard1  \n    rest=true  \n    port=47017  \n    dbpath=/home/gsunis/data/data1  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data1/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db2.cnf\n\n    //db2.cnf  \n    replSet=shard2  \n    rest=true  \n    port=47018  \n    dbpath=/home/gsunis/data/data2  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data2/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db3.cnf\n\n    //db3.cnf  \n    replSet=shard3  \n    rest=true  \n    port=47019  \n    dbpath=/home/gsunis/data/data3  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data3/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db4.cnf\n\n    //db4.cnf  \n    replSet=shard4  \n    rest=true  \n    port=47020  \n    dbpath=/home/gsunis/data/data4  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data4/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db5.cnf\n\n    //db5.cnf  \n    replSet=shard5  \n    rest=true  \n    port=47021  \n    dbpath=/home/gsunis/data/data5  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data5/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db6.cnf\n\n    //db6.cnf  \n    replSet=shard6  \n    rest=true  \n    port=47022  \n    dbpath=/home/gsunis/data/data6  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data6/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n#### (7).编写启动mongo服务的脚本\n    sudo vi mg.sh\n\n    #!/bin/bash  \n    instance=$1  \n    action=$2  \n    case \"$action\" in  \n       'start')  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf ;;  \n       'stop')  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown;;  \n       'restart')  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf;;  \n    esac  \n\n#### (8).启动docker实例的mongo服务脚本\n    sudo vi start.sh\n\n    #!/bin/bash \n\trm /data/conf/*.lock\n\trm /data/data1/*.lock\t\n\trm /data/data2/*.lock\n\trm /data/data3/*.lock\n\trm /data/data4/*.lock\n\trm /data/data5/*.lock\n\trm /data/data6/*.lock\n\t/home/gsunis/data/mg.sh conf start \n    /home/gsunis/data/mg.sh db1 start  \n    /home/gsunis/data/mg.sh db2 start  \n    /home/gsunis/data/mg.sh db3 start  \n    /home/gsunis/data/mg.sh db4 start  \n    /home/gsunis/data/mg.sh db5 start\n\t/home/gsunis/data/mg.sh db6 start  \n\n\nsudo vi start.sh\n\n    #!/bin/bash \n\trm /data/conf/*.lock\n\trm /data/data1/*.lock\t\n\trm /data/data2/*.lock\n\trm /data/data3/*.lock\n\trm /data/data4/*.lock\n\trm /data/data5/*.lock\n\trm /data/data6/*.lock\n\t/home/gsunis/data/mg.sh conf stop \n    /home/gsunis/data/mg.sh db1 stop  \n    /home/gsunis/data/mg.sh db2 stop  \n    /home/gsunis/data/mg.sh db3 stop  \n    /home/gsunis/data/mg.sh db4 stop  \n    /home/gsunis/data/mg.sh db5 stop\n\t/home/gsunis/data/mg.sh db6 stop  \n\n正常关闭mongoDB服务\n\n\t./mongo\n\tuse admin\n\tdb.shutdownServer()\n\n### (9).shard服务器副本集的建立\n\t./mongo --port 47017\n\n\tconfig = {_id: 'shard1', members: [\n     {_id: 0, host: '10.62.0.128:47017'},\n\t {_id: 1, host: '10.62.0.159:47017'}]\n     }\n    rs.initiate(config)\n\n\tCtrl + C 退出\n\n\t./mongo --port 47018\n\n    config = {_id: 'shard2', members: [\n     {_id: 0, host: '10.62.0.128:47018'},\n\t {_id: 1, host: '10.62.0.159:47018'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47019\n\n    config = {_id: 'shard3', members: [\n     {_id: 0, host: '10.62.0.128:47019'},\n\t {_id: 1, host: '10.62.0.159:47019'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47020\n\n    config = {_id: 'shard4', members: [\n     {_id: 0, host: '10.62.0.128:47020'},\n\t {_id: 1, host: '10.62.0.159:47020'}]\n     }\n    rs.initiate(config)\n\n\t./mongo --port 47021\n\n    config = {_id: 'shard5', members: [\n     {_id: 0, host: '10.62.0.128:47021'},\n\t {_id: 1, host: '10.62.0.159:47021'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47022\n\n    config = {_id: 'shard6', members: [\n     {_id: 0, host: '10.62.0.128:47022'},\n\t {_id: 1, host: '10.62.0.159:47022'}]\n     }\n    rs.initiate(config)\n\n","source":"_posts/数据库/2018-12-10-MongoDB搭建.md","raw":"---\ntitle: MongoDB安装\ntags:\n  - MongoDB \ncopyright: true\ncomments: true\ntoc: true\ncategories: 数据库\npassword:\n---\n\n\n\n### (1).解压安装文件\n\n\t[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n\n### (2).将mongoDB文件移动到/usr/local/mongodb目录下\n\n\t[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /usr/local/mongodb\n\texport PATH=/usr/local/mongodb/bin:$PATH\n\n### (3).数据存储目录\n\n\t[root@gsunis bin]# mkdir -p /home/gsunis/data/db\n\tmkdir -p /data/conf \n\tmkdir -p /data/data1  \n    mkdir -p /data/data2  \n    mkdir -p /data/data3  \n    mkdir -p /data/data4  \n    mkdir -p /data/data5  \n\tmkdir -p /data/data6 \n\n### (4).启动mongod服务\n\n\t[root@gsunis Desktop]# cd /usr/local/mongodb/bin\n\t[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n\n### (5).启动mongo客户端\n\n\t打开新的Terminal\n\t[gsunis@gsunis Desktop]$ su \n\t查看mongod服务启动情况\n\t[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n\t[root@gsunis Desktop]# cd /usr/local/mongodb/bin/\n\t[root@gsunis bin]# ./mongo\n\t\n\n### (6).编辑mongo配置文件\n\n\tsudo vi conf.cnf\n\n    //conf.cnf  \n    rest=true  \n    port=37017  \n    dbpath=/home/gsunis/data/conf  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/conf/mongodb.log  \n    nojournal=false  \n    configsvr=true  \n    profile=1 \n\n    sudo vi db1.cnf\n\n    //db1.cnf  \n    replSet=shard1  \n    rest=true  \n    port=47017  \n    dbpath=/home/gsunis/data/data1  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data1/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db2.cnf\n\n    //db2.cnf  \n    replSet=shard2  \n    rest=true  \n    port=47018  \n    dbpath=/home/gsunis/data/data2  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data2/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db3.cnf\n\n    //db3.cnf  \n    replSet=shard3  \n    rest=true  \n    port=47019  \n    dbpath=/home/gsunis/data/data3  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data3/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db4.cnf\n\n    //db4.cnf  \n    replSet=shard4  \n    rest=true  \n    port=47020  \n    dbpath=/home/gsunis/data/data4  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data4/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db5.cnf\n\n    //db5.cnf  \n    replSet=shard5  \n    rest=true  \n    port=47021  \n    dbpath=/home/gsunis/data/data5  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data5/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db6.cnf\n\n    //db6.cnf  \n    replSet=shard6  \n    rest=true  \n    port=47022  \n    dbpath=/home/gsunis/data/data6  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data6/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n#### (7).编写启动mongo服务的脚本\n    sudo vi mg.sh\n\n    #!/bin/bash  \n    instance=$1  \n    action=$2  \n    case \"$action\" in  \n       'start')  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf ;;  \n       'stop')  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown;;  \n       'restart')  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown  \n    /usr/local/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf;;  \n    esac  \n\n#### (8).启动docker实例的mongo服务脚本\n    sudo vi start.sh\n\n    #!/bin/bash \n\trm /data/conf/*.lock\n\trm /data/data1/*.lock\t\n\trm /data/data2/*.lock\n\trm /data/data3/*.lock\n\trm /data/data4/*.lock\n\trm /data/data5/*.lock\n\trm /data/data6/*.lock\n\t/home/gsunis/data/mg.sh conf start \n    /home/gsunis/data/mg.sh db1 start  \n    /home/gsunis/data/mg.sh db2 start  \n    /home/gsunis/data/mg.sh db3 start  \n    /home/gsunis/data/mg.sh db4 start  \n    /home/gsunis/data/mg.sh db5 start\n\t/home/gsunis/data/mg.sh db6 start  \n\n\nsudo vi start.sh\n\n    #!/bin/bash \n\trm /data/conf/*.lock\n\trm /data/data1/*.lock\t\n\trm /data/data2/*.lock\n\trm /data/data3/*.lock\n\trm /data/data4/*.lock\n\trm /data/data5/*.lock\n\trm /data/data6/*.lock\n\t/home/gsunis/data/mg.sh conf stop \n    /home/gsunis/data/mg.sh db1 stop  \n    /home/gsunis/data/mg.sh db2 stop  \n    /home/gsunis/data/mg.sh db3 stop  \n    /home/gsunis/data/mg.sh db4 stop  \n    /home/gsunis/data/mg.sh db5 stop\n\t/home/gsunis/data/mg.sh db6 stop  \n\n正常关闭mongoDB服务\n\n\t./mongo\n\tuse admin\n\tdb.shutdownServer()\n\n### (9).shard服务器副本集的建立\n\t./mongo --port 47017\n\n\tconfig = {_id: 'shard1', members: [\n     {_id: 0, host: '10.62.0.128:47017'},\n\t {_id: 1, host: '10.62.0.159:47017'}]\n     }\n    rs.initiate(config)\n\n\tCtrl + C 退出\n\n\t./mongo --port 47018\n\n    config = {_id: 'shard2', members: [\n     {_id: 0, host: '10.62.0.128:47018'},\n\t {_id: 1, host: '10.62.0.159:47018'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47019\n\n    config = {_id: 'shard3', members: [\n     {_id: 0, host: '10.62.0.128:47019'},\n\t {_id: 1, host: '10.62.0.159:47019'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47020\n\n    config = {_id: 'shard4', members: [\n     {_id: 0, host: '10.62.0.128:47020'},\n\t {_id: 1, host: '10.62.0.159:47020'}]\n     }\n    rs.initiate(config)\n\n\t./mongo --port 47021\n\n    config = {_id: 'shard5', members: [\n     {_id: 0, host: '10.62.0.128:47021'},\n\t {_id: 1, host: '10.62.0.159:47021'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47022\n\n    config = {_id: 'shard6', members: [\n     {_id: 0, host: '10.62.0.128:47022'},\n\t {_id: 1, host: '10.62.0.159:47022'}]\n     }\n    rs.initiate(config)\n\n","slug":"数据库-2018-12-10-MongoDB搭建","published":1,"date":"2019-02-14T08:23:15.000Z","updated":"2019-02-14T08:23:15.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0e006a5b8h045fe5w7","content":"<h3 id=\"1解压安装文件\"><a class=\"markdownIt-Anchor\" href=\"#1解压安装文件\"></a> (1).解压安装文件</h3>\n<pre><code>[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n</code></pre>\n<h3 id=\"2将mongodb文件移动到usrlocalmongodb目录下\"><a class=\"markdownIt-Anchor\" href=\"#2将mongodb文件移动到usrlocalmongodb目录下\"></a> (2).将mongoDB文件移动到/usr/local/mongodb目录下</h3>\n<pre><code>[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /usr/local/mongodb\nexport PATH=/usr/local/mongodb/bin:$PATH\n</code></pre>\n<h3 id=\"3数据存储目录\"><a class=\"markdownIt-Anchor\" href=\"#3数据存储目录\"></a> (3).数据存储目录</h3>\n<pre><code>[root@gsunis bin]# mkdir -p /home/gsunis/data/db\nmkdir -p /data/conf \nmkdir -p /data/data1  \nmkdir -p /data/data2  \nmkdir -p /data/data3  \nmkdir -p /data/data4  \nmkdir -p /data/data5  \nmkdir -p /data/data6 \n</code></pre>\n<h3 id=\"4启动mongod服务\"><a class=\"markdownIt-Anchor\" href=\"#4启动mongod服务\"></a> (4).启动mongod服务</h3>\n<pre><code>[root@gsunis Desktop]# cd /usr/local/mongodb/bin\n[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n</code></pre>\n<h3 id=\"5启动mongo客户端\"><a class=\"markdownIt-Anchor\" href=\"#5启动mongo客户端\"></a> (5).启动mongo客户端</h3>\n<pre><code>打开新的Terminal\n[gsunis@gsunis Desktop]$ su \n查看mongod服务启动情况\n[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n[root@gsunis Desktop]# cd /usr/local/mongodb/bin/\n[root@gsunis bin]# ./mongo\n</code></pre>\n<h3 id=\"6编辑mongo配置文件\"><a class=\"markdownIt-Anchor\" href=\"#6编辑mongo配置文件\"></a> (6).编辑mongo配置文件</h3>\n<pre><code>sudo vi conf.cnf\n\n//conf.cnf  \nrest=true  \nport=37017  \ndbpath=/home/gsunis/data/conf  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/conf/mongodb.log  \nnojournal=false  \nconfigsvr=true  \nprofile=1 \n\nsudo vi db1.cnf\n\n//db1.cnf  \nreplSet=shard1  \nrest=true  \nport=47017  \ndbpath=/home/gsunis/data/data1  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data1/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db2.cnf\n\n//db2.cnf  \nreplSet=shard2  \nrest=true  \nport=47018  \ndbpath=/home/gsunis/data/data2  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data2/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db3.cnf\n\n//db3.cnf  \nreplSet=shard3  \nrest=true  \nport=47019  \ndbpath=/home/gsunis/data/data3  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data3/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db4.cnf\n\n//db4.cnf  \nreplSet=shard4  \nrest=true  \nport=47020  \ndbpath=/home/gsunis/data/data4  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data4/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db5.cnf\n\n//db5.cnf  \nreplSet=shard5  \nrest=true  \nport=47021  \ndbpath=/home/gsunis/data/data5  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data5/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db6.cnf\n\n//db6.cnf  \nreplSet=shard6  \nrest=true  \nport=47022  \ndbpath=/home/gsunis/data/data6  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data6/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n</code></pre>\n<h4 id=\"7编写启动mongo服务的脚本\"><a class=\"markdownIt-Anchor\" href=\"#7编写启动mongo服务的脚本\"></a> (7).编写启动mongo服务的脚本</h4>\n<pre><code>sudo vi mg.sh\n\n#!/bin/bash  \ninstance=$1  \naction=$2  \ncase &quot;$action&quot; in  \n   'start')  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf ;;  \n   'stop')  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown;;  \n   'restart')  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf;;  \nesac  \n</code></pre>\n<h4 id=\"8启动docker实例的mongo服务脚本\"><a class=\"markdownIt-Anchor\" href=\"#8启动docker实例的mongo服务脚本\"></a> (8).启动docker实例的mongo服务脚本</h4>\n<pre><code>sudo vi start.sh\n\n#!/bin/bash \nrm /data/conf/*.lock\nrm /data/data1/*.lock\t\nrm /data/data2/*.lock\nrm /data/data3/*.lock\nrm /data/data4/*.lock\nrm /data/data5/*.lock\nrm /data/data6/*.lock\n/home/gsunis/data/mg.sh conf start \n/home/gsunis/data/mg.sh db1 start  \n/home/gsunis/data/mg.sh db2 start  \n/home/gsunis/data/mg.sh db3 start  \n/home/gsunis/data/mg.sh db4 start  \n/home/gsunis/data/mg.sh db5 start\n/home/gsunis/data/mg.sh db6 start  \n</code></pre>\n<p>sudo vi <a href=\"http://start.sh\" target=\"_blank\" rel=\"noopener\">start.sh</a></p>\n<pre><code>#!/bin/bash \nrm /data/conf/*.lock\nrm /data/data1/*.lock\t\nrm /data/data2/*.lock\nrm /data/data3/*.lock\nrm /data/data4/*.lock\nrm /data/data5/*.lock\nrm /data/data6/*.lock\n/home/gsunis/data/mg.sh conf stop \n/home/gsunis/data/mg.sh db1 stop  \n/home/gsunis/data/mg.sh db2 stop  \n/home/gsunis/data/mg.sh db3 stop  \n/home/gsunis/data/mg.sh db4 stop  \n/home/gsunis/data/mg.sh db5 stop\n/home/gsunis/data/mg.sh db6 stop  \n</code></pre>\n<p>正常关闭mongoDB服务</p>\n<pre><code>./mongo\nuse admin\ndb.shutdownServer()\n</code></pre>\n<h3 id=\"9shard服务器副本集的建立\"><a class=\"markdownIt-Anchor\" href=\"#9shard服务器副本集的建立\"></a> (9).shard服务器副本集的建立</h3>\n<pre><code>./mongo --port 47017\n\nconfig = {_id: 'shard1', members: [\n {_id: 0, host: '10.62.0.128:47017'},\n {_id: 1, host: '10.62.0.159:47017'}]\n }\nrs.initiate(config)\n\nCtrl + C 退出\n\n./mongo --port 47018\n\nconfig = {_id: 'shard2', members: [\n {_id: 0, host: '10.62.0.128:47018'},\n {_id: 1, host: '10.62.0.159:47018'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47019\n\nconfig = {_id: 'shard3', members: [\n {_id: 0, host: '10.62.0.128:47019'},\n {_id: 1, host: '10.62.0.159:47019'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47020\n\nconfig = {_id: 'shard4', members: [\n {_id: 0, host: '10.62.0.128:47020'},\n {_id: 1, host: '10.62.0.159:47020'}]\n }\nrs.initiate(config)\n\n./mongo --port 47021\n\nconfig = {_id: 'shard5', members: [\n {_id: 0, host: '10.62.0.128:47021'},\n {_id: 1, host: '10.62.0.159:47021'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47022\n\nconfig = {_id: 'shard6', members: [\n {_id: 0, host: '10.62.0.128:47022'},\n {_id: 1, host: '10.62.0.159:47022'}]\n }\nrs.initiate(config)\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1解压安装文件\"><a class=\"markdownIt-Anchor\" href=\"#1解压安装文件\"></a> (1).解压安装文件</h3>\n<pre><code>[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n</code></pre>\n<h3 id=\"2将mongodb文件移动到usrlocalmongodb目录下\"><a class=\"markdownIt-Anchor\" href=\"#2将mongodb文件移动到usrlocalmongodb目录下\"></a> (2).将mongoDB文件移动到/usr/local/mongodb目录下</h3>\n<pre><code>[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /usr/local/mongodb\nexport PATH=/usr/local/mongodb/bin:$PATH\n</code></pre>\n<h3 id=\"3数据存储目录\"><a class=\"markdownIt-Anchor\" href=\"#3数据存储目录\"></a> (3).数据存储目录</h3>\n<pre><code>[root@gsunis bin]# mkdir -p /home/gsunis/data/db\nmkdir -p /data/conf \nmkdir -p /data/data1  \nmkdir -p /data/data2  \nmkdir -p /data/data3  \nmkdir -p /data/data4  \nmkdir -p /data/data5  \nmkdir -p /data/data6 \n</code></pre>\n<h3 id=\"4启动mongod服务\"><a class=\"markdownIt-Anchor\" href=\"#4启动mongod服务\"></a> (4).启动mongod服务</h3>\n<pre><code>[root@gsunis Desktop]# cd /usr/local/mongodb/bin\n[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n</code></pre>\n<h3 id=\"5启动mongo客户端\"><a class=\"markdownIt-Anchor\" href=\"#5启动mongo客户端\"></a> (5).启动mongo客户端</h3>\n<pre><code>打开新的Terminal\n[gsunis@gsunis Desktop]$ su \n查看mongod服务启动情况\n[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n[root@gsunis Desktop]# cd /usr/local/mongodb/bin/\n[root@gsunis bin]# ./mongo\n</code></pre>\n<h3 id=\"6编辑mongo配置文件\"><a class=\"markdownIt-Anchor\" href=\"#6编辑mongo配置文件\"></a> (6).编辑mongo配置文件</h3>\n<pre><code>sudo vi conf.cnf\n\n//conf.cnf  \nrest=true  \nport=37017  \ndbpath=/home/gsunis/data/conf  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/conf/mongodb.log  \nnojournal=false  \nconfigsvr=true  \nprofile=1 \n\nsudo vi db1.cnf\n\n//db1.cnf  \nreplSet=shard1  \nrest=true  \nport=47017  \ndbpath=/home/gsunis/data/data1  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data1/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db2.cnf\n\n//db2.cnf  \nreplSet=shard2  \nrest=true  \nport=47018  \ndbpath=/home/gsunis/data/data2  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data2/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db3.cnf\n\n//db3.cnf  \nreplSet=shard3  \nrest=true  \nport=47019  \ndbpath=/home/gsunis/data/data3  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data3/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db4.cnf\n\n//db4.cnf  \nreplSet=shard4  \nrest=true  \nport=47020  \ndbpath=/home/gsunis/data/data4  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data4/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db5.cnf\n\n//db5.cnf  \nreplSet=shard5  \nrest=true  \nport=47021  \ndbpath=/home/gsunis/data/data5  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data5/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db6.cnf\n\n//db6.cnf  \nreplSet=shard6  \nrest=true  \nport=47022  \ndbpath=/home/gsunis/data/data6  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data6/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n</code></pre>\n<h4 id=\"7编写启动mongo服务的脚本\"><a class=\"markdownIt-Anchor\" href=\"#7编写启动mongo服务的脚本\"></a> (7).编写启动mongo服务的脚本</h4>\n<pre><code>sudo vi mg.sh\n\n#!/bin/bash  \ninstance=$1  \naction=$2  \ncase &quot;$action&quot; in  \n   'start')  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf ;;  \n   'stop')  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown;;  \n   'restart')  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown  \n/usr/local/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf;;  \nesac  \n</code></pre>\n<h4 id=\"8启动docker实例的mongo服务脚本\"><a class=\"markdownIt-Anchor\" href=\"#8启动docker实例的mongo服务脚本\"></a> (8).启动docker实例的mongo服务脚本</h4>\n<pre><code>sudo vi start.sh\n\n#!/bin/bash \nrm /data/conf/*.lock\nrm /data/data1/*.lock\t\nrm /data/data2/*.lock\nrm /data/data3/*.lock\nrm /data/data4/*.lock\nrm /data/data5/*.lock\nrm /data/data6/*.lock\n/home/gsunis/data/mg.sh conf start \n/home/gsunis/data/mg.sh db1 start  \n/home/gsunis/data/mg.sh db2 start  \n/home/gsunis/data/mg.sh db3 start  \n/home/gsunis/data/mg.sh db4 start  \n/home/gsunis/data/mg.sh db5 start\n/home/gsunis/data/mg.sh db6 start  \n</code></pre>\n<p>sudo vi <a href=\"http://start.sh\" target=\"_blank\" rel=\"noopener\">start.sh</a></p>\n<pre><code>#!/bin/bash \nrm /data/conf/*.lock\nrm /data/data1/*.lock\t\nrm /data/data2/*.lock\nrm /data/data3/*.lock\nrm /data/data4/*.lock\nrm /data/data5/*.lock\nrm /data/data6/*.lock\n/home/gsunis/data/mg.sh conf stop \n/home/gsunis/data/mg.sh db1 stop  \n/home/gsunis/data/mg.sh db2 stop  \n/home/gsunis/data/mg.sh db3 stop  \n/home/gsunis/data/mg.sh db4 stop  \n/home/gsunis/data/mg.sh db5 stop\n/home/gsunis/data/mg.sh db6 stop  \n</code></pre>\n<p>正常关闭mongoDB服务</p>\n<pre><code>./mongo\nuse admin\ndb.shutdownServer()\n</code></pre>\n<h3 id=\"9shard服务器副本集的建立\"><a class=\"markdownIt-Anchor\" href=\"#9shard服务器副本集的建立\"></a> (9).shard服务器副本集的建立</h3>\n<pre><code>./mongo --port 47017\n\nconfig = {_id: 'shard1', members: [\n {_id: 0, host: '10.62.0.128:47017'},\n {_id: 1, host: '10.62.0.159:47017'}]\n }\nrs.initiate(config)\n\nCtrl + C 退出\n\n./mongo --port 47018\n\nconfig = {_id: 'shard2', members: [\n {_id: 0, host: '10.62.0.128:47018'},\n {_id: 1, host: '10.62.0.159:47018'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47019\n\nconfig = {_id: 'shard3', members: [\n {_id: 0, host: '10.62.0.128:47019'},\n {_id: 1, host: '10.62.0.159:47019'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47020\n\nconfig = {_id: 'shard4', members: [\n {_id: 0, host: '10.62.0.128:47020'},\n {_id: 1, host: '10.62.0.159:47020'}]\n }\nrs.initiate(config)\n\n./mongo --port 47021\n\nconfig = {_id: 'shard5', members: [\n {_id: 0, host: '10.62.0.128:47021'},\n {_id: 1, host: '10.62.0.159:47021'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47022\n\nconfig = {_id: 'shard6', members: [\n {_id: 0, host: '10.62.0.128:47022'},\n {_id: 1, host: '10.62.0.159:47022'}]\n }\nrs.initiate(config)\n</code></pre>\n"},{"title":"MongoDB集群搭建","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n##集群环境:三台服务器\n### server1:10.62.0.128主;server2:10.62.0.135从;server3:10.62.0.159从\n#### 每一台分为6个片：shard1~shard6端口为47017,47018,47019,47020,47021,47022；每一片建三个副本集；配置服务器端口号：37017；路由服务器端口号：30000；\n\n### (1).解压安装文件\n\n\t[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n\n### (2).将mongoDB文件移动到/home/gsunis/mongodb目录下\n\n\t[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /home/gsunis/mongodb\n\t\n\n### (3).数据存储目录\n\n\t[root@gsunis bin]# mkdir -p /home/gsunis/data/db\n\t\n### (4).启动mongod服务\n\n\t[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin\n\t[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n\n### (5).启动mongo客户端\n\n\t打开新的Terminal\n\t[gsunis@gsunis Desktop]$ su \n\t查看mongod服务启动情况\n\t[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n\t[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin/\n\t[root@gsunis bin]# ./mongo\n###正常关闭mongoDB服务\n\n\t./mongo\n\tuse admin\n\tdb.shutdownServer() 或者ps -ef|grep mongodb  kill -2 pid\n##以上是简单的安装mongodb，下面是开始建立集群，分片和建立副本集\n\t\n###创建目录\n    mkdir -p /data/conf \n\tmkdir -p /data/data1  \n    mkdir -p /data/data2  \n    mkdir -p /data/data3  \n    mkdir -p /data/data4  \n    mkdir -p /data/data5  \n\tmkdir -p /data/data6 \n\n### (6).编辑mongo配置文件\n\n\tsudo vi conf.cnf\n\n    //conf.cnf   \n    port=37017  \n    dbpath=/home/gsunis/data/conf  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/conf/mongodb.log  \n    nojournal=false  \n    configsvr=true  \n    profile=1 \n\n    sudo vi db1.cnf\n\n    //db1.cnf  \n    replSet=shard1  \n    port=47017  \n    dbpath=/home/gsunis/data/data1  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data1/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db2.cnf\n\n    //db2.cnf  \n    replSet=shard2   \n    port=47018  \n    dbpath=/home/gsunis/data/data2  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data2/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db3.cnf\n\n    //db3.cnf  \n    replSet=shard3  \n    port=47019  \n    dbpath=/home/gsunis/data/data3  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data3/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db4.cnf\n\n    //db4.cnf  \n    replSet=shard4   \n    port=47020  \n    dbpath=/home/gsunis/data/data4  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data4/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db5.cnf\n\n    //db5.cnf  \n    replSet=shard5   \n    port=47021  \n    dbpath=/home/gsunis/data/data5  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data5/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db6.cnf\n\n    //db6.cnf  \n    replSet=shard6   \n    port=47022  \n    dbpath=/home/gsunis/data/data6  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data6/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n#### (7).编写启动mongo服务的脚本\n    sudo vi mg.sh\n\n    #!/bin/bash  \n    instance=$1  \n    action=$2  \n    case \"$action\" in  \n       'start')  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf ;;  \n       'stop')  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown;;  \n       'restart')  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf;;  \n    esac  \n\n#### (8).启动mongo服务脚本\n    sudo vi start.sh\n\n    #!/bin/bash \n\trm /data/conf/*.lock\n\trm /data/data1/*.lock\t\n\trm /data/data2/*.lock\n\trm /data/data3/*.lock\n\trm /data/data4/*.lock\n\trm /data/data5/*.lock\n\trm /data/data6/*.lock\n    /home/gsunis/data/mg.sh db1 start  \n    /home/gsunis/data/mg.sh db2 start  \n    /home/gsunis/data/mg.sh db3 start  \n    /home/gsunis/data/mg.sh db4 start  \n    /home/gsunis/data/mg.sh db5 start\n\t/home/gsunis/data/mg.sh db6 start  \n\n\nsudo vi stop.sh\n\n    #!/bin/bash \n\t/home/gsunis/data/mg.sh conf stop \n    /home/gsunis/data/mg.sh db1 stop  \n    /home/gsunis/data/mg.sh db2 stop  \n    /home/gsunis/data/mg.sh db3 stop  \n    /home/gsunis/data/mg.sh db4 stop  \n    /home/gsunis/data/mg.sh db5 stop\n\t/home/gsunis/data/mg.sh db6 stop  \n###准备工作做好，先启动配置服务器（先启动主，依次启动两从机）\n    /home/gsunis/data/mg.sh conf start\n###再启动路由服务器（先启动主，依次启动两从机）\n    /home/gsunis/mongodb/bin/mongos  --configdb 10.62.0.128:37017,10.62.0.135:37017,10.62.0.159:37017 --port 30000 --chunkSize 1 --logpath /home/gsunis/data/mongos1.log --logappend --fork\n###最后启动mongod（先启动主，依次启动两从机）\n    /home/gsunis/mongodb/data/start.sh\n\n\n### (9).shard服务器副本集的建立（只需要在主机上做即可，两从机会自动复制）\n\n\t./mongo --port 47017\n\n\tconfig = {_id: 'shard1', members: [\n     {_id: 0, host: '10.62.0.128:47017'},\n\t {_id: 1, host: '10.62.0.135:47017'},\n\t {_id: 2, host: '10.62.0.159:47017'}]\n     }\n    rs.initiate(config)\n\n\tCtrl + C 退出\n\n*\trs.add({\"_id\":2,\"host\":\"10.62.0.135:47017\"})\t#在线增加复制集\n\n----\n\t./mongo --port 47018\n\n    config = {_id: 'shard2', members: [\n     {_id: 0, host: '10.62.0.128:47018'},\n\t {_id: 1, host: '10.62.0.135:47018'},\n\t {_id: 2, host: '10.62.0.159:47018'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47019\n\n    config = {_id: 'shard3', members: [\n     {_id: 0, host: '10.62.0.128:47019'},\n\t {_id: 1, host: '10.62.0.135:47019'},\n\t {_id: 2, host: '10.62.0.159:47019'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47020\n\n    config = {_id: 'shard4', members: [\n     {_id: 0, host: '10.62.0.128:47020'},\n\t {_id: 1, host: '10.62.0.135:47020'},\n\t {_id: 2, host: '10.62.0.159:47020'}]\n     }\n    rs.initiate(config)\n\n\t./mongo --port 47021\n\n    config = {_id: 'shard5', members: [\n     {_id: 0, host: '10.62.0.128:47021'},\n\t {_id: 1, host: '10.62.0.135:47021'},\n\t {_id: 2, host: '10.62.0.159:47021'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47022\n\n    config = {_id: 'shard6', members: [\n     {_id: 0, host: '10.62.0.128:47022'},\n\t {_id: 1, host: '10.62.0.135:47022'},\n\t {_id: 2, host: '10.62.0.159:47022'}]\n     }\n    rs.initiate(config)\n\n## 配置sharding:登录到mongos，添加shard节点\n\n    ./mongo --port 30000\n\n    use admin\n\n    db.runCommand({addshard:\"shard1/10.62.0.128:47017,10.62.0.159:47017,10.62.0.135:47017\"});\n    db.runCommand({addshard:\"shard2/10.62.0.128:47018,10.62.0.159:47018,10.62.0.135:47018\"});\n    db.runCommand({addshard:\"shard3/10.62.0.128:47019,10.62.0.159:47019,10.62.0.135:47019\"});\n    db.runCommand({addshard:\"shard4/10.62.0.128:47020,10.62.0.159:47020,10.62.0.135:47020\"});\n\tdb.runCommand({addshard:\"shard5/10.62.0.128:47021,10.62.0.159:47021,10.62.0.135:47021\"});\n\tdb.runCommand({addshard:\"shard6/10.62.0.128:47022,10.62.0.159:47022,10.62.0.135:47022\"});\n\n\n    use config\n\n    db.shards.find()\n\n#### 启动路由服务出错 \n\n错误：\n\n![时钟不同步，导致无法启动路由服务](http://i.imgur.com/Usu4wPa.png)\n\n解决方法：\n\n*\t(1).关闭所有mongo相关服务\n*\t(2).先启配置服务 \t\tConfig Server\n*\t(3).启动路由服务\t\tmongos\n*\t(4).最后启动所有mongod服务\tmongod\n###远程copy\n    scp /home/gsunis/Tools/mongodb-linux-x86_64-3.0.6.tgz gsunis@10.62.0.135:/home/gsunis/\n","source":"_posts/数据库/2018-12-10-MongoDB集群搭建.md","raw":"---\ntitle: MongoDB集群搭建\ntags:\n  - MongoDB \ncopyright: true\ncomments: true\ntoc: true\ncategories: 数据库\npassword:\n---\n\n##集群环境:三台服务器\n### server1:10.62.0.128主;server2:10.62.0.135从;server3:10.62.0.159从\n#### 每一台分为6个片：shard1~shard6端口为47017,47018,47019,47020,47021,47022；每一片建三个副本集；配置服务器端口号：37017；路由服务器端口号：30000；\n\n### (1).解压安装文件\n\n\t[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n\n### (2).将mongoDB文件移动到/home/gsunis/mongodb目录下\n\n\t[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /home/gsunis/mongodb\n\t\n\n### (3).数据存储目录\n\n\t[root@gsunis bin]# mkdir -p /home/gsunis/data/db\n\t\n### (4).启动mongod服务\n\n\t[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin\n\t[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n\n### (5).启动mongo客户端\n\n\t打开新的Terminal\n\t[gsunis@gsunis Desktop]$ su \n\t查看mongod服务启动情况\n\t[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n\t[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin/\n\t[root@gsunis bin]# ./mongo\n###正常关闭mongoDB服务\n\n\t./mongo\n\tuse admin\n\tdb.shutdownServer() 或者ps -ef|grep mongodb  kill -2 pid\n##以上是简单的安装mongodb，下面是开始建立集群，分片和建立副本集\n\t\n###创建目录\n    mkdir -p /data/conf \n\tmkdir -p /data/data1  \n    mkdir -p /data/data2  \n    mkdir -p /data/data3  \n    mkdir -p /data/data4  \n    mkdir -p /data/data5  \n\tmkdir -p /data/data6 \n\n### (6).编辑mongo配置文件\n\n\tsudo vi conf.cnf\n\n    //conf.cnf   \n    port=37017  \n    dbpath=/home/gsunis/data/conf  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/conf/mongodb.log  \n    nojournal=false  \n    configsvr=true  \n    profile=1 \n\n    sudo vi db1.cnf\n\n    //db1.cnf  \n    replSet=shard1  \n    port=47017  \n    dbpath=/home/gsunis/data/data1  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data1/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db2.cnf\n\n    //db2.cnf  \n    replSet=shard2   \n    port=47018  \n    dbpath=/home/gsunis/data/data2  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data2/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db3.cnf\n\n    //db3.cnf  \n    replSet=shard3  \n    port=47019  \n    dbpath=/home/gsunis/data/data3  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data3/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db4.cnf\n\n    //db4.cnf  \n    replSet=shard4   \n    port=47020  \n    dbpath=/home/gsunis/data/data4  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data4/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db5.cnf\n\n    //db5.cnf  \n    replSet=shard5   \n    port=47021  \n    dbpath=/home/gsunis/data/data5  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data5/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n    sudo vi db6.cnf\n\n    //db6.cnf  \n    replSet=shard6   \n    port=47022  \n    dbpath=/home/gsunis/data/data6  \n    logappend = true  \n    fork=true  \n    logpath=/home/gsunis/data/data6/mongodb.log  \n    nojournal=false  \n    shardsvr=true  \n    profile=1  \n\n#### (7).编写启动mongo服务的脚本\n    sudo vi mg.sh\n\n    #!/bin/bash  \n    instance=$1  \n    action=$2  \n    case \"$action\" in  \n       'start')  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf ;;  \n       'stop')  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown;;  \n       'restart')  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf --shutdown  \n    /home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/\"$instance\".cnf;;  \n    esac  \n\n#### (8).启动mongo服务脚本\n    sudo vi start.sh\n\n    #!/bin/bash \n\trm /data/conf/*.lock\n\trm /data/data1/*.lock\t\n\trm /data/data2/*.lock\n\trm /data/data3/*.lock\n\trm /data/data4/*.lock\n\trm /data/data5/*.lock\n\trm /data/data6/*.lock\n    /home/gsunis/data/mg.sh db1 start  \n    /home/gsunis/data/mg.sh db2 start  \n    /home/gsunis/data/mg.sh db3 start  \n    /home/gsunis/data/mg.sh db4 start  \n    /home/gsunis/data/mg.sh db5 start\n\t/home/gsunis/data/mg.sh db6 start  \n\n\nsudo vi stop.sh\n\n    #!/bin/bash \n\t/home/gsunis/data/mg.sh conf stop \n    /home/gsunis/data/mg.sh db1 stop  \n    /home/gsunis/data/mg.sh db2 stop  \n    /home/gsunis/data/mg.sh db3 stop  \n    /home/gsunis/data/mg.sh db4 stop  \n    /home/gsunis/data/mg.sh db5 stop\n\t/home/gsunis/data/mg.sh db6 stop  \n###准备工作做好，先启动配置服务器（先启动主，依次启动两从机）\n    /home/gsunis/data/mg.sh conf start\n###再启动路由服务器（先启动主，依次启动两从机）\n    /home/gsunis/mongodb/bin/mongos  --configdb 10.62.0.128:37017,10.62.0.135:37017,10.62.0.159:37017 --port 30000 --chunkSize 1 --logpath /home/gsunis/data/mongos1.log --logappend --fork\n###最后启动mongod（先启动主，依次启动两从机）\n    /home/gsunis/mongodb/data/start.sh\n\n\n### (9).shard服务器副本集的建立（只需要在主机上做即可，两从机会自动复制）\n\n\t./mongo --port 47017\n\n\tconfig = {_id: 'shard1', members: [\n     {_id: 0, host: '10.62.0.128:47017'},\n\t {_id: 1, host: '10.62.0.135:47017'},\n\t {_id: 2, host: '10.62.0.159:47017'}]\n     }\n    rs.initiate(config)\n\n\tCtrl + C 退出\n\n*\trs.add({\"_id\":2,\"host\":\"10.62.0.135:47017\"})\t#在线增加复制集\n\n----\n\t./mongo --port 47018\n\n    config = {_id: 'shard2', members: [\n     {_id: 0, host: '10.62.0.128:47018'},\n\t {_id: 1, host: '10.62.0.135:47018'},\n\t {_id: 2, host: '10.62.0.159:47018'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47019\n\n    config = {_id: 'shard3', members: [\n     {_id: 0, host: '10.62.0.128:47019'},\n\t {_id: 1, host: '10.62.0.135:47019'},\n\t {_id: 2, host: '10.62.0.159:47019'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47020\n\n    config = {_id: 'shard4', members: [\n     {_id: 0, host: '10.62.0.128:47020'},\n\t {_id: 1, host: '10.62.0.135:47020'},\n\t {_id: 2, host: '10.62.0.159:47020'}]\n     }\n    rs.initiate(config)\n\n\t./mongo --port 47021\n\n    config = {_id: 'shard5', members: [\n     {_id: 0, host: '10.62.0.128:47021'},\n\t {_id: 1, host: '10.62.0.135:47021'},\n\t {_id: 2, host: '10.62.0.159:47021'}]\n     }\n    rs.initiate(config)\n\n\n\t./mongo --port 47022\n\n    config = {_id: 'shard6', members: [\n     {_id: 0, host: '10.62.0.128:47022'},\n\t {_id: 1, host: '10.62.0.135:47022'},\n\t {_id: 2, host: '10.62.0.159:47022'}]\n     }\n    rs.initiate(config)\n\n## 配置sharding:登录到mongos，添加shard节点\n\n    ./mongo --port 30000\n\n    use admin\n\n    db.runCommand({addshard:\"shard1/10.62.0.128:47017,10.62.0.159:47017,10.62.0.135:47017\"});\n    db.runCommand({addshard:\"shard2/10.62.0.128:47018,10.62.0.159:47018,10.62.0.135:47018\"});\n    db.runCommand({addshard:\"shard3/10.62.0.128:47019,10.62.0.159:47019,10.62.0.135:47019\"});\n    db.runCommand({addshard:\"shard4/10.62.0.128:47020,10.62.0.159:47020,10.62.0.135:47020\"});\n\tdb.runCommand({addshard:\"shard5/10.62.0.128:47021,10.62.0.159:47021,10.62.0.135:47021\"});\n\tdb.runCommand({addshard:\"shard6/10.62.0.128:47022,10.62.0.159:47022,10.62.0.135:47022\"});\n\n\n    use config\n\n    db.shards.find()\n\n#### 启动路由服务出错 \n\n错误：\n\n![时钟不同步，导致无法启动路由服务](http://i.imgur.com/Usu4wPa.png)\n\n解决方法：\n\n*\t(1).关闭所有mongo相关服务\n*\t(2).先启配置服务 \t\tConfig Server\n*\t(3).启动路由服务\t\tmongos\n*\t(4).最后启动所有mongod服务\tmongod\n###远程copy\n    scp /home/gsunis/Tools/mongodb-linux-x86_64-3.0.6.tgz gsunis@10.62.0.135:/home/gsunis/\n","slug":"数据库-2018-12-10-MongoDB集群搭建","published":1,"date":"2019-02-14T08:23:24.000Z","updated":"2019-02-14T08:23:24.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0f006e5b8h31k88h64","content":"<p>##集群环境:三台服务器</p>\n<h3 id=\"server110620128主server210620135从server310620159从\"><a class=\"markdownIt-Anchor\" href=\"#server110620128主server210620135从server310620159从\"></a> server1:10.62.0.128主;server2:10.62.0.135从;server3:10.62.0.159从</h3>\n<h4 id=\"每一台分为6个片shard1~shard6端口为470174701847019470204702147022每一片建三个副本集配置服务器端口号37017路由服务器端口号30000\"><a class=\"markdownIt-Anchor\" href=\"#每一台分为6个片shard1~shard6端口为470174701847019470204702147022每一片建三个副本集配置服务器端口号37017路由服务器端口号30000\"></a> 每一台分为6个片：shard1~shard6端口为47017,47018,47019,47020,47021,47022；每一片建三个副本集；配置服务器端口号：37017；路由服务器端口号：30000；</h4>\n<h3 id=\"1解压安装文件\"><a class=\"markdownIt-Anchor\" href=\"#1解压安装文件\"></a> (1).解压安装文件</h3>\n<pre><code>[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n</code></pre>\n<h3 id=\"2将mongodb文件移动到homegsunismongodb目录下\"><a class=\"markdownIt-Anchor\" href=\"#2将mongodb文件移动到homegsunismongodb目录下\"></a> (2).将mongoDB文件移动到/home/gsunis/mongodb目录下</h3>\n<pre><code>[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /home/gsunis/mongodb\n</code></pre>\n<h3 id=\"3数据存储目录\"><a class=\"markdownIt-Anchor\" href=\"#3数据存储目录\"></a> (3).数据存储目录</h3>\n<pre><code>[root@gsunis bin]# mkdir -p /home/gsunis/data/db\n</code></pre>\n<h3 id=\"4启动mongod服务\"><a class=\"markdownIt-Anchor\" href=\"#4启动mongod服务\"></a> (4).启动mongod服务</h3>\n<pre><code>[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin\n[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n</code></pre>\n<h3 id=\"5启动mongo客户端\"><a class=\"markdownIt-Anchor\" href=\"#5启动mongo客户端\"></a> (5).启动mongo客户端</h3>\n<pre><code>打开新的Terminal\n[gsunis@gsunis Desktop]$ su \n查看mongod服务启动情况\n[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin/\n[root@gsunis bin]# ./mongo\n</code></pre>\n<p>###正常关闭mongoDB服务</p>\n<pre><code>./mongo\nuse admin\ndb.shutdownServer() 或者ps -ef|grep mongodb  kill -2 pid\n</code></pre>\n<p>##以上是简单的安装mongodb，下面是开始建立集群，分片和建立副本集</p>\n<p>###创建目录<br>\nmkdir -p /data/conf<br>\nmkdir -p /data/data1<br>\nmkdir -p /data/data2<br>\nmkdir -p /data/data3<br>\nmkdir -p /data/data4<br>\nmkdir -p /data/data5<br>\nmkdir -p /data/data6</p>\n<h3 id=\"6编辑mongo配置文件\"><a class=\"markdownIt-Anchor\" href=\"#6编辑mongo配置文件\"></a> (6).编辑mongo配置文件</h3>\n<pre><code>sudo vi conf.cnf\n\n//conf.cnf   \nport=37017  \ndbpath=/home/gsunis/data/conf  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/conf/mongodb.log  \nnojournal=false  \nconfigsvr=true  \nprofile=1 \n\nsudo vi db1.cnf\n\n//db1.cnf  \nreplSet=shard1  \nport=47017  \ndbpath=/home/gsunis/data/data1  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data1/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db2.cnf\n\n//db2.cnf  \nreplSet=shard2   \nport=47018  \ndbpath=/home/gsunis/data/data2  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data2/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db3.cnf\n\n//db3.cnf  \nreplSet=shard3  \nport=47019  \ndbpath=/home/gsunis/data/data3  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data3/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db4.cnf\n\n//db4.cnf  \nreplSet=shard4   \nport=47020  \ndbpath=/home/gsunis/data/data4  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data4/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db5.cnf\n\n//db5.cnf  \nreplSet=shard5   \nport=47021  \ndbpath=/home/gsunis/data/data5  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data5/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db6.cnf\n\n//db6.cnf  \nreplSet=shard6   \nport=47022  \ndbpath=/home/gsunis/data/data6  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data6/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n</code></pre>\n<h4 id=\"7编写启动mongo服务的脚本\"><a class=\"markdownIt-Anchor\" href=\"#7编写启动mongo服务的脚本\"></a> (7).编写启动mongo服务的脚本</h4>\n<pre><code>sudo vi mg.sh\n\n#!/bin/bash  \ninstance=$1  \naction=$2  \ncase &quot;$action&quot; in  \n   'start')  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf ;;  \n   'stop')  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown;;  \n   'restart')  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf;;  \nesac  \n</code></pre>\n<h4 id=\"8启动mongo服务脚本\"><a class=\"markdownIt-Anchor\" href=\"#8启动mongo服务脚本\"></a> (8).启动mongo服务脚本</h4>\n<pre><code>sudo vi start.sh\n\n#!/bin/bash \nrm /data/conf/*.lock\nrm /data/data1/*.lock\t\nrm /data/data2/*.lock\nrm /data/data3/*.lock\nrm /data/data4/*.lock\nrm /data/data5/*.lock\nrm /data/data6/*.lock\n/home/gsunis/data/mg.sh db1 start  \n/home/gsunis/data/mg.sh db2 start  \n/home/gsunis/data/mg.sh db3 start  \n/home/gsunis/data/mg.sh db4 start  \n/home/gsunis/data/mg.sh db5 start\n/home/gsunis/data/mg.sh db6 start  \n</code></pre>\n<p>sudo vi <a href=\"http://stop.sh\" target=\"_blank\" rel=\"noopener\">stop.sh</a></p>\n<pre><code>#!/bin/bash \n/home/gsunis/data/mg.sh conf stop \n/home/gsunis/data/mg.sh db1 stop  \n/home/gsunis/data/mg.sh db2 stop  \n/home/gsunis/data/mg.sh db3 stop  \n/home/gsunis/data/mg.sh db4 stop  \n/home/gsunis/data/mg.sh db5 stop\n/home/gsunis/data/mg.sh db6 stop  \n</code></pre>\n<p>###准备工作做好，先启动配置服务器（先启动主，依次启动两从机）<br>\n/home/gsunis/data/mg.sh conf start<br>\n###再启动路由服务器（先启动主，依次启动两从机）<br>\n/home/gsunis/mongodb/bin/mongos  --configdb 10.62.0.128:37017,10.62.0.135:37017,10.62.0.159:37017 --port 30000 --chunkSize 1 --logpath /home/gsunis/data/mongos1.log --logappend --fork<br>\n###最后启动mongod（先启动主，依次启动两从机）<br>\n/home/gsunis/mongodb/data/start.sh</p>\n<h3 id=\"9shard服务器副本集的建立只需要在主机上做即可两从机会自动复制\"><a class=\"markdownIt-Anchor\" href=\"#9shard服务器副本集的建立只需要在主机上做即可两从机会自动复制\"></a> (9).shard服务器副本集的建立（只需要在主机上做即可，两从机会自动复制）</h3>\n<pre><code>./mongo --port 47017\n\nconfig = {_id: 'shard1', members: [\n {_id: 0, host: '10.62.0.128:47017'},\n {_id: 1, host: '10.62.0.135:47017'},\n {_id: 2, host: '10.62.0.159:47017'}]\n }\nrs.initiate(config)\n\nCtrl + C 退出\n</code></pre>\n<ul>\n<li>rs.add({&quot;_id&quot;:2,“host”:“10.62.0.135:47017”})\t#在线增加复制集</li>\n</ul>\n<hr>\n<pre><code>./mongo --port 47018\n\nconfig = {_id: 'shard2', members: [\n {_id: 0, host: '10.62.0.128:47018'},\n {_id: 1, host: '10.62.0.135:47018'},\n {_id: 2, host: '10.62.0.159:47018'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47019\n\nconfig = {_id: 'shard3', members: [\n {_id: 0, host: '10.62.0.128:47019'},\n {_id: 1, host: '10.62.0.135:47019'},\n {_id: 2, host: '10.62.0.159:47019'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47020\n\nconfig = {_id: 'shard4', members: [\n {_id: 0, host: '10.62.0.128:47020'},\n {_id: 1, host: '10.62.0.135:47020'},\n {_id: 2, host: '10.62.0.159:47020'}]\n }\nrs.initiate(config)\n\n./mongo --port 47021\n\nconfig = {_id: 'shard5', members: [\n {_id: 0, host: '10.62.0.128:47021'},\n {_id: 1, host: '10.62.0.135:47021'},\n {_id: 2, host: '10.62.0.159:47021'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47022\n\nconfig = {_id: 'shard6', members: [\n {_id: 0, host: '10.62.0.128:47022'},\n {_id: 1, host: '10.62.0.135:47022'},\n {_id: 2, host: '10.62.0.159:47022'}]\n }\nrs.initiate(config)\n</code></pre>\n<h2 id=\"配置sharding登录到mongos添加shard节点\"><a class=\"markdownIt-Anchor\" href=\"#配置sharding登录到mongos添加shard节点\"></a> 配置sharding:登录到mongos，添加shard节点</h2>\n<pre><code>./mongo --port 30000\n\nuse admin\n\ndb.runCommand({addshard:&quot;shard1/10.62.0.128:47017,10.62.0.159:47017,10.62.0.135:47017&quot;});\ndb.runCommand({addshard:&quot;shard2/10.62.0.128:47018,10.62.0.159:47018,10.62.0.135:47018&quot;});\ndb.runCommand({addshard:&quot;shard3/10.62.0.128:47019,10.62.0.159:47019,10.62.0.135:47019&quot;});\ndb.runCommand({addshard:&quot;shard4/10.62.0.128:47020,10.62.0.159:47020,10.62.0.135:47020&quot;});\ndb.runCommand({addshard:&quot;shard5/10.62.0.128:47021,10.62.0.159:47021,10.62.0.135:47021&quot;});\ndb.runCommand({addshard:&quot;shard6/10.62.0.128:47022,10.62.0.159:47022,10.62.0.135:47022&quot;});\n\n\nuse config\n\ndb.shards.find()\n</code></pre>\n<h4 id=\"启动路由服务出错\"><a class=\"markdownIt-Anchor\" href=\"#启动路由服务出错\"></a> 启动路由服务出错</h4>\n<p>错误：</p>\n<p><img src=\"http://i.imgur.com/Usu4wPa.png\" alt=\"时钟不同步，导致无法启动路由服务\"></p>\n<p>解决方法：</p>\n<ul>\n<li>(1).关闭所有mongo相关服务</li>\n<li>(2).先启配置服务 \t\tConfig Server</li>\n<li>(3).启动路由服务\t\tmongos</li>\n<li>(4).最后启动所有mongod服务\tmongod<br>\n###远程copy<br>\nscp /home/gsunis/Tools/mongodb-linux-x86_64-3.0.6.tgz <a href=\"mailto:gsunis@10.62.0.135\" target=\"_blank\" rel=\"noopener\">gsunis@10.62.0.135</a>:/home/gsunis/</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>##集群环境:三台服务器</p>\n<h3 id=\"server110620128主server210620135从server310620159从\"><a class=\"markdownIt-Anchor\" href=\"#server110620128主server210620135从server310620159从\"></a> server1:10.62.0.128主;server2:10.62.0.135从;server3:10.62.0.159从</h3>\n<h4 id=\"每一台分为6个片shard1~shard6端口为470174701847019470204702147022每一片建三个副本集配置服务器端口号37017路由服务器端口号30000\"><a class=\"markdownIt-Anchor\" href=\"#每一台分为6个片shard1~shard6端口为470174701847019470204702147022每一片建三个副本集配置服务器端口号37017路由服务器端口号30000\"></a> 每一台分为6个片：shard1~shard6端口为47017,47018,47019,47020,47021,47022；每一片建三个副本集；配置服务器端口号：37017；路由服务器端口号：30000；</h4>\n<h3 id=\"1解压安装文件\"><a class=\"markdownIt-Anchor\" href=\"#1解压安装文件\"></a> (1).解压安装文件</h3>\n<pre><code>[gsunis@gsunis Desktop]$ tar zxvf mongodb-linux-x86_64-3.0.6.tgz\n</code></pre>\n<h3 id=\"2将mongodb文件移动到homegsunismongodb目录下\"><a class=\"markdownIt-Anchor\" href=\"#2将mongodb文件移动到homegsunismongodb目录下\"></a> (2).将mongoDB文件移动到/home/gsunis/mongodb目录下</h3>\n<pre><code>[root@gsunis Desktop]# mv mongodb-linux-x86_64-3.0.6 /home/gsunis/mongodb\n</code></pre>\n<h3 id=\"3数据存储目录\"><a class=\"markdownIt-Anchor\" href=\"#3数据存储目录\"></a> (3).数据存储目录</h3>\n<pre><code>[root@gsunis bin]# mkdir -p /home/gsunis/data/db\n</code></pre>\n<h3 id=\"4启动mongod服务\"><a class=\"markdownIt-Anchor\" href=\"#4启动mongod服务\"></a> (4).启动mongod服务</h3>\n<pre><code>[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin\n[root@gsunis bin]# ./mongod --port 27017 --dbpath=/home/gsunis/data/db\n</code></pre>\n<h3 id=\"5启动mongo客户端\"><a class=\"markdownIt-Anchor\" href=\"#5启动mongo客户端\"></a> (5).启动mongo客户端</h3>\n<pre><code>打开新的Terminal\n[gsunis@gsunis Desktop]$ su \n查看mongod服务启动情况\n[root@gsunis Desktop]# netstat -ntpl | grep 27017\n\n[root@gsunis Desktop]# cd /home/gsunis/mongodb/bin/\n[root@gsunis bin]# ./mongo\n</code></pre>\n<p>###正常关闭mongoDB服务</p>\n<pre><code>./mongo\nuse admin\ndb.shutdownServer() 或者ps -ef|grep mongodb  kill -2 pid\n</code></pre>\n<p>##以上是简单的安装mongodb，下面是开始建立集群，分片和建立副本集</p>\n<p>###创建目录<br>\nmkdir -p /data/conf<br>\nmkdir -p /data/data1<br>\nmkdir -p /data/data2<br>\nmkdir -p /data/data3<br>\nmkdir -p /data/data4<br>\nmkdir -p /data/data5<br>\nmkdir -p /data/data6</p>\n<h3 id=\"6编辑mongo配置文件\"><a class=\"markdownIt-Anchor\" href=\"#6编辑mongo配置文件\"></a> (6).编辑mongo配置文件</h3>\n<pre><code>sudo vi conf.cnf\n\n//conf.cnf   \nport=37017  \ndbpath=/home/gsunis/data/conf  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/conf/mongodb.log  \nnojournal=false  \nconfigsvr=true  \nprofile=1 \n\nsudo vi db1.cnf\n\n//db1.cnf  \nreplSet=shard1  \nport=47017  \ndbpath=/home/gsunis/data/data1  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data1/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db2.cnf\n\n//db2.cnf  \nreplSet=shard2   \nport=47018  \ndbpath=/home/gsunis/data/data2  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data2/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db3.cnf\n\n//db3.cnf  \nreplSet=shard3  \nport=47019  \ndbpath=/home/gsunis/data/data3  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data3/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db4.cnf\n\n//db4.cnf  \nreplSet=shard4   \nport=47020  \ndbpath=/home/gsunis/data/data4  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data4/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db5.cnf\n\n//db5.cnf  \nreplSet=shard5   \nport=47021  \ndbpath=/home/gsunis/data/data5  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data5/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n\nsudo vi db6.cnf\n\n//db6.cnf  \nreplSet=shard6   \nport=47022  \ndbpath=/home/gsunis/data/data6  \nlogappend = true  \nfork=true  \nlogpath=/home/gsunis/data/data6/mongodb.log  \nnojournal=false  \nshardsvr=true  \nprofile=1  \n</code></pre>\n<h4 id=\"7编写启动mongo服务的脚本\"><a class=\"markdownIt-Anchor\" href=\"#7编写启动mongo服务的脚本\"></a> (7).编写启动mongo服务的脚本</h4>\n<pre><code>sudo vi mg.sh\n\n#!/bin/bash  \ninstance=$1  \naction=$2  \ncase &quot;$action&quot; in  \n   'start')  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf ;;  \n   'stop')  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown;;  \n   'restart')  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf --shutdown  \n/home/gsunis/mongodb/bin/mongod -f /home/gsunis/data/&quot;$instance&quot;.cnf;;  \nesac  \n</code></pre>\n<h4 id=\"8启动mongo服务脚本\"><a class=\"markdownIt-Anchor\" href=\"#8启动mongo服务脚本\"></a> (8).启动mongo服务脚本</h4>\n<pre><code>sudo vi start.sh\n\n#!/bin/bash \nrm /data/conf/*.lock\nrm /data/data1/*.lock\t\nrm /data/data2/*.lock\nrm /data/data3/*.lock\nrm /data/data4/*.lock\nrm /data/data5/*.lock\nrm /data/data6/*.lock\n/home/gsunis/data/mg.sh db1 start  \n/home/gsunis/data/mg.sh db2 start  \n/home/gsunis/data/mg.sh db3 start  \n/home/gsunis/data/mg.sh db4 start  \n/home/gsunis/data/mg.sh db5 start\n/home/gsunis/data/mg.sh db6 start  \n</code></pre>\n<p>sudo vi <a href=\"http://stop.sh\" target=\"_blank\" rel=\"noopener\">stop.sh</a></p>\n<pre><code>#!/bin/bash \n/home/gsunis/data/mg.sh conf stop \n/home/gsunis/data/mg.sh db1 stop  \n/home/gsunis/data/mg.sh db2 stop  \n/home/gsunis/data/mg.sh db3 stop  \n/home/gsunis/data/mg.sh db4 stop  \n/home/gsunis/data/mg.sh db5 stop\n/home/gsunis/data/mg.sh db6 stop  \n</code></pre>\n<p>###准备工作做好，先启动配置服务器（先启动主，依次启动两从机）<br>\n/home/gsunis/data/mg.sh conf start<br>\n###再启动路由服务器（先启动主，依次启动两从机）<br>\n/home/gsunis/mongodb/bin/mongos  --configdb 10.62.0.128:37017,10.62.0.135:37017,10.62.0.159:37017 --port 30000 --chunkSize 1 --logpath /home/gsunis/data/mongos1.log --logappend --fork<br>\n###最后启动mongod（先启动主，依次启动两从机）<br>\n/home/gsunis/mongodb/data/start.sh</p>\n<h3 id=\"9shard服务器副本集的建立只需要在主机上做即可两从机会自动复制\"><a class=\"markdownIt-Anchor\" href=\"#9shard服务器副本集的建立只需要在主机上做即可两从机会自动复制\"></a> (9).shard服务器副本集的建立（只需要在主机上做即可，两从机会自动复制）</h3>\n<pre><code>./mongo --port 47017\n\nconfig = {_id: 'shard1', members: [\n {_id: 0, host: '10.62.0.128:47017'},\n {_id: 1, host: '10.62.0.135:47017'},\n {_id: 2, host: '10.62.0.159:47017'}]\n }\nrs.initiate(config)\n\nCtrl + C 退出\n</code></pre>\n<ul>\n<li>rs.add({&quot;_id&quot;:2,“host”:“10.62.0.135:47017”})\t#在线增加复制集</li>\n</ul>\n<hr>\n<pre><code>./mongo --port 47018\n\nconfig = {_id: 'shard2', members: [\n {_id: 0, host: '10.62.0.128:47018'},\n {_id: 1, host: '10.62.0.135:47018'},\n {_id: 2, host: '10.62.0.159:47018'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47019\n\nconfig = {_id: 'shard3', members: [\n {_id: 0, host: '10.62.0.128:47019'},\n {_id: 1, host: '10.62.0.135:47019'},\n {_id: 2, host: '10.62.0.159:47019'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47020\n\nconfig = {_id: 'shard4', members: [\n {_id: 0, host: '10.62.0.128:47020'},\n {_id: 1, host: '10.62.0.135:47020'},\n {_id: 2, host: '10.62.0.159:47020'}]\n }\nrs.initiate(config)\n\n./mongo --port 47021\n\nconfig = {_id: 'shard5', members: [\n {_id: 0, host: '10.62.0.128:47021'},\n {_id: 1, host: '10.62.0.135:47021'},\n {_id: 2, host: '10.62.0.159:47021'}]\n }\nrs.initiate(config)\n\n\n./mongo --port 47022\n\nconfig = {_id: 'shard6', members: [\n {_id: 0, host: '10.62.0.128:47022'},\n {_id: 1, host: '10.62.0.135:47022'},\n {_id: 2, host: '10.62.0.159:47022'}]\n }\nrs.initiate(config)\n</code></pre>\n<h2 id=\"配置sharding登录到mongos添加shard节点\"><a class=\"markdownIt-Anchor\" href=\"#配置sharding登录到mongos添加shard节点\"></a> 配置sharding:登录到mongos，添加shard节点</h2>\n<pre><code>./mongo --port 30000\n\nuse admin\n\ndb.runCommand({addshard:&quot;shard1/10.62.0.128:47017,10.62.0.159:47017,10.62.0.135:47017&quot;});\ndb.runCommand({addshard:&quot;shard2/10.62.0.128:47018,10.62.0.159:47018,10.62.0.135:47018&quot;});\ndb.runCommand({addshard:&quot;shard3/10.62.0.128:47019,10.62.0.159:47019,10.62.0.135:47019&quot;});\ndb.runCommand({addshard:&quot;shard4/10.62.0.128:47020,10.62.0.159:47020,10.62.0.135:47020&quot;});\ndb.runCommand({addshard:&quot;shard5/10.62.0.128:47021,10.62.0.159:47021,10.62.0.135:47021&quot;});\ndb.runCommand({addshard:&quot;shard6/10.62.0.128:47022,10.62.0.159:47022,10.62.0.135:47022&quot;});\n\n\nuse config\n\ndb.shards.find()\n</code></pre>\n<h4 id=\"启动路由服务出错\"><a class=\"markdownIt-Anchor\" href=\"#启动路由服务出错\"></a> 启动路由服务出错</h4>\n<p>错误：</p>\n<p><img src=\"http://i.imgur.com/Usu4wPa.png\" alt=\"时钟不同步，导致无法启动路由服务\"></p>\n<p>解决方法：</p>\n<ul>\n<li>(1).关闭所有mongo相关服务</li>\n<li>(2).先启配置服务 \t\tConfig Server</li>\n<li>(3).启动路由服务\t\tmongos</li>\n<li>(4).最后启动所有mongod服务\tmongod<br>\n###远程copy<br>\nscp /home/gsunis/Tools/mongodb-linux-x86_64-3.0.6.tgz <a href=\"mailto:gsunis@10.62.0.135\" target=\"_blank\" rel=\"noopener\">gsunis@10.62.0.135</a>:/home/gsunis/</li>\n</ul>\n"},{"title":"MySQL与MariaDB对比","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n# MySQL与MariaDB对比\n## MySQL：\n> MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。\n\n## MariaDB\n> 甲骨文收购 MySQL 后，由于甲骨文对 MySQL 的开发和维护更多倾向于闭门的立场，很多 MySQL 的开发者和用户放弃了它。在社区驱动下，促使更多人移到 MySQL 的另一个叫 MariaDB 的分支，在原有 MySQL 开发人员的带领下，MariaDB 的开发遵循开源的理念，并确保它的二进制格式与 MySQL 兼容。","source":"_posts/数据库/MySQL与MariaDB对比.md","raw":"---\ntitle: MySQL与MariaDB对比\ntags:\n  - CentOS \ncopyright: true\ncomments: true\ntoc: true\ncategories: Linux\npassword:\n---\n\n# MySQL与MariaDB对比\n## MySQL：\n> MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。\n\n## MariaDB\n> 甲骨文收购 MySQL 后，由于甲骨文对 MySQL 的开发和维护更多倾向于闭门的立场，很多 MySQL 的开发者和用户放弃了它。在社区驱动下，促使更多人移到 MySQL 的另一个叫 MariaDB 的分支，在原有 MySQL 开发人员的带领下，MariaDB 的开发遵循开源的理念，并确保它的二进制格式与 MySQL 兼容。","slug":"数据库-MySQL与MariaDB对比","published":1,"date":"2019-02-14T08:22:58.000Z","updated":"2019-02-14T08:22:58.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0g006g5b8h60t5ou3y","content":"<h1 id=\"mysql与mariadb对比\"><a class=\"markdownIt-Anchor\" href=\"#mysql与mariadb对比\"></a> MySQL与MariaDB对比</h1>\n<h2 id=\"mysql\"><a class=\"markdownIt-Anchor\" href=\"#mysql\"></a> MySQL：</h2>\n<blockquote>\n<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。</p>\n</blockquote>\n<h2 id=\"mariadb\"><a class=\"markdownIt-Anchor\" href=\"#mariadb\"></a> MariaDB</h2>\n<blockquote>\n<p>甲骨文收购 MySQL 后，由于甲骨文对 MySQL 的开发和维护更多倾向于闭门的立场，很多 MySQL 的开发者和用户放弃了它。在社区驱动下，促使更多人移到 MySQL 的另一个叫 MariaDB 的分支，在原有 MySQL 开发人员的带领下，MariaDB 的开发遵循开源的理念，并确保它的二进制格式与 MySQL 兼容。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mysql与mariadb对比\"><a class=\"markdownIt-Anchor\" href=\"#mysql与mariadb对比\"></a> MySQL与MariaDB对比</h1>\n<h2 id=\"mysql\"><a class=\"markdownIt-Anchor\" href=\"#mysql\"></a> MySQL：</h2>\n<blockquote>\n<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。</p>\n</blockquote>\n<h2 id=\"mariadb\"><a class=\"markdownIt-Anchor\" href=\"#mariadb\"></a> MariaDB</h2>\n<blockquote>\n<p>甲骨文收购 MySQL 后，由于甲骨文对 MySQL 的开发和维护更多倾向于闭门的立场，很多 MySQL 的开发者和用户放弃了它。在社区驱动下，促使更多人移到 MySQL 的另一个叫 MariaDB 的分支，在原有 MySQL 开发人员的带领下，MariaDB 的开发遵循开源的理念，并确保它的二进制格式与 MySQL 兼容。</p>\n</blockquote>\n"},{"title":"MySQL安装_Windows","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T02:04:03.000Z","password":null,"_content":"\n[toc]\n\n# 软件准备\nmysql从官网下载，包括workbench。\n地址：\nhttp://dev.mysql.com/downloads/mysql/\n\nhttp://dev.mysql.com/downloads/workbench/\n\n# 安装mysql\ndmg下载后直接打开，安装过程中，会弹窗里边有随机生成的密码。记好了！不然还得卸载重装。\n\n# 修改密码(方法一)\n进入终端\n1. 输入：cd /usr/local/mysql/bin/\n2. su root\n3.  ./mysqld_safe --skip-grant-tables &   //禁止mysql验证功能\n4.  在root 模式下\n~~~\nsh-3.2# alias mysql=/usr/local/mysql/bin/mysql\nsh-3.2# alias mysqladmin=/usr/local/mysql/bin/mysqladmin\nsh-3.2# mysqladmin -u root -p password\n~~~\n5. 然后输入临时密码\n6. 然后提示输入新密码\n\n\n# 修改密码（方法二）\n1. 按账号mysql并启动服务\n2. 进入终端输入命令行\n3. 由于刚刚安装好的mysql密码为空，输入命令：mysql -u root -p  按回车即可登录mysql命令行\n4. 显示所有数据库,输入命令：show databases; \n5. 进入到名为mysql的数据库\n6. 显示出mysql数据库里面的表, 有一个user表，里面就存储的是mysql用户名，密码\n7. 打印user表结构\n8. 更新authentication_string（相当于windows里面的password字段）字段，此处要用PASSWORD（）函数修改：update user set authentication_string=PASSWORD('root') where user='root';\n\n\n# 添加用户\n~~~\nmysql -uroot -punistolllink;\nGRANT USAGE ON  *.* TO \t'ITS_GANSU'@'localhost' IDENTIFIED BY 'ITS_GANSU_STI' WITH GRANT OPTION;\n\nuse mysql;\nupdate user set host='%' where user='ITS_GANSU' and host='localhost'; \n\ngrant all privileges on *.* to ITS_GANSU@\"%\" identified by 'ITS_GANSU_STI';\nflush privileges;\nexit\n~~~","source":"_posts/数据库/MySQL安装-Windows.md","raw":"---\ntitle: MySQL安装_Windows\ntags:\n  - MySQL\n  - 数据库\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 10:04:03\ncategories: 数据库\npassword:\n---\n\n[toc]\n\n# 软件准备\nmysql从官网下载，包括workbench。\n地址：\nhttp://dev.mysql.com/downloads/mysql/\n\nhttp://dev.mysql.com/downloads/workbench/\n\n# 安装mysql\ndmg下载后直接打开，安装过程中，会弹窗里边有随机生成的密码。记好了！不然还得卸载重装。\n\n# 修改密码(方法一)\n进入终端\n1. 输入：cd /usr/local/mysql/bin/\n2. su root\n3.  ./mysqld_safe --skip-grant-tables &   //禁止mysql验证功能\n4.  在root 模式下\n~~~\nsh-3.2# alias mysql=/usr/local/mysql/bin/mysql\nsh-3.2# alias mysqladmin=/usr/local/mysql/bin/mysqladmin\nsh-3.2# mysqladmin -u root -p password\n~~~\n5. 然后输入临时密码\n6. 然后提示输入新密码\n\n\n# 修改密码（方法二）\n1. 按账号mysql并启动服务\n2. 进入终端输入命令行\n3. 由于刚刚安装好的mysql密码为空，输入命令：mysql -u root -p  按回车即可登录mysql命令行\n4. 显示所有数据库,输入命令：show databases; \n5. 进入到名为mysql的数据库\n6. 显示出mysql数据库里面的表, 有一个user表，里面就存储的是mysql用户名，密码\n7. 打印user表结构\n8. 更新authentication_string（相当于windows里面的password字段）字段，此处要用PASSWORD（）函数修改：update user set authentication_string=PASSWORD('root') where user='root';\n\n\n# 添加用户\n~~~\nmysql -uroot -punistolllink;\nGRANT USAGE ON  *.* TO \t'ITS_GANSU'@'localhost' IDENTIFIED BY 'ITS_GANSU_STI' WITH GRANT OPTION;\n\nuse mysql;\nupdate user set host='%' where user='ITS_GANSU' and host='localhost'; \n\ngrant all privileges on *.* to ITS_GANSU@\"%\" identified by 'ITS_GANSU_STI';\nflush privileges;\nexit\n~~~","slug":"数据库-MySQL安装-Windows","published":1,"updated":"2019-02-14T03:01:56.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0i006k5b8h067tbfk3","content":"<p>[toc]</p>\n<h1 id=\"软件准备\"><a class=\"markdownIt-Anchor\" href=\"#软件准备\"></a> 软件准备</h1>\n<p>mysql从官网下载，包括workbench。<br>\n地址：<br>\n<a href=\"http://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/mysql/</a></p>\n<p><a href=\"http://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/workbench/</a></p>\n<h1 id=\"安装mysql\"><a class=\"markdownIt-Anchor\" href=\"#安装mysql\"></a> 安装mysql</h1>\n<p>dmg下载后直接打开，安装过程中，会弹窗里边有随机生成的密码。记好了！不然还得卸载重装。</p>\n<h1 id=\"修改密码方法一\"><a class=\"markdownIt-Anchor\" href=\"#修改密码方法一\"></a> 修改密码(方法一)</h1>\n<p>进入终端</p>\n<ol>\n<li>输入：cd /usr/local/mysql/bin/</li>\n<li>su root</li>\n<li>./mysqld_safe --skip-grant-tables &amp;   //禁止mysql验证功能</li>\n<li>在root 模式下</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-3.2# alias mysql=/usr/local/mysql/bin/mysql</span><br><span class=\"line\">sh-3.2# alias mysqladmin=/usr/local/mysql/bin/mysqladmin</span><br><span class=\"line\">sh-3.2# mysqladmin -u root -p password</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>然后输入临时密码</li>\n<li>然后提示输入新密码</li>\n</ol>\n<h1 id=\"修改密码方法二\"><a class=\"markdownIt-Anchor\" href=\"#修改密码方法二\"></a> 修改密码（方法二）</h1>\n<ol>\n<li>按账号mysql并启动服务</li>\n<li>进入终端输入命令行</li>\n<li>由于刚刚安装好的mysql密码为空，输入命令：mysql -u root -p  按回车即可登录mysql命令行</li>\n<li>显示所有数据库,输入命令：show databases;</li>\n<li>进入到名为mysql的数据库</li>\n<li>显示出mysql数据库里面的表, 有一个user表，里面就存储的是mysql用户名，密码</li>\n<li>打印user表结构</li>\n<li>更新authentication_string（相当于windows里面的password字段）字段，此处要用PASSWORD（）函数修改：update user set authentication_string=PASSWORD(‘root’) where user=‘root’;</li>\n</ol>\n<h1 id=\"添加用户\"><a class=\"markdownIt-Anchor\" href=\"#添加用户\"></a> 添加用户</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -punistolllink;</span><br><span class=\"line\">GRANT USAGE ON  *.* TO \t&apos;ITS_GANSU&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ITS_GANSU_STI&apos; WITH GRANT OPTION;</span><br><span class=\"line\"></span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host=&apos;%&apos; where user=&apos;ITS_GANSU&apos; and host=&apos;localhost&apos;; </span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to ITS_GANSU@&quot;%&quot; identified by &apos;ITS_GANSU_STI&apos;;</span><br><span class=\"line\">flush privileges;</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"软件准备\"><a class=\"markdownIt-Anchor\" href=\"#软件准备\"></a> 软件准备</h1>\n<p>mysql从官网下载，包括workbench。<br>\n地址：<br>\n<a href=\"http://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/mysql/</a></p>\n<p><a href=\"http://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/workbench/</a></p>\n<h1 id=\"安装mysql\"><a class=\"markdownIt-Anchor\" href=\"#安装mysql\"></a> 安装mysql</h1>\n<p>dmg下载后直接打开，安装过程中，会弹窗里边有随机生成的密码。记好了！不然还得卸载重装。</p>\n<h1 id=\"修改密码方法一\"><a class=\"markdownIt-Anchor\" href=\"#修改密码方法一\"></a> 修改密码(方法一)</h1>\n<p>进入终端</p>\n<ol>\n<li>输入：cd /usr/local/mysql/bin/</li>\n<li>su root</li>\n<li>./mysqld_safe --skip-grant-tables &amp;   //禁止mysql验证功能</li>\n<li>在root 模式下</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-3.2# alias mysql=/usr/local/mysql/bin/mysql</span><br><span class=\"line\">sh-3.2# alias mysqladmin=/usr/local/mysql/bin/mysqladmin</span><br><span class=\"line\">sh-3.2# mysqladmin -u root -p password</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>然后输入临时密码</li>\n<li>然后提示输入新密码</li>\n</ol>\n<h1 id=\"修改密码方法二\"><a class=\"markdownIt-Anchor\" href=\"#修改密码方法二\"></a> 修改密码（方法二）</h1>\n<ol>\n<li>按账号mysql并启动服务</li>\n<li>进入终端输入命令行</li>\n<li>由于刚刚安装好的mysql密码为空，输入命令：mysql -u root -p  按回车即可登录mysql命令行</li>\n<li>显示所有数据库,输入命令：show databases;</li>\n<li>进入到名为mysql的数据库</li>\n<li>显示出mysql数据库里面的表, 有一个user表，里面就存储的是mysql用户名，密码</li>\n<li>打印user表结构</li>\n<li>更新authentication_string（相当于windows里面的password字段）字段，此处要用PASSWORD（）函数修改：update user set authentication_string=PASSWORD(‘root’) where user=‘root’;</li>\n</ol>\n<h1 id=\"添加用户\"><a class=\"markdownIt-Anchor\" href=\"#添加用户\"></a> 添加用户</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -punistolllink;</span><br><span class=\"line\">GRANT USAGE ON  *.* TO \t&apos;ITS_GANSU&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ITS_GANSU_STI&apos; WITH GRANT OPTION;</span><br><span class=\"line\"></span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host=&apos;%&apos; where user=&apos;ITS_GANSU&apos; and host=&apos;localhost&apos;; </span><br><span class=\"line\"></span><br><span class=\"line\">grant all privileges on *.* to ITS_GANSU@&quot;%&quot; identified by &apos;ITS_GANSU_STI&apos;;</span><br><span class=\"line\">flush privileges;</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>"},{"title":"SQLServer连接测试","copyright":true,"comments":1,"toc":true,"date":"2018-10-05T02:04:03.000Z","password":null,"_content":"\nwindows系统下：\n1. 新建文件 后缀改成.udl\n2. 打开后，输入IP地址、用户名、密码，选择数据库进行连接","source":"_posts/数据库/SQLServer连接测试.md","raw":"---\ntitle: SQLServer连接测试\ntags:\n  - SQLServer\n  - 数据库\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-05 10:04:03\ncategories: 数据库\npassword:\n---\n\nwindows系统下：\n1. 新建文件 后缀改成.udl\n2. 打开后，输入IP地址、用户名、密码，选择数据库进行连接","slug":"数据库-SQLServer连接测试","published":1,"updated":"2019-02-14T03:03:01.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0j006n5b8htdx06wwf","content":"<p>windows系统下：</p>\n<ol>\n<li>新建文件 后缀改成.udl</li>\n<li>打开后，输入IP地址、用户名、密码，选择数据库进行连接</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>windows系统下：</p>\n<ol>\n<li>新建文件 后缀改成.udl</li>\n<li>打开后，输入IP地址、用户名、密码，选择数据库进行连接</li>\n</ol>\n"},{"title":"mac系统安装","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# U盘启动\nU盘启动：目的是为了在没有装系统的情况下进行临时启动，它可以启动DOS、备份还原软件或内存中运行的PE系统。现在大部分的电脑都支持U盘启动。U盘启动在系统奔溃和快速安装系统时能起到很大的作用。\n\n# mac系统安装启动盘制作\n1. 准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料\n2. 下载好需要安装的系统。在App Store中搜索系统，如：MacOS Sierra，完成下载。\n3. 打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致)\n4. 打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去：\n~~~\nsudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\\ macOS\\ Sierra.app --nointeraction\n~~~\n\n回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了：\n![image](/pub-images/macOS制作U盘启动.png)\n\n如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了\n\n# mac系统U盘安装\n0. （此步骤可选：如果想格式化磁盘则进行此操作）启动时按住[command + r]，进入磁盘管理工具抹掉磁盘即可\n1. 先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住[option」(alt)] 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。\n2. 选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装\n3. 启动过程中电脑会重启，重启的时候，拔掉U盘\n\n\n# 安装软件\n* 在登陆App Store之后，往常安装过的软件在\"已购项目\"列表中有，不用每次安装系统后再一一去查找安装过的程序。\n\n非App Store安装的程序，在安装时，又是会提示app出现某些安装包已损坏、显示未激活、打开崩溃等的提示！！这种多是因为新系统屏蔽了任何来源的设置，所以需要大家打开“允许任何来源”方可安装，可按如下方式操作\n* 步骤1：Spotlight搜索(快捷键：command+空格或右上角搜索的符号)：搜索 “终端”\n* 步骤2：直接复制粘贴 sudo spctl --master-disable   回车\n* 步骤3：输入你的 开机密码\n* 步骤4：回到系统偏好设置 的“安全与隐私”，勾选 “允许任何来源”完成安装.\n\n\n# macOS一些其他维护相关知识\n官方技术支持网址：https://support.apple.com/zh-cn\n1. 关于 Mac 启动时您看到的屏幕：在从 OS X 启动 Mac 时，系统会显示不同的屏幕，以让您了解 Mac 的启动方式，或是启动可能未完成的原因。\nhttps://support.apple.com/zh-cn/HT204156\n\n2. 启动 Mac 时显示闪烁的问号\n如果启动时在 Mac 屏幕上看到闪烁的问号，这意味着您的 Mac 无法找到自身的系统软件。\nhttps://support.apple.com/zh-cn/HT204323\n\n3. 如何重新安装 macOS\nhttps://support.apple.com/zh-cn/HT204904\n\n4. 关于 macOS 恢复功能\nhttps://support.apple.com/zh-cn/HT201314\n\n5. 使用 Time Machine 备份或恢复 Mac\nhttps://support.apple.com/zh-cn/HT201250\n\n6. 如何重置 Mac 上的 NVRAM        Command-Option-P-R \nhttps://support.apple.com/zh-cn/HT204063\n\n7. 重置 Mac 上的系统管理控制器 (SMC)       Shift-Control-Option\nhttps://support.apple.com/zh-cn/HT201295\n\n8. 如何识别 MacBook Pro 机型\nhttps://support.apple.com/zh-cn/HT201300","source":"_posts/环境搭建/01_mac系统安装.md","raw":"---\ntitle: mac系统安装\ntags:\n  - 环境搭建\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\n\n# U盘启动\nU盘启动：目的是为了在没有装系统的情况下进行临时启动，它可以启动DOS、备份还原软件或内存中运行的PE系统。现在大部分的电脑都支持U盘启动。U盘启动在系统奔溃和快速安装系统时能起到很大的作用。\n\n# mac系统安装启动盘制作\n1. 准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料\n2. 下载好需要安装的系统。在App Store中搜索系统，如：MacOS Sierra，完成下载。\n3. 打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致)\n4. 打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去：\n~~~\nsudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\\ macOS\\ Sierra.app --nointeraction\n~~~\n\n回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了：\n![image](/pub-images/macOS制作U盘启动.png)\n\n如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了\n\n# mac系统U盘安装\n0. （此步骤可选：如果想格式化磁盘则进行此操作）启动时按住[command + r]，进入磁盘管理工具抹掉磁盘即可\n1. 先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住[option」(alt)] 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。\n2. 选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装\n3. 启动过程中电脑会重启，重启的时候，拔掉U盘\n\n\n# 安装软件\n* 在登陆App Store之后，往常安装过的软件在\"已购项目\"列表中有，不用每次安装系统后再一一去查找安装过的程序。\n\n非App Store安装的程序，在安装时，又是会提示app出现某些安装包已损坏、显示未激活、打开崩溃等的提示！！这种多是因为新系统屏蔽了任何来源的设置，所以需要大家打开“允许任何来源”方可安装，可按如下方式操作\n* 步骤1：Spotlight搜索(快捷键：command+空格或右上角搜索的符号)：搜索 “终端”\n* 步骤2：直接复制粘贴 sudo spctl --master-disable   回车\n* 步骤3：输入你的 开机密码\n* 步骤4：回到系统偏好设置 的“安全与隐私”，勾选 “允许任何来源”完成安装.\n\n\n# macOS一些其他维护相关知识\n官方技术支持网址：https://support.apple.com/zh-cn\n1. 关于 Mac 启动时您看到的屏幕：在从 OS X 启动 Mac 时，系统会显示不同的屏幕，以让您了解 Mac 的启动方式，或是启动可能未完成的原因。\nhttps://support.apple.com/zh-cn/HT204156\n\n2. 启动 Mac 时显示闪烁的问号\n如果启动时在 Mac 屏幕上看到闪烁的问号，这意味着您的 Mac 无法找到自身的系统软件。\nhttps://support.apple.com/zh-cn/HT204323\n\n3. 如何重新安装 macOS\nhttps://support.apple.com/zh-cn/HT204904\n\n4. 关于 macOS 恢复功能\nhttps://support.apple.com/zh-cn/HT201314\n\n5. 使用 Time Machine 备份或恢复 Mac\nhttps://support.apple.com/zh-cn/HT201250\n\n6. 如何重置 Mac 上的 NVRAM        Command-Option-P-R \nhttps://support.apple.com/zh-cn/HT204063\n\n7. 重置 Mac 上的系统管理控制器 (SMC)       Shift-Control-Option\nhttps://support.apple.com/zh-cn/HT201295\n\n8. 如何识别 MacBook Pro 机型\nhttps://support.apple.com/zh-cn/HT201300","slug":"环境搭建-01-mac系统安装","published":1,"updated":"2019-02-14T01:54:02.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0k006r5b8hn4regyl1","content":"<h1 id=\"u盘启动\"><a class=\"markdownIt-Anchor\" href=\"#u盘启动\"></a> U盘启动</h1>\n<p>U盘启动：目的是为了在没有装系统的情况下进行临时启动，它可以启动DOS、备份还原软件或内存中运行的PE系统。现在大部分的电脑都支持U盘启动。U盘启动在系统奔溃和快速安装系统时能起到很大的作用。</p>\n<h1 id=\"mac系统安装启动盘制作\"><a class=\"markdownIt-Anchor\" href=\"#mac系统安装启动盘制作\"></a> mac系统安装启动盘制作</h1>\n<ol>\n<li>准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料</li>\n<li>下载好需要安装的系统。在App Store中搜索系统，如：MacOS Sierra，完成下载。</li>\n<li>打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致)</li>\n<li>打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\\ macOS\\ Sierra.app --nointeraction</span><br></pre></td></tr></table></figure>\n<p>回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了：<br>\n<img src=\"/pub-images/macOS%E5%88%B6%E4%BD%9CU%E7%9B%98%E5%90%AF%E5%8A%A8.png\" alt=\"image\"></p>\n<p>如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了</p>\n<h1 id=\"mac系统u盘安装\"><a class=\"markdownIt-Anchor\" href=\"#mac系统u盘安装\"></a> mac系统U盘安装</h1>\n<ol start=\"0\">\n<li>（此步骤可选：如果想格式化磁盘则进行此操作）启动时按住[command + r]，进入磁盘管理工具抹掉磁盘即可</li>\n<li>先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住[option」(alt)] 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。</li>\n<li>选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装</li>\n<li>启动过程中电脑会重启，重启的时候，拔掉U盘</li>\n</ol>\n<h1 id=\"安装软件\"><a class=\"markdownIt-Anchor\" href=\"#安装软件\"></a> 安装软件</h1>\n<ul>\n<li>在登陆App Store之后，往常安装过的软件在&quot;已购项目&quot;列表中有，不用每次安装系统后再一一去查找安装过的程序。</li>\n</ul>\n<p>非App Store安装的程序，在安装时，又是会提示app出现某些安装包已损坏、显示未激活、打开崩溃等的提示！！这种多是因为新系统屏蔽了任何来源的设置，所以需要大家打开“允许任何来源”方可安装，可按如下方式操作</p>\n<ul>\n<li>步骤1：Spotlight搜索(快捷键：command+空格或右上角搜索的符号)：搜索 “终端”</li>\n<li>步骤2：直接复制粘贴 sudo spctl --master-disable   回车</li>\n<li>步骤3：输入你的 开机密码</li>\n<li>步骤4：回到系统偏好设置 的“安全与隐私”，勾选 “允许任何来源”完成安装.</li>\n</ul>\n<h1 id=\"macos一些其他维护相关知识\"><a class=\"markdownIt-Anchor\" href=\"#macos一些其他维护相关知识\"></a> macOS一些其他维护相关知识</h1>\n<p>官方技术支持网址：<a href=\"https://support.apple.com/zh-cn\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn</a></p>\n<ol>\n<li>\n<p>关于 Mac 启动时您看到的屏幕：在从 OS X 启动 Mac 时，系统会显示不同的屏幕，以让您了解 Mac 的启动方式，或是启动可能未完成的原因。<br>\n<a href=\"https://support.apple.com/zh-cn/HT204156\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204156</a></p>\n</li>\n<li>\n<p>启动 Mac 时显示闪烁的问号<br>\n如果启动时在 Mac 屏幕上看到闪烁的问号，这意味着您的 Mac 无法找到自身的系统软件。<br>\n<a href=\"https://support.apple.com/zh-cn/HT204323\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204323</a></p>\n</li>\n<li>\n<p>如何重新安装 macOS<br>\n<a href=\"https://support.apple.com/zh-cn/HT204904\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204904</a></p>\n</li>\n<li>\n<p>关于 macOS 恢复功能<br>\n<a href=\"https://support.apple.com/zh-cn/HT201314\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201314</a></p>\n</li>\n<li>\n<p>使用 Time Machine 备份或恢复 Mac<br>\n<a href=\"https://support.apple.com/zh-cn/HT201250\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201250</a></p>\n</li>\n<li>\n<p>如何重置 Mac 上的 NVRAM        Command-Option-P-R<br>\n<a href=\"https://support.apple.com/zh-cn/HT204063\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204063</a></p>\n</li>\n<li>\n<p>重置 Mac 上的系统管理控制器 (SMC)       Shift-Control-Option<br>\n<a href=\"https://support.apple.com/zh-cn/HT201295\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201295</a></p>\n</li>\n<li>\n<p>如何识别 MacBook Pro 机型<br>\n<a href=\"https://support.apple.com/zh-cn/HT201300\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201300</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"u盘启动\"><a class=\"markdownIt-Anchor\" href=\"#u盘启动\"></a> U盘启动</h1>\n<p>U盘启动：目的是为了在没有装系统的情况下进行临时启动，它可以启动DOS、备份还原软件或内存中运行的PE系统。现在大部分的电脑都支持U盘启动。U盘启动在系统奔溃和快速安装系统时能起到很大的作用。</p>\n<h1 id=\"mac系统安装启动盘制作\"><a class=\"markdownIt-Anchor\" href=\"#mac系统安装启动盘制作\"></a> mac系统安装启动盘制作</h1>\n<ol>\n<li>准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料</li>\n<li>下载好需要安装的系统。在App Store中搜索系统，如：MacOS Sierra，完成下载。</li>\n<li>打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致)</li>\n<li>打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\\ macOS\\ Sierra.app --nointeraction</span><br></pre></td></tr></table></figure>\n<p>回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了：<br>\n<img src=\"/pub-images/macOS%E5%88%B6%E4%BD%9CU%E7%9B%98%E5%90%AF%E5%8A%A8.png\" alt=\"image\"></p>\n<p>如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了</p>\n<h1 id=\"mac系统u盘安装\"><a class=\"markdownIt-Anchor\" href=\"#mac系统u盘安装\"></a> mac系统U盘安装</h1>\n<ol start=\"0\">\n<li>（此步骤可选：如果想格式化磁盘则进行此操作）启动时按住[command + r]，进入磁盘管理工具抹掉磁盘即可</li>\n<li>先在目标电脑上插上 U 盘，然后重启你的 Mac，然后一直按住[option」(alt)] 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。</li>\n<li>选择 U 盘的图标回车，即可通过 U 盘来安装 macOS Sierra 了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装</li>\n<li>启动过程中电脑会重启，重启的时候，拔掉U盘</li>\n</ol>\n<h1 id=\"安装软件\"><a class=\"markdownIt-Anchor\" href=\"#安装软件\"></a> 安装软件</h1>\n<ul>\n<li>在登陆App Store之后，往常安装过的软件在&quot;已购项目&quot;列表中有，不用每次安装系统后再一一去查找安装过的程序。</li>\n</ul>\n<p>非App Store安装的程序，在安装时，又是会提示app出现某些安装包已损坏、显示未激活、打开崩溃等的提示！！这种多是因为新系统屏蔽了任何来源的设置，所以需要大家打开“允许任何来源”方可安装，可按如下方式操作</p>\n<ul>\n<li>步骤1：Spotlight搜索(快捷键：command+空格或右上角搜索的符号)：搜索 “终端”</li>\n<li>步骤2：直接复制粘贴 sudo spctl --master-disable   回车</li>\n<li>步骤3：输入你的 开机密码</li>\n<li>步骤4：回到系统偏好设置 的“安全与隐私”，勾选 “允许任何来源”完成安装.</li>\n</ul>\n<h1 id=\"macos一些其他维护相关知识\"><a class=\"markdownIt-Anchor\" href=\"#macos一些其他维护相关知识\"></a> macOS一些其他维护相关知识</h1>\n<p>官方技术支持网址：<a href=\"https://support.apple.com/zh-cn\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn</a></p>\n<ol>\n<li>\n<p>关于 Mac 启动时您看到的屏幕：在从 OS X 启动 Mac 时，系统会显示不同的屏幕，以让您了解 Mac 的启动方式，或是启动可能未完成的原因。<br>\n<a href=\"https://support.apple.com/zh-cn/HT204156\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204156</a></p>\n</li>\n<li>\n<p>启动 Mac 时显示闪烁的问号<br>\n如果启动时在 Mac 屏幕上看到闪烁的问号，这意味着您的 Mac 无法找到自身的系统软件。<br>\n<a href=\"https://support.apple.com/zh-cn/HT204323\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204323</a></p>\n</li>\n<li>\n<p>如何重新安装 macOS<br>\n<a href=\"https://support.apple.com/zh-cn/HT204904\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204904</a></p>\n</li>\n<li>\n<p>关于 macOS 恢复功能<br>\n<a href=\"https://support.apple.com/zh-cn/HT201314\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201314</a></p>\n</li>\n<li>\n<p>使用 Time Machine 备份或恢复 Mac<br>\n<a href=\"https://support.apple.com/zh-cn/HT201250\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201250</a></p>\n</li>\n<li>\n<p>如何重置 Mac 上的 NVRAM        Command-Option-P-R<br>\n<a href=\"https://support.apple.com/zh-cn/HT204063\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT204063</a></p>\n</li>\n<li>\n<p>重置 Mac 上的系统管理控制器 (SMC)       Shift-Control-Option<br>\n<a href=\"https://support.apple.com/zh-cn/HT201295\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201295</a></p>\n</li>\n<li>\n<p>如何识别 MacBook Pro 机型<br>\n<a href=\"https://support.apple.com/zh-cn/HT201300\" target=\"_blank\" rel=\"noopener\">https://support.apple.com/zh-cn/HT201300</a></p>\n</li>\n</ol>\n"},{"title":"mac虚拟机安装及设置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 简介\nParallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。\n\n# 安装\nPD为收费软件，链接: https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ 提取码: es9m，有经济能力的希望支持正版\n\nPD安装操作系统需准备一个系统ISO镜像,虚拟机系统安装过程和普通系统安装过程基本一致。\nwindows10镜像下载： https://www.microsoft.com/zh-cn/software-download/windows10ISO/\n\n系统安装完成之后，需安装Parallels Tools，否则使用时鼠标使用等方面会有很多不便，注意安装Parallels Tools时注意PD版本，防止有和系统不兼容。\n如下图：\n![image](/pub-images/Parallels%20Tools.png)\n\n# PD使用注意事项\n1. 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统内存、硬盘相关参数设置\n2. 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统共享文件夹设置，方便系统间数据共享\n3. 虚拟机初试安装后，再进行系统其他重要软件安装前，请先保存快照，再进行操作，操作不成功还可回退\n4. 虚拟机系统更新、相关开发环境设置完成之后，建议移动硬盘保存虚拟机，方便后期恢复和循环使用\n5. 虚拟机系统文件在右键【显示包内容】后，如下\n![image](/pub-images/虚拟机文件结构.png)\n其中.hdd文件为硬盘文件，可在虚拟机系统故障时优先保存此文件，或者将此文件复制替换到备份的虚拟机系统即可恢复\n\n\n\n\n\n\n ","source":"_posts/环境搭建/03_mac虚拟机安装系统及设置.md","raw":"---\ntitle: mac虚拟机安装及设置\ntags:\n  - 工具\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\n\n# 简介\nParallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。\n\n# 安装\nPD为收费软件，链接: https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ 提取码: es9m，有经济能力的希望支持正版\n\nPD安装操作系统需准备一个系统ISO镜像,虚拟机系统安装过程和普通系统安装过程基本一致。\nwindows10镜像下载： https://www.microsoft.com/zh-cn/software-download/windows10ISO/\n\n系统安装完成之后，需安装Parallels Tools，否则使用时鼠标使用等方面会有很多不便，注意安装Parallels Tools时注意PD版本，防止有和系统不兼容。\n如下图：\n![image](/pub-images/Parallels%20Tools.png)\n\n# PD使用注意事项\n1. 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统内存、硬盘相关参数设置\n2. 虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统共享文件夹设置，方便系统间数据共享\n3. 虚拟机初试安装后，再进行系统其他重要软件安装前，请先保存快照，再进行操作，操作不成功还可回退\n4. 虚拟机系统更新、相关开发环境设置完成之后，建议移动硬盘保存虚拟机，方便后期恢复和循环使用\n5. 虚拟机系统文件在右键【显示包内容】后，如下\n![image](/pub-images/虚拟机文件结构.png)\n其中.hdd文件为硬盘文件，可在虚拟机系统故障时优先保存此文件，或者将此文件复制替换到备份的虚拟机系统即可恢复\n\n\n\n\n\n\n ","slug":"环境搭建-03-mac虚拟机安装系统及设置","published":1,"updated":"2019-02-14T02:23:25.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0n006u5b8hrknhmxu3","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>PD为收费软件，链接: <a href=\"https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ</a> 提取码: es9m，有经济能力的希望支持正版</p>\n<p>PD安装操作系统需准备一个系统ISO镜像,虚拟机系统安装过程和普通系统安装过程基本一致。<br>\nwindows10镜像下载： <a href=\"https://www.microsoft.com/zh-cn/software-download/windows10ISO/\" target=\"_blank\" rel=\"noopener\">https://www.microsoft.com/zh-cn/software-download/windows10ISO/</a></p>\n<p>系统安装完成之后，需安装Parallels Tools，否则使用时鼠标使用等方面会有很多不便，注意安装Parallels Tools时注意PD版本，防止有和系统不兼容。<br>\n如下图：<br>\n<img src=\"/pub-images/Parallels%20Tools.png\" alt=\"image\"></p>\n<h1 id=\"pd使用注意事项\"><a class=\"markdownIt-Anchor\" href=\"#pd使用注意事项\"></a> PD使用注意事项</h1>\n<ol>\n<li>虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统内存、硬盘相关参数设置</li>\n<li>虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统共享文件夹设置，方便系统间数据共享</li>\n<li>虚拟机初试安装后，再进行系统其他重要软件安装前，请先保存快照，再进行操作，操作不成功还可回退</li>\n<li>虚拟机系统更新、相关开发环境设置完成之后，建议移动硬盘保存虚拟机，方便后期恢复和循环使用</li>\n<li>虚拟机系统文件在右键【显示包内容】后，如下<br>\n<img src=\"/pub-images/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png\" alt=\"image\"><br>\n其中.hdd文件为硬盘文件，可在虚拟机系统故障时优先保存此文件，或者将此文件复制替换到备份的虚拟机系统即可恢复</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>PD为收费软件，链接: <a href=\"https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1CBa7tIghlF7JIiJTtuqdYQ</a> 提取码: es9m，有经济能力的希望支持正版</p>\n<p>PD安装操作系统需准备一个系统ISO镜像,虚拟机系统安装过程和普通系统安装过程基本一致。<br>\nwindows10镜像下载： <a href=\"https://www.microsoft.com/zh-cn/software-download/windows10ISO/\" target=\"_blank\" rel=\"noopener\">https://www.microsoft.com/zh-cn/software-download/windows10ISO/</a></p>\n<p>系统安装完成之后，需安装Parallels Tools，否则使用时鼠标使用等方面会有很多不便，注意安装Parallels Tools时注意PD版本，防止有和系统不兼容。<br>\n如下图：<br>\n<img src=\"/pub-images/Parallels%20Tools.png\" alt=\"image\"></p>\n<h1 id=\"pd使用注意事项\"><a class=\"markdownIt-Anchor\" href=\"#pd使用注意事项\"></a> PD使用注意事项</h1>\n<ol>\n<li>虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统内存、硬盘相关参数设置</li>\n<li>虚拟机系统安装完之后在虚拟机系统的【配置】中进行系统共享文件夹设置，方便系统间数据共享</li>\n<li>虚拟机初试安装后，再进行系统其他重要软件安装前，请先保存快照，再进行操作，操作不成功还可回退</li>\n<li>虚拟机系统更新、相关开发环境设置完成之后，建议移动硬盘保存虚拟机，方便后期恢复和循环使用</li>\n<li>虚拟机系统文件在右键【显示包内容】后，如下<br>\n<img src=\"/pub-images/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png\" alt=\"image\"><br>\n其中.hdd文件为硬盘文件，可在虚拟机系统故障时优先保存此文件，或者将此文件复制替换到备份的虚拟机系统即可恢复</li>\n</ol>\n"},{"title":"git安装配置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 简介\n官网：https://git-scm.com/\nGit是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n\n详细学习，推荐：\n* http://www.runoob.com/git/git-tutorial.html\n* 廖雪峰大神的git教程\nhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n* git的前世今生： https://blog.csdn.net/csdnprogram/article/details/52155078\n\n# 工作原理\n## 本地\n* 工作区（Working Directory）：就是你在电脑里能看到的目录\n* 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n![image](/pub-images/git.png)\n我们把文件往Git版本库里添加的时候，是分两步执行的：\n* 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n* 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n## 远程配合\n![image](/pub-images/git2.png)\n\n# git安装\n参考教程：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git\n\n各平台都支持安装包安装方式\n\n## mac系统\n~~~\n> brew install git\n> git --version //验证安装\n~~~\n\n# git全局设置\nconfig 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local,底层配置会覆盖顶层配置 \n查看git不同级别配置信息\n~~~\ngit config --system --list\ngit config --global --list\ngit config --和local --list\n~~~\n\ngit安装完成后，还需要最后一步设置，在命令行输入：\n\n~~~\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n~~~\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门\n\n# git账号关联流程\n1. 生成SSHkey\nssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥.\nssh-keygen(选项)\n~~~\n-b：指定密钥长度； \n-e：读取openssh的私钥或者公钥文件； \n-C：添加注释； \n-f：指定用来保存密钥的文件名； \n-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； \n-l：显示公钥文件的指纹数据； \n-N：提供一个新密语； \n-P：提供（旧）密语；\n-q：静默模式； \n-t：指定要创建的密钥类型。\n~~~\n2. 登陆git服务器，添加public key信息\n3. 测试登陆\n~~~\n测试是否成功,第一此输入命令，需输入yes后再次输入测试命令后出现类似\"Hi...\"，表示配置成功\n> ssh -T git@github.com\n> ssh -T git@gitee.com\n> ssh -T git@gitlab.com\n~~~\n\n# git单账号关联\n~~~\n> ssh-keygen -t rsa -C xxxxx@gmail.com（注册github时的email）\n> cat ~/.ssh/id_rsa.pub\n~~~\n登陆网站，如github／gitee／gitlab等，在如设置／Settings中有SSH and GPG keys中【add new keys】，将id_rsa.pub内容添加，会自动识别标题,设置完成之后测试登陆\n\n\n# git多账号设置关联\n多账号配置是通过.ssh文件夹下config文件实现，操作如下：\n~~~\n> touch ~/.ssh/config \n> chmod 600 ~/.ssh/config \n\n> ssh-keygen -f ~/.ssh/id_rsa.github -t rsa -C \"chetaofeng@163.com\"\n> ssh-keygen -f ~/.ssh/id_rsa.gitee -t rsa -C \"chetaofeng@163.com\"\n> ssh-keygen -f ~/.ssh/id_rsa.gitlab -t rsa -C \"chetaofeng@163.com\"\n~~~\n\nconfig文件内容如下：\n~~~\n# github\nHost github.com\n    HostName github.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/id_rsa.github\n\n# gitee\nHost gitee.com\n     HostName gitee.com\n     PreferredAuthentications publickey\n     IdentityFile ~/.ssh/id_rsa.gitee\n\n# gitlab\nHost gitlab.com\n     HostName gitlab.com\n     PreferredAuthentications publickey\n     IdentityFile ~/.ssh/id_rsa.gitlab\n~~~\n* Host： 是我们在输入命令的时候的名字 比如我这里是lab  那么我使用ssh命令的时候需要使用 ssh lab \n* HostName： 是目标主机的主机名，也就是平时我们使用ssh后面跟的地址名称。\n* Port：指定的端口号。\n* User：指定的登陆用户名。\n* IdentifyFile：指定的私钥地址。\n \n# .gitignore文件\n不添加到版本库的内容记录，创建项目后一定要添加.gitignore文件\n\n# 开发环境中配置\n在Jetbrains系列开发工具中，【Version Control】界面中github选项默认有，进行设置即可\n![image](/pub-images/github设置.png)\ngitlab／gitee没有配置选项，需先安装相应插件，如下：\n![image](/pub-images/插件安装.png)\n\n以前配置gitlab的时候，是通过Other Settings->GitLab Settings设置如下：\n* GitLab Server Url: https://gitlab.com/\n* GitLab API Key： https://gitlab.com/profile/account\n\n\n# git项目权限管理\nGit项目一般有五种身份权限，分别是：\n* Owner 项目所有者，拥有所有的操作权限\n* Master 项目的管理者，除更改、删除项目元信息外其它操作均可\n* Developer 项目的开发人员，做一些开发工作，对受保护内容无权限\n* Reporter 项目的报告者，只有项目的读权限，可以创建代码片断\n* Guest 项目的游客，只能提交问题和评论内容\n\n# 私服项目使用推荐流程\n> 以下为项目owner需进行工作\n1. 在私服先创建项目，添加人员并设置人员权限\n2. 在本地webstorm中clone项目\n3. 在clone项目中添加.gitignore文件\n4. 添加.gitignore及相关需要版本控制的文件夹到版本控制（选中项后右键操作）\n5. 提交项目并备注为初始提交\n\n> 以下为项目成员需做工作\n1. 在本地webstorm中clone项目\n2. 创建项目分支（可一人一个，也可通过项目模块进行分支创建），如果直接在master分支，则无法成功push项目提示被rejected\n3. 进行代码编写\n4. 提交需管理分支\n5. 在gitlab私服网页发起合并请求，并添加详细描述\n6. 等待相关人员进行合并\n7. 合并结束后更新master分支\n8. 创建分支继续工作","source":"_posts/环境搭建/04_git安装配置.md","raw":"---\ntitle: git安装配置\ntags:\n  - git\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\n\n# 简介\n官网：https://git-scm.com/\nGit是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n\n详细学习，推荐：\n* http://www.runoob.com/git/git-tutorial.html\n* 廖雪峰大神的git教程\nhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n* git的前世今生： https://blog.csdn.net/csdnprogram/article/details/52155078\n\n# 工作原理\n## 本地\n* 工作区（Working Directory）：就是你在电脑里能看到的目录\n* 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n![image](/pub-images/git.png)\n我们把文件往Git版本库里添加的时候，是分两步执行的：\n* 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n* 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n## 远程配合\n![image](/pub-images/git2.png)\n\n# git安装\n参考教程：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git\n\n各平台都支持安装包安装方式\n\n## mac系统\n~~~\n> brew install git\n> git --version //验证安装\n~~~\n\n# git全局设置\nconfig 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local,底层配置会覆盖顶层配置 \n查看git不同级别配置信息\n~~~\ngit config --system --list\ngit config --global --list\ngit config --和local --list\n~~~\n\ngit安装完成后，还需要最后一步设置，在命令行输入：\n\n~~~\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n~~~\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门\n\n# git账号关联流程\n1. 生成SSHkey\nssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥.\nssh-keygen(选项)\n~~~\n-b：指定密钥长度； \n-e：读取openssh的私钥或者公钥文件； \n-C：添加注释； \n-f：指定用来保存密钥的文件名； \n-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； \n-l：显示公钥文件的指纹数据； \n-N：提供一个新密语； \n-P：提供（旧）密语；\n-q：静默模式； \n-t：指定要创建的密钥类型。\n~~~\n2. 登陆git服务器，添加public key信息\n3. 测试登陆\n~~~\n测试是否成功,第一此输入命令，需输入yes后再次输入测试命令后出现类似\"Hi...\"，表示配置成功\n> ssh -T git@github.com\n> ssh -T git@gitee.com\n> ssh -T git@gitlab.com\n~~~\n\n# git单账号关联\n~~~\n> ssh-keygen -t rsa -C xxxxx@gmail.com（注册github时的email）\n> cat ~/.ssh/id_rsa.pub\n~~~\n登陆网站，如github／gitee／gitlab等，在如设置／Settings中有SSH and GPG keys中【add new keys】，将id_rsa.pub内容添加，会自动识别标题,设置完成之后测试登陆\n\n\n# git多账号设置关联\n多账号配置是通过.ssh文件夹下config文件实现，操作如下：\n~~~\n> touch ~/.ssh/config \n> chmod 600 ~/.ssh/config \n\n> ssh-keygen -f ~/.ssh/id_rsa.github -t rsa -C \"chetaofeng@163.com\"\n> ssh-keygen -f ~/.ssh/id_rsa.gitee -t rsa -C \"chetaofeng@163.com\"\n> ssh-keygen -f ~/.ssh/id_rsa.gitlab -t rsa -C \"chetaofeng@163.com\"\n~~~\n\nconfig文件内容如下：\n~~~\n# github\nHost github.com\n    HostName github.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/id_rsa.github\n\n# gitee\nHost gitee.com\n     HostName gitee.com\n     PreferredAuthentications publickey\n     IdentityFile ~/.ssh/id_rsa.gitee\n\n# gitlab\nHost gitlab.com\n     HostName gitlab.com\n     PreferredAuthentications publickey\n     IdentityFile ~/.ssh/id_rsa.gitlab\n~~~\n* Host： 是我们在输入命令的时候的名字 比如我这里是lab  那么我使用ssh命令的时候需要使用 ssh lab \n* HostName： 是目标主机的主机名，也就是平时我们使用ssh后面跟的地址名称。\n* Port：指定的端口号。\n* User：指定的登陆用户名。\n* IdentifyFile：指定的私钥地址。\n \n# .gitignore文件\n不添加到版本库的内容记录，创建项目后一定要添加.gitignore文件\n\n# 开发环境中配置\n在Jetbrains系列开发工具中，【Version Control】界面中github选项默认有，进行设置即可\n![image](/pub-images/github设置.png)\ngitlab／gitee没有配置选项，需先安装相应插件，如下：\n![image](/pub-images/插件安装.png)\n\n以前配置gitlab的时候，是通过Other Settings->GitLab Settings设置如下：\n* GitLab Server Url: https://gitlab.com/\n* GitLab API Key： https://gitlab.com/profile/account\n\n\n# git项目权限管理\nGit项目一般有五种身份权限，分别是：\n* Owner 项目所有者，拥有所有的操作权限\n* Master 项目的管理者，除更改、删除项目元信息外其它操作均可\n* Developer 项目的开发人员，做一些开发工作，对受保护内容无权限\n* Reporter 项目的报告者，只有项目的读权限，可以创建代码片断\n* Guest 项目的游客，只能提交问题和评论内容\n\n# 私服项目使用推荐流程\n> 以下为项目owner需进行工作\n1. 在私服先创建项目，添加人员并设置人员权限\n2. 在本地webstorm中clone项目\n3. 在clone项目中添加.gitignore文件\n4. 添加.gitignore及相关需要版本控制的文件夹到版本控制（选中项后右键操作）\n5. 提交项目并备注为初始提交\n\n> 以下为项目成员需做工作\n1. 在本地webstorm中clone项目\n2. 创建项目分支（可一人一个，也可通过项目模块进行分支创建），如果直接在master分支，则无法成功push项目提示被rejected\n3. 进行代码编写\n4. 提交需管理分支\n5. 在gitlab私服网页发起合并请求，并添加详细描述\n6. 等待相关人员进行合并\n7. 合并结束后更新master分支\n8. 创建分支继续工作","slug":"环境搭建-04-git安装配置","published":1,"updated":"2019-02-14T02:07:34.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0o006y5b8hbpr91ld1","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>官网：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a><br>\nGit是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>\n<p>详细学习，推荐：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/git/git-tutorial.html</a></li>\n<li>廖雪峰大神的git教程<br>\n<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li>\n<li>git的前世今生： <a href=\"https://blog.csdn.net/csdnprogram/article/details/52155078\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/csdnprogram/article/details/52155078</a></li>\n</ul>\n<h1 id=\"工作原理\"><a class=\"markdownIt-Anchor\" href=\"#工作原理\"></a> 工作原理</h1>\n<h2 id=\"本地\"><a class=\"markdownIt-Anchor\" href=\"#本地\"></a> 本地</h2>\n<ul>\n<li>工作区（Working Directory）：就是你在电脑里能看到的目录</li>\n<li>版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库<br>\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>\n</ul>\n<p><img src=\"/pub-images/git.png\" alt=\"image\"><br>\n我们把文件往Git版本库里添加的时候，是分两步执行的：</p>\n<ul>\n<li>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</li>\n<li>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>\n</ul>\n<h2 id=\"远程配合\"><a class=\"markdownIt-Anchor\" href=\"#远程配合\"></a> 远程配合</h2>\n<p><img src=\"/pub-images/git2.png\" alt=\"image\"></p>\n<h1 id=\"git安装\"><a class=\"markdownIt-Anchor\" href=\"#git安装\"></a> git安装</h1>\n<p>参考教程：<a href=\"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/book/zh/v2/起步-安装-Git</a></p>\n<p>各平台都支持安装包安装方式</p>\n<h2 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; brew install git</span><br><span class=\"line\">&gt; git --version //验证安装</span><br></pre></td></tr></table></figure>\n<h1 id=\"git全局设置\"><a class=\"markdownIt-Anchor\" href=\"#git全局设置\"></a> git全局设置</h1>\n<p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local,底层配置会覆盖顶层配置<br>\n查看git不同级别配置信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --system --list</span><br><span class=\"line\">git config --global --list</span><br><span class=\"line\">git config --和local --list</span><br></pre></td></tr></table></figure>\n<p>git安装完成后，还需要最后一步设置，在命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门</p>\n<h1 id=\"git账号关联流程\"><a class=\"markdownIt-Anchor\" href=\"#git账号关联流程\"></a> git账号关联流程</h1>\n<ol>\n<li>生成SSHkey<br>\nssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥.<br>\nssh-keygen(选项)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b：指定密钥长度； </span><br><span class=\"line\">-e：读取openssh的私钥或者公钥文件； </span><br><span class=\"line\">-C：添加注释； </span><br><span class=\"line\">-f：指定用来保存密钥的文件名； </span><br><span class=\"line\">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； </span><br><span class=\"line\">-l：显示公钥文件的指纹数据； </span><br><span class=\"line\">-N：提供一个新密语； </span><br><span class=\"line\">-P：提供（旧）密语；</span><br><span class=\"line\">-q：静默模式； </span><br><span class=\"line\">-t：指定要创建的密钥类型。</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>登陆git服务器，添加public key信息</li>\n<li>测试登陆</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">测试是否成功,第一此输入命令，需输入yes后再次输入测试命令后出现类似&quot;Hi...&quot;，表示配置成功</span><br><span class=\"line\">&gt; ssh -T git@github.com</span><br><span class=\"line\">&gt; ssh -T git@gitee.com</span><br><span class=\"line\">&gt; ssh -T git@gitlab.com</span><br></pre></td></tr></table></figure>\n<h1 id=\"git单账号关联\"><a class=\"markdownIt-Anchor\" href=\"#git单账号关联\"></a> git单账号关联</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ssh-keygen -t rsa -C xxxxx@gmail.com（注册github时的email）</span><br><span class=\"line\">&gt; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>登陆网站，如github／gitee／gitlab等，在如设置／Settings中有SSH and GPG keys中【add new keys】，将id_rsa.pub内容添加，会自动识别标题,设置完成之后测试登陆</p>\n<h1 id=\"git多账号设置关联\"><a class=\"markdownIt-Anchor\" href=\"#git多账号设置关联\"></a> git多账号设置关联</h1>\n<p>多账号配置是通过.ssh文件夹下config文件实现，操作如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; touch ~/.ssh/config </span><br><span class=\"line\">&gt; chmod 600 ~/.ssh/config </span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ssh-keygen -f ~/.ssh/id_rsa.github -t rsa -C &quot;chetaofeng@163.com&quot;</span><br><span class=\"line\">&gt; ssh-keygen -f ~/.ssh/id_rsa.gitee -t rsa -C &quot;chetaofeng@163.com&quot;</span><br><span class=\"line\">&gt; ssh-keygen -f ~/.ssh/id_rsa.gitlab -t rsa -C &quot;chetaofeng@163.com&quot;</span><br></pre></td></tr></table></figure>\n<p>config文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># github</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">    HostName github.com</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_rsa.github</span><br><span class=\"line\"></span><br><span class=\"line\"># gitee</span><br><span class=\"line\">Host gitee.com</span><br><span class=\"line\">     HostName gitee.com</span><br><span class=\"line\">     PreferredAuthentications publickey</span><br><span class=\"line\">     IdentityFile ~/.ssh/id_rsa.gitee</span><br><span class=\"line\"></span><br><span class=\"line\"># gitlab</span><br><span class=\"line\">Host gitlab.com</span><br><span class=\"line\">     HostName gitlab.com</span><br><span class=\"line\">     PreferredAuthentications publickey</span><br><span class=\"line\">     IdentityFile ~/.ssh/id_rsa.gitlab</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Host： 是我们在输入命令的时候的名字 比如我这里是lab  那么我使用ssh命令的时候需要使用 ssh lab</li>\n<li>HostName： 是目标主机的主机名，也就是平时我们使用ssh后面跟的地址名称。</li>\n<li>Port：指定的端口号。</li>\n<li>User：指定的登陆用户名。</li>\n<li>IdentifyFile：指定的私钥地址。</li>\n</ul>\n<h1 id=\"gitignore文件\"><a class=\"markdownIt-Anchor\" href=\"#gitignore文件\"></a> .gitignore文件</h1>\n<p>不添加到版本库的内容记录，创建项目后一定要添加.gitignore文件</p>\n<h1 id=\"开发环境中配置\"><a class=\"markdownIt-Anchor\" href=\"#开发环境中配置\"></a> 开发环境中配置</h1>\n<p>在Jetbrains系列开发工具中，【Version Control】界面中github选项默认有，进行设置即可<br>\n<img src=\"/pub-images/github%E8%AE%BE%E7%BD%AE.png\" alt=\"image\"><br>\ngitlab／gitee没有配置选项，需先安装相应插件，如下：<br>\n<img src=\"/pub-images/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.png\" alt=\"image\"></p>\n<p>以前配置gitlab的时候，是通过Other Settings-&gt;GitLab Settings设置如下：</p>\n<ul>\n<li>GitLab Server Url: <a href=\"https://gitlab.com/\" target=\"_blank\" rel=\"noopener\">https://gitlab.com/</a></li>\n<li>GitLab API Key： <a href=\"https://gitlab.com/profile/account\" target=\"_blank\" rel=\"noopener\">https://gitlab.com/profile/account</a></li>\n</ul>\n<h1 id=\"git项目权限管理\"><a class=\"markdownIt-Anchor\" href=\"#git项目权限管理\"></a> git项目权限管理</h1>\n<p>Git项目一般有五种身份权限，分别是：</p>\n<ul>\n<li>Owner 项目所有者，拥有所有的操作权限</li>\n<li>Master 项目的管理者，除更改、删除项目元信息外其它操作均可</li>\n<li>Developer 项目的开发人员，做一些开发工作，对受保护内容无权限</li>\n<li>Reporter 项目的报告者，只有项目的读权限，可以创建代码片断</li>\n<li>Guest 项目的游客，只能提交问题和评论内容</li>\n</ul>\n<h1 id=\"私服项目使用推荐流程\"><a class=\"markdownIt-Anchor\" href=\"#私服项目使用推荐流程\"></a> 私服项目使用推荐流程</h1>\n<blockquote>\n<p>以下为项目owner需进行工作</p>\n</blockquote>\n<ol>\n<li>在私服先创建项目，添加人员并设置人员权限</li>\n<li>在本地webstorm中clone项目</li>\n<li>在clone项目中添加.gitignore文件</li>\n<li>添加.gitignore及相关需要版本控制的文件夹到版本控制（选中项后右键操作）</li>\n<li>提交项目并备注为初始提交</li>\n</ol>\n<blockquote>\n<p>以下为项目成员需做工作</p>\n</blockquote>\n<ol>\n<li>在本地webstorm中clone项目</li>\n<li>创建项目分支（可一人一个，也可通过项目模块进行分支创建），如果直接在master分支，则无法成功push项目提示被rejected</li>\n<li>进行代码编写</li>\n<li>提交需管理分支</li>\n<li>在gitlab私服网页发起合并请求，并添加详细描述</li>\n<li>等待相关人员进行合并</li>\n<li>合并结束后更新master分支</li>\n<li>创建分支继续工作</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>官网：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a><br>\nGit是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>\n<p>详细学习，推荐：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/git/git-tutorial.html</a></li>\n<li>廖雪峰大神的git教程<br>\n<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></li>\n<li>git的前世今生： <a href=\"https://blog.csdn.net/csdnprogram/article/details/52155078\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/csdnprogram/article/details/52155078</a></li>\n</ul>\n<h1 id=\"工作原理\"><a class=\"markdownIt-Anchor\" href=\"#工作原理\"></a> 工作原理</h1>\n<h2 id=\"本地\"><a class=\"markdownIt-Anchor\" href=\"#本地\"></a> 本地</h2>\n<ul>\n<li>工作区（Working Directory）：就是你在电脑里能看到的目录</li>\n<li>版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库<br>\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>\n</ul>\n<p><img src=\"/pub-images/git.png\" alt=\"image\"><br>\n我们把文件往Git版本库里添加的时候，是分两步执行的：</p>\n<ul>\n<li>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</li>\n<li>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>\n</ul>\n<h2 id=\"远程配合\"><a class=\"markdownIt-Anchor\" href=\"#远程配合\"></a> 远程配合</h2>\n<p><img src=\"/pub-images/git2.png\" alt=\"image\"></p>\n<h1 id=\"git安装\"><a class=\"markdownIt-Anchor\" href=\"#git安装\"></a> git安装</h1>\n<p>参考教程：<a href=\"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/book/zh/v2/起步-安装-Git</a></p>\n<p>各平台都支持安装包安装方式</p>\n<h2 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; brew install git</span><br><span class=\"line\">&gt; git --version //验证安装</span><br></pre></td></tr></table></figure>\n<h1 id=\"git全局设置\"><a class=\"markdownIt-Anchor\" href=\"#git全局设置\"></a> git全局设置</h1>\n<p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local,底层配置会覆盖顶层配置<br>\n查看git不同级别配置信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --system --list</span><br><span class=\"line\">git config --global --list</span><br><span class=\"line\">git config --和local --list</span><br></pre></td></tr></table></figure>\n<p>git安装完成后，还需要最后一步设置，在命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门</p>\n<h1 id=\"git账号关联流程\"><a class=\"markdownIt-Anchor\" href=\"#git账号关联流程\"></a> git账号关联流程</h1>\n<ol>\n<li>生成SSHkey<br>\nssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥.<br>\nssh-keygen(选项)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b：指定密钥长度； </span><br><span class=\"line\">-e：读取openssh的私钥或者公钥文件； </span><br><span class=\"line\">-C：添加注释； </span><br><span class=\"line\">-f：指定用来保存密钥的文件名； </span><br><span class=\"line\">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； </span><br><span class=\"line\">-l：显示公钥文件的指纹数据； </span><br><span class=\"line\">-N：提供一个新密语； </span><br><span class=\"line\">-P：提供（旧）密语；</span><br><span class=\"line\">-q：静默模式； </span><br><span class=\"line\">-t：指定要创建的密钥类型。</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>登陆git服务器，添加public key信息</li>\n<li>测试登陆</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">测试是否成功,第一此输入命令，需输入yes后再次输入测试命令后出现类似&quot;Hi...&quot;，表示配置成功</span><br><span class=\"line\">&gt; ssh -T git@github.com</span><br><span class=\"line\">&gt; ssh -T git@gitee.com</span><br><span class=\"line\">&gt; ssh -T git@gitlab.com</span><br></pre></td></tr></table></figure>\n<h1 id=\"git单账号关联\"><a class=\"markdownIt-Anchor\" href=\"#git单账号关联\"></a> git单账号关联</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ssh-keygen -t rsa -C xxxxx@gmail.com（注册github时的email）</span><br><span class=\"line\">&gt; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>登陆网站，如github／gitee／gitlab等，在如设置／Settings中有SSH and GPG keys中【add new keys】，将id_rsa.pub内容添加，会自动识别标题,设置完成之后测试登陆</p>\n<h1 id=\"git多账号设置关联\"><a class=\"markdownIt-Anchor\" href=\"#git多账号设置关联\"></a> git多账号设置关联</h1>\n<p>多账号配置是通过.ssh文件夹下config文件实现，操作如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; touch ~/.ssh/config </span><br><span class=\"line\">&gt; chmod 600 ~/.ssh/config </span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ssh-keygen -f ~/.ssh/id_rsa.github -t rsa -C &quot;chetaofeng@163.com&quot;</span><br><span class=\"line\">&gt; ssh-keygen -f ~/.ssh/id_rsa.gitee -t rsa -C &quot;chetaofeng@163.com&quot;</span><br><span class=\"line\">&gt; ssh-keygen -f ~/.ssh/id_rsa.gitlab -t rsa -C &quot;chetaofeng@163.com&quot;</span><br></pre></td></tr></table></figure>\n<p>config文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># github</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">    HostName github.com</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_rsa.github</span><br><span class=\"line\"></span><br><span class=\"line\"># gitee</span><br><span class=\"line\">Host gitee.com</span><br><span class=\"line\">     HostName gitee.com</span><br><span class=\"line\">     PreferredAuthentications publickey</span><br><span class=\"line\">     IdentityFile ~/.ssh/id_rsa.gitee</span><br><span class=\"line\"></span><br><span class=\"line\"># gitlab</span><br><span class=\"line\">Host gitlab.com</span><br><span class=\"line\">     HostName gitlab.com</span><br><span class=\"line\">     PreferredAuthentications publickey</span><br><span class=\"line\">     IdentityFile ~/.ssh/id_rsa.gitlab</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Host： 是我们在输入命令的时候的名字 比如我这里是lab  那么我使用ssh命令的时候需要使用 ssh lab</li>\n<li>HostName： 是目标主机的主机名，也就是平时我们使用ssh后面跟的地址名称。</li>\n<li>Port：指定的端口号。</li>\n<li>User：指定的登陆用户名。</li>\n<li>IdentifyFile：指定的私钥地址。</li>\n</ul>\n<h1 id=\"gitignore文件\"><a class=\"markdownIt-Anchor\" href=\"#gitignore文件\"></a> .gitignore文件</h1>\n<p>不添加到版本库的内容记录，创建项目后一定要添加.gitignore文件</p>\n<h1 id=\"开发环境中配置\"><a class=\"markdownIt-Anchor\" href=\"#开发环境中配置\"></a> 开发环境中配置</h1>\n<p>在Jetbrains系列开发工具中，【Version Control】界面中github选项默认有，进行设置即可<br>\n<img src=\"/pub-images/github%E8%AE%BE%E7%BD%AE.png\" alt=\"image\"><br>\ngitlab／gitee没有配置选项，需先安装相应插件，如下：<br>\n<img src=\"/pub-images/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.png\" alt=\"image\"></p>\n<p>以前配置gitlab的时候，是通过Other Settings-&gt;GitLab Settings设置如下：</p>\n<ul>\n<li>GitLab Server Url: <a href=\"https://gitlab.com/\" target=\"_blank\" rel=\"noopener\">https://gitlab.com/</a></li>\n<li>GitLab API Key： <a href=\"https://gitlab.com/profile/account\" target=\"_blank\" rel=\"noopener\">https://gitlab.com/profile/account</a></li>\n</ul>\n<h1 id=\"git项目权限管理\"><a class=\"markdownIt-Anchor\" href=\"#git项目权限管理\"></a> git项目权限管理</h1>\n<p>Git项目一般有五种身份权限，分别是：</p>\n<ul>\n<li>Owner 项目所有者，拥有所有的操作权限</li>\n<li>Master 项目的管理者，除更改、删除项目元信息外其它操作均可</li>\n<li>Developer 项目的开发人员，做一些开发工作，对受保护内容无权限</li>\n<li>Reporter 项目的报告者，只有项目的读权限，可以创建代码片断</li>\n<li>Guest 项目的游客，只能提交问题和评论内容</li>\n</ul>\n<h1 id=\"私服项目使用推荐流程\"><a class=\"markdownIt-Anchor\" href=\"#私服项目使用推荐流程\"></a> 私服项目使用推荐流程</h1>\n<blockquote>\n<p>以下为项目owner需进行工作</p>\n</blockquote>\n<ol>\n<li>在私服先创建项目，添加人员并设置人员权限</li>\n<li>在本地webstorm中clone项目</li>\n<li>在clone项目中添加.gitignore文件</li>\n<li>添加.gitignore及相关需要版本控制的文件夹到版本控制（选中项后右键操作）</li>\n<li>提交项目并备注为初始提交</li>\n</ol>\n<blockquote>\n<p>以下为项目成员需做工作</p>\n</blockquote>\n<ol>\n<li>在本地webstorm中clone项目</li>\n<li>创建项目分支（可一人一个，也可通过项目模块进行分支创建），如果直接在master分支，则无法成功push项目提示被rejected</li>\n<li>进行代码编写</li>\n<li>提交需管理分支</li>\n<li>在gitlab私服网页发起合并请求，并添加详细描述</li>\n<li>等待相关人员进行合并</li>\n<li>合并结束后更新master分支</li>\n<li>创建分支继续工作</li>\n</ol>\n"},{"title":"node安装配置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 相关概念\nnodejs：在项目开发时的所需要的代码库\nnvm：nodejs 版本管理工具。\nnpm：nodejs包管理工具，在安装的 nodejs 的时候，npm也会跟着一起安装，它是包管理工具，管理nodejs中的第三方插件\nyarn：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ， 是为了弥补 npm 的一些缺陷而出现的\n即：一个nvm可以管理多个node版本和npm版本\n\n# nvm安装\n官网： https://github.com/creationix/nvm\n安装：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash\n安装完成后的提示界面会有类似一下的提示信息：\n~~~\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n~~~\n在~/.bash_profile中添加以上内容(如果没有这个文件则创建)后保存；通过source ~/.bash_profile使设置生效。 \n安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功\n\n注：curl看系统是否已安装，如果没有安装则：sudo apt-get install curl\n\n# nvm常用命令\nnvm install stable ## 安装最新稳定版 node，当前是node v9.5.0 (npm v5.6.0)\nnvm install <version> ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4\nnvm uninstall <version> ## 删除已安装的指定版本，语法与install类似\nnvm use <version> ## 切换使用指定的版本node\nnvm ls ## 列出所有安装的版本\nnvm ls-remote ## 列出所有远程服务器的版本（官方node version list）\nnvm current ## 显示当前的版本\nnvm alias <name> <version> ## 给不同的版本号添加别名\nnvm unalias <name> ## 删除已定义的别名\nnvm reinstall-packages <version> ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包 \n\n# nvm安装node\nnvm install stable\n\n# yarn\n快速、可靠、安全的依赖管理工具\n## 安装\nbrew install yarn\nbrew install yarn --without-node\n\n# Yarn和npm命令对比\nnpm |\tyarn\n----|-------\nnpm install |\tyarn install\nnpm install react --save |\tyarn add react\nnpm uninstall react --save |\tyarn remove react\nnpm install react --save-dev |\tyarn add react --dev\nnpm update --save |\tyarn upgrade\n\n ","source":"_posts/环境搭建/05_node安装.md","raw":"---\ntitle: node安装配置\ntags:\n  - node\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\n\n# 相关概念\nnodejs：在项目开发时的所需要的代码库\nnvm：nodejs 版本管理工具。\nnpm：nodejs包管理工具，在安装的 nodejs 的时候，npm也会跟着一起安装，它是包管理工具，管理nodejs中的第三方插件\nyarn：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ， 是为了弥补 npm 的一些缺陷而出现的\n即：一个nvm可以管理多个node版本和npm版本\n\n# nvm安装\n官网： https://github.com/creationix/nvm\n安装：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash\n安装完成后的提示界面会有类似一下的提示信息：\n~~~\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n~~~\n在~/.bash_profile中添加以上内容(如果没有这个文件则创建)后保存；通过source ~/.bash_profile使设置生效。 \n安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功\n\n注：curl看系统是否已安装，如果没有安装则：sudo apt-get install curl\n\n# nvm常用命令\nnvm install stable ## 安装最新稳定版 node，当前是node v9.5.0 (npm v5.6.0)\nnvm install <version> ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4\nnvm uninstall <version> ## 删除已安装的指定版本，语法与install类似\nnvm use <version> ## 切换使用指定的版本node\nnvm ls ## 列出所有安装的版本\nnvm ls-remote ## 列出所有远程服务器的版本（官方node version list）\nnvm current ## 显示当前的版本\nnvm alias <name> <version> ## 给不同的版本号添加别名\nnvm unalias <name> ## 删除已定义的别名\nnvm reinstall-packages <version> ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包 \n\n# nvm安装node\nnvm install stable\n\n# yarn\n快速、可靠、安全的依赖管理工具\n## 安装\nbrew install yarn\nbrew install yarn --without-node\n\n# Yarn和npm命令对比\nnpm |\tyarn\n----|-------\nnpm install |\tyarn install\nnpm install react --save |\tyarn add react\nnpm uninstall react --save |\tyarn remove react\nnpm install react --save-dev |\tyarn add react --dev\nnpm update --save |\tyarn upgrade\n\n ","slug":"环境搭建-05-node安装","published":1,"updated":"2019-02-14T02:07:49.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0q00715b8hrnpsfuq4","content":"<h1 id=\"相关概念\"><a class=\"markdownIt-Anchor\" href=\"#相关概念\"></a> 相关概念</h1>\n<p>nodejs：在项目开发时的所需要的代码库<br>\nnvm：nodejs 版本管理工具。<br>\nnpm：nodejs包管理工具，在安装的 nodejs 的时候，npm也会跟着一起安装，它是包管理工具，管理nodejs中的第三方插件<br>\nyarn：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ， 是为了弥补 npm 的一些缺陷而出现的<br>\n即：一个nvm可以管理多个node版本和npm版本</p>\n<h1 id=\"nvm安装\"><a class=\"markdownIt-Anchor\" href=\"#nvm安装\"></a> nvm安装</h1>\n<p>官网： <a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"noopener\">https://github.com/creationix/nvm</a><br>\n安装：curl -o- <a href=\"https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh</a> | bash<br>\n安装完成后的提示界面会有类似一下的提示信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class=\"line\">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure>\n<p>在~/.bash_profile中添加以上内容(如果没有这个文件则创建)后保存；通过source ~/.bash_profile使设置生效。<br>\n安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功</p>\n<p>注：curl看系统是否已安装，如果没有安装则：sudo apt-get install curl</p>\n<h1 id=\"nvm常用命令\"><a class=\"markdownIt-Anchor\" href=\"#nvm常用命令\"></a> nvm常用命令</h1>\n<p>nvm install stable ## 安装最新稳定版 node，当前是node v9.5.0 (npm v5.6.0)<br>\nnvm install <version> ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4<br>\nnvm uninstall <version> ## 删除已安装的指定版本，语法与install类似<br>\nnvm use <version> ## 切换使用指定的版本node<br>\nnvm ls ## 列出所有安装的版本<br>\nnvm ls-remote ## 列出所有远程服务器的版本（官方node version list）<br>\nnvm current ## 显示当前的版本<br>\nnvm alias <name> <version> ## 给不同的版本号添加别名<br>\nnvm unalias <name> ## 删除已定义的别名<br>\nnvm reinstall-packages <version> ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</version></name></version></name></version></version></version></p>\n<h1 id=\"nvm安装node\"><a class=\"markdownIt-Anchor\" href=\"#nvm安装node\"></a> nvm安装node</h1>\n<p>nvm install stable</p>\n<h1 id=\"yarn\"><a class=\"markdownIt-Anchor\" href=\"#yarn\"></a> yarn</h1>\n<p>快速、可靠、安全的依赖管理工具</p>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h2>\n<p>brew install yarn<br>\nbrew install yarn --without-node</p>\n<h1 id=\"yarn和npm命令对比\"><a class=\"markdownIt-Anchor\" href=\"#yarn和npm命令对比\"></a> Yarn和npm命令对比</h1>\n<table>\n<thead>\n<tr>\n<th>npm</th>\n<th>yarn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install</td>\n<td>yarn install</td>\n</tr>\n<tr>\n<td>npm install react --save</td>\n<td>yarn add react</td>\n</tr>\n<tr>\n<td>npm uninstall react --save</td>\n<td>yarn remove react</td>\n</tr>\n<tr>\n<td>npm install react --save-dev</td>\n<td>yarn add react --dev</td>\n</tr>\n<tr>\n<td>npm update --save</td>\n<td>yarn upgrade</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"相关概念\"><a class=\"markdownIt-Anchor\" href=\"#相关概念\"></a> 相关概念</h1>\n<p>nodejs：在项目开发时的所需要的代码库<br>\nnvm：nodejs 版本管理工具。<br>\nnpm：nodejs包管理工具，在安装的 nodejs 的时候，npm也会跟着一起安装，它是包管理工具，管理nodejs中的第三方插件<br>\nyarn：Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ， 是为了弥补 npm 的一些缺陷而出现的<br>\n即：一个nvm可以管理多个node版本和npm版本</p>\n<h1 id=\"nvm安装\"><a class=\"markdownIt-Anchor\" href=\"#nvm安装\"></a> nvm安装</h1>\n<p>官网： <a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"noopener\">https://github.com/creationix/nvm</a><br>\n安装：curl -o- <a href=\"https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh</a> | bash<br>\n安装完成后的提示界面会有类似一下的提示信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class=\"line\">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure>\n<p>在~/.bash_profile中添加以上内容(如果没有这个文件则创建)后保存；通过source ~/.bash_profile使设置生效。<br>\n安装完成后关闭终端，重新打开终端输入 nvm 验证一下是否安装成功</p>\n<p>注：curl看系统是否已安装，如果没有安装则：sudo apt-get install curl</p>\n<h1 id=\"nvm常用命令\"><a class=\"markdownIt-Anchor\" href=\"#nvm常用命令\"></a> nvm常用命令</h1>\n<p>nvm install stable ## 安装最新稳定版 node，当前是node v9.5.0 (npm v5.6.0)<br>\nnvm install <version> ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4<br>\nnvm uninstall <version> ## 删除已安装的指定版本，语法与install类似<br>\nnvm use <version> ## 切换使用指定的版本node<br>\nnvm ls ## 列出所有安装的版本<br>\nnvm ls-remote ## 列出所有远程服务器的版本（官方node version list）<br>\nnvm current ## 显示当前的版本<br>\nnvm alias <name> <version> ## 给不同的版本号添加别名<br>\nnvm unalias <name> ## 删除已定义的别名<br>\nnvm reinstall-packages <version> ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</version></name></version></name></version></version></version></p>\n<h1 id=\"nvm安装node\"><a class=\"markdownIt-Anchor\" href=\"#nvm安装node\"></a> nvm安装node</h1>\n<p>nvm install stable</p>\n<h1 id=\"yarn\"><a class=\"markdownIt-Anchor\" href=\"#yarn\"></a> yarn</h1>\n<p>快速、可靠、安全的依赖管理工具</p>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h2>\n<p>brew install yarn<br>\nbrew install yarn --without-node</p>\n<h1 id=\"yarn和npm命令对比\"><a class=\"markdownIt-Anchor\" href=\"#yarn和npm命令对比\"></a> Yarn和npm命令对比</h1>\n<table>\n<thead>\n<tr>\n<th>npm</th>\n<th>yarn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install</td>\n<td>yarn install</td>\n</tr>\n<tr>\n<td>npm install react --save</td>\n<td>yarn add react</td>\n</tr>\n<tr>\n<td>npm uninstall react --save</td>\n<td>yarn remove react</td>\n</tr>\n<tr>\n<td>npm install react --save-dev</td>\n<td>yarn add react --dev</td>\n</tr>\n<tr>\n<td>npm update --save</td>\n<td>yarn upgrade</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"CentOS安装设置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"https://blog.csdn.net/ganeshys2017/article/details/81300246\n\nhttp://www.cnblogs.com/linnuo/p/6257204.html\n\nhttps://blog.csdn.net/lwwl12/article/details/78247307","source":"_posts/环境搭建/07_CentOS系统初始设置.md","raw":"---\ntitle: CentOS安装设置\ntags:\n  - CentOS\n  - Linux\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\nhttps://blog.csdn.net/ganeshys2017/article/details/81300246\n\nhttp://www.cnblogs.com/linnuo/p/6257204.html\n\nhttps://blog.csdn.net/lwwl12/article/details/78247307","slug":"环境搭建-07-CentOS系统初始设置","published":1,"updated":"2019-02-14T02:22:49.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0s00755b8htab69k9q","content":"<p><a href=\"https://blog.csdn.net/ganeshys2017/article/details/81300246\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ganeshys2017/article/details/81300246</a></p>\n<p><a href=\"http://www.cnblogs.com/linnuo/p/6257204.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/linnuo/p/6257204.html</a></p>\n<p><a href=\"https://blog.csdn.net/lwwl12/article/details/78247307\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lwwl12/article/details/78247307</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/ganeshys2017/article/details/81300246\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ganeshys2017/article/details/81300246</a></p>\n<p><a href=\"http://www.cnblogs.com/linnuo/p/6257204.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/linnuo/p/6257204.html</a></p>\n<p><a href=\"https://blog.csdn.net/lwwl12/article/details/78247307\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lwwl12/article/details/78247307</a></p>\n"},{"title":"JDK安装配置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"<!-- oracle官网账号：  chetaofeng@163.com / Chetaofeng123./ --> \n                                           \n# JDK下载\nhttp://www.oracle.com/technetwork/java/javase/downloads/index.html\nhttps://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n\n# 环境变量设置说明\n（jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置）\n* CLASS_PATH 保证class文件能够在任意目录下运行\n* PATH 保证javac可以在任意目录下运行\n \n# mac系统\n环境变量配置文件执行的顺序：\n/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc\n/etc/profile和/etc/paths是系统级别的，系统启动就会加载，剩下的是用户级别的。 \n\n下载dmg安装包后直接安装后，通过java -version；java；javac验证，个人发现最新版本中不用系统环境变量配置，重启电脑验证过，\n\n配置环境变量的方式：\n1. 找到JDK安装目录，如：\n~~~\n/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home\n~~~\n2. 编辑文件~/.bash_profile 文件\n~~~\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home\nPATH=$JAVA_HOME/bin:$PATH:.\n\nexport JAVA_HOME\nexport PATH\n~~~\n3. 使配置生效：source .bash_profile\n4. 输入 echo $JAVA_HOME 显示刚才配置的路径\n5. 验证安装\n \n\n# Linux系统\n安装前，请在终端中通过java命令查看是否系统已默认安装OpenJDK，如果有，则先卸载\n1. 下载安装包后解压，如：sudo tar -zxvf jdk-8u77-linux-x64.tar.gz,得到jdk1.8.0_77文件夹\n2. sudo mkdir /usr/java\n3. sudo cp -r jdk1.8.0_77/ /usr/java/\n4. 配置环境变量,sudo vim /etc/profile,在前面添加\n~~~\nexport JAVA_HOME=/usr/java/jdk1.8.0_77\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH\n~~~\n5. source /etc/profile 使配置立即生效\n6. 检查新安装的jdk:java -version;java;javac\n ","source":"_posts/环境搭建/06_Java安装.md","raw":"---\ntitle: JDK安装配置\ntags:\n  - Java\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword: \n---\n<!-- oracle官网账号：  chetaofeng@163.com / Chetaofeng123./ --> \n                                           \n# JDK下载\nhttp://www.oracle.com/technetwork/java/javase/downloads/index.html\nhttps://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n\n# 环境变量设置说明\n（jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置）\n* CLASS_PATH 保证class文件能够在任意目录下运行\n* PATH 保证javac可以在任意目录下运行\n \n# mac系统\n环境变量配置文件执行的顺序：\n/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc\n/etc/profile和/etc/paths是系统级别的，系统启动就会加载，剩下的是用户级别的。 \n\n下载dmg安装包后直接安装后，通过java -version；java；javac验证，个人发现最新版本中不用系统环境变量配置，重启电脑验证过，\n\n配置环境变量的方式：\n1. 找到JDK安装目录，如：\n~~~\n/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home\n~~~\n2. 编辑文件~/.bash_profile 文件\n~~~\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home\nPATH=$JAVA_HOME/bin:$PATH:.\n\nexport JAVA_HOME\nexport PATH\n~~~\n3. 使配置生效：source .bash_profile\n4. 输入 echo $JAVA_HOME 显示刚才配置的路径\n5. 验证安装\n \n\n# Linux系统\n安装前，请在终端中通过java命令查看是否系统已默认安装OpenJDK，如果有，则先卸载\n1. 下载安装包后解压，如：sudo tar -zxvf jdk-8u77-linux-x64.tar.gz,得到jdk1.8.0_77文件夹\n2. sudo mkdir /usr/java\n3. sudo cp -r jdk1.8.0_77/ /usr/java/\n4. 配置环境变量,sudo vim /etc/profile,在前面添加\n~~~\nexport JAVA_HOME=/usr/java/jdk1.8.0_77\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH\n~~~\n5. source /etc/profile 使配置立即生效\n6. 检查新安装的jdk:java -version;java;javac\n ","slug":"环境搭建-06-Java安装","published":1,"updated":"2019-02-14T02:22:04.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0t00775b8h4fjw0a7y","content":"<!-- oracle官网账号：  chetaofeng@163.com / Chetaofeng123./ --> \n<h1 id=\"jdk下载\"><a class=\"markdownIt-Anchor\" href=\"#jdk下载\"></a> JDK下载</h1>\n<p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>\n<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>\n<h1 id=\"环境变量设置说明\"><a class=\"markdownIt-Anchor\" href=\"#环境变量设置说明\"></a> 环境变量设置说明</h1>\n<p>（jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置）</p>\n<ul>\n<li>CLASS_PATH 保证class文件能够在任意目录下运行</li>\n<li>PATH 保证javac可以在任意目录下运行</li>\n</ul>\n<h1 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h1>\n<p>环境变量配置文件执行的顺序：<br>\n/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc<br>\n/etc/profile和/etc/paths是系统级别的，系统启动就会加载，剩下的是用户级别的。</p>\n<p>下载dmg安装包后直接安装后，通过java -version；java；javac验证，个人发现最新版本中不用系统环境变量配置，重启电脑验证过，</p>\n<p>配置环境变量的方式：</p>\n<ol>\n<li>找到JDK安装目录，如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>编辑文件~/.bash_profile 文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home</span><br><span class=\"line\">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class=\"line\"></span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">export PATH</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使配置生效：source .bash_profile</li>\n<li>输入 echo $JAVA_HOME 显示刚才配置的路径</li>\n<li>验证安装</li>\n</ol>\n<h1 id=\"linux系统\"><a class=\"markdownIt-Anchor\" href=\"#linux系统\"></a> Linux系统</h1>\n<p>安装前，请在终端中通过java命令查看是否系统已默认安装OpenJDK，如果有，则先卸载</p>\n<ol>\n<li>下载安装包后解压，如：sudo tar -zxvf jdk-8u77-linux-x64.tar.gz,得到jdk1.8.0_77文件夹</li>\n<li>sudo mkdir /usr/java</li>\n<li>sudo cp -r jdk1.8.0_77/ /usr/java/</li>\n<li>配置环境变量,sudo vim /etc/profile,在前面添加</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/java/jdk1.8.0_77</span><br><span class=\"line\">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class=\"line\">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>source /etc/profile 使配置立即生效</li>\n<li>检查新安装的jdk:java -version;java;javac</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<!-- oracle官网账号：  chetaofeng@163.com / Chetaofeng123./ --> \n<h1 id=\"jdk下载\"><a class=\"markdownIt-Anchor\" href=\"#jdk下载\"></a> JDK下载</h1>\n<p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>\n<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>\n<h1 id=\"环境变量设置说明\"><a class=\"markdownIt-Anchor\" href=\"#环境变量设置说明\"></a> 环境变量设置说明</h1>\n<p>（jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置）</p>\n<ul>\n<li>CLASS_PATH 保证class文件能够在任意目录下运行</li>\n<li>PATH 保证javac可以在任意目录下运行</li>\n</ul>\n<h1 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h1>\n<p>环境变量配置文件执行的顺序：<br>\n/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc<br>\n/etc/profile和/etc/paths是系统级别的，系统启动就会加载，剩下的是用户级别的。</p>\n<p>下载dmg安装包后直接安装后，通过java -version；java；javac验证，个人发现最新版本中不用系统环境变量配置，重启电脑验证过，</p>\n<p>配置环境变量的方式：</p>\n<ol>\n<li>找到JDK安装目录，如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>编辑文件~/.bash_profile 文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home</span><br><span class=\"line\">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class=\"line\"></span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">export PATH</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使配置生效：source .bash_profile</li>\n<li>输入 echo $JAVA_HOME 显示刚才配置的路径</li>\n<li>验证安装</li>\n</ol>\n<h1 id=\"linux系统\"><a class=\"markdownIt-Anchor\" href=\"#linux系统\"></a> Linux系统</h1>\n<p>安装前，请在终端中通过java命令查看是否系统已默认安装OpenJDK，如果有，则先卸载</p>\n<ol>\n<li>下载安装包后解压，如：sudo tar -zxvf jdk-8u77-linux-x64.tar.gz,得到jdk1.8.0_77文件夹</li>\n<li>sudo mkdir /usr/java</li>\n<li>sudo cp -r jdk1.8.0_77/ /usr/java/</li>\n<li>配置环境变量,sudo vim /etc/profile,在前面添加</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/java/jdk1.8.0_77</span><br><span class=\"line\">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class=\"line\">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>source /etc/profile 使配置立即生效</li>\n<li>检查新安装的jdk:java -version;java;javac</li>\n</ol>\n"},{"title":"Ubuntu系统安装后的设置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"# 修改默认源为国内源\n1. cd /etc/apt\n2. cp /etc/apt/sources.list /etc/apt/sources.list.bak   备份/etc/apt/sources.list\n3. 在/etc/apt/sources.list文件前面添加源条目,具体源条目可百度，如阿里源：\n~~~\n#添加阿里源\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n~~~\n4. 更新源\n~~~\nsudo apt-get update\nsudo apt-get upgrade\n~~~\n\n# 系统分辨率设置\n安装Ubuntu系统后分辨率为800*600且无法修改，通过以下方式修改：\n1. 首先打开终端Terminal，输入: sudo apt-get install xdiagnose \n2. sudo xdiagnose 启动【X 诊断工具设置】，点击【Apply】\n3. sudo reboot 重启系统\n4. 再次打开设置发现分辨率可以设置了,如设置为：1280*800\n\n# chrome浏览器安装\n* wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n* sudo dpkg -i google-chrome-stable_current_amd64.deb \n\n\n","source":"_posts/环境搭建/08_Ubuntu系统安装后的设置.md","raw":"---\ntitle: Ubuntu系统安装后的设置\ntags:\n  - ubuntu\n  - Linux\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\n# 修改默认源为国内源\n1. cd /etc/apt\n2. cp /etc/apt/sources.list /etc/apt/sources.list.bak   备份/etc/apt/sources.list\n3. 在/etc/apt/sources.list文件前面添加源条目,具体源条目可百度，如阿里源：\n~~~\n#添加阿里源\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n~~~\n4. 更新源\n~~~\nsudo apt-get update\nsudo apt-get upgrade\n~~~\n\n# 系统分辨率设置\n安装Ubuntu系统后分辨率为800*600且无法修改，通过以下方式修改：\n1. 首先打开终端Terminal，输入: sudo apt-get install xdiagnose \n2. sudo xdiagnose 启动【X 诊断工具设置】，点击【Apply】\n3. sudo reboot 重启系统\n4. 再次打开设置发现分辨率可以设置了,如设置为：1280*800\n\n# chrome浏览器安装\n* wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n* sudo dpkg -i google-chrome-stable_current_amd64.deb \n\n\n","slug":"环境搭建-08-Ubuntu系统安装后的设置","published":1,"updated":"2019-02-14T02:08:30.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0v007b5b8hws4galig","content":"<h1 id=\"修改默认源为国内源\"><a class=\"markdownIt-Anchor\" href=\"#修改默认源为国内源\"></a> 修改默认源为国内源</h1>\n<ol>\n<li>cd /etc/apt</li>\n<li>cp /etc/apt/sources.list /etc/apt/sources.list.bak   备份/etc/apt/sources.list</li>\n<li>在/etc/apt/sources.list文件前面添加源条目,具体源条目可百度，如阿里源：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#添加阿里源</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>更新源</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n<h1 id=\"系统分辨率设置\"><a class=\"markdownIt-Anchor\" href=\"#系统分辨率设置\"></a> 系统分辨率设置</h1>\n<p>安装Ubuntu系统后分辨率为800*600且无法修改，通过以下方式修改：</p>\n<ol>\n<li>首先打开终端Terminal，输入: sudo apt-get install xdiagnose</li>\n<li>sudo xdiagnose 启动【X 诊断工具设置】，点击【Apply】</li>\n<li>sudo reboot 重启系统</li>\n<li>再次打开设置发现分辨率可以设置了,如设置为：1280*800</li>\n</ol>\n<h1 id=\"chrome浏览器安装\"><a class=\"markdownIt-Anchor\" href=\"#chrome浏览器安装\"></a> chrome浏览器安装</h1>\n<ul>\n<li>wget <a href=\"https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\" target=\"_blank\" rel=\"noopener\">https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</a></li>\n<li>sudo dpkg -i google-chrome-stable_current_amd64.deb</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"修改默认源为国内源\"><a class=\"markdownIt-Anchor\" href=\"#修改默认源为国内源\"></a> 修改默认源为国内源</h1>\n<ol>\n<li>cd /etc/apt</li>\n<li>cp /etc/apt/sources.list /etc/apt/sources.list.bak   备份/etc/apt/sources.list</li>\n<li>在/etc/apt/sources.list文件前面添加源条目,具体源条目可百度，如阿里源：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#添加阿里源</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>更新源</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n<h1 id=\"系统分辨率设置\"><a class=\"markdownIt-Anchor\" href=\"#系统分辨率设置\"></a> 系统分辨率设置</h1>\n<p>安装Ubuntu系统后分辨率为800*600且无法修改，通过以下方式修改：</p>\n<ol>\n<li>首先打开终端Terminal，输入: sudo apt-get install xdiagnose</li>\n<li>sudo xdiagnose 启动【X 诊断工具设置】，点击【Apply】</li>\n<li>sudo reboot 重启系统</li>\n<li>再次打开设置发现分辨率可以设置了,如设置为：1280*800</li>\n</ol>\n<h1 id=\"chrome浏览器安装\"><a class=\"markdownIt-Anchor\" href=\"#chrome浏览器安装\"></a> chrome浏览器安装</h1>\n<ul>\n<li>wget <a href=\"https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\" target=\"_blank\" rel=\"noopener\">https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</a></li>\n<li>sudo dpkg -i google-chrome-stable_current_amd64.deb</li>\n</ul>\n"},{"title":"JetBrains系列软件安装配置","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 软件破解\n软件破解请参考： http://idea.lanyus.com/\n1. 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中\n2. 在网页获取注册码，在注册页面填入注册码即可\n\n# Android Studio安装\n以下为相关软件下载，2／3中软件为采用第三方模拟器的时候需要下载，利用自带模拟器则可跳过下载\n1. 下载Android Studio安装软件： https://developer.android.google.cn/studio/#downloads\n2. 下载virtualbox： https://www.virtualbox.org/wiki/Linux_Downloads\n3. 下载Genymotion： https://www.genymotion.com/download\n\n安装前请确保网络状态良好，现在安装Android Studio，所需Android SDK、自带模拟器镜像、gradle等都可以在线直接通过开发工具下载安装\n\n## mac系统\n直接安装dmg安装包即可\n\n## Linux系统\n1. 进入安装包所在目录下，如：android-studio-ide-181.5056338-linux.zip\n2. sudo mkdir /usr/JetBrains\n3. sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains\n4. cd /usr/JetBrains\n5. sudo unzip  android-studio-ide-181.5056338-linux.zip\n6. cd android-studio/bin  \n7. 命令行启动AndroidStuido： ./studio.sh，正常的话应该会出现软件的配置设置\n8. 软件启动，因为没有Android SDK，会弹出提示界面，点击cancle之后会自动下载Android SDK，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可\n\n设置启动图标启动Android Studio\n1. sudo vim /usr/share/applications/android-studio.desktop \n2. 编辑文件内容：\n~~~\n[Desktop Entry]\nType=Application\nName=Android Studio\nComment=Android Studio Integrated Development Environment\nIcon=/usr/JetBrains/android-studio/bin/studio.png\nExec=/usr/JetBrains/android-studio/bin/studio.sh  \n~~~\n3. 在启动器别表即可找到Android Studio启动图标，点击启动即可\n\n# 模拟器\nAndroid程序调试可通过真机、自带模拟器、第三方模拟器调试\n\n第三方模拟器大多使用Genymotion，官网下载：https://www.genymotion.com/download/\nandroid Studio安装Genymotion插件使用\n\n\n## 安装过程遇到的问题\n1. linux中启动模拟器出现grant current user access to /dev/kvm错误\n解决方法：打开terminal,输入代码who／whoami查找当前用户名；sudo chown username -R /dev/kvm 注意username是你用的用户名\n\n2. 无法修改模拟器创建时的选项 emulated performance\n解决方法： Nexus 5X和Nexus 5镜像不支持，换成其他镜像即可\n\nhttps://blog.csdn.net/wshish920907/article/details/78249528\n\n# InteliJ IDEA安装\n下载地址：http://www.jetbrains.com/idea/?fromMenu\n## Linux系统\n1. 进入安装包所在目录下，如：ideaIU-2016.1.2.tar.gz\n2. sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains，如果没有JetBrains则自己创建\n4. cd /usr/JetBrains\n5. sudo tar -zxvf ideaIU-2016.1.2.tar.gz\n6. sudo mv idea-IU-145.971.21 idea\n7. cd idea/bin\n8. 命令行启动Idea： ./idea.sh，正常的话应该会出现软件的配置设置\n9. 软件启动，创建任意Java程序，配置JDK路径，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可\n\n设置启动图标启动Idea\n1. sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标\n2. 编辑文件内容：\n~~~\n[Desktop Entry]\nType=Application\nName=InteliJ IDEA\nComment=InteliJ IDEA Integrated Development Environment\nIcon=/usr/JetBrains/idea/bin/idea.png\nExec=/usr/JetBrains/idea/bin/idea.sh  \n~~~\n3. 在启动器别表即可找到InteliJ IDEA启动图标，点击启动即可\n\n# WebStorm安装\n下载地址：http://www.jetbrains.com/webstorm/download/#section=linux\n\nwebstorm安装请参考AndroidStudio和IDEA\n\n设置启动图标启动Idea\n1. sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标\n2. 编辑文件内容：\n~~~\n[Desktop Entry]\nType=Application\nName=WebStorm\nComment=WebStorm Integrated Development Environment\nIcon=/usr/JetBrains/WebStorm/bin/webstorm.png\nExec=/usr/JetBrains/WebStorm/bin/webstorm.sh  \n~~~","source":"_posts/环境搭建/09_JetBrains系列软件安装使用.md","raw":"---\ntitle: JetBrains系列软件安装配置\ntags:\n  - Java\n  - 工具\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: 环境搭建\npassword:\n---\n\n# 软件破解\n软件破解请参考： http://idea.lanyus.com/\n1. 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中\n2. 在网页获取注册码，在注册页面填入注册码即可\n\n# Android Studio安装\n以下为相关软件下载，2／3中软件为采用第三方模拟器的时候需要下载，利用自带模拟器则可跳过下载\n1. 下载Android Studio安装软件： https://developer.android.google.cn/studio/#downloads\n2. 下载virtualbox： https://www.virtualbox.org/wiki/Linux_Downloads\n3. 下载Genymotion： https://www.genymotion.com/download\n\n安装前请确保网络状态良好，现在安装Android Studio，所需Android SDK、自带模拟器镜像、gradle等都可以在线直接通过开发工具下载安装\n\n## mac系统\n直接安装dmg安装包即可\n\n## Linux系统\n1. 进入安装包所在目录下，如：android-studio-ide-181.5056338-linux.zip\n2. sudo mkdir /usr/JetBrains\n3. sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains\n4. cd /usr/JetBrains\n5. sudo unzip  android-studio-ide-181.5056338-linux.zip\n6. cd android-studio/bin  \n7. 命令行启动AndroidStuido： ./studio.sh，正常的话应该会出现软件的配置设置\n8. 软件启动，因为没有Android SDK，会弹出提示界面，点击cancle之后会自动下载Android SDK，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可\n\n设置启动图标启动Android Studio\n1. sudo vim /usr/share/applications/android-studio.desktop \n2. 编辑文件内容：\n~~~\n[Desktop Entry]\nType=Application\nName=Android Studio\nComment=Android Studio Integrated Development Environment\nIcon=/usr/JetBrains/android-studio/bin/studio.png\nExec=/usr/JetBrains/android-studio/bin/studio.sh  \n~~~\n3. 在启动器别表即可找到Android Studio启动图标，点击启动即可\n\n# 模拟器\nAndroid程序调试可通过真机、自带模拟器、第三方模拟器调试\n\n第三方模拟器大多使用Genymotion，官网下载：https://www.genymotion.com/download/\nandroid Studio安装Genymotion插件使用\n\n\n## 安装过程遇到的问题\n1. linux中启动模拟器出现grant current user access to /dev/kvm错误\n解决方法：打开terminal,输入代码who／whoami查找当前用户名；sudo chown username -R /dev/kvm 注意username是你用的用户名\n\n2. 无法修改模拟器创建时的选项 emulated performance\n解决方法： Nexus 5X和Nexus 5镜像不支持，换成其他镜像即可\n\nhttps://blog.csdn.net/wshish920907/article/details/78249528\n\n# InteliJ IDEA安装\n下载地址：http://www.jetbrains.com/idea/?fromMenu\n## Linux系统\n1. 进入安装包所在目录下，如：ideaIU-2016.1.2.tar.gz\n2. sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains，如果没有JetBrains则自己创建\n4. cd /usr/JetBrains\n5. sudo tar -zxvf ideaIU-2016.1.2.tar.gz\n6. sudo mv idea-IU-145.971.21 idea\n7. cd idea/bin\n8. 命令行启动Idea： ./idea.sh，正常的话应该会出现软件的配置设置\n9. 软件启动，创建任意Java程序，配置JDK路径，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可\n\n设置启动图标启动Idea\n1. sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标\n2. 编辑文件内容：\n~~~\n[Desktop Entry]\nType=Application\nName=InteliJ IDEA\nComment=InteliJ IDEA Integrated Development Environment\nIcon=/usr/JetBrains/idea/bin/idea.png\nExec=/usr/JetBrains/idea/bin/idea.sh  \n~~~\n3. 在启动器别表即可找到InteliJ IDEA启动图标，点击启动即可\n\n# WebStorm安装\n下载地址：http://www.jetbrains.com/webstorm/download/#section=linux\n\nwebstorm安装请参考AndroidStudio和IDEA\n\n设置启动图标启动Idea\n1. sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标\n2. 编辑文件内容：\n~~~\n[Desktop Entry]\nType=Application\nName=WebStorm\nComment=WebStorm Integrated Development Environment\nIcon=/usr/JetBrains/WebStorm/bin/webstorm.png\nExec=/usr/JetBrains/WebStorm/bin/webstorm.sh  \n~~~","slug":"环境搭建-09-JetBrains系列软件安装使用","published":1,"updated":"2019-02-14T02:08:50.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0x007e5b8hrqr6bbn4","content":"<h1 id=\"软件破解\"><a class=\"markdownIt-Anchor\" href=\"#软件破解\"></a> 软件破解</h1>\n<p>软件破解请参考： <a href=\"http://idea.lanyus.com/\" target=\"_blank\" rel=\"noopener\">http://idea.lanyus.com/</a></p>\n<ol>\n<li>使用前请将“0.0.0.0 <a href=\"http://account.jetbrains.com\" target=\"_blank\" rel=\"noopener\">account.jetbrains.com</a>”添加到hosts文件中</li>\n<li>在网页获取注册码，在注册页面填入注册码即可</li>\n</ol>\n<h1 id=\"android-studio安装\"><a class=\"markdownIt-Anchor\" href=\"#android-studio安装\"></a> Android Studio安装</h1>\n<p>以下为相关软件下载，2／3中软件为采用第三方模拟器的时候需要下载，利用自带模拟器则可跳过下载</p>\n<ol>\n<li>下载Android Studio安装软件： <a href=\"https://developer.android.google.cn/studio/#downloads\" target=\"_blank\" rel=\"noopener\">https://developer.android.google.cn/studio/#downloads</a></li>\n<li>下载virtualbox： <a href=\"https://www.virtualbox.org/wiki/Linux_Downloads\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/wiki/Linux_Downloads</a></li>\n<li>下载Genymotion： <a href=\"https://www.genymotion.com/download\" target=\"_blank\" rel=\"noopener\">https://www.genymotion.com/download</a></li>\n</ol>\n<p>安装前请确保网络状态良好，现在安装Android Studio，所需Android SDK、自带模拟器镜像、gradle等都可以在线直接通过开发工具下载安装</p>\n<h2 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h2>\n<p>直接安装dmg安装包即可</p>\n<h2 id=\"linux系统\"><a class=\"markdownIt-Anchor\" href=\"#linux系统\"></a> Linux系统</h2>\n<ol>\n<li>进入安装包所在目录下，如：android-studio-ide-181.5056338-linux.zip</li>\n<li>sudo mkdir /usr/JetBrains</li>\n<li>sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains</li>\n<li>cd /usr/JetBrains</li>\n<li>sudo unzip  android-studio-ide-181.5056338-linux.zip</li>\n<li>cd android-studio/bin</li>\n<li>命令行启动AndroidStuido： ./studio.sh，正常的话应该会出现软件的配置设置</li>\n<li>软件启动，因为没有Android SDK，会弹出提示界面，点击cancle之后会自动下载Android SDK，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可</li>\n</ol>\n<p>设置启动图标启动Android Studio</p>\n<ol>\n<li>sudo vim /usr/share/applications/android-studio.desktop</li>\n<li>编辑文件内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=Android Studio</span><br><span class=\"line\">Comment=Android Studio Integrated Development Environment</span><br><span class=\"line\">Icon=/usr/JetBrains/android-studio/bin/studio.png</span><br><span class=\"line\">Exec=/usr/JetBrains/android-studio/bin/studio.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在启动器别表即可找到Android Studio启动图标，点击启动即可</li>\n</ol>\n<h1 id=\"模拟器\"><a class=\"markdownIt-Anchor\" href=\"#模拟器\"></a> 模拟器</h1>\n<p>Android程序调试可通过真机、自带模拟器、第三方模拟器调试</p>\n<p>第三方模拟器大多使用Genymotion，官网下载：<a href=\"https://www.genymotion.com/download/\" target=\"_blank\" rel=\"noopener\">https://www.genymotion.com/download/</a><br>\nandroid Studio安装Genymotion插件使用</p>\n<h2 id=\"安装过程遇到的问题\"><a class=\"markdownIt-Anchor\" href=\"#安装过程遇到的问题\"></a> 安装过程遇到的问题</h2>\n<ol>\n<li>\n<p>linux中启动模拟器出现grant current user access to /dev/kvm错误<br>\n解决方法：打开terminal,输入代码who／whoami查找当前用户名；sudo chown username -R /dev/kvm 注意username是你用的用户名</p>\n</li>\n<li>\n<p>无法修改模拟器创建时的选项 emulated performance<br>\n解决方法： Nexus 5X和Nexus 5镜像不支持，换成其他镜像即可</p>\n</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/wshish920907/article/details/78249528\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wshish920907/article/details/78249528</a></p>\n<h1 id=\"intelij-idea安装\"><a class=\"markdownIt-Anchor\" href=\"#intelij-idea安装\"></a> InteliJ IDEA安装</h1>\n<p>下载地址：<a href=\"http://www.jetbrains.com/idea/?fromMenu\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/idea/?fromMenu</a></p>\n<h2 id=\"linux系统-2\"><a class=\"markdownIt-Anchor\" href=\"#linux系统-2\"></a> Linux系统</h2>\n<ol>\n<li>进入安装包所在目录下，如：ideaIU-2016.1.2.tar.gz</li>\n<li>sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains，如果没有JetBrains则自己创建</li>\n<li>cd /usr/JetBrains</li>\n<li>sudo tar -zxvf ideaIU-2016.1.2.tar.gz</li>\n<li>sudo mv idea-IU-145.971.21 idea</li>\n<li>cd idea/bin</li>\n<li>命令行启动Idea： ./idea.sh，正常的话应该会出现软件的配置设置</li>\n<li>软件启动，创建任意Java程序，配置JDK路径，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可</li>\n</ol>\n<p>设置启动图标启动Idea</p>\n<ol>\n<li>sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标</li>\n<li>编辑文件内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=InteliJ IDEA</span><br><span class=\"line\">Comment=InteliJ IDEA Integrated Development Environment</span><br><span class=\"line\">Icon=/usr/JetBrains/idea/bin/idea.png</span><br><span class=\"line\">Exec=/usr/JetBrains/idea/bin/idea.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在启动器别表即可找到InteliJ IDEA启动图标，点击启动即可</li>\n</ol>\n<h1 id=\"webstorm安装\"><a class=\"markdownIt-Anchor\" href=\"#webstorm安装\"></a> WebStorm安装</h1>\n<p>下载地址：<a href=\"http://www.jetbrains.com/webstorm/download/#section=linux\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/webstorm/download/#section=linux</a></p>\n<p>webstorm安装请参考AndroidStudio和IDEA</p>\n<p>设置启动图标启动Idea</p>\n<ol>\n<li>sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标</li>\n<li>编辑文件内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=WebStorm</span><br><span class=\"line\">Comment=WebStorm Integrated Development Environment</span><br><span class=\"line\">Icon=/usr/JetBrains/WebStorm/bin/webstorm.png</span><br><span class=\"line\">Exec=/usr/JetBrains/WebStorm/bin/webstorm.sh</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件破解\"><a class=\"markdownIt-Anchor\" href=\"#软件破解\"></a> 软件破解</h1>\n<p>软件破解请参考： <a href=\"http://idea.lanyus.com/\" target=\"_blank\" rel=\"noopener\">http://idea.lanyus.com/</a></p>\n<ol>\n<li>使用前请将“0.0.0.0 <a href=\"http://account.jetbrains.com\" target=\"_blank\" rel=\"noopener\">account.jetbrains.com</a>”添加到hosts文件中</li>\n<li>在网页获取注册码，在注册页面填入注册码即可</li>\n</ol>\n<h1 id=\"android-studio安装\"><a class=\"markdownIt-Anchor\" href=\"#android-studio安装\"></a> Android Studio安装</h1>\n<p>以下为相关软件下载，2／3中软件为采用第三方模拟器的时候需要下载，利用自带模拟器则可跳过下载</p>\n<ol>\n<li>下载Android Studio安装软件： <a href=\"https://developer.android.google.cn/studio/#downloads\" target=\"_blank\" rel=\"noopener\">https://developer.android.google.cn/studio/#downloads</a></li>\n<li>下载virtualbox： <a href=\"https://www.virtualbox.org/wiki/Linux_Downloads\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/wiki/Linux_Downloads</a></li>\n<li>下载Genymotion： <a href=\"https://www.genymotion.com/download\" target=\"_blank\" rel=\"noopener\">https://www.genymotion.com/download</a></li>\n</ol>\n<p>安装前请确保网络状态良好，现在安装Android Studio，所需Android SDK、自带模拟器镜像、gradle等都可以在线直接通过开发工具下载安装</p>\n<h2 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h2>\n<p>直接安装dmg安装包即可</p>\n<h2 id=\"linux系统\"><a class=\"markdownIt-Anchor\" href=\"#linux系统\"></a> Linux系统</h2>\n<ol>\n<li>进入安装包所在目录下，如：android-studio-ide-181.5056338-linux.zip</li>\n<li>sudo mkdir /usr/JetBrains</li>\n<li>sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains</li>\n<li>cd /usr/JetBrains</li>\n<li>sudo unzip  android-studio-ide-181.5056338-linux.zip</li>\n<li>cd android-studio/bin</li>\n<li>命令行启动AndroidStuido： ./studio.sh，正常的话应该会出现软件的配置设置</li>\n<li>软件启动，因为没有Android SDK，会弹出提示界面，点击cancle之后会自动下载Android SDK，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可</li>\n</ol>\n<p>设置启动图标启动Android Studio</p>\n<ol>\n<li>sudo vim /usr/share/applications/android-studio.desktop</li>\n<li>编辑文件内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=Android Studio</span><br><span class=\"line\">Comment=Android Studio Integrated Development Environment</span><br><span class=\"line\">Icon=/usr/JetBrains/android-studio/bin/studio.png</span><br><span class=\"line\">Exec=/usr/JetBrains/android-studio/bin/studio.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在启动器别表即可找到Android Studio启动图标，点击启动即可</li>\n</ol>\n<h1 id=\"模拟器\"><a class=\"markdownIt-Anchor\" href=\"#模拟器\"></a> 模拟器</h1>\n<p>Android程序调试可通过真机、自带模拟器、第三方模拟器调试</p>\n<p>第三方模拟器大多使用Genymotion，官网下载：<a href=\"https://www.genymotion.com/download/\" target=\"_blank\" rel=\"noopener\">https://www.genymotion.com/download/</a><br>\nandroid Studio安装Genymotion插件使用</p>\n<h2 id=\"安装过程遇到的问题\"><a class=\"markdownIt-Anchor\" href=\"#安装过程遇到的问题\"></a> 安装过程遇到的问题</h2>\n<ol>\n<li>\n<p>linux中启动模拟器出现grant current user access to /dev/kvm错误<br>\n解决方法：打开terminal,输入代码who／whoami查找当前用户名；sudo chown username -R /dev/kvm 注意username是你用的用户名</p>\n</li>\n<li>\n<p>无法修改模拟器创建时的选项 emulated performance<br>\n解决方法： Nexus 5X和Nexus 5镜像不支持，换成其他镜像即可</p>\n</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/wshish920907/article/details/78249528\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wshish920907/article/details/78249528</a></p>\n<h1 id=\"intelij-idea安装\"><a class=\"markdownIt-Anchor\" href=\"#intelij-idea安装\"></a> InteliJ IDEA安装</h1>\n<p>下载地址：<a href=\"http://www.jetbrains.com/idea/?fromMenu\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/idea/?fromMenu</a></p>\n<h2 id=\"linux系统-2\"><a class=\"markdownIt-Anchor\" href=\"#linux系统-2\"></a> Linux系统</h2>\n<ol>\n<li>进入安装包所在目录下，如：ideaIU-2016.1.2.tar.gz</li>\n<li>sudo cp android-studio-ide-181.5056338-linux.zip /usr/JetBrains，如果没有JetBrains则自己创建</li>\n<li>cd /usr/JetBrains</li>\n<li>sudo tar -zxvf ideaIU-2016.1.2.tar.gz</li>\n<li>sudo mv idea-IU-145.971.21 idea</li>\n<li>cd idea/bin</li>\n<li>命令行启动Idea： ./idea.sh，正常的话应该会出现软件的配置设置</li>\n<li>软件启动，创建任意Java程序，配置JDK路径，然后创建测试项目，过程中运行所需资源都会自动下载，耐心等待即可</li>\n</ol>\n<p>设置启动图标启动Idea</p>\n<ol>\n<li>sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标</li>\n<li>编辑文件内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=InteliJ IDEA</span><br><span class=\"line\">Comment=InteliJ IDEA Integrated Development Environment</span><br><span class=\"line\">Icon=/usr/JetBrains/idea/bin/idea.png</span><br><span class=\"line\">Exec=/usr/JetBrains/idea/bin/idea.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在启动器别表即可找到InteliJ IDEA启动图标，点击启动即可</li>\n</ol>\n<h1 id=\"webstorm安装\"><a class=\"markdownIt-Anchor\" href=\"#webstorm安装\"></a> WebStorm安装</h1>\n<p>下载地址：<a href=\"http://www.jetbrains.com/webstorm/download/#section=linux\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/webstorm/download/#section=linux</a></p>\n<p>webstorm安装请参考AndroidStudio和IDEA</p>\n<p>设置启动图标启动Idea</p>\n<ol>\n<li>sudo vim /usr/share/applications/idea.desktop，当然软件启动后也会提示是否创建快捷访问链接，可通过IDEA创建启动图标</li>\n<li>编辑文件内容：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=WebStorm</span><br><span class=\"line\">Comment=WebStorm Integrated Development Environment</span><br><span class=\"line\">Icon=/usr/JetBrains/WebStorm/bin/webstorm.png</span><br><span class=\"line\">Exec=/usr/JetBrains/WebStorm/bin/webstorm.sh</span><br></pre></td></tr></table></figure>"},{"title":"VirtualBox安装","copyright":true,"comments":1,"toc":true,"date":"2018-10-04T14:10:23.000Z","password":null,"_content":"\n\n \nhttps://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html","source":"_posts/环境搭建/11_VirturalBox安装.md","raw":"---\ntitle: VirtualBox安装\ntags:\n  - 容器技术 \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-04 22:10:23\ncategories: 环境搭建\npassword:\n---\n\n\n \nhttps://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html","slug":"环境搭建-11-VirturalBox安装","published":1,"updated":"2019-02-14T02:10:04.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0y007i5b8hf6apm5x2","content":"<p><a href=\"https://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/36d6ed1f821ca21bcf4883da.html</a></p>\n"},{"title":"hexo使用速记","copyright":true,"comments":1,"toc":true,"date":"2018-10-04T14:10:23.000Z","password":null,"_content":"\n# 说明\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。详细学习请参考：https://hexo.io/zh-cn/docs 。\n本文章只是个人使用过程中重点内容记录。\n\n# 安装\n前置安装：node，git\n安装：npm install -g hexo-cli\n\n# 初始化项目\n1. mkdir [项目名称, 如：test]\n2. hexo init [项目名称, 如：test] //此处要求文件夹内为空\n3. cd [项目名称, 如：test]\n4. npm install\n\n# 常用命令\n* hexo new [layout] '【文章名称】'    //创建不通类型文章\n~~~\nlaytou及路径如下：\npost\tsource/_posts\npage\tsource\ndraft\tsource/_drafts\n~~~\n* hexo clean    //清除hexo生成静态网站内容\n* hexo g        //生成hexo静态网站\n* hexo s        //启用hexo服务\n* hexo d        //hexo网站部署，配合hexo-deployer-git插件使用\n* hexo version  //hexo相关软件版本\n* hexo list [type] //type:post,page等\n\n# Front-matter和JSON Front-matter\n用来设定文章的一些参数，如是否添加密码、版权、标签、分类等信息。\n* Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，基于YAML\n~~~\ntitle: Hello World\ndate: 2013/7/13 20:46:25\n---\n~~~\n* JSON Front-matter 使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可\n~~~\n\"title\": \"Hello World\",\n\"date\": \"2013/7/13 20:46:25\"\n;;;\n~~~\n可配置参数如下：\n\n参数|描述|默认值\n--|--|--\nlayout\t| 布局\t\ntitle\t|标题\t\ndate\t|建立日期\t|文件建立日期\nupdated\t|更新日期\t|文件更新日期\ncomments\t|开启文章的评论功能|\ttrue\ntags\t|标签（不适用于分页）\t\ncategories\t|分类（不适用于分页）\t\npermalink\t|覆盖文章网址\t \n\n可以通过直接修改scaffolds内的模版来设定统一的文章额外信息，如：\n~~~\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\n  - \n  - \ncategories: \npassword: \ncopyright: true\ncomments: true\ntoc: true\n---\n~~~\n\n# 部署\n* 安装 hexo-deployer-git：npm install hexo-deployer-git --save\n* 配置hexo的_config.yml文件\n~~~\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://[XXX]@github.com/[XXX]/[XXX].github.io  //库（Repository）地址,如：https://epaypad@github.com/epaypad/epaypad.github.io\n  branch: master    //分支名称\n  message: https://github.com/chetaofeng/MyHexoBlogSource 内容部署 {{ now('YYYY-MM-DD HH:mm:ss') }} //自定义提交信息\n~~~\n* hexo d //命令执行后，稍等一会查看部署结果\n\n# hexo主题\nhexo默认主题为landscape，大家可以根据各自需要使用不通主题。\n本人使用的是NexT主题，使用请参考：http://theme-next.iissnan.com ，NexT更多配置，请参考：\nhttps://www.jianshu.com/p/1f8107a8778c","source":"_posts/环境搭建/10_hexo安装配置.md","raw":"---\ntitle: hexo使用速记\ntags:\n  - node\n  - hexo\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-04 22:10:23\ncategories: 环境搭建\npassword:\n---\n\n# 说明\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。详细学习请参考：https://hexo.io/zh-cn/docs 。\n本文章只是个人使用过程中重点内容记录。\n\n# 安装\n前置安装：node，git\n安装：npm install -g hexo-cli\n\n# 初始化项目\n1. mkdir [项目名称, 如：test]\n2. hexo init [项目名称, 如：test] //此处要求文件夹内为空\n3. cd [项目名称, 如：test]\n4. npm install\n\n# 常用命令\n* hexo new [layout] '【文章名称】'    //创建不通类型文章\n~~~\nlaytou及路径如下：\npost\tsource/_posts\npage\tsource\ndraft\tsource/_drafts\n~~~\n* hexo clean    //清除hexo生成静态网站内容\n* hexo g        //生成hexo静态网站\n* hexo s        //启用hexo服务\n* hexo d        //hexo网站部署，配合hexo-deployer-git插件使用\n* hexo version  //hexo相关软件版本\n* hexo list [type] //type:post,page等\n\n# Front-matter和JSON Front-matter\n用来设定文章的一些参数，如是否添加密码、版权、标签、分类等信息。\n* Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，基于YAML\n~~~\ntitle: Hello World\ndate: 2013/7/13 20:46:25\n---\n~~~\n* JSON Front-matter 使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可\n~~~\n\"title\": \"Hello World\",\n\"date\": \"2013/7/13 20:46:25\"\n;;;\n~~~\n可配置参数如下：\n\n参数|描述|默认值\n--|--|--\nlayout\t| 布局\t\ntitle\t|标题\t\ndate\t|建立日期\t|文件建立日期\nupdated\t|更新日期\t|文件更新日期\ncomments\t|开启文章的评论功能|\ttrue\ntags\t|标签（不适用于分页）\t\ncategories\t|分类（不适用于分页）\t\npermalink\t|覆盖文章网址\t \n\n可以通过直接修改scaffolds内的模版来设定统一的文章额外信息，如：\n~~~\n---\ntitle: {{ title }}\ndate: {{ date }}\ntags:\n  - \n  - \ncategories: \npassword: \ncopyright: true\ncomments: true\ntoc: true\n---\n~~~\n\n# 部署\n* 安装 hexo-deployer-git：npm install hexo-deployer-git --save\n* 配置hexo的_config.yml文件\n~~~\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://[XXX]@github.com/[XXX]/[XXX].github.io  //库（Repository）地址,如：https://epaypad@github.com/epaypad/epaypad.github.io\n  branch: master    //分支名称\n  message: https://github.com/chetaofeng/MyHexoBlogSource 内容部署 {{ now('YYYY-MM-DD HH:mm:ss') }} //自定义提交信息\n~~~\n* hexo d //命令执行后，稍等一会查看部署结果\n\n# hexo主题\nhexo默认主题为landscape，大家可以根据各自需要使用不通主题。\n本人使用的是NexT主题，使用请参考：http://theme-next.iissnan.com ，NexT更多配置，请参考：\nhttps://www.jianshu.com/p/1f8107a8778c","slug":"环境搭建-10-hexo安装配置","published":1,"updated":"2019-02-14T02:09:11.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue0z007l5b8h7ism8fpy","content":"<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。详细学习请参考：<a href=\"https://hexo.io/zh-cn/docs\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs</a> 。<br>\n本文章只是个人使用过程中重点内容记录。</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>前置安装：node，git<br>\n安装：npm install -g hexo-cli</p>\n<h1 id=\"初始化项目\"><a class=\"markdownIt-Anchor\" href=\"#初始化项目\"></a> 初始化项目</h1>\n<ol>\n<li>mkdir [项目名称, 如：test]</li>\n<li>hexo init [项目名称, 如：test] //此处要求文件夹内为空</li>\n<li>cd [项目名称, 如：test]</li>\n<li>npm install</li>\n</ol>\n<h1 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\"></a> 常用命令</h1>\n<ul>\n<li>hexo new [layout] ‘【文章名称】’    //创建不通类型文章</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">laytou及路径如下：</span><br><span class=\"line\">post\tsource/_posts</span><br><span class=\"line\">page\tsource</span><br><span class=\"line\">draft\tsource/_drafts</span><br></pre></td></tr></table></figure>\n<ul>\n<li>hexo clean    //清除hexo生成静态网站内容</li>\n<li>hexo g        //生成hexo静态网站</li>\n<li>hexo s        //启用hexo服务</li>\n<li>hexo d        //hexo网站部署，配合hexo-deployer-git插件使用</li>\n<li>hexo version  //hexo相关软件版本</li>\n<li>hexo list [type] //type:post,page等</li>\n</ul>\n<h1 id=\"front-matter和json-front-matter\"><a class=\"markdownIt-Anchor\" href=\"#front-matter和json-front-matter\"></a> Front-matter和JSON Front-matter</h1>\n<p>用来设定文章的一些参数，如是否添加密码、版权、标签、分类等信息。</p>\n<ul>\n<li>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，基于YAML</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: Hello World</span><br><span class=\"line\">date: 2013/7/13 20:46:25</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<ul>\n<li>JSON Front-matter 使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class=\"line\">&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;</span><br><span class=\"line\">;;;</span><br></pre></td></tr></table></figure>\n<p>可配置参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n<td></td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>建立日期</td>\n<td>文件建立日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>更新日期</td>\n<td>文件更新日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>开启文章的评论功能</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签（不适用于分页）</td>\n<td></td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类（不适用于分页）</td>\n<td></td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>覆盖文章网址</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>可以通过直接修改scaffolds内的模版来设定统一的文章额外信息，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - </span><br><span class=\"line\">  - </span><br><span class=\"line\">categories: </span><br><span class=\"line\">password: </span><br><span class=\"line\">copyright: true</span><br><span class=\"line\">comments: true</span><br><span class=\"line\">toc: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h1 id=\"部署\"><a class=\"markdownIt-Anchor\" href=\"#部署\"></a> 部署</h1>\n<ul>\n<li>安装 hexo-deployer-git：npm install hexo-deployer-git --save</li>\n<li>配置hexo的_config.yml文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://[XXX]@github.com/[XXX]/[XXX].github.io  //库（Repository）地址,如：https://epaypad@github.com/epaypad/epaypad.github.io</span><br><span class=\"line\">  branch: master    //分支名称</span><br><span class=\"line\">  message: https://github.com/chetaofeng/MyHexoBlogSource 内容部署 &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125; //自定义提交信息</span><br></pre></td></tr></table></figure>\n<ul>\n<li>hexo d //命令执行后，稍等一会查看部署结果</li>\n</ul>\n<h1 id=\"hexo主题\"><a class=\"markdownIt-Anchor\" href=\"#hexo主题\"></a> hexo主题</h1>\n<p>hexo默认主题为landscape，大家可以根据各自需要使用不通主题。<br>\n本人使用的是NexT主题，使用请参考：<a href=\"http://theme-next.iissnan.com\" target=\"_blank\" rel=\"noopener\">http://theme-next.iissnan.com</a> ，NexT更多配置，请参考：<br>\n<a href=\"https://www.jianshu.com/p/1f8107a8778c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1f8107a8778c</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\"></a> 说明</h1>\n<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。详细学习请参考：<a href=\"https://hexo.io/zh-cn/docs\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs</a> 。<br>\n本文章只是个人使用过程中重点内容记录。</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>前置安装：node，git<br>\n安装：npm install -g hexo-cli</p>\n<h1 id=\"初始化项目\"><a class=\"markdownIt-Anchor\" href=\"#初始化项目\"></a> 初始化项目</h1>\n<ol>\n<li>mkdir [项目名称, 如：test]</li>\n<li>hexo init [项目名称, 如：test] //此处要求文件夹内为空</li>\n<li>cd [项目名称, 如：test]</li>\n<li>npm install</li>\n</ol>\n<h1 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\"></a> 常用命令</h1>\n<ul>\n<li>hexo new [layout] ‘【文章名称】’    //创建不通类型文章</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">laytou及路径如下：</span><br><span class=\"line\">post\tsource/_posts</span><br><span class=\"line\">page\tsource</span><br><span class=\"line\">draft\tsource/_drafts</span><br></pre></td></tr></table></figure>\n<ul>\n<li>hexo clean    //清除hexo生成静态网站内容</li>\n<li>hexo g        //生成hexo静态网站</li>\n<li>hexo s        //启用hexo服务</li>\n<li>hexo d        //hexo网站部署，配合hexo-deployer-git插件使用</li>\n<li>hexo version  //hexo相关软件版本</li>\n<li>hexo list [type] //type:post,page等</li>\n</ul>\n<h1 id=\"front-matter和json-front-matter\"><a class=\"markdownIt-Anchor\" href=\"#front-matter和json-front-matter\"></a> Front-matter和JSON Front-matter</h1>\n<p>用来设定文章的一些参数，如是否添加密码、版权、标签、分类等信息。</p>\n<ul>\n<li>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，基于YAML</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: Hello World</span><br><span class=\"line\">date: 2013/7/13 20:46:25</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<ul>\n<li>JSON Front-matter 使用 JSON 来编写 Front-matter，只要将 — 代换成 ;;; 即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class=\"line\">&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;</span><br><span class=\"line\">;;;</span><br></pre></td></tr></table></figure>\n<p>可配置参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>layout</td>\n<td>布局</td>\n<td></td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题</td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>建立日期</td>\n<td>文件建立日期</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>更新日期</td>\n<td>文件更新日期</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>开启文章的评论功能</td>\n<td>true</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>标签（不适用于分页）</td>\n<td></td>\n</tr>\n<tr>\n<td>categories</td>\n<td>分类（不适用于分页）</td>\n<td></td>\n</tr>\n<tr>\n<td>permalink</td>\n<td>覆盖文章网址</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>可以通过直接修改scaffolds内的模版来设定统一的文章额外信息，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">date: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - </span><br><span class=\"line\">  - </span><br><span class=\"line\">categories: </span><br><span class=\"line\">password: </span><br><span class=\"line\">copyright: true</span><br><span class=\"line\">comments: true</span><br><span class=\"line\">toc: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h1 id=\"部署\"><a class=\"markdownIt-Anchor\" href=\"#部署\"></a> 部署</h1>\n<ul>\n<li>安装 hexo-deployer-git：npm install hexo-deployer-git --save</li>\n<li>配置hexo的_config.yml文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://[XXX]@github.com/[XXX]/[XXX].github.io  //库（Repository）地址,如：https://epaypad@github.com/epaypad/epaypad.github.io</span><br><span class=\"line\">  branch: master    //分支名称</span><br><span class=\"line\">  message: https://github.com/chetaofeng/MyHexoBlogSource 内容部署 &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125; //自定义提交信息</span><br></pre></td></tr></table></figure>\n<ul>\n<li>hexo d //命令执行后，稍等一会查看部署结果</li>\n</ul>\n<h1 id=\"hexo主题\"><a class=\"markdownIt-Anchor\" href=\"#hexo主题\"></a> hexo主题</h1>\n<p>hexo默认主题为landscape，大家可以根据各自需要使用不通主题。<br>\n本人使用的是NexT主题，使用请参考：<a href=\"http://theme-next.iissnan.com\" target=\"_blank\" rel=\"noopener\">http://theme-next.iissnan.com</a> ，NexT更多配置，请参考：<br>\n<a href=\"https://www.jianshu.com/p/1f8107a8778c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1f8107a8778c</a></p>\n"},{"title":"MySQL安装配置","copyright":true,"comments":1,"toc":true,"date":"2018-10-04T14:10:23.000Z","password":null,"_content":" \n# 简介\n下载地址：https://dev.mysql.com/downloads/mysql/\n官方数据客户端工具： https://dev.mysql.com/downloads/workbench/\n推荐客户端工具：Navicat Premium- https://www.navicat.com/en/download/navicat-premium\n\n# 安装登陆\n## mac系统\n1. 安装dmg安装包，如：mysql-5.7.8-rc-osx10.9-x86_64.dmg，安装过程中会弹出临时的密码，务必截图保存方便后面更改密码，安装过程有时会卡顿，时间会比较长，需耐心等待一会。\n2. 在【系统偏好设置】中启动MySQL服务，如果启动不起来，可选择开机启动，然后重启macOS\n3. 在MySQLWorkBench中，创建连接信息,hostname-127.0.0.1或localhost，端口3307\n4. 点击\"Store in Keychain...\"输入安装时提示的临时密码后确定\n5. 如果临时密码输入正确，则会弹出修改密码界面，修改密码后重新登陆即可\n\n## Linux系统\nLinux下安装有多种方式：\n1. 直接用软件仓库自动安装（如：ubuntu下，sudo apt-get install mysql-server）\n2. 通过下载deb或rmp安装包，直接双击安装\n3. 下载tar安装包，解压到硬盘，然后自己配置mysql\n4. 通过源码编译安装\n\n以下以tar包安装记录:参考文章（http://www.pianshen.com/article/975954037/）\n1. sudo cp mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz /usr\n2. cd /usr\n3. sudo tar xvJf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz\n4. 为MySQL创建专用用户，用户名为mysql，用户组为mysql；\nsudo groupadd mysql //创建组\nsudo useradd -r -g mysql mysql //创建用户并划入mysql组下 \n5. 为解压出来的所有文件更改用户和组\nsudo chown -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改拥有者\nsudo chgrp -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改组\n6. sudo apt-get install libaio1 libaio-dev\n7. 初始化数据库: sudo ./bin/mysqld --initialize --user mysql\n执行过程中会生成一个临时密码，一定要保存好，后面修改密码需要用到，如图：\n![image](/pub-images/mysql.png)\n8. 开启服务: bin/mysqld_safe --user=mysql &\n9. 使用用户root登录: bin/mysql -uroot -p\n10. 更改root用户密码:\n~~~\nALTER USER 'root'@'localhost' IDENTIFIED BY 'root' PASSWORD EXPIRE NEVER;   //修改root的密码与加密方式\nuse mysql; #切换到mysql库 \nupdate user set host='%' where user='root'; //更改可以登录的IP为任意IP\nALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';  //再次更改root用户密码，使其可以在任意IP访问\nflush privileges; #刷新权限\n~~~\n11. 通过客户端测试登陆即可\n\n# Navicat安装\n## Linux\n1. 进入安装包所在目录下，如：navicat_premium12_cs_x64_for_linux.zip\n2. sudo cp navicat_premium12_cs_x64_for_linux.zip /usr/\n4. cd /usr/\n5. sudo unzip navicat_premium12_cs_x64_for_linux.zip \n6. cd navicat120_premium_cs_x64\n7. 命令行启动：sudo ./start_navicat，正常的话应该会出现一个Win Mono下载界面，可不下载，跳过即可 \n\n## Windows & macOS\n直接下载安装就行，破解请自行查找","source":"_posts/环境搭建/11_MySQL安装配置.md","raw":"---\ntitle: MySQL安装配置\ntags:\n  - MySQL\n  - 数据库\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-04 22:10:23\ncategories: 环境搭建\npassword:\n---\n \n# 简介\n下载地址：https://dev.mysql.com/downloads/mysql/\n官方数据客户端工具： https://dev.mysql.com/downloads/workbench/\n推荐客户端工具：Navicat Premium- https://www.navicat.com/en/download/navicat-premium\n\n# 安装登陆\n## mac系统\n1. 安装dmg安装包，如：mysql-5.7.8-rc-osx10.9-x86_64.dmg，安装过程中会弹出临时的密码，务必截图保存方便后面更改密码，安装过程有时会卡顿，时间会比较长，需耐心等待一会。\n2. 在【系统偏好设置】中启动MySQL服务，如果启动不起来，可选择开机启动，然后重启macOS\n3. 在MySQLWorkBench中，创建连接信息,hostname-127.0.0.1或localhost，端口3307\n4. 点击\"Store in Keychain...\"输入安装时提示的临时密码后确定\n5. 如果临时密码输入正确，则会弹出修改密码界面，修改密码后重新登陆即可\n\n## Linux系统\nLinux下安装有多种方式：\n1. 直接用软件仓库自动安装（如：ubuntu下，sudo apt-get install mysql-server）\n2. 通过下载deb或rmp安装包，直接双击安装\n3. 下载tar安装包，解压到硬盘，然后自己配置mysql\n4. 通过源码编译安装\n\n以下以tar包安装记录:参考文章（http://www.pianshen.com/article/975954037/）\n1. sudo cp mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz /usr\n2. cd /usr\n3. sudo tar xvJf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz\n4. 为MySQL创建专用用户，用户名为mysql，用户组为mysql；\nsudo groupadd mysql //创建组\nsudo useradd -r -g mysql mysql //创建用户并划入mysql组下 \n5. 为解压出来的所有文件更改用户和组\nsudo chown -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改拥有者\nsudo chgrp -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改组\n6. sudo apt-get install libaio1 libaio-dev\n7. 初始化数据库: sudo ./bin/mysqld --initialize --user mysql\n执行过程中会生成一个临时密码，一定要保存好，后面修改密码需要用到，如图：\n![image](/pub-images/mysql.png)\n8. 开启服务: bin/mysqld_safe --user=mysql &\n9. 使用用户root登录: bin/mysql -uroot -p\n10. 更改root用户密码:\n~~~\nALTER USER 'root'@'localhost' IDENTIFIED BY 'root' PASSWORD EXPIRE NEVER;   //修改root的密码与加密方式\nuse mysql; #切换到mysql库 \nupdate user set host='%' where user='root'; //更改可以登录的IP为任意IP\nALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';  //再次更改root用户密码，使其可以在任意IP访问\nflush privileges; #刷新权限\n~~~\n11. 通过客户端测试登陆即可\n\n# Navicat安装\n## Linux\n1. 进入安装包所在目录下，如：navicat_premium12_cs_x64_for_linux.zip\n2. sudo cp navicat_premium12_cs_x64_for_linux.zip /usr/\n4. cd /usr/\n5. sudo unzip navicat_premium12_cs_x64_for_linux.zip \n6. cd navicat120_premium_cs_x64\n7. 命令行启动：sudo ./start_navicat，正常的话应该会出现一个Win Mono下载界面，可不下载，跳过即可 \n\n## Windows & macOS\n直接下载安装就行，破解请自行查找","slug":"环境搭建-11-MySQL安装配置","published":1,"updated":"2019-02-14T02:09:24.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue11007p5b8hle6zrx9p","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>下载地址：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/mysql/</a><br>\n官方数据客户端工具： <a href=\"https://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/workbench/</a><br>\n推荐客户端工具：Navicat Premium- <a href=\"https://www.navicat.com/en/download/navicat-premium\" target=\"_blank\" rel=\"noopener\">https://www.navicat.com/en/download/navicat-premium</a></p>\n<h1 id=\"安装登陆\"><a class=\"markdownIt-Anchor\" href=\"#安装登陆\"></a> 安装登陆</h1>\n<h2 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h2>\n<ol>\n<li>安装dmg安装包，如：mysql-5.7.8-rc-osx10.9-x86_64.dmg，安装过程中会弹出临时的密码，务必截图保存方便后面更改密码，安装过程有时会卡顿，时间会比较长，需耐心等待一会。</li>\n<li>在【系统偏好设置】中启动MySQL服务，如果启动不起来，可选择开机启动，然后重启macOS</li>\n<li>在MySQLWorkBench中，创建连接信息,hostname-127.0.0.1或localhost，端口3307</li>\n<li>点击&quot;Store in Keychain…&quot;输入安装时提示的临时密码后确定</li>\n<li>如果临时密码输入正确，则会弹出修改密码界面，修改密码后重新登陆即可</li>\n</ol>\n<h2 id=\"linux系统\"><a class=\"markdownIt-Anchor\" href=\"#linux系统\"></a> Linux系统</h2>\n<p>Linux下安装有多种方式：</p>\n<ol>\n<li>直接用软件仓库自动安装（如：ubuntu下，sudo apt-get install mysql-server）</li>\n<li>通过下载deb或rmp安装包，直接双击安装</li>\n<li>下载tar安装包，解压到硬盘，然后自己配置mysql</li>\n<li>通过源码编译安装</li>\n</ol>\n<p>以下以tar包安装记录:参考文章（<a href=\"http://www.pianshen.com/article/975954037/%EF%BC%89\" target=\"_blank\" rel=\"noopener\">http://www.pianshen.com/article/975954037/）</a></p>\n<ol>\n<li>sudo cp mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz /usr</li>\n<li>cd /usr</li>\n<li>sudo tar xvJf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz</li>\n<li>为MySQL创建专用用户，用户名为mysql，用户组为mysql；<br>\nsudo groupadd mysql //创建组<br>\nsudo useradd -r -g mysql mysql //创建用户并划入mysql组下</li>\n<li>为解压出来的所有文件更改用户和组<br>\nsudo chown -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改拥有者<br>\nsudo chgrp -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改组</li>\n<li>sudo apt-get install libaio1 libaio-dev</li>\n<li>初始化数据库: sudo ./bin/mysqld --initialize --user mysql<br>\n执行过程中会生成一个临时密码，一定要保存好，后面修改密码需要用到，如图：<br>\n<img src=\"/pub-images/mysql.png\" alt=\"image\"></li>\n<li>开启服务: bin/mysqld_safe --user=mysql &amp;</li>\n<li>使用用户root登录: bin/mysql -uroot -p</li>\n<li>更改root用户密码:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;root&apos; PASSWORD EXPIRE NEVER;   //修改root的密码与加密方式</span><br><span class=\"line\">use mysql; #切换到mysql库 </span><br><span class=\"line\">update user set host=&apos;%&apos; where user=&apos;root&apos;; //更改可以登录的IP为任意IP</span><br><span class=\"line\">ALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;;  //再次更改root用户密码，使其可以在任意IP访问</span><br><span class=\"line\">flush privileges; #刷新权限</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>通过客户端测试登陆即可</li>\n</ol>\n<h1 id=\"navicat安装\"><a class=\"markdownIt-Anchor\" href=\"#navicat安装\"></a> Navicat安装</h1>\n<h2 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\"></a> Linux</h2>\n<ol>\n<li>进入安装包所在目录下，如：navicat_premium12_cs_x64_for_linux.zip</li>\n<li>sudo cp navicat_premium12_cs_x64_for_linux.zip /usr/</li>\n<li>cd /usr/</li>\n<li>sudo unzip navicat_premium12_cs_x64_for_linux.zip</li>\n<li>cd navicat120_premium_cs_x64</li>\n<li>命令行启动：sudo ./start_navicat，正常的话应该会出现一个Win Mono下载界面，可不下载，跳过即可</li>\n</ol>\n<h2 id=\"windows-macos\"><a class=\"markdownIt-Anchor\" href=\"#windows-macos\"></a> Windows &amp; macOS</h2>\n<p>直接下载安装就行，破解请自行查找</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>下载地址：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/mysql/</a><br>\n官方数据客户端工具： <a href=\"https://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/workbench/</a><br>\n推荐客户端工具：Navicat Premium- <a href=\"https://www.navicat.com/en/download/navicat-premium\" target=\"_blank\" rel=\"noopener\">https://www.navicat.com/en/download/navicat-premium</a></p>\n<h1 id=\"安装登陆\"><a class=\"markdownIt-Anchor\" href=\"#安装登陆\"></a> 安装登陆</h1>\n<h2 id=\"mac系统\"><a class=\"markdownIt-Anchor\" href=\"#mac系统\"></a> mac系统</h2>\n<ol>\n<li>安装dmg安装包，如：mysql-5.7.8-rc-osx10.9-x86_64.dmg，安装过程中会弹出临时的密码，务必截图保存方便后面更改密码，安装过程有时会卡顿，时间会比较长，需耐心等待一会。</li>\n<li>在【系统偏好设置】中启动MySQL服务，如果启动不起来，可选择开机启动，然后重启macOS</li>\n<li>在MySQLWorkBench中，创建连接信息,hostname-127.0.0.1或localhost，端口3307</li>\n<li>点击&quot;Store in Keychain…&quot;输入安装时提示的临时密码后确定</li>\n<li>如果临时密码输入正确，则会弹出修改密码界面，修改密码后重新登陆即可</li>\n</ol>\n<h2 id=\"linux系统\"><a class=\"markdownIt-Anchor\" href=\"#linux系统\"></a> Linux系统</h2>\n<p>Linux下安装有多种方式：</p>\n<ol>\n<li>直接用软件仓库自动安装（如：ubuntu下，sudo apt-get install mysql-server）</li>\n<li>通过下载deb或rmp安装包，直接双击安装</li>\n<li>下载tar安装包，解压到硬盘，然后自己配置mysql</li>\n<li>通过源码编译安装</li>\n</ol>\n<p>以下以tar包安装记录:参考文章（<a href=\"http://www.pianshen.com/article/975954037/%EF%BC%89\" target=\"_blank\" rel=\"noopener\">http://www.pianshen.com/article/975954037/）</a></p>\n<ol>\n<li>sudo cp mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz /usr</li>\n<li>cd /usr</li>\n<li>sudo tar xvJf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz</li>\n<li>为MySQL创建专用用户，用户名为mysql，用户组为mysql；<br>\nsudo groupadd mysql //创建组<br>\nsudo useradd -r -g mysql mysql //创建用户并划入mysql组下</li>\n<li>为解压出来的所有文件更改用户和组<br>\nsudo chown -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改拥有者<br>\nsudo chgrp -R mysql mysql-8.0.13-linux-glibc2.12-x86_64 //更改组</li>\n<li>sudo apt-get install libaio1 libaio-dev</li>\n<li>初始化数据库: sudo ./bin/mysqld --initialize --user mysql<br>\n执行过程中会生成一个临时密码，一定要保存好，后面修改密码需要用到，如图：<br>\n<img src=\"/pub-images/mysql.png\" alt=\"image\"></li>\n<li>开启服务: bin/mysqld_safe --user=mysql &amp;</li>\n<li>使用用户root登录: bin/mysql -uroot -p</li>\n<li>更改root用户密码:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;root&apos; PASSWORD EXPIRE NEVER;   //修改root的密码与加密方式</span><br><span class=\"line\">use mysql; #切换到mysql库 </span><br><span class=\"line\">update user set host=&apos;%&apos; where user=&apos;root&apos;; //更改可以登录的IP为任意IP</span><br><span class=\"line\">ALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;;  //再次更改root用户密码，使其可以在任意IP访问</span><br><span class=\"line\">flush privileges; #刷新权限</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>通过客户端测试登陆即可</li>\n</ol>\n<h1 id=\"navicat安装\"><a class=\"markdownIt-Anchor\" href=\"#navicat安装\"></a> Navicat安装</h1>\n<h2 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\"></a> Linux</h2>\n<ol>\n<li>进入安装包所在目录下，如：navicat_premium12_cs_x64_for_linux.zip</li>\n<li>sudo cp navicat_premium12_cs_x64_for_linux.zip /usr/</li>\n<li>cd /usr/</li>\n<li>sudo unzip navicat_premium12_cs_x64_for_linux.zip</li>\n<li>cd navicat120_premium_cs_x64</li>\n<li>命令行启动：sudo ./start_navicat，正常的话应该会出现一个Win Mono下载界面，可不下载，跳过即可</li>\n</ol>\n<h2 id=\"windows-macos\"><a class=\"markdownIt-Anchor\" href=\"#windows-macos\"></a> Windows &amp; macOS</h2>\n<p>直接下载安装就行，破解请自行查找</p>\n"},{"title":"Gitblit搭建git服务器","copyright":true,"comments":1,"toc":true,"date":"2018-10-08T13:00:14.000Z","password":null,"_content":"\nhttp://www.gitblit.com/\nhttps://www.cnblogs.com/ucos/p/3924720.html\n\nhttps://blog.csdn.net/llengnuo/article/details/73477355\n\nhttp://gitblit.com/setup_go.html\n\nhttps://blog.csdn.net/zhangwenjie1105/article/details/81482238\n\n\nhttps://www.cnblogs.com/royi123/p/7754235.html","source":"_posts/环境搭建/2018-10-08-Gitblit搭建git服务器.md","raw":"---\ntitle: Gitblit搭建git服务器\ntags:\n  - git \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-08 21:00:14\ncategories: 工具\npassword:\n---\n\nhttp://www.gitblit.com/\nhttps://www.cnblogs.com/ucos/p/3924720.html\n\nhttps://blog.csdn.net/llengnuo/article/details/73477355\n\nhttp://gitblit.com/setup_go.html\n\nhttps://blog.csdn.net/zhangwenjie1105/article/details/81482238\n\n\nhttps://www.cnblogs.com/royi123/p/7754235.html","slug":"环境搭建-2018-10-08-Gitblit搭建git服务器","published":1,"updated":"2019-02-14T02:24:19.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue12007s5b8h6psyfvft","content":"<p><a href=\"http://www.gitblit.com/\" target=\"_blank\" rel=\"noopener\">http://www.gitblit.com/</a><br>\n<a href=\"https://www.cnblogs.com/ucos/p/3924720.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ucos/p/3924720.html</a></p>\n<p><a href=\"https://blog.csdn.net/llengnuo/article/details/73477355\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/llengnuo/article/details/73477355</a></p>\n<p><a href=\"http://gitblit.com/setup_go.html\" target=\"_blank\" rel=\"noopener\">http://gitblit.com/setup_go.html</a></p>\n<p><a href=\"https://blog.csdn.net/zhangwenjie1105/article/details/81482238\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhangwenjie1105/article/details/81482238</a></p>\n<p><a href=\"https://www.cnblogs.com/royi123/p/7754235.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/royi123/p/7754235.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.gitblit.com/\" target=\"_blank\" rel=\"noopener\">http://www.gitblit.com/</a><br>\n<a href=\"https://www.cnblogs.com/ucos/p/3924720.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ucos/p/3924720.html</a></p>\n<p><a href=\"https://blog.csdn.net/llengnuo/article/details/73477355\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/llengnuo/article/details/73477355</a></p>\n<p><a href=\"http://gitblit.com/setup_go.html\" target=\"_blank\" rel=\"noopener\">http://gitblit.com/setup_go.html</a></p>\n<p><a href=\"https://blog.csdn.net/zhangwenjie1105/article/details/81482238\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhangwenjie1105/article/details/81482238</a></p>\n<p><a href=\"https://www.cnblogs.com/royi123/p/7754235.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/royi123/p/7754235.html</a></p>\n"},{"title":"使用Github Pages进行个人博客搭建","copyright":true,"comments":1,"toc":true,"date":"2018-10-02T14:10:23.000Z","password":null,"_content":"\n# Github Pages介绍\n\n官网：https://pages.github.com/\nGitHub Pages 是一个静态网站托管服务，使用github.io域名和HTTPS来提供服务。一个github账号只能有一个Github Pages网站。\nGitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它。\n\n# Github Pages创建\n1. 申请邮箱\n2. 申请github账号\n~~~\n前两步是为了准备没有进行Github Pages服务开通的github账号，如果已经有，可以跳过\n~~~\n3. 创建repository。和普通创建一样，但是名称要以\".github.io\"结尾，如：test.github.io，这样创建完之后才在这个项目的settings中有github pages选项\n4. 访问：https://test.github.io/,即可以看见Github Pages网站\n\n# Github Pages网站内容编辑\n1. 创建源码repository，用来存放Github Pages网站源码\n2. 此处选用Hexo作为网站模版，在本地初始化hexo项目，参考：\n3. 在hexo中安装配置hexo-deployer-git进行github项目管理\n4. 下载【1】中github代码到本地，本人是通过webstorm进行编辑操作的\n5. 拷贝【2】中代码到【1】中的repository中，在本地运行查看hexo效果\n6. 编辑.gitignore文件,忽略操作系统文件、编辑器临时文件、node临时文件等，提交\n7. 提交repository到github\n8. hexo部署本地代码到Github Pages，查看效果\n\n\n","source":"_posts/环境搭建/2018-10-02-GithubPages.md","raw":"---\ntitle: 使用Github Pages进行个人博客搭建\ntags: \n  - git\n  - github\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-02 22:10:23\ncategories: 其他\npassword:\n---\n\n# Github Pages介绍\n\n官网：https://pages.github.com/\nGitHub Pages 是一个静态网站托管服务，使用github.io域名和HTTPS来提供服务。一个github账号只能有一个Github Pages网站。\nGitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它。\n\n# Github Pages创建\n1. 申请邮箱\n2. 申请github账号\n~~~\n前两步是为了准备没有进行Github Pages服务开通的github账号，如果已经有，可以跳过\n~~~\n3. 创建repository。和普通创建一样，但是名称要以\".github.io\"结尾，如：test.github.io，这样创建完之后才在这个项目的settings中有github pages选项\n4. 访问：https://test.github.io/,即可以看见Github Pages网站\n\n# Github Pages网站内容编辑\n1. 创建源码repository，用来存放Github Pages网站源码\n2. 此处选用Hexo作为网站模版，在本地初始化hexo项目，参考：\n3. 在hexo中安装配置hexo-deployer-git进行github项目管理\n4. 下载【1】中github代码到本地，本人是通过webstorm进行编辑操作的\n5. 拷贝【2】中代码到【1】中的repository中，在本地运行查看hexo效果\n6. 编辑.gitignore文件,忽略操作系统文件、编辑器临时文件、node临时文件等，提交\n7. 提交repository到github\n8. hexo部署本地代码到Github Pages，查看效果\n\n\n","slug":"环境搭建-2018-10-02-GithubPages","published":1,"updated":"2019-02-14T02:23:54.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue14007w5b8hyooln991","content":"<h1 id=\"github-pages介绍\"><a class=\"markdownIt-Anchor\" href=\"#github-pages介绍\"></a> Github Pages介绍</h1>\n<p>官网：<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">https://pages.github.com/</a><br>\nGitHub Pages 是一个静态网站托管服务，使用github.io域名和HTTPS来提供服务。一个github账号只能有一个Github Pages网站。<br>\nGitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它。</p>\n<h1 id=\"github-pages创建\"><a class=\"markdownIt-Anchor\" href=\"#github-pages创建\"></a> Github Pages创建</h1>\n<ol>\n<li>申请邮箱</li>\n<li>申请github账号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前两步是为了准备没有进行Github Pages服务开通的github账号，如果已经有，可以跳过</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建repository。和普通创建一样，但是名称要以&quot;.github.io&quot;结尾，如：<a href=\"http://test.github.io\" target=\"_blank\" rel=\"noopener\">test.github.io</a>，这样创建完之后才在这个项目的settings中有github pages选项</li>\n<li>访问：<a href=\"https://test.github.io/,%E5%8D%B3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%A7%81Github\" target=\"_blank\" rel=\"noopener\">https://test.github.io/,即可以看见Github</a> Pages网站</li>\n</ol>\n<h1 id=\"github-pages网站内容编辑\"><a class=\"markdownIt-Anchor\" href=\"#github-pages网站内容编辑\"></a> Github Pages网站内容编辑</h1>\n<ol>\n<li>创建源码repository，用来存放Github Pages网站源码</li>\n<li>此处选用Hexo作为网站模版，在本地初始化hexo项目，参考：</li>\n<li>在hexo中安装配置hexo-deployer-git进行github项目管理</li>\n<li>下载【1】中github代码到本地，本人是通过webstorm进行编辑操作的</li>\n<li>拷贝【2】中代码到【1】中的repository中，在本地运行查看hexo效果</li>\n<li>编辑.gitignore文件,忽略操作系统文件、编辑器临时文件、node临时文件等，提交</li>\n<li>提交repository到github</li>\n<li>hexo部署本地代码到Github Pages，查看效果</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"github-pages介绍\"><a class=\"markdownIt-Anchor\" href=\"#github-pages介绍\"></a> Github Pages介绍</h1>\n<p>官网：<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">https://pages.github.com/</a><br>\nGitHub Pages 是一个静态网站托管服务，使用github.io域名和HTTPS来提供服务。一个github账号只能有一个Github Pages网站。<br>\nGitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它。</p>\n<h1 id=\"github-pages创建\"><a class=\"markdownIt-Anchor\" href=\"#github-pages创建\"></a> Github Pages创建</h1>\n<ol>\n<li>申请邮箱</li>\n<li>申请github账号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前两步是为了准备没有进行Github Pages服务开通的github账号，如果已经有，可以跳过</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建repository。和普通创建一样，但是名称要以&quot;.github.io&quot;结尾，如：<a href=\"http://test.github.io\" target=\"_blank\" rel=\"noopener\">test.github.io</a>，这样创建完之后才在这个项目的settings中有github pages选项</li>\n<li>访问：<a href=\"https://test.github.io/,%E5%8D%B3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%A7%81Github\" target=\"_blank\" rel=\"noopener\">https://test.github.io/,即可以看见Github</a> Pages网站</li>\n</ol>\n<h1 id=\"github-pages网站内容编辑\"><a class=\"markdownIt-Anchor\" href=\"#github-pages网站内容编辑\"></a> Github Pages网站内容编辑</h1>\n<ol>\n<li>创建源码repository，用来存放Github Pages网站源码</li>\n<li>此处选用Hexo作为网站模版，在本地初始化hexo项目，参考：</li>\n<li>在hexo中安装配置hexo-deployer-git进行github项目管理</li>\n<li>下载【1】中github代码到本地，本人是通过webstorm进行编辑操作的</li>\n<li>拷贝【2】中代码到【1】中的repository中，在本地运行查看hexo效果</li>\n<li>编辑.gitignore文件,忽略操作系统文件、编辑器临时文件、node临时文件等，提交</li>\n<li>提交repository到github</li>\n<li>hexo部署本地代码到Github Pages，查看效果</li>\n</ol>\n"},{"title":"Activity启动模式","copyright":true,"comments":1,"toc":true,"date":"2018-10-02T14:10:23.000Z","password":null,"_content":" https://blog.csdn.net/carson_ho/article/details/54669547\n\n\n","source":"_posts/移动开发/Activity启动模式.md","raw":"---\ntitle: Activity启动模式\ntags: \n  - Android  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-02 22:10:23\ncategories: 移动开发\npassword:\n---\n https://blog.csdn.net/carson_ho/article/details/54669547\n\n\n","slug":"移动开发-Activity启动模式","published":1,"updated":"2019-02-14T02:47:30.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue16007y5b8h5ef51vop","content":"<p><a href=\"https://blog.csdn.net/carson_ho/article/details/54669547\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/carson_ho/article/details/54669547</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/carson_ho/article/details/54669547\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/carson_ho/article/details/54669547</a></p>\n"},{"title":"windows git","copyright":true,"comments":1,"toc":true,"date":"2018-10-08T13:15:47.000Z","password":null,"_content":"\nhttps://git-scm.com/\n\n\n\nhttps://www.cnblogs.com/vitah/p/3612473.html\n","source":"_posts/环境搭建/2018-10-08-windows-git.md","raw":"---\ntitle: windows git\ntags:\n  - git \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-08 21:15:47\ncategories: 工具\npassword:\n---\n\nhttps://git-scm.com/\n\n\n\nhttps://www.cnblogs.com/vitah/p/3612473.html\n","slug":"环境搭建-2018-10-08-windows-git","published":1,"updated":"2019-02-14T02:24:15.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue1800825b8hpf9k7b1p","content":"<p><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<p><a href=\"https://www.cnblogs.com/vitah/p/3612473.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vitah/p/3612473.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<p><a href=\"https://www.cnblogs.com/vitah/p/3612473.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vitah/p/3612473.html</a></p>\n"},{"title":"RxJava从源码到应用移动端开发效率秒提速","copyright":true,"comments":1,"toc":true,"date":"2018-10-02T14:10:23.000Z","password":null,"_content":"\n# 响应式编程思想概述\n* 响应式编程：是一种面向数据流和变化传播的编程范式\n* 数据流：只能以事先规定好的顺序被读取一次的数据的一个序列\n* 变化传播：类似观察者模式，变化了要通知别人\n\n# RxJava源码分析\n## 基本元素\nRxJava是一个基于回调的异步的库，是一个基于事件分发和消息传递的库\n\n## Operator操作符变换原理\n\n## Scheduler线程变换原理\n\n## 整体变换compose和transformer原理\n\n\n\n\n\n","source":"_posts/移动开发/RxJava.md","raw":"---\ntitle: RxJava从源码到应用移动端开发效率秒提速\ntags: \n  - andrioid \n  - RxJava\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-02 22:10:23\ncategories: Java\npassword:\n---\n\n# 响应式编程思想概述\n* 响应式编程：是一种面向数据流和变化传播的编程范式\n* 数据流：只能以事先规定好的顺序被读取一次的数据的一个序列\n* 变化传播：类似观察者模式，变化了要通知别人\n\n# RxJava源码分析\n## 基本元素\nRxJava是一个基于回调的异步的库，是一个基于事件分发和消息传递的库\n\n## Operator操作符变换原理\n\n## Scheduler线程变换原理\n\n## 整体变换compose和transformer原理\n\n\n\n\n\n","slug":"移动开发-RxJava","published":1,"updated":"2019-02-14T02:32:40.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue1900855b8hkb4pdqqp","content":"<h1 id=\"响应式编程思想概述\"><a class=\"markdownIt-Anchor\" href=\"#响应式编程思想概述\"></a> 响应式编程思想概述</h1>\n<ul>\n<li>响应式编程：是一种面向数据流和变化传播的编程范式</li>\n<li>数据流：只能以事先规定好的顺序被读取一次的数据的一个序列</li>\n<li>变化传播：类似观察者模式，变化了要通知别人</li>\n</ul>\n<h1 id=\"rxjava源码分析\"><a class=\"markdownIt-Anchor\" href=\"#rxjava源码分析\"></a> RxJava源码分析</h1>\n<h2 id=\"基本元素\"><a class=\"markdownIt-Anchor\" href=\"#基本元素\"></a> 基本元素</h2>\n<p>RxJava是一个基于回调的异步的库，是一个基于事件分发和消息传递的库</p>\n<h2 id=\"operator操作符变换原理\"><a class=\"markdownIt-Anchor\" href=\"#operator操作符变换原理\"></a> Operator操作符变换原理</h2>\n<h2 id=\"scheduler线程变换原理\"><a class=\"markdownIt-Anchor\" href=\"#scheduler线程变换原理\"></a> Scheduler线程变换原理</h2>\n<h2 id=\"整体变换compose和transformer原理\"><a class=\"markdownIt-Anchor\" href=\"#整体变换compose和transformer原理\"></a> 整体变换compose和transformer原理</h2>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"响应式编程思想概述\"><a class=\"markdownIt-Anchor\" href=\"#响应式编程思想概述\"></a> 响应式编程思想概述</h1>\n<ul>\n<li>响应式编程：是一种面向数据流和变化传播的编程范式</li>\n<li>数据流：只能以事先规定好的顺序被读取一次的数据的一个序列</li>\n<li>变化传播：类似观察者模式，变化了要通知别人</li>\n</ul>\n<h1 id=\"rxjava源码分析\"><a class=\"markdownIt-Anchor\" href=\"#rxjava源码分析\"></a> RxJava源码分析</h1>\n<h2 id=\"基本元素\"><a class=\"markdownIt-Anchor\" href=\"#基本元素\"></a> 基本元素</h2>\n<p>RxJava是一个基于回调的异步的库，是一个基于事件分发和消息传递的库</p>\n<h2 id=\"operator操作符变换原理\"><a class=\"markdownIt-Anchor\" href=\"#operator操作符变换原理\"></a> Operator操作符变换原理</h2>\n<h2 id=\"scheduler线程变换原理\"><a class=\"markdownIt-Anchor\" href=\"#scheduler线程变换原理\"></a> Scheduler线程变换原理</h2>\n<h2 id=\"整体变换compose和transformer原理\"><a class=\"markdownIt-Anchor\" href=\"#整体变换compose和transformer原理\"></a> 整体变换compose和transformer原理</h2>\n"},{"title":"React入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:04:22.000Z","password":null,"_content":"\n# 简介\n* React 是一个用于构建用户界面的 JAVASCRIPT 库\n* React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）\n* React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源\n* React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它\n* React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用\n* react有 函数式组件和类组件，现在的使用都以类组件为主，函数式组件不考虑\n* angualr霸道，用了之后原生定时器、jquery等都不能用，而react没有这个限制\n* react中对事件的大小写敏感，因为有一个编译过程\n* 相关有用网址\n~~~\n官网：https://facebook.github.io/react/\n中文网站：http://www.css88.com/react/\n中文论坛:http://react-china.org/\n~~~\n\n# react特点\n1. 声明式设计 −React采用声明范式，可以轻松描述应用。\n2. 高效 −虚拟DOM,React通过对DOM的模拟，最大限度地减少与DOM的交互。React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态\n3. 灵活 −React可以与已知的库或框架很好地配合。\n4. JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\n5. 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\n6. 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单\n\n# react全家桶（技术栈）\n> 如果一个技术你不知道，那说明你还用不上\n\n1. react：主体\n2. webpack、grunt、gulp自动化构建工具\n3. Flex：布局\n4. react-route：路由\n5. redux：view层\n6. Mocha：测试\n7. Istanbul：覆盖率\n\n# 安装\n## 网页使用\n网页中用babel会页面加载会有编译过程，比较缓慢，babel也可以后台编译\n~~~\n<script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"></script>\n<script type=\"text/babel\">\n  ReactDOM.render(\n    <h1>Hello, world!</h1>,\n    document.getElementById('example')\n  );\n</script>\n~~~\n引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js：\n1. react.min.js - React 的核心库\n2. react-dom.min.js - 提供与 DOM 相关的功能\n3. babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平\n\n## 使用 create-react-app 快速构建\n* create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。\n* create-react-app 自动创建的项目是基于 Webpack + ES6\n* create-react-app网址：https://github.com/facebookincubator/create-react-app\n* create-react-app说明：https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases\n~~~\n$ cnpm install -g create-react-app\n$ create-react-app my-app\n$ cd my-app/\n$ npm start\n~~~\n在浏览器中打开 http://localhost:3000/,查看结果\n\n# JSX\n> JSX是可选的，对于使用 React而言不需要\n\nReact 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。\n\n优点：\n* JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化，需babel编译后才能运行，bower babel install,官网：http://babeljs.io/\n* 它是类型安全的，在编译过程中就能发现错误\n* 使用 JSX 编写模板更加简单快速\n\n使用过程中的注意事项：\n1. 组件必须返回一个单独的根元素。render的内容必须有且仅有一个父元\n2. 网页中使用：\n~~~\n<script src=\"js/react.js\" charset=\"utf-8\"/></script>\n<script src=\"js/react-dom.js\" charset=\"utf-8\"/></script>\n<script src=\"js/browser.js\" charset=\"utf-8\"/></script>\n<script type=\"text/babel\">\n    window.onload=function(){\n        var oDiv = document.getElementById(\"div1\"); \n        ReactDom.render(\n            <span>111</span>,//内容\n            oDiv//到哪\n        ); \n    };\n</script>\n<body>\n    <div id=\"div1></div>\n</body>\n~~~\n3. 添加自定义属性需要使用 data- 前缀，因为jsx对html标签有识别，如果符合则不显示，而在自定义属性前面加data-可以保证显示显示\n4. 自定义组件可以单独文件存储\n5. 可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中；在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代\n6. React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px \n7. JSX 允许在模板中插入数组，数组会自动展开所有成员\n8. 注释:在标签内部的注释需要花括号;在标签外的的注释不能使用花括号\n9. 可以使用双引号来指定字符串字面量作为属性值\n10. class 在JSX中变为className，tabindex 变为 tabIndex\n11. React DOM 使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称\n~~~\nReactDOM.render(\n    /*注释 */\n    <h1>孙朝阳 {/*注释*/}</h1>,\n    document.getElementById('example')\n);\n~~~\n12. 如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时十分有用\n~~~\nimport React from 'react';\n\nconst MyComponents = {\n  DatePicker: function DatePicker(props) {\n    return <div>Imagine a {props.color} datepicker here.</div>;\n  }\n}\n\nfunction BlueDatePicker() {\n  return <MyComponents.DatePicker color=\"blue\" />;\n}\n~~~\n13. JSX 中的 Children：在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children\n\n# 组件\n* 组件名称总是以大写字母开始\n* 组件有构造函数，构造函数的第一行应该是调用super函数，其参数为...args参数，在constructor方法中进行一些初始\n* 绑定事件的方式：onChange={this.函数名称.bind(this)}\n* 有狗那年，定时器中的this就不合适，在使用前通过_this=this保存一份，然后在定时中用_this代替\n* react处理了this，原生中如果要用this，最好也处理一下\n* react中阻止事件冒泡：ev.nativeEvent.stopImmediatePropergation\n* 父级属性传递给子级直接通过属性，子级属性传递给父级需要通过在父级绑定回调函数如cb()，在子级中通过this.props.cb(传递的参数)的方式把参数传递到父级\n* react中设置样式style需要通过双大括号}}来设置\n* 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识。keys 只在数组的上下文中存在意义； keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一\n* 自定义组件的方式如下：\n~~~\nclass 组件名称 extends React.Component{\n    render(){\n        retrun <span>我的年龄是：{this.props.age}</span>\n    }    \n}\n~~~\n~~~\n//定义\nclass Comp extends React.Component{\n    render(){\n        return <span>111</span>;\n    }\n}\n~~~\n* 组件使用：类似于标签的使用\n~~~\nReactDom.render(\n    <Comp age=\"18\"/>,//内容,类名\n    document.body//到哪\n); \n~~~\n~~~\nwindow.onload=function(){ \n    ReactDom.render(\n        <Comp/>,//内容,类名\n        document.body//到哪\n    ); \n};\n~~~ \n\n# 状态state\n* React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。\n* React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。\n* this.setState({属性：'值'});  \n* state(状态) 更新可能是异步的。React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。\n\n# 属性props\nstate 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据\n\n* 如果你没给 prop(属性) 传值，那么他默认为 true\n* 控制表单的value，如果用props设置了默认值，由于props是死的，不能修改，修改为defaultValue即可\n* 控制checkbox的默认值，修改为defalultChecked\n* 属性扩展:如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。以上两种方法等效：\n~~~\nfunction App1() {\n  return <Greeting firstName=\"Ben\" lastName=\"Hector\" />;\n}\n\nfunction App2() {\n  const props = {firstName: 'Ben', lastName: 'Hector'};\n  return <Greeting {...props} />;\n}\n~~~\n\n# 组件生命周期\n组件的生命周期可分成三个状态：\n1. Mounting：已插入真实 DOM\n2. Updating：正在被重新渲染\n3. Unmounting：已移出真实 DOM\n\n生命周期的方法有：\n* componentWillMount 在渲染前调用,在客户端也在服务端\n* componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)\n* componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用\n* shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用\n* componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用\n* componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用\n* componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。==当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求==\n\n# React Refs\n* React 支持一种非常特殊的属性 Ref ，可以用来绑定到 render() 输出的任何组件上。\n这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例\n* 可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用\n* ref 标示组件内的node，可以原生操作节点，在this.refs['ref名字']=原生\n* React 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行\n* 不能在函数式组件上使用 ref 属性，因为它们没有实例\n\n# 使用 Chrome Timeline 分析组件性能\n在 开发模式 中，你可以在支持相关功能的浏览器中使用性能工具来可视化组件 装载(mount) ，更新(update) 和 卸载(unmount) 的各个过程。在 Chrome 中具体操作如下： \n1. 通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf)\n2. 打开 Chrome DevTools Timeline 并点击 Record\n3. 执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起\n4. 停止记录\n5. 在 User Timing 标签下，React事件将会分组列出\n\n注意：上述数字是相对的，组件会在生产环境中会更快\n\n\n# route\nreact-router + react-router-redux: 前者是业界标准，后者可以同步 route 信息到 state，这样你可以在 view 根据 route 信息调整展现，以及通过 action 来修改 route 。","source":"_posts/react+rn/2018-10-26-React入门.md","raw":"---\ntitle: React入门\ntags:\n  - React \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:04:22\ncategories: React\npassword:\n---\n\n# 简介\n* React 是一个用于构建用户界面的 JAVASCRIPT 库\n* React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）\n* React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源\n* React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它\n* React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用\n* react有 函数式组件和类组件，现在的使用都以类组件为主，函数式组件不考虑\n* angualr霸道，用了之后原生定时器、jquery等都不能用，而react没有这个限制\n* react中对事件的大小写敏感，因为有一个编译过程\n* 相关有用网址\n~~~\n官网：https://facebook.github.io/react/\n中文网站：http://www.css88.com/react/\n中文论坛:http://react-china.org/\n~~~\n\n# react特点\n1. 声明式设计 −React采用声明范式，可以轻松描述应用。\n2. 高效 −虚拟DOM,React通过对DOM的模拟，最大限度地减少与DOM的交互。React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态\n3. 灵活 −React可以与已知的库或框架很好地配合。\n4. JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。\n5. 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。\n6. 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单\n\n# react全家桶（技术栈）\n> 如果一个技术你不知道，那说明你还用不上\n\n1. react：主体\n2. webpack、grunt、gulp自动化构建工具\n3. Flex：布局\n4. react-route：路由\n5. redux：view层\n6. Mocha：测试\n7. Istanbul：覆盖率\n\n# 安装\n## 网页使用\n网页中用babel会页面加载会有编译过程，比较缓慢，babel也可以后台编译\n~~~\n<script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"></script>\n<script type=\"text/babel\">\n  ReactDOM.render(\n    <h1>Hello, world!</h1>,\n    document.getElementById('example')\n  );\n</script>\n~~~\n引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js：\n1. react.min.js - React 的核心库\n2. react-dom.min.js - 提供与 DOM 相关的功能\n3. babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平\n\n## 使用 create-react-app 快速构建\n* create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。\n* create-react-app 自动创建的项目是基于 Webpack + ES6\n* create-react-app网址：https://github.com/facebookincubator/create-react-app\n* create-react-app说明：https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases\n~~~\n$ cnpm install -g create-react-app\n$ create-react-app my-app\n$ cd my-app/\n$ npm start\n~~~\n在浏览器中打开 http://localhost:3000/,查看结果\n\n# JSX\n> JSX是可选的，对于使用 React而言不需要\n\nReact 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。\n\n优点：\n* JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化，需babel编译后才能运行，bower babel install,官网：http://babeljs.io/\n* 它是类型安全的，在编译过程中就能发现错误\n* 使用 JSX 编写模板更加简单快速\n\n使用过程中的注意事项：\n1. 组件必须返回一个单独的根元素。render的内容必须有且仅有一个父元\n2. 网页中使用：\n~~~\n<script src=\"js/react.js\" charset=\"utf-8\"/></script>\n<script src=\"js/react-dom.js\" charset=\"utf-8\"/></script>\n<script src=\"js/browser.js\" charset=\"utf-8\"/></script>\n<script type=\"text/babel\">\n    window.onload=function(){\n        var oDiv = document.getElementById(\"div1\"); \n        ReactDom.render(\n            <span>111</span>,//内容\n            oDiv//到哪\n        ); \n    };\n</script>\n<body>\n    <div id=\"div1></div>\n</body>\n~~~\n3. 添加自定义属性需要使用 data- 前缀，因为jsx对html标签有识别，如果符合则不显示，而在自定义属性前面加data-可以保证显示显示\n4. 自定义组件可以单独文件存储\n5. 可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中；在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代\n6. React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px \n7. JSX 允许在模板中插入数组，数组会自动展开所有成员\n8. 注释:在标签内部的注释需要花括号;在标签外的的注释不能使用花括号\n9. 可以使用双引号来指定字符串字面量作为属性值\n10. class 在JSX中变为className，tabindex 变为 tabIndex\n11. React DOM 使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称\n~~~\nReactDOM.render(\n    /*注释 */\n    <h1>孙朝阳 {/*注释*/}</h1>,\n    document.getElementById('example')\n);\n~~~\n12. 如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时十分有用\n~~~\nimport React from 'react';\n\nconst MyComponents = {\n  DatePicker: function DatePicker(props) {\n    return <div>Imagine a {props.color} datepicker here.</div>;\n  }\n}\n\nfunction BlueDatePicker() {\n  return <MyComponents.DatePicker color=\"blue\" />;\n}\n~~~\n13. JSX 中的 Children：在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children\n\n# 组件\n* 组件名称总是以大写字母开始\n* 组件有构造函数，构造函数的第一行应该是调用super函数，其参数为...args参数，在constructor方法中进行一些初始\n* 绑定事件的方式：onChange={this.函数名称.bind(this)}\n* 有狗那年，定时器中的this就不合适，在使用前通过_this=this保存一份，然后在定时中用_this代替\n* react处理了this，原生中如果要用this，最好也处理一下\n* react中阻止事件冒泡：ev.nativeEvent.stopImmediatePropergation\n* 父级属性传递给子级直接通过属性，子级属性传递给父级需要通过在父级绑定回调函数如cb()，在子级中通过this.props.cb(传递的参数)的方式把参数传递到父级\n* react中设置样式style需要通过双大括号}}来设置\n* 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识。keys 只在数组的上下文中存在意义； keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一\n* 自定义组件的方式如下：\n~~~\nclass 组件名称 extends React.Component{\n    render(){\n        retrun <span>我的年龄是：{this.props.age}</span>\n    }    \n}\n~~~\n~~~\n//定义\nclass Comp extends React.Component{\n    render(){\n        return <span>111</span>;\n    }\n}\n~~~\n* 组件使用：类似于标签的使用\n~~~\nReactDom.render(\n    <Comp age=\"18\"/>,//内容,类名\n    document.body//到哪\n); \n~~~\n~~~\nwindow.onload=function(){ \n    ReactDom.render(\n        <Comp/>,//内容,类名\n        document.body//到哪\n    ); \n};\n~~~ \n\n# 状态state\n* React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。\n* React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。\n* this.setState({属性：'值'});  \n* state(状态) 更新可能是异步的。React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。\n\n# 属性props\nstate 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据\n\n* 如果你没给 prop(属性) 传值，那么他默认为 true\n* 控制表单的value，如果用props设置了默认值，由于props是死的，不能修改，修改为defaultValue即可\n* 控制checkbox的默认值，修改为defalultChecked\n* 属性扩展:如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。以上两种方法等效：\n~~~\nfunction App1() {\n  return <Greeting firstName=\"Ben\" lastName=\"Hector\" />;\n}\n\nfunction App2() {\n  const props = {firstName: 'Ben', lastName: 'Hector'};\n  return <Greeting {...props} />;\n}\n~~~\n\n# 组件生命周期\n组件的生命周期可分成三个状态：\n1. Mounting：已插入真实 DOM\n2. Updating：正在被重新渲染\n3. Unmounting：已移出真实 DOM\n\n生命周期的方法有：\n* componentWillMount 在渲染前调用,在客户端也在服务端\n* componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)\n* componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用\n* shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用\n* componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用\n* componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用\n* componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。==当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求==\n\n# React Refs\n* React 支持一种非常特殊的属性 Ref ，可以用来绑定到 render() 输出的任何组件上。\n这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例\n* 可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用\n* ref 标示组件内的node，可以原生操作节点，在this.refs['ref名字']=原生\n* React 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行\n* 不能在函数式组件上使用 ref 属性，因为它们没有实例\n\n# 使用 Chrome Timeline 分析组件性能\n在 开发模式 中，你可以在支持相关功能的浏览器中使用性能工具来可视化组件 装载(mount) ，更新(update) 和 卸载(unmount) 的各个过程。在 Chrome 中具体操作如下： \n1. 通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf)\n2. 打开 Chrome DevTools Timeline 并点击 Record\n3. 执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起\n4. 停止记录\n5. 在 User Timing 标签下，React事件将会分组列出\n\n注意：上述数字是相对的，组件会在生产环境中会更快\n\n\n# route\nreact-router + react-router-redux: 前者是业界标准，后者可以同步 route 信息到 state，这样你可以在 view 根据 route 信息调整展现，以及通过 action 来修改 route 。","slug":"react-rn-2018-10-26-React入门","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3f00de5b8h01d5bvmd","content":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>React 是一个用于构建用户界面的 JAVASCRIPT 库</li>\n<li>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）</li>\n<li>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源</li>\n<li>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它</li>\n<li>React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用</li>\n<li>react有 函数式组件和类组件，现在的使用都以类组件为主，函数式组件不考虑</li>\n<li>angualr霸道，用了之后原生定时器、jquery等都不能用，而react没有这个限制</li>\n<li>react中对事件的大小写敏感，因为有一个编译过程</li>\n<li>相关有用网址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">官网：https://facebook.github.io/react/</span><br><span class=\"line\">中文网站：http://www.css88.com/react/</span><br><span class=\"line\">中文论坛:http://react-china.org/</span><br></pre></td></tr></table></figure>\n<h1 id=\"react特点\"><a class=\"markdownIt-Anchor\" href=\"#react特点\"></a> react特点</h1>\n<ol>\n<li>声明式设计 −React采用声明范式，可以轻松描述应用。</li>\n<li>高效 −虚拟DOM,React通过对DOM的模拟，最大限度地减少与DOM的交互。React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态</li>\n<li>灵活 −React可以与已知的库或框架很好地配合。</li>\n<li>JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</li>\n<li>组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</li>\n<li>单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单</li>\n</ol>\n<h1 id=\"react全家桶技术栈\"><a class=\"markdownIt-Anchor\" href=\"#react全家桶技术栈\"></a> react全家桶（技术栈）</h1>\n<blockquote>\n<p>如果一个技术你不知道，那说明你还用不上</p>\n</blockquote>\n<ol>\n<li>react：主体</li>\n<li>webpack、grunt、gulp自动化构建工具</li>\n<li>Flex：布局</li>\n<li>react-route：路由</li>\n<li>redux：view层</li>\n<li>Mocha：测试</li>\n<li>Istanbul：覆盖率</li>\n</ol>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<h2 id=\"网页使用\"><a class=\"markdownIt-Anchor\" href=\"#网页使用\"></a> 网页使用</h2>\n<p>网页中用babel会页面加载会有编译过程，比较缓慢，babel也可以后台编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class=\"line\">    document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js：</p>\n<ol>\n<li>react.min.js - React 的核心库</li>\n<li>react-dom.min.js - 提供与 DOM 相关的功能</li>\n<li>babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平</li>\n</ol>\n<h2 id=\"使用-create-react-app-快速构建\"><a class=\"markdownIt-Anchor\" href=\"#使用-create-react-app-快速构建\"></a> 使用 create-react-app 快速构建</h2>\n<ul>\n<li>create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。</li>\n<li>create-react-app 自动创建的项目是基于 Webpack + ES6</li>\n<li>create-react-app网址：<a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"noopener\">https://github.com/facebookincubator/create-react-app</a></li>\n<li>create-react-app说明：<a href=\"https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases\" target=\"_blank\" rel=\"noopener\">https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g create-react-app</span><br><span class=\"line\">$ create-react-app my-app</span><br><span class=\"line\">$ cd my-app/</span><br><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure>\n<p>在浏览器中打开 <a href=\"http://localhost:3000/,%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/,查看结果</a></p>\n<h1 id=\"jsx\"><a class=\"markdownIt-Anchor\" href=\"#jsx\"></a> JSX</h1>\n<blockquote>\n<p>JSX是可选的，对于使用 React而言不需要</p>\n</blockquote>\n<p>React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。</p>\n<p>优点：</p>\n<ul>\n<li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化，需babel编译后才能运行，bower babel install,官网：<a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"noopener\">http://babeljs.io/</a></li>\n<li>它是类型安全的，在编译过程中就能发现错误</li>\n<li>使用 JSX 编写模板更加简单快速</li>\n</ul>\n<p>使用过程中的注意事项：</p>\n<ol>\n<li>组件必须返回一个单独的根元素。render的内容必须有且仅有一个父元</li>\n<li>网页中使用：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;js/react.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/react-dom.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/browser.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">    window.onload=function()&#123;</span><br><span class=\"line\">        var oDiv = document.getElementById(&quot;div1&quot;); </span><br><span class=\"line\">        ReactDom.render(</span><br><span class=\"line\">            &lt;span&gt;111&lt;/span&gt;,//内容</span><br><span class=\"line\">            oDiv//到哪</span><br><span class=\"line\">        ); </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div1&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>添加自定义属性需要使用 data- 前缀，因为jsx对html标签有识别，如果符合则不显示，而在自定义属性前面加data-可以保证显示显示</li>\n<li>自定义组件可以单独文件存储</li>\n<li>可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中；在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代</li>\n<li>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px</li>\n<li>JSX 允许在模板中插入数组，数组会自动展开所有成员</li>\n<li>注释:在标签内部的注释需要花括号;在标签外的的注释不能使用花括号</li>\n<li>可以使用双引号来指定字符串字面量作为属性值</li>\n<li>class 在JSX中变为className，tabindex 变为 tabIndex</li>\n<li>React DOM 使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    /*注释 */</span><br><span class=\"line\">    &lt;h1&gt;孙朝阳 &#123;/*注释*/&#125;&lt;/h1&gt;,</span><br><span class=\"line\">    document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ol start=\"12\">\n<li>如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时十分有用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const MyComponents = &#123;</span><br><span class=\"line\">  DatePicker: function DatePicker(props) &#123;</span><br><span class=\"line\">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function BlueDatePicker() &#123;</span><br><span class=\"line\">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>JSX 中的 Children：在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children</li>\n</ol>\n<h1 id=\"组件\"><a class=\"markdownIt-Anchor\" href=\"#组件\"></a> 组件</h1>\n<ul>\n<li>组件名称总是以大写字母开始</li>\n<li>组件有构造函数，构造函数的第一行应该是调用super函数，其参数为…args参数，在constructor方法中进行一些初始</li>\n<li>绑定事件的方式：onChange={this.函数名称.bind(this)}</li>\n<li>有狗那年，定时器中的this就不合适，在使用前通过_this=this保存一份，然后在定时中用_this代替</li>\n<li>react处理了this，原生中如果要用this，最好也处理一下</li>\n<li>react中阻止事件冒泡：ev.nativeEvent.stopImmediatePropergation</li>\n<li>父级属性传递给子级直接通过属性，子级属性传递给父级需要通过在父级绑定回调函数如cb()，在子级中通过this.props.cb(传递的参数)的方式把参数传递到父级</li>\n<li>react中设置样式style需要通过双大括号}}来设置</li>\n<li>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识。keys 只在数组的上下文中存在意义； keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一</li>\n<li>自定义组件的方式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 组件名称 extends React.Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        retrun &lt;span&gt;我的年龄是：&#123;this.props.age&#125;&lt;/span&gt;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">class Comp extends React.Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;span&gt;111&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组件使用：类似于标签的使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Comp age=&quot;18&quot;/&gt;,//内容,类名</span><br><span class=\"line\">    document.body//到哪</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload=function()&#123; </span><br><span class=\"line\">    ReactDom.render(</span><br><span class=\"line\">        &lt;Comp/&gt;,//内容,类名</span><br><span class=\"line\">        document.body//到哪</span><br><span class=\"line\">    ); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\"># 状态state</span><br><span class=\"line\">* React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</span><br><span class=\"line\">* React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</span><br><span class=\"line\">* this.setState(&#123;属性：&apos;值&apos;&#125;);  </span><br><span class=\"line\">* state(状态) 更新可能是异步的。React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。</span><br><span class=\"line\"></span><br><span class=\"line\"># 属性props</span><br><span class=\"line\">state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果你没给 prop(属性) 传值，那么他默认为 true</span><br><span class=\"line\">* 控制表单的value，如果用props设置了默认值，由于props是死的，不能修改，修改为defaultValue即可</span><br><span class=\"line\">* 控制checkbox的默认值，修改为defalultChecked</span><br><span class=\"line\">* 属性扩展:如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。以上两种方法等效：</span><br></pre></td></tr></table></figure>\n<p>function App1() {<br>\nreturn <greeting firstname=\"Ben\" lastname=\"Hector\">;<br>\n}</greeting></p>\n<p>function App2() {<br>\nconst props = {firstName: ‘Ben’, lastName: ‘Hector’};<br>\nreturn &lt;Greeting {…props} /&gt;;<br>\n}</p>\n<pre class=\"highlight\"><code class=\"\">\n# 组件生命周期\n组件的生命周期可分成三个状态：\n1. Mounting：已插入真实 DOM\n2. Updating：正在被重新渲染\n3. Unmounting：已移出真实 DOM\n\n生命周期的方法有：\n* componentWillMount 在渲染前调用,在客户端也在服务端\n* componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)\n* componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用\n* shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用\n* componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用\n* componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用\n* componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。==当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求==\n\n# React Refs\n* React 支持一种非常特殊的属性 Ref ，可以用来绑定到 render() 输出的任何组件上。\n这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例\n* 可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用\n* ref 标示组件内的node，可以原生操作节点，在this.refs['ref名字']=原生\n* React 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行\n* 不能在函数式组件上使用 ref 属性，因为它们没有实例\n\n# 使用 Chrome Timeline 分析组件性能\n在 开发模式 中，你可以在支持相关功能的浏览器中使用性能工具来可视化组件 装载(mount) ，更新(update) 和 卸载(unmount) 的各个过程。在 Chrome 中具体操作如下： \n1. 通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf)\n2. 打开 Chrome DevTools Timeline 并点击 Record\n3. 执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起\n4. 停止记录\n5. 在 User Timing 标签下，React事件将会分组列出\n\n注意：上述数字是相对的，组件会在生产环境中会更快\n\n\n# route\nreact-router + react-router-redux: 前者是业界标准，后者可以同步 route 信息到 state，这样你可以在 view 根据 route 信息调整展现，以及通过 action 来修改 route 。</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<ul>\n<li>React 是一个用于构建用户界面的 JAVASCRIPT 库</li>\n<li>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）</li>\n<li>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源</li>\n<li>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它</li>\n<li>React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用</li>\n<li>react有 函数式组件和类组件，现在的使用都以类组件为主，函数式组件不考虑</li>\n<li>angualr霸道，用了之后原生定时器、jquery等都不能用，而react没有这个限制</li>\n<li>react中对事件的大小写敏感，因为有一个编译过程</li>\n<li>相关有用网址</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">官网：https://facebook.github.io/react/</span><br><span class=\"line\">中文网站：http://www.css88.com/react/</span><br><span class=\"line\">中文论坛:http://react-china.org/</span><br></pre></td></tr></table></figure>\n<h1 id=\"react特点\"><a class=\"markdownIt-Anchor\" href=\"#react特点\"></a> react特点</h1>\n<ol>\n<li>声明式设计 −React采用声明范式，可以轻松描述应用。</li>\n<li>高效 −虚拟DOM,React通过对DOM的模拟，最大限度地减少与DOM的交互。React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态</li>\n<li>灵活 −React可以与已知的库或框架很好地配合。</li>\n<li>JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</li>\n<li>组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</li>\n<li>单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单</li>\n</ol>\n<h1 id=\"react全家桶技术栈\"><a class=\"markdownIt-Anchor\" href=\"#react全家桶技术栈\"></a> react全家桶（技术栈）</h1>\n<blockquote>\n<p>如果一个技术你不知道，那说明你还用不上</p>\n</blockquote>\n<ol>\n<li>react：主体</li>\n<li>webpack、grunt、gulp自动化构建工具</li>\n<li>Flex：布局</li>\n<li>react-route：路由</li>\n<li>redux：view层</li>\n<li>Mocha：测试</li>\n<li>Istanbul：覆盖率</li>\n</ol>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<h2 id=\"网页使用\"><a class=\"markdownIt-Anchor\" href=\"#网页使用\"></a> 网页使用</h2>\n<p>网页中用babel会页面加载会有编译过程，比较缓慢，babel也可以后台编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/react/15.4.2/react-dom.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class=\"line\">    document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js：</p>\n<ol>\n<li>react.min.js - React 的核心库</li>\n<li>react-dom.min.js - 提供与 DOM 相关的功能</li>\n<li>babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平</li>\n</ol>\n<h2 id=\"使用-create-react-app-快速构建\"><a class=\"markdownIt-Anchor\" href=\"#使用-create-react-app-快速构建\"></a> 使用 create-react-app 快速构建</h2>\n<ul>\n<li>create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。</li>\n<li>create-react-app 自动创建的项目是基于 Webpack + ES6</li>\n<li>create-react-app网址：<a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"noopener\">https://github.com/facebookincubator/create-react-app</a></li>\n<li>create-react-app说明：<a href=\"https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases\" target=\"_blank\" rel=\"noopener\">https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g create-react-app</span><br><span class=\"line\">$ create-react-app my-app</span><br><span class=\"line\">$ cd my-app/</span><br><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure>\n<p>在浏览器中打开 <a href=\"http://localhost:3000/,%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/,查看结果</a></p>\n<h1 id=\"jsx\"><a class=\"markdownIt-Anchor\" href=\"#jsx\"></a> JSX</h1>\n<blockquote>\n<p>JSX是可选的，对于使用 React而言不需要</p>\n</blockquote>\n<p>React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。</p>\n<p>优点：</p>\n<ul>\n<li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化，需babel编译后才能运行，bower babel install,官网：<a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"noopener\">http://babeljs.io/</a></li>\n<li>它是类型安全的，在编译过程中就能发现错误</li>\n<li>使用 JSX 编写模板更加简单快速</li>\n</ul>\n<p>使用过程中的注意事项：</p>\n<ol>\n<li>组件必须返回一个单独的根元素。render的内容必须有且仅有一个父元</li>\n<li>网页中使用：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;js/react.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/react-dom.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;js/browser.js&quot; charset=&quot;utf-8&quot;/&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">    window.onload=function()&#123;</span><br><span class=\"line\">        var oDiv = document.getElementById(&quot;div1&quot;); </span><br><span class=\"line\">        ReactDom.render(</span><br><span class=\"line\">            &lt;span&gt;111&lt;/span&gt;,//内容</span><br><span class=\"line\">            oDiv//到哪</span><br><span class=\"line\">        ); </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div1&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>添加自定义属性需要使用 data- 前缀，因为jsx对html标签有识别，如果符合则不显示，而在自定义属性前面加data-可以保证显示显示</li>\n<li>自定义组件可以单独文件存储</li>\n<li>可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中；在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代</li>\n<li>React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px</li>\n<li>JSX 允许在模板中插入数组，数组会自动展开所有成员</li>\n<li>注释:在标签内部的注释需要花括号;在标签外的的注释不能使用花括号</li>\n<li>可以使用双引号来指定字符串字面量作为属性值</li>\n<li>class 在JSX中变为className，tabindex 变为 tabIndex</li>\n<li>React DOM 使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    /*注释 */</span><br><span class=\"line\">    &lt;h1&gt;孙朝阳 &#123;/*注释*/&#125;&lt;/h1&gt;,</span><br><span class=\"line\">    document.getElementById(&apos;example&apos;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<ol start=\"12\">\n<li>如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时十分有用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const MyComponents = &#123;</span><br><span class=\"line\">  DatePicker: function DatePicker(props) &#123;</span><br><span class=\"line\">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function BlueDatePicker() &#123;</span><br><span class=\"line\">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>JSX 中的 Children：在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children</li>\n</ol>\n<h1 id=\"组件\"><a class=\"markdownIt-Anchor\" href=\"#组件\"></a> 组件</h1>\n<ul>\n<li>组件名称总是以大写字母开始</li>\n<li>组件有构造函数，构造函数的第一行应该是调用super函数，其参数为…args参数，在constructor方法中进行一些初始</li>\n<li>绑定事件的方式：onChange={this.函数名称.bind(this)}</li>\n<li>有狗那年，定时器中的this就不合适，在使用前通过_this=this保存一份，然后在定时中用_this代替</li>\n<li>react处理了this，原生中如果要用this，最好也处理一下</li>\n<li>react中阻止事件冒泡：ev.nativeEvent.stopImmediatePropergation</li>\n<li>父级属性传递给子级直接通过属性，子级属性传递给父级需要通过在父级绑定回调函数如cb()，在子级中通过this.props.cb(传递的参数)的方式把参数传递到父级</li>\n<li>react中设置样式style需要通过双大括号}}来设置</li>\n<li>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识。keys 只在数组的上下文中存在意义； keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一</li>\n<li>自定义组件的方式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 组件名称 extends React.Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        retrun &lt;span&gt;我的年龄是：&#123;this.props.age&#125;&lt;/span&gt;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">class Comp extends React.Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return &lt;span&gt;111&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组件使用：类似于标签的使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDom.render(</span><br><span class=\"line\">    &lt;Comp age=&quot;18&quot;/&gt;,//内容,类名</span><br><span class=\"line\">    document.body//到哪</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload=function()&#123; </span><br><span class=\"line\">    ReactDom.render(</span><br><span class=\"line\">        &lt;Comp/&gt;,//内容,类名</span><br><span class=\"line\">        document.body//到哪</span><br><span class=\"line\">    ); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\"># 状态state</span><br><span class=\"line\">* React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</span><br><span class=\"line\">* React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</span><br><span class=\"line\">* this.setState(&#123;属性：&apos;值&apos;&#125;);  </span><br><span class=\"line\">* state(状态) 更新可能是异步的。React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。</span><br><span class=\"line\"></span><br><span class=\"line\"># 属性props</span><br><span class=\"line\">state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果你没给 prop(属性) 传值，那么他默认为 true</span><br><span class=\"line\">* 控制表单的value，如果用props设置了默认值，由于props是死的，不能修改，修改为defaultValue即可</span><br><span class=\"line\">* 控制checkbox的默认值，修改为defalultChecked</span><br><span class=\"line\">* 属性扩展:如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。以上两种方法等效：</span><br></pre></td></tr></table></figure>\n<p>function App1() {<br>\nreturn <greeting firstname=\"Ben\" lastname=\"Hector\">;<br>\n}</greeting></p>\n<p>function App2() {<br>\nconst props = {firstName: ‘Ben’, lastName: ‘Hector’};<br>\nreturn &lt;Greeting {…props} /&gt;;<br>\n}</p>\n<pre class=\"highlight\"><code class=\"\">\n# 组件生命周期\n组件的生命周期可分成三个状态：\n1. Mounting：已插入真实 DOM\n2. Updating：正在被重新渲染\n3. Unmounting：已移出真实 DOM\n\n生命周期的方法有：\n* componentWillMount 在渲染前调用,在客户端也在服务端\n* componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)\n* componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用\n* shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用\n* componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用\n* componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用\n* componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。==当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求==\n\n# React Refs\n* React 支持一种非常特殊的属性 Ref ，可以用来绑定到 render() 输出的任何组件上。\n这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例\n* 可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用\n* ref 标示组件内的node，可以原生操作节点，在this.refs['ref名字']=原生\n* React 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行\n* 不能在函数式组件上使用 ref 属性，因为它们没有实例\n\n# 使用 Chrome Timeline 分析组件性能\n在 开发模式 中，你可以在支持相关功能的浏览器中使用性能工具来可视化组件 装载(mount) ，更新(update) 和 卸载(unmount) 的各个过程。在 Chrome 中具体操作如下： \n1. 通过添加 ?react_perf 查询字段加载你的应用(例如：http://localhost:3000/?react_perf)\n2. 打开 Chrome DevTools Timeline 并点击 Record\n3. 执行你想要分析的操作，不要超过20秒，否则 Chrome 可能会挂起\n4. 停止记录\n5. 在 User Timing 标签下，React事件将会分组列出\n\n注意：上述数字是相对的，组件会在生产环境中会更快\n\n\n# route\nreact-router + react-router-redux: 前者是业界标准，后者可以同步 route 信息到 state，这样你可以在 view 根据 route 信息调整展现，以及通过 action 来修改 route 。</code></pre>\n"},{"title":"Redux入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T07:20:26.000Z","password":null,"_content":"~~~\nhttp://redux.js.org/\nhttp://www.redux.org.cn/\nhttp://www.imooc.com/learn/744  视频教程\n~~~\n\n# 简介\nRedux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性\n\n~~~\nimport { createStore } from 'redux';\n\n/**\n * 这是一个 reducer，形式为 (state, action) => state 的纯函数。\n * 描述了 action 如何把 state 转变成下一个 state。\n *\n * state 的形式取决于你，可以是基本类型、数组、对象、\n * 甚至是 Immutable.js 生成的数据结构。惟一的要点是\n * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。\n *\n * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)\n * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。\n */\nfunction counter(state = 0, action) {\n  switch (action.type) {\n  case 'INCREMENT':\n    return state + 1;\n  case 'DECREMENT':\n    return state - 1;\n  default:\n    return state;\n  }\n}\n\n// 创建 Redux store 来存放应用的状态。\n// API 是 { subscribe, dispatch, getState }。\nlet store = createStore(counter);\n\n// 可以手动订阅更新，也可以事件绑定到视图层。\nstore.subscribe(() =>\n  console.log(store.getState())\n);\n\n// 改变内部 state 惟一方法是 dispatch 一个 action。\n// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行\nstore.dispatch({ type: 'INCREMENT' });\n// 1\nstore.dispatch({ type: 'INCREMENT' });\n// 2\nstore.dispatch({ type: 'DECREMENT' });\n// 1\n~~~\n\nRedux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）\n\n![image](http://note.youdao.com/yws/api/personal/file/WEBe992302275f8c8d667e0a308299fd566?method=download&shareKey=f1d0d83b8281356a94bc605858349a2d)\n\n## 中间件\n~~~\nredux-thunk — 用最简单的方式搭建异步 action 构造器\nredux-promise — 遵从 FSA 标准的 promise 中间件\nredux-axios-middleware — 使用 axios HTTP 客户端获取数据的 Redux 中间件\nredux-observable — Redux 的 RxJS 中间件\nredux-rx — 给 Redux 用的 RxJS 工具，包括观察变量的中间件\nredux-logger — 记录所有 Redux action 和下一次 state 的日志\nredux-immutable-state-invariant — 开发中的状态变更提醒\nredux-unhandled-action — 开发过程中，若 Action 未使 State 发生变化则发出警告\nredux-analytics — Redux middleware 分析\nredux-gen — Redux middleware 生成器\nredux-saga — Redux 应用的另一种副作用 model\nredux-action-tree — Redux 的可组合性 Cerebral-style 信号\napollo-client — 针对 GraphQL 服务器及基于 Redux 的 UI 框架的缓存客户端\n~~~\n\n# 三大原则\nRedux 可以用这三个基本原则来描述：\n## 单一数据源\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中\n\n## State 是只读的\n惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象\n\n## 使用纯函数来执行修改\n为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state\n\n## 总结\n1. 应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中\n2. 惟一改变 state 的办法是触发 action，一个描述发生什么的对象\n3. 为了描述 action 如何改变 state 树，你需要编写 reducers\n4. 编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 reducer\n\n# 安装\n1. 安装redux：npm install redux --save \n2. 使用 React 绑定库和开发者工具：npm install  react-redux --save；npm install redux-devtools --save-dev\n\n# 原理\n![image](/pub-images/redux组件配合原理.png)\n\n# Action\nAction 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源。一般来说会通过 store.dispatch() 将 action 传到 store。\n\naction 内必须使用一个字符串类型的 type 字段来表示将要执行的动作.多数情况下，type 会被定义成字符串常量,建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由自己决定\n~~~\nimport { ADD_TODO, REMOVE_TODO } from '../actionTypes'\n~~~\n## Action 创建函数\nAction 创建函数 就是生成 action 的方法\n~~~\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n~~~\nbindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。\n\n# Reducer\n永远不要在 reducer 里做这些操作：\n1. 修改传入参数；\n2. 执行有副作用的操作，如 API 请求和路由跳转；\n3. 调用非纯函数，如 Date.now() 或 Math.random()\n\n~~~\nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    default:\n      return state\n  }\n}\n~~~\n1. 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { ...state, ...newState } 达到相同的目的。\n2. 在 default 情况下返回旧的 state\n3. Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。\n4. 新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的\n\n# Store\nStore 有以下职责：\n1. 维持应用的 state；\n2. 提供 getState() 方法获取 state；\n3. 提供 dispatch(action) 方法更新 state；\n4. 通过 subscribe(listener) 注册监听器;\n5. 通过 subscribe(listener) 返回的函数注销监听器\n \n# 搭配react\nRedux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。\n\n连接到 Redux：我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch actions 以及从 Redux store 读取到 state\n1. 获取从之前安装好的 react-redux 提供的 Provider，并且在渲染之前将根组件包装进 <Provider>\n~~~\n//index.js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport todoApp from './reducers'\n\nlet store = createStore(todoApp);\n\nlet rootElement = document.getElementById('root')\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n)\n~~~\n2. 通过 react-redux 提供的 connect() 方法将包装好的组件连接到Redux\n~~~\nimport React, { Component, PropTypes } from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo, completeTodo, setVisibilityFilter, VisibilityFilters } from '../actions';\nimport AddTodo from '../components/AddTodo';\nimport TodoList from '../components/TodoList';\nimport Footer from '../components/Footer';\n\nclass App extends Component {\n  render() {\n    // 通过调用 connect() 注入:\n    const { dispatch, visibleTodos, visibilityFilter } = this.props\n    return (\n      <div>\n        <AddTodo\n          onAddClick={text =>\n            dispatch(addTodo(text))\n          } />\n        <TodoList\n          todos={this.props.visibleTodos}\n          onTodoClick={index =>\n            dispatch(completeTodo(index))\n          } />\n        <Footer\n          filter={visibilityFilter}\n          onFilterChange={nextFilter =>\n            dispatch(setVisibilityFilter(nextFilter))\n          } />\n      </div>\n    )\n  }\n}\n\nApp.propTypes = {\n  visibleTodos: PropTypes.arrayOf(PropTypes.shape({\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired\n  })),\n  visibilityFilter: PropTypes.oneOf([\n    'SHOW_ALL',\n    'SHOW_COMPLETED',\n    'SHOW_ACTIVE'\n  ]).isRequired\n}\n\nfunction selectTodos(todos, filter) {\n  switch (filter) {\n  case VisibilityFilters.SHOW_ALL:\n    return todos;\n  case VisibilityFilters.SHOW_COMPLETED:\n    return todos.filter(todo => todo.completed);\n  case VisibilityFilters.SHOW_ACTIVE:\n    return todos.filter(todo => !todo.completed);\n  }\n}\n\n// 基于全局 state ，哪些是我们想注入的 props ?\n// 注意：使用 https://github.com/reactjs/reselect 效果更佳。\nfunction select(state) {\n  return {\n    visibleTodos: selectTodos(state.todos, state.visibilityFilter),\n    visibilityFilter: state.visibilityFilter\n  };\n}\n\n// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；\nexport default connect(select)(App);\n~~~\n\n","source":"_posts/react+rn/2018-10-26-Redux入门.md","raw":"---\ntitle: Redux入门\ntags:\n  - React\n  - Redux\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 15:20:26\ncategories: React\npassword:\n---\n~~~\nhttp://redux.js.org/\nhttp://www.redux.org.cn/\nhttp://www.imooc.com/learn/744  视频教程\n~~~\n\n# 简介\nRedux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性\n\n~~~\nimport { createStore } from 'redux';\n\n/**\n * 这是一个 reducer，形式为 (state, action) => state 的纯函数。\n * 描述了 action 如何把 state 转变成下一个 state。\n *\n * state 的形式取决于你，可以是基本类型、数组、对象、\n * 甚至是 Immutable.js 生成的数据结构。惟一的要点是\n * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。\n *\n * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)\n * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。\n */\nfunction counter(state = 0, action) {\n  switch (action.type) {\n  case 'INCREMENT':\n    return state + 1;\n  case 'DECREMENT':\n    return state - 1;\n  default:\n    return state;\n  }\n}\n\n// 创建 Redux store 来存放应用的状态。\n// API 是 { subscribe, dispatch, getState }。\nlet store = createStore(counter);\n\n// 可以手动订阅更新，也可以事件绑定到视图层。\nstore.subscribe(() =>\n  console.log(store.getState())\n);\n\n// 改变内部 state 惟一方法是 dispatch 一个 action。\n// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行\nstore.dispatch({ type: 'INCREMENT' });\n// 1\nstore.dispatch({ type: 'INCREMENT' });\n// 2\nstore.dispatch({ type: 'DECREMENT' });\n// 1\n~~~\n\nRedux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）\n\n![image](http://note.youdao.com/yws/api/personal/file/WEBe992302275f8c8d667e0a308299fd566?method=download&shareKey=f1d0d83b8281356a94bc605858349a2d)\n\n## 中间件\n~~~\nredux-thunk — 用最简单的方式搭建异步 action 构造器\nredux-promise — 遵从 FSA 标准的 promise 中间件\nredux-axios-middleware — 使用 axios HTTP 客户端获取数据的 Redux 中间件\nredux-observable — Redux 的 RxJS 中间件\nredux-rx — 给 Redux 用的 RxJS 工具，包括观察变量的中间件\nredux-logger — 记录所有 Redux action 和下一次 state 的日志\nredux-immutable-state-invariant — 开发中的状态变更提醒\nredux-unhandled-action — 开发过程中，若 Action 未使 State 发生变化则发出警告\nredux-analytics — Redux middleware 分析\nredux-gen — Redux middleware 生成器\nredux-saga — Redux 应用的另一种副作用 model\nredux-action-tree — Redux 的可组合性 Cerebral-style 信号\napollo-client — 针对 GraphQL 服务器及基于 Redux 的 UI 框架的缓存客户端\n~~~\n\n# 三大原则\nRedux 可以用这三个基本原则来描述：\n## 单一数据源\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中\n\n## State 是只读的\n惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象\n\n## 使用纯函数来执行修改\n为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state\n\n## 总结\n1. 应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中\n2. 惟一改变 state 的办法是触发 action，一个描述发生什么的对象\n3. 为了描述 action 如何改变 state 树，你需要编写 reducers\n4. 编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 reducer\n\n# 安装\n1. 安装redux：npm install redux --save \n2. 使用 React 绑定库和开发者工具：npm install  react-redux --save；npm install redux-devtools --save-dev\n\n# 原理\n![image](/pub-images/redux组件配合原理.png)\n\n# Action\nAction 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源。一般来说会通过 store.dispatch() 将 action 传到 store。\n\naction 内必须使用一个字符串类型的 type 字段来表示将要执行的动作.多数情况下，type 会被定义成字符串常量,建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由自己决定\n~~~\nimport { ADD_TODO, REMOVE_TODO } from '../actionTypes'\n~~~\n## Action 创建函数\nAction 创建函数 就是生成 action 的方法\n~~~\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n~~~\nbindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。\n\n# Reducer\n永远不要在 reducer 里做这些操作：\n1. 修改传入参数；\n2. 执行有副作用的操作，如 API 请求和路由跳转；\n3. 调用非纯函数，如 Date.now() 或 Math.random()\n\n~~~\nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    default:\n      return state\n  }\n}\n~~~\n1. 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { ...state, ...newState } 达到相同的目的。\n2. 在 default 情况下返回旧的 state\n3. Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。\n4. 新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的\n\n# Store\nStore 有以下职责：\n1. 维持应用的 state；\n2. 提供 getState() 方法获取 state；\n3. 提供 dispatch(action) 方法更新 state；\n4. 通过 subscribe(listener) 注册监听器;\n5. 通过 subscribe(listener) 返回的函数注销监听器\n \n# 搭配react\nRedux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。\n\n连接到 Redux：我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch actions 以及从 Redux store 读取到 state\n1. 获取从之前安装好的 react-redux 提供的 Provider，并且在渲染之前将根组件包装进 <Provider>\n~~~\n//index.js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport todoApp from './reducers'\n\nlet store = createStore(todoApp);\n\nlet rootElement = document.getElementById('root')\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n)\n~~~\n2. 通过 react-redux 提供的 connect() 方法将包装好的组件连接到Redux\n~~~\nimport React, { Component, PropTypes } from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo, completeTodo, setVisibilityFilter, VisibilityFilters } from '../actions';\nimport AddTodo from '../components/AddTodo';\nimport TodoList from '../components/TodoList';\nimport Footer from '../components/Footer';\n\nclass App extends Component {\n  render() {\n    // 通过调用 connect() 注入:\n    const { dispatch, visibleTodos, visibilityFilter } = this.props\n    return (\n      <div>\n        <AddTodo\n          onAddClick={text =>\n            dispatch(addTodo(text))\n          } />\n        <TodoList\n          todos={this.props.visibleTodos}\n          onTodoClick={index =>\n            dispatch(completeTodo(index))\n          } />\n        <Footer\n          filter={visibilityFilter}\n          onFilterChange={nextFilter =>\n            dispatch(setVisibilityFilter(nextFilter))\n          } />\n      </div>\n    )\n  }\n}\n\nApp.propTypes = {\n  visibleTodos: PropTypes.arrayOf(PropTypes.shape({\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired\n  })),\n  visibilityFilter: PropTypes.oneOf([\n    'SHOW_ALL',\n    'SHOW_COMPLETED',\n    'SHOW_ACTIVE'\n  ]).isRequired\n}\n\nfunction selectTodos(todos, filter) {\n  switch (filter) {\n  case VisibilityFilters.SHOW_ALL:\n    return todos;\n  case VisibilityFilters.SHOW_COMPLETED:\n    return todos.filter(todo => todo.completed);\n  case VisibilityFilters.SHOW_ACTIVE:\n    return todos.filter(todo => !todo.completed);\n  }\n}\n\n// 基于全局 state ，哪些是我们想注入的 props ?\n// 注意：使用 https://github.com/reactjs/reselect 效果更佳。\nfunction select(state) {\n  return {\n    visibleTodos: selectTodos(state.todos, state.visibilityFilter),\n    visibilityFilter: state.visibilityFilter\n  };\n}\n\n// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；\nexport default connect(select)(App);\n~~~\n\n","slug":"react-rn-2018-10-26-Redux入门","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3h00df5b8htploeigb","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://redux.js.org/</span><br><span class=\"line\">http://www.redux.org.cn/</span><br><span class=\"line\">http://www.imooc.com/learn/744  视频教程</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。</span><br><span class=\"line\"> * 描述了 action 如何把 state 转变成下一个 state。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * state 的形式取决于你，可以是基本类型、数组、对象、</span><br><span class=\"line\"> * 甚至是 Immutable.js 生成的数据结构。惟一的要点是</span><br><span class=\"line\"> * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)</span><br><span class=\"line\"> * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。</span><br><span class=\"line\"> */</span><br><span class=\"line\">function counter(state = 0, action) &#123;</span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">  case &apos;INCREMENT&apos;:</span><br><span class=\"line\">    return state + 1;</span><br><span class=\"line\">  case &apos;DECREMENT&apos;:</span><br><span class=\"line\">    return state - 1;</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建 Redux store 来存放应用的状态。</span><br><span class=\"line\">// API 是 &#123; subscribe, dispatch, getState &#125;。</span><br><span class=\"line\">let store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以手动订阅更新，也可以事件绑定到视图层。</span><br><span class=\"line\">store.subscribe(() =&gt;</span><br><span class=\"line\">  console.log(store.getState())</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">// 改变内部 state 惟一方法是 dispatch 一个 action。</span><br><span class=\"line\">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span><br><span class=\"line\">store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);</span><br><span class=\"line\">// 1</span><br><span class=\"line\">store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);</span><br><span class=\"line\">// 2</span><br><span class=\"line\">store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;);</span><br><span class=\"line\">// 1</span><br></pre></td></tr></table></figure>\n<p>Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEBe992302275f8c8d667e0a308299fd566?method=download&amp;shareKey=f1d0d83b8281356a94bc605858349a2d\" alt=\"image\"></p>\n<h2 id=\"中间件\"><a class=\"markdownIt-Anchor\" href=\"#中间件\"></a> 中间件</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redux-thunk — 用最简单的方式搭建异步 action 构造器</span><br><span class=\"line\">redux-promise — 遵从 FSA 标准的 promise 中间件</span><br><span class=\"line\">redux-axios-middleware — 使用 axios HTTP 客户端获取数据的 Redux 中间件</span><br><span class=\"line\">redux-observable — Redux 的 RxJS 中间件</span><br><span class=\"line\">redux-rx — 给 Redux 用的 RxJS 工具，包括观察变量的中间件</span><br><span class=\"line\">redux-logger — 记录所有 Redux action 和下一次 state 的日志</span><br><span class=\"line\">redux-immutable-state-invariant — 开发中的状态变更提醒</span><br><span class=\"line\">redux-unhandled-action — 开发过程中，若 Action 未使 State 发生变化则发出警告</span><br><span class=\"line\">redux-analytics — Redux middleware 分析</span><br><span class=\"line\">redux-gen — Redux middleware 生成器</span><br><span class=\"line\">redux-saga — Redux 应用的另一种副作用 model</span><br><span class=\"line\">redux-action-tree — Redux 的可组合性 Cerebral-style 信号</span><br><span class=\"line\">apollo-client — 针对 GraphQL 服务器及基于 Redux 的 UI 框架的缓存客户端</span><br></pre></td></tr></table></figure>\n<h1 id=\"三大原则\"><a class=\"markdownIt-Anchor\" href=\"#三大原则\"></a> 三大原则</h1>\n<p>Redux 可以用这三个基本原则来描述：</p>\n<h2 id=\"单一数据源\"><a class=\"markdownIt-Anchor\" href=\"#单一数据源\"></a> 单一数据源</h2>\n<p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中</p>\n<h2 id=\"state-是只读的\"><a class=\"markdownIt-Anchor\" href=\"#state-是只读的\"></a> State 是只读的</h2>\n<p>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象</p>\n<h2 id=\"使用纯函数来执行修改\"><a class=\"markdownIt-Anchor\" href=\"#使用纯函数来执行修改\"></a> 使用纯函数来执行修改</h2>\n<p>为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<ol>\n<li>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中</li>\n<li>惟一改变 state 的办法是触发 action，一个描述发生什么的对象</li>\n<li>为了描述 action 如何改变 state 树，你需要编写 reducers</li>\n<li>编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 reducer</li>\n</ol>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<ol>\n<li>安装redux：npm install redux --save</li>\n<li>使用 React 绑定库和开发者工具：npm install  react-redux --save；npm install redux-devtools --save-dev</li>\n</ol>\n<h1 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h1>\n<p><img src=\"/pub-images/redux%E7%BB%84%E4%BB%B6%E9%85%8D%E5%90%88%E5%8E%9F%E7%90%86.png\" alt=\"image\"></p>\n<h1 id=\"action\"><a class=\"markdownIt-Anchor\" href=\"#action\"></a> Action</h1>\n<p>Action 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源。一般来说会通过 store.dispatch() 将 action 传到 store。</p>\n<p>action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作.多数情况下，type 会被定义成字符串常量,建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由自己决定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; ADD_TODO, REMOVE_TODO &#125; from &apos;../actionTypes&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"action-创建函数\"><a class=\"markdownIt-Anchor\" href=\"#action-创建函数\"></a> Action 创建函数</h2>\n<p>Action 创建函数 就是生成 action 的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addTodo(text) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。</p>\n<h1 id=\"reducer\"><a class=\"markdownIt-Anchor\" href=\"#reducer\"></a> Reducer</h1>\n<p>永远不要在 reducer 里做这些操作：</p>\n<ol>\n<li>修改传入参数；</li>\n<li>执行有副作用的操作，如 API 请求和路由跳转；</li>\n<li>调用非纯函数，如 Date.now() 或 Math.random()</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function todoApp(state = initialState, action) &#123;</span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">    case SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        visibilityFilter: action.filter</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    case ADD_TODO:</span><br><span class=\"line\">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          ...state.todos,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            text: action.text,</span><br><span class=\"line\">            completed: false</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      return state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。</li>\n<li>在 default 情况下返回旧的 state</li>\n<li>Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。</li>\n<li>新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的</li>\n</ol>\n<h1 id=\"store\"><a class=\"markdownIt-Anchor\" href=\"#store\"></a> Store</h1>\n<p>Store 有以下职责：</p>\n<ol>\n<li>维持应用的 state；</li>\n<li>提供 getState() 方法获取 state；</li>\n<li>提供 dispatch(action) 方法更新 state；</li>\n<li>通过 subscribe(listener) 注册监听器;</li>\n<li>通过 subscribe(listener) 返回的函数注销监听器</li>\n</ol>\n<h1 id=\"搭配react\"><a class=\"markdownIt-Anchor\" href=\"#搭配react\"></a> 搭配react</h1>\n<p>Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>\n<p>连接到 Redux：我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch actions 以及从 Redux store 读取到 state</p>\n<ol>\n<li>获取从之前安装好的 react-redux 提供的 Provider，并且在渲染之前将根组件包装进 <provider></provider></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//index.js</span><br><span class=\"line\">import React from &apos;react&apos;</span><br><span class=\"line\">import &#123; render &#125; from &apos;react-dom&apos;</span><br><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class=\"line\">import &#123; Provider &#125; from &apos;react-redux&apos;</span><br><span class=\"line\">import App from &apos;./containers/App&apos;</span><br><span class=\"line\">import todoApp from &apos;./reducers&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">let store = createStore(todoApp);</span><br><span class=\"line\"></span><br><span class=\"line\">let rootElement = document.getElementById(&apos;root&apos;)</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  rootElement</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过 react-redux 提供的 connect() 方法将包装好的组件连接到Redux</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class=\"line\">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class=\"line\">import &#123; addTodo, completeTodo, setVisibilityFilter, VisibilityFilters &#125; from &apos;../actions&apos;;</span><br><span class=\"line\">import AddTodo from &apos;../components/AddTodo&apos;;</span><br><span class=\"line\">import TodoList from &apos;../components/TodoList&apos;;</span><br><span class=\"line\">import Footer from &apos;../components/Footer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    // 通过调用 connect() 注入:</span><br><span class=\"line\">    const &#123; dispatch, visibleTodos, visibilityFilter &#125; = this.props</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;AddTodo</span><br><span class=\"line\">          onAddClick=&#123;text =&gt;</span><br><span class=\"line\">            dispatch(addTodo(text))</span><br><span class=\"line\">          &#125; /&gt;</span><br><span class=\"line\">        &lt;TodoList</span><br><span class=\"line\">          todos=&#123;this.props.visibleTodos&#125;</span><br><span class=\"line\">          onTodoClick=&#123;index =&gt;</span><br><span class=\"line\">            dispatch(completeTodo(index))</span><br><span class=\"line\">          &#125; /&gt;</span><br><span class=\"line\">        &lt;Footer</span><br><span class=\"line\">          filter=&#123;visibilityFilter&#125;</span><br><span class=\"line\">          onFilterChange=&#123;nextFilter =&gt;</span><br><span class=\"line\">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class=\"line\">          &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.propTypes = &#123;</span><br><span class=\"line\">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class=\"line\">    text: PropTypes.string.isRequired,</span><br><span class=\"line\">    completed: PropTypes.bool.isRequired</span><br><span class=\"line\">  &#125;)),</span><br><span class=\"line\">  visibilityFilter: PropTypes.oneOf([</span><br><span class=\"line\">    &apos;SHOW_ALL&apos;,</span><br><span class=\"line\">    &apos;SHOW_COMPLETED&apos;,</span><br><span class=\"line\">    &apos;SHOW_ACTIVE&apos;</span><br><span class=\"line\">  ]).isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function selectTodos(todos, filter) &#123;</span><br><span class=\"line\">  switch (filter) &#123;</span><br><span class=\"line\">  case VisibilityFilters.SHOW_ALL:</span><br><span class=\"line\">    return todos;</span><br><span class=\"line\">  case VisibilityFilters.SHOW_COMPLETED:</span><br><span class=\"line\">    return todos.filter(todo =&gt; todo.completed);</span><br><span class=\"line\">  case VisibilityFilters.SHOW_ACTIVE:</span><br><span class=\"line\">    return todos.filter(todo =&gt; !todo.completed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 基于全局 state ，哪些是我们想注入的 props ?</span><br><span class=\"line\">// 注意：使用 https://github.com/reactjs/reselect 效果更佳。</span><br><span class=\"line\">function select(state) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visibleTodos: selectTodos(state.todos, state.visibilityFilter),</span><br><span class=\"line\">    visibilityFilter: state.visibilityFilter</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；</span><br><span class=\"line\">export default connect(select)(App);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://redux.js.org/</span><br><span class=\"line\">http://www.redux.org.cn/</span><br><span class=\"line\">http://www.imooc.com/learn/744  视频教程</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。</span><br><span class=\"line\"> * 描述了 action 如何把 state 转变成下一个 state。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * state 的形式取决于你，可以是基本类型、数组、对象、</span><br><span class=\"line\"> * 甚至是 Immutable.js 生成的数据结构。惟一的要点是</span><br><span class=\"line\"> * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)</span><br><span class=\"line\"> * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。</span><br><span class=\"line\"> */</span><br><span class=\"line\">function counter(state = 0, action) &#123;</span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">  case &apos;INCREMENT&apos;:</span><br><span class=\"line\">    return state + 1;</span><br><span class=\"line\">  case &apos;DECREMENT&apos;:</span><br><span class=\"line\">    return state - 1;</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建 Redux store 来存放应用的状态。</span><br><span class=\"line\">// API 是 &#123; subscribe, dispatch, getState &#125;。</span><br><span class=\"line\">let store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以手动订阅更新，也可以事件绑定到视图层。</span><br><span class=\"line\">store.subscribe(() =&gt;</span><br><span class=\"line\">  console.log(store.getState())</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">// 改变内部 state 惟一方法是 dispatch 一个 action。</span><br><span class=\"line\">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span><br><span class=\"line\">store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);</span><br><span class=\"line\">// 1</span><br><span class=\"line\">store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;);</span><br><span class=\"line\">// 2</span><br><span class=\"line\">store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;);</span><br><span class=\"line\">// 1</span><br></pre></td></tr></table></figure>\n<p>Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEBe992302275f8c8d667e0a308299fd566?method=download&amp;shareKey=f1d0d83b8281356a94bc605858349a2d\" alt=\"image\"></p>\n<h2 id=\"中间件\"><a class=\"markdownIt-Anchor\" href=\"#中间件\"></a> 中间件</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redux-thunk — 用最简单的方式搭建异步 action 构造器</span><br><span class=\"line\">redux-promise — 遵从 FSA 标准的 promise 中间件</span><br><span class=\"line\">redux-axios-middleware — 使用 axios HTTP 客户端获取数据的 Redux 中间件</span><br><span class=\"line\">redux-observable — Redux 的 RxJS 中间件</span><br><span class=\"line\">redux-rx — 给 Redux 用的 RxJS 工具，包括观察变量的中间件</span><br><span class=\"line\">redux-logger — 记录所有 Redux action 和下一次 state 的日志</span><br><span class=\"line\">redux-immutable-state-invariant — 开发中的状态变更提醒</span><br><span class=\"line\">redux-unhandled-action — 开发过程中，若 Action 未使 State 发生变化则发出警告</span><br><span class=\"line\">redux-analytics — Redux middleware 分析</span><br><span class=\"line\">redux-gen — Redux middleware 生成器</span><br><span class=\"line\">redux-saga — Redux 应用的另一种副作用 model</span><br><span class=\"line\">redux-action-tree — Redux 的可组合性 Cerebral-style 信号</span><br><span class=\"line\">apollo-client — 针对 GraphQL 服务器及基于 Redux 的 UI 框架的缓存客户端</span><br></pre></td></tr></table></figure>\n<h1 id=\"三大原则\"><a class=\"markdownIt-Anchor\" href=\"#三大原则\"></a> 三大原则</h1>\n<p>Redux 可以用这三个基本原则来描述：</p>\n<h2 id=\"单一数据源\"><a class=\"markdownIt-Anchor\" href=\"#单一数据源\"></a> 单一数据源</h2>\n<p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中</p>\n<h2 id=\"state-是只读的\"><a class=\"markdownIt-Anchor\" href=\"#state-是只读的\"></a> State 是只读的</h2>\n<p>惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象</p>\n<h2 id=\"使用纯函数来执行修改\"><a class=\"markdownIt-Anchor\" href=\"#使用纯函数来执行修改\"></a> 使用纯函数来执行修改</h2>\n<p>为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<ol>\n<li>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中</li>\n<li>惟一改变 state 的办法是触发 action，一个描述发生什么的对象</li>\n<li>为了描述 action 如何改变 state 树，你需要编写 reducers</li>\n<li>编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 reducer</li>\n</ol>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<ol>\n<li>安装redux：npm install redux --save</li>\n<li>使用 React 绑定库和开发者工具：npm install  react-redux --save；npm install redux-devtools --save-dev</li>\n</ol>\n<h1 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h1>\n<p><img src=\"/pub-images/redux%E7%BB%84%E4%BB%B6%E9%85%8D%E5%90%88%E5%8E%9F%E7%90%86.png\" alt=\"image\"></p>\n<h1 id=\"action\"><a class=\"markdownIt-Anchor\" href=\"#action\"></a> Action</h1>\n<p>Action 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源。一般来说会通过 store.dispatch() 将 action 传到 store。</p>\n<p>action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作.多数情况下，type 会被定义成字符串常量,建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由自己决定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; ADD_TODO, REMOVE_TODO &#125; from &apos;../actionTypes&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"action-创建函数\"><a class=\"markdownIt-Anchor\" href=\"#action-创建函数\"></a> Action 创建函数</h2>\n<p>Action 创建函数 就是生成 action 的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addTodo(text) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。</p>\n<h1 id=\"reducer\"><a class=\"markdownIt-Anchor\" href=\"#reducer\"></a> Reducer</h1>\n<p>永远不要在 reducer 里做这些操作：</p>\n<ol>\n<li>修改传入参数；</li>\n<li>执行有副作用的操作，如 API 请求和路由跳转；</li>\n<li>调用非纯函数，如 Date.now() 或 Math.random()</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function todoApp(state = initialState, action) &#123;</span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">    case SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        visibilityFilter: action.filter</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    case ADD_TODO:</span><br><span class=\"line\">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          ...state.todos,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            text: action.text,</span><br><span class=\"line\">            completed: false</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      return state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。</li>\n<li>在 default 情况下返回旧的 state</li>\n<li>Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。</li>\n<li>新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的</li>\n</ol>\n<h1 id=\"store\"><a class=\"markdownIt-Anchor\" href=\"#store\"></a> Store</h1>\n<p>Store 有以下职责：</p>\n<ol>\n<li>维持应用的 state；</li>\n<li>提供 getState() 方法获取 state；</li>\n<li>提供 dispatch(action) 方法更新 state；</li>\n<li>通过 subscribe(listener) 注册监听器;</li>\n<li>通过 subscribe(listener) 返回的函数注销监听器</li>\n</ol>\n<h1 id=\"搭配react\"><a class=\"markdownIt-Anchor\" href=\"#搭配react\"></a> 搭配react</h1>\n<p>Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>\n<p>连接到 Redux：我们需要做出两个变化，将 App 组件连接到 Redux 并且让它能够 dispatch actions 以及从 Redux store 读取到 state</p>\n<ol>\n<li>获取从之前安装好的 react-redux 提供的 Provider，并且在渲染之前将根组件包装进 <provider></provider></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//index.js</span><br><span class=\"line\">import React from &apos;react&apos;</span><br><span class=\"line\">import &#123; render &#125; from &apos;react-dom&apos;</span><br><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class=\"line\">import &#123; Provider &#125; from &apos;react-redux&apos;</span><br><span class=\"line\">import App from &apos;./containers/App&apos;</span><br><span class=\"line\">import todoApp from &apos;./reducers&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">let store = createStore(todoApp);</span><br><span class=\"line\"></span><br><span class=\"line\">let rootElement = document.getElementById(&apos;root&apos;)</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  rootElement</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过 react-redux 提供的 connect() 方法将包装好的组件连接到Redux</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class=\"line\">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class=\"line\">import &#123; addTodo, completeTodo, setVisibilityFilter, VisibilityFilters &#125; from &apos;../actions&apos;;</span><br><span class=\"line\">import AddTodo from &apos;../components/AddTodo&apos;;</span><br><span class=\"line\">import TodoList from &apos;../components/TodoList&apos;;</span><br><span class=\"line\">import Footer from &apos;../components/Footer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    // 通过调用 connect() 注入:</span><br><span class=\"line\">    const &#123; dispatch, visibleTodos, visibilityFilter &#125; = this.props</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;AddTodo</span><br><span class=\"line\">          onAddClick=&#123;text =&gt;</span><br><span class=\"line\">            dispatch(addTodo(text))</span><br><span class=\"line\">          &#125; /&gt;</span><br><span class=\"line\">        &lt;TodoList</span><br><span class=\"line\">          todos=&#123;this.props.visibleTodos&#125;</span><br><span class=\"line\">          onTodoClick=&#123;index =&gt;</span><br><span class=\"line\">            dispatch(completeTodo(index))</span><br><span class=\"line\">          &#125; /&gt;</span><br><span class=\"line\">        &lt;Footer</span><br><span class=\"line\">          filter=&#123;visibilityFilter&#125;</span><br><span class=\"line\">          onFilterChange=&#123;nextFilter =&gt;</span><br><span class=\"line\">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class=\"line\">          &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.propTypes = &#123;</span><br><span class=\"line\">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class=\"line\">    text: PropTypes.string.isRequired,</span><br><span class=\"line\">    completed: PropTypes.bool.isRequired</span><br><span class=\"line\">  &#125;)),</span><br><span class=\"line\">  visibilityFilter: PropTypes.oneOf([</span><br><span class=\"line\">    &apos;SHOW_ALL&apos;,</span><br><span class=\"line\">    &apos;SHOW_COMPLETED&apos;,</span><br><span class=\"line\">    &apos;SHOW_ACTIVE&apos;</span><br><span class=\"line\">  ]).isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function selectTodos(todos, filter) &#123;</span><br><span class=\"line\">  switch (filter) &#123;</span><br><span class=\"line\">  case VisibilityFilters.SHOW_ALL:</span><br><span class=\"line\">    return todos;</span><br><span class=\"line\">  case VisibilityFilters.SHOW_COMPLETED:</span><br><span class=\"line\">    return todos.filter(todo =&gt; todo.completed);</span><br><span class=\"line\">  case VisibilityFilters.SHOW_ACTIVE:</span><br><span class=\"line\">    return todos.filter(todo =&gt; !todo.completed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 基于全局 state ，哪些是我们想注入的 props ?</span><br><span class=\"line\">// 注意：使用 https://github.com/reactjs/reselect 效果更佳。</span><br><span class=\"line\">function select(state) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visibleTodos: selectTodos(state.todos, state.visibilityFilter),</span><br><span class=\"line\">    visibilityFilter: state.visibilityFilter</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；</span><br><span class=\"line\">export default connect(select)(App);</span><br></pre></td></tr></table></figure>\n"},{"title":"linux 配置文件启动顺序","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\nhttps://www.cnblogs.com/GO-NO-1/p/9084713.html\n\n[toc]\n\n# 启动顺序概述\n当用户打开PC的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导 Linux，Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc 当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这 样就完成了从开机到登录的整个启动过程。\n\n# 0.BIOS加电自检\n* 首先被启动执行的就是这个BIOS（BasicInput/Output System）程序。访问硬盘先头512Bit的MBR（Master Boot Record）\n* 经BIOS的控制，将MBR中的Boot Record调入内存中。这里就要说说Linux的Boot程序了，Linux的Boot程序有GRUB和LILO，而CentOS默认的Boot程序是GRUB\n* 通过Boot程序，访问硬盘中的Linux内核程序\n* 将内核程序调入内存中\n\n# 1.内核的引导(核内引导)\n> Red Hat可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权， 然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。\n\n内核程序调用完成后，通过内核访问硬盘中将要用到的其他文件。\n内核第一个执行的文件是/sbin/init，而这个文件的设置和定义文件是/etc/inittab这个文件，也就是说/sbin/init按照/etc/inittab的定义来执行下一步的启动\n\n# 2.运行init\n1. init是一个由内核启动的用户级进程。它的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序\n2. init程序需 要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成\n3. inittab的格式如下。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式：\n~~~\nid:runlevel:action:process\n* id:是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。\n* runlevel: 是init所处于的运行级别的标识，一般使用0－6以及S或s。\n - 0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模 式，6为重启；S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现\n - runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行\n* action:描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等\n* process为具体的执行程序。程序后面可以带参数\n~~~\n\n加载内核 执行init程序\n~~~\n* /etc/rc.d/rc.sysinit  #由init执行的第一个脚本\n - 主要做在各个运行模式中相同的初始化工作，包括： 调入keymap以及系统字体 启动swapping 设置主机名、设置NIS域名检查(fsck)并mount文件系统打开quota 装载声卡模块设置系统时钟等等\n* /etc/rc.d/rc $RUNLEVEL #$RUNLEVEL为缺省的运行模式\n* /etc/rc.d/rc.local #相应级别服务启动之后、在执行该文件(其实也可以把需要执行的命令写到该文件中) \n* /sbin/mingetty # 等待用户登录\n~~~\n\n# 3.系统初始化\n在init的配置文件中有这么一行:si::sysinit:/etc/rc.d/rc.sysinit\n,它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分 区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。\n\n# 4.启动对应运行级别的守护进程\n在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。\n\n以运行级别3为例，init将执行配置文件inittab中的以下这行：\n==l5:5:wait:/etc/rc.d/rc 5==\n~~~\n* 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d /rc5.d/目录下的所有的rc启动脚本\n* /etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本， 真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下\n* 这些rc启动脚本有着类似的用法，它们一般能接受start、stop、 restart、status等参数\n* /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行；调用的顺序按xx 从小到大来执行\n* 如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作 为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行\n~~~\n\n# 5.建立终端\n* rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统\n* 通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端：\n~~~\n1:2345:respawn:/sbin/mingetty tty1\n2:2345:respawn:/sbin/mingetty tty2\n3:2345:respawn:/sbin/mingetty tty3\n4:2345:respawn:/sbin/mingetty tty4\n5:2345:respawn:/sbin/mingetty tty5\n6:2345:respawn:/sbin/mingetty tty6\n~~~\n从 上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示 一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用 户的身份。\n\n# 6.登录系统，启动完成\n* 当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了\n* Linux 的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。\n* 在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息\n    - 对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它；然后如果用户的主目录中存在.bash_profile文件，就执行它\n\n## 登录时自动运行程序\n~~~\n用户登录时，bash首先自动执行系统管理员建立的全局登录script ：/etc/profile。\n然后bash在用户起始目录下按顺序查找三个特殊文件中的一个：/.bash_profile、/.bash_login、 /.profile，但只执行最先找到的一个。\n因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序（类似于DOS下的Autoexec.bat）\n~~~\n\n## 退出登录时自动运行程序\n~~~\n退出登录时，bash自动执行个人的退出登录脚本/.bash_logout。\n例如，在/.bash_logout中加入命令\"tar －cvzf c.source.tgz ＊.c\"，则在每次退出登录时自动执行 \"tar\" 命令备份 ＊.c 文件。\n~~~\n\n# rc.d目录\n> 执行==ls -l /etc/rc.d==命令，会有刚提到的目录，说明如下：\n\n1. init.d\n* 这个不是文件，是一个目录，这个目录下面存放着各各服务的控制脚本，这下面的文件和你安装了些什么软件包有关系。\n* etc/rc.d/rcX.d下的文件和这个init.d下面的文件是通过软连接相连的\n2. rc\n3. rc.loca\n> 可以将启动命令写到这个文件中，让开机启动服务完毕之后，==最后==启动这个服务\n4. rc.sysini\n>这个文件是在boot的时候就被执行的脚本，它的任务是初始化系统的网络，设定hostname，欢迎信息表示，时钟设置，挂载文件系统等。\n5. rcX.d\n> 在察看这个文件的时候注意3点：\n* ls -l 察看它们的详细信息，看看他们的link指向\n* ls -l 察看它们的文件名的头字母，形式应该是这样的[S或K <数字> <名称>]的形势。==S代表启动==，==K代表停止==。\n即：开机的时候，以S开头的脚本文件别执行，已被开机运行；以K开头的文件不被执行，这个文件所控制的服务也不被执行，这个文件控制的服务也不被开机运行\n* 打开link指向的文件，文件头有类似“# chkconfig: 2345 10 90”一行，这一行就指定了其启动和的优先级\n\n# 控制服务的一些工具\n## chkconfig\n\n## setup\n> 是系统综合的配置工具，命令行下也可以用 \n\n## system-config-services\n> 如果你安装了gnome这样的窗口桌面系统，你也可以使用这个工具来体验下鼠标点击带来的方便。 \n\n# Linux设置服务自启动的三种方式 \n## ln -s\n> ln -s                 在/etc/rc.d/rc*.d目录中建立/etc/init.d/服务的软链接(*代表0～6七个运行级别之一）\n\n> etc/rc[0~6].d其实是/etc/rc.d/rc[0~6].d的软连接，主要是为了保持和Unix的兼容性才做此策\n\n> 例如：etc/rc[0~6].d其实是/etc/rc.d/rc[0~6].d的软连接，主要是为了保持和Unix的兼容性才做此策\n\n文件位于/etc/rc.d/init.d下,名为apached，如果要服务自启动，则：\n\n* #chmod +x /etc/rc.d/init.d/apached //设置文件的属性为可执行\n* #ln -s /etc/rc.d/init.d/apached /etc/rc3.d/S90apache //建立软连接,快捷方式\n* #ln -s /etc/rc.d/init.d/apached /etc/rc0.d/K20apache\n\n## chkonfig\n> 命令行运行级别设置\n\n> 如果需要自启动某些服务，只需使用chkconfig 服务名 on即可，若想关闭，将on改为off\n在默认情况下，chkconfig会自启动2345这四个级别，如果想自定义可以加上--level选项\n\n## ntsysv\n> 伪图形运行级别设置\n\n> 启动ntsysv有两种方式，一是直接在命令行中输入ntsysv，二是使用setup命令，然后选择系统服务\n\n# 常见的守护进程\n> 在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\"System Services\"来自行设定.\n\n常见的守护进程:\n~~~\namd：自动安装NFS守护进程\napmd:高级电源管理守护进程\narpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库\nautofs：自动安装管理进程automount，与NFS相关，依赖于NIS\ncrond：Linux下的计划任务的守护进程\nnamed：DNS服务器\nnetfs：安装NFS、Samba和NetWare网络文件系统\nnetwork：激活已配置网络接口的脚本程序\nnfs：打开NFS服务\nportmap：RPC portmap管理器，它管理基于RPC服务的连接\nsendmail：邮件服务器sendmail\nsmb：Samba文件共享/打印服务\nsyslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本\nxfs：X Window字型服务器，为本地和远程X服务器提供字型集\nXinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务\n~~~","source":"_posts/Linux/01_linux 配置文件启动顺序.md","raw":"---\ntitle: linux 配置文件启动顺序\ntags:\n  - Linux\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\nhttps://www.cnblogs.com/GO-NO-1/p/9084713.html\n\n[toc]\n\n# 启动顺序概述\n当用户打开PC的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导 Linux，Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc 当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这 样就完成了从开机到登录的整个启动过程。\n\n# 0.BIOS加电自检\n* 首先被启动执行的就是这个BIOS（BasicInput/Output System）程序。访问硬盘先头512Bit的MBR（Master Boot Record）\n* 经BIOS的控制，将MBR中的Boot Record调入内存中。这里就要说说Linux的Boot程序了，Linux的Boot程序有GRUB和LILO，而CentOS默认的Boot程序是GRUB\n* 通过Boot程序，访问硬盘中的Linux内核程序\n* 将内核程序调入内存中\n\n# 1.内核的引导(核内引导)\n> Red Hat可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权， 然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。\n\n内核程序调用完成后，通过内核访问硬盘中将要用到的其他文件。\n内核第一个执行的文件是/sbin/init，而这个文件的设置和定义文件是/etc/inittab这个文件，也就是说/sbin/init按照/etc/inittab的定义来执行下一步的启动\n\n# 2.运行init\n1. init是一个由内核启动的用户级进程。它的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序\n2. init程序需 要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成\n3. inittab的格式如下。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式：\n~~~\nid:runlevel:action:process\n* id:是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。\n* runlevel: 是init所处于的运行级别的标识，一般使用0－6以及S或s。\n - 0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模 式，6为重启；S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现\n - runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行\n* action:描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等\n* process为具体的执行程序。程序后面可以带参数\n~~~\n\n加载内核 执行init程序\n~~~\n* /etc/rc.d/rc.sysinit  #由init执行的第一个脚本\n - 主要做在各个运行模式中相同的初始化工作，包括： 调入keymap以及系统字体 启动swapping 设置主机名、设置NIS域名检查(fsck)并mount文件系统打开quota 装载声卡模块设置系统时钟等等\n* /etc/rc.d/rc $RUNLEVEL #$RUNLEVEL为缺省的运行模式\n* /etc/rc.d/rc.local #相应级别服务启动之后、在执行该文件(其实也可以把需要执行的命令写到该文件中) \n* /sbin/mingetty # 等待用户登录\n~~~\n\n# 3.系统初始化\n在init的配置文件中有这么一行:si::sysinit:/etc/rc.d/rc.sysinit\n,它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分 区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。\n\n# 4.启动对应运行级别的守护进程\n在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。\n\n以运行级别3为例，init将执行配置文件inittab中的以下这行：\n==l5:5:wait:/etc/rc.d/rc 5==\n~~~\n* 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d /rc5.d/目录下的所有的rc启动脚本\n* /etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本， 真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下\n* 这些rc启动脚本有着类似的用法，它们一般能接受start、stop、 restart、status等参数\n* /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行；调用的顺序按xx 从小到大来执行\n* 如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作 为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行\n~~~\n\n# 5.建立终端\n* rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统\n* 通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端：\n~~~\n1:2345:respawn:/sbin/mingetty tty1\n2:2345:respawn:/sbin/mingetty tty2\n3:2345:respawn:/sbin/mingetty tty3\n4:2345:respawn:/sbin/mingetty tty4\n5:2345:respawn:/sbin/mingetty tty5\n6:2345:respawn:/sbin/mingetty tty6\n~~~\n从 上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示 一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用 户的身份。\n\n# 6.登录系统，启动完成\n* 当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了\n* Linux 的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。\n* 在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息\n    - 对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它；然后如果用户的主目录中存在.bash_profile文件，就执行它\n\n## 登录时自动运行程序\n~~~\n用户登录时，bash首先自动执行系统管理员建立的全局登录script ：/etc/profile。\n然后bash在用户起始目录下按顺序查找三个特殊文件中的一个：/.bash_profile、/.bash_login、 /.profile，但只执行最先找到的一个。\n因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序（类似于DOS下的Autoexec.bat）\n~~~\n\n## 退出登录时自动运行程序\n~~~\n退出登录时，bash自动执行个人的退出登录脚本/.bash_logout。\n例如，在/.bash_logout中加入命令\"tar －cvzf c.source.tgz ＊.c\"，则在每次退出登录时自动执行 \"tar\" 命令备份 ＊.c 文件。\n~~~\n\n# rc.d目录\n> 执行==ls -l /etc/rc.d==命令，会有刚提到的目录，说明如下：\n\n1. init.d\n* 这个不是文件，是一个目录，这个目录下面存放着各各服务的控制脚本，这下面的文件和你安装了些什么软件包有关系。\n* etc/rc.d/rcX.d下的文件和这个init.d下面的文件是通过软连接相连的\n2. rc\n3. rc.loca\n> 可以将启动命令写到这个文件中，让开机启动服务完毕之后，==最后==启动这个服务\n4. rc.sysini\n>这个文件是在boot的时候就被执行的脚本，它的任务是初始化系统的网络，设定hostname，欢迎信息表示，时钟设置，挂载文件系统等。\n5. rcX.d\n> 在察看这个文件的时候注意3点：\n* ls -l 察看它们的详细信息，看看他们的link指向\n* ls -l 察看它们的文件名的头字母，形式应该是这样的[S或K <数字> <名称>]的形势。==S代表启动==，==K代表停止==。\n即：开机的时候，以S开头的脚本文件别执行，已被开机运行；以K开头的文件不被执行，这个文件所控制的服务也不被执行，这个文件控制的服务也不被开机运行\n* 打开link指向的文件，文件头有类似“# chkconfig: 2345 10 90”一行，这一行就指定了其启动和的优先级\n\n# 控制服务的一些工具\n## chkconfig\n\n## setup\n> 是系统综合的配置工具，命令行下也可以用 \n\n## system-config-services\n> 如果你安装了gnome这样的窗口桌面系统，你也可以使用这个工具来体验下鼠标点击带来的方便。 \n\n# Linux设置服务自启动的三种方式 \n## ln -s\n> ln -s                 在/etc/rc.d/rc*.d目录中建立/etc/init.d/服务的软链接(*代表0～6七个运行级别之一）\n\n> etc/rc[0~6].d其实是/etc/rc.d/rc[0~6].d的软连接，主要是为了保持和Unix的兼容性才做此策\n\n> 例如：etc/rc[0~6].d其实是/etc/rc.d/rc[0~6].d的软连接，主要是为了保持和Unix的兼容性才做此策\n\n文件位于/etc/rc.d/init.d下,名为apached，如果要服务自启动，则：\n\n* #chmod +x /etc/rc.d/init.d/apached //设置文件的属性为可执行\n* #ln -s /etc/rc.d/init.d/apached /etc/rc3.d/S90apache //建立软连接,快捷方式\n* #ln -s /etc/rc.d/init.d/apached /etc/rc0.d/K20apache\n\n## chkonfig\n> 命令行运行级别设置\n\n> 如果需要自启动某些服务，只需使用chkconfig 服务名 on即可，若想关闭，将on改为off\n在默认情况下，chkconfig会自启动2345这四个级别，如果想自定义可以加上--level选项\n\n## ntsysv\n> 伪图形运行级别设置\n\n> 启动ntsysv有两种方式，一是直接在命令行中输入ntsysv，二是使用setup命令，然后选择系统服务\n\n# 常见的守护进程\n> 在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\"System Services\"来自行设定.\n\n常见的守护进程:\n~~~\namd：自动安装NFS守护进程\napmd:高级电源管理守护进程\narpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库\nautofs：自动安装管理进程automount，与NFS相关，依赖于NIS\ncrond：Linux下的计划任务的守护进程\nnamed：DNS服务器\nnetfs：安装NFS、Samba和NetWare网络文件系统\nnetwork：激活已配置网络接口的脚本程序\nnfs：打开NFS服务\nportmap：RPC portmap管理器，它管理基于RPC服务的连接\nsendmail：邮件服务器sendmail\nsmb：Samba文件共享/打印服务\nsyslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本\nxfs：X Window字型服务器，为本地和远程X服务器提供字型集\nXinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务\n~~~","slug":"Linux-01-linux-配置文件启动顺序","published":1,"updated":"2019-02-14T05:23:08.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3i00dh5b8hik2jdb8h","content":"<p><a href=\"https://www.cnblogs.com/GO-NO-1/p/9084713.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/GO-NO-1/p/9084713.html</a></p>\n<p>[toc]</p>\n<h1 id=\"启动顺序概述\"><a class=\"markdownIt-Anchor\" href=\"#启动顺序概述\"></a> 启动顺序概述</h1>\n<p>当用户打开PC的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导 Linux，Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc 当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这 样就完成了从开机到登录的整个启动过程。</p>\n<h1 id=\"0bios加电自检\"><a class=\"markdownIt-Anchor\" href=\"#0bios加电自检\"></a> 0.BIOS加电自检</h1>\n<ul>\n<li>首先被启动执行的就是这个BIOS（BasicInput/Output System）程序。访问硬盘先头512Bit的MBR（Master Boot Record）</li>\n<li>经BIOS的控制，将MBR中的Boot Record调入内存中。这里就要说说Linux的Boot程序了，Linux的Boot程序有GRUB和LILO，而CentOS默认的Boot程序是GRUB</li>\n<li>通过Boot程序，访问硬盘中的Linux内核程序</li>\n<li>将内核程序调入内存中</li>\n</ul>\n<h1 id=\"1内核的引导核内引导\"><a class=\"markdownIt-Anchor\" href=\"#1内核的引导核内引导\"></a> 1.内核的引导(核内引导)</h1>\n<blockquote>\n<p>Red Hat可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权， 然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。</p>\n</blockquote>\n<p>内核程序调用完成后，通过内核访问硬盘中将要用到的其他文件。<br>\n内核第一个执行的文件是/sbin/init，而这个文件的设置和定义文件是/etc/inittab这个文件，也就是说/sbin/init按照/etc/inittab的定义来执行下一步的启动</p>\n<h1 id=\"2运行init\"><a class=\"markdownIt-Anchor\" href=\"#2运行init\"></a> 2.运行init</h1>\n<ol>\n<li>init是一个由内核启动的用户级进程。它的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序</li>\n<li>init程序需 要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成</li>\n<li>inittab的格式如下。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id:runlevel:action:process</span><br><span class=\"line\">* id:是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。</span><br><span class=\"line\">* runlevel: 是init所处于的运行级别的标识，一般使用0－6以及S或s。</span><br><span class=\"line\"> - 0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模 式，6为重启；S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现</span><br><span class=\"line\"> - runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行</span><br><span class=\"line\">* action:描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等</span><br><span class=\"line\">* process为具体的执行程序。程序后面可以带参数</span><br></pre></td></tr></table></figure>\n<p>加载内核 执行init程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* /etc/rc.d/rc.sysinit  #由init执行的第一个脚本</span><br><span class=\"line\"> - 主要做在各个运行模式中相同的初始化工作，包括： 调入keymap以及系统字体 启动swapping 设置主机名、设置NIS域名检查(fsck)并mount文件系统打开quota 装载声卡模块设置系统时钟等等</span><br><span class=\"line\">* /etc/rc.d/rc $RUNLEVEL #$RUNLEVEL为缺省的运行模式</span><br><span class=\"line\">* /etc/rc.d/rc.local #相应级别服务启动之后、在执行该文件(其实也可以把需要执行的命令写到该文件中) </span><br><span class=\"line\">* /sbin/mingetty # 等待用户登录</span><br></pre></td></tr></table></figure>\n<h1 id=\"3系统初始化\"><a class=\"markdownIt-Anchor\" href=\"#3系统初始化\"></a> 3.系统初始化</h1>\n<p>在init的配置文件中有这么一行:si::sysinit:/etc/rc.d/rc.sysinit<br>\n,它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分 区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>\n<h1 id=\"4启动对应运行级别的守护进程\"><a class=\"markdownIt-Anchor\" href=\"#4启动对应运行级别的守护进程\"></a> 4.启动对应运行级别的守护进程</h1>\n<p>在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。</p>\n<p>以运行级别3为例，init将执行配置文件inittab中的以下这行：<br>\n==l5:5:wait:/etc/rc.d/rc 5==</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d /rc5.d/目录下的所有的rc启动脚本</span><br><span class=\"line\">* /etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本， 真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下</span><br><span class=\"line\">* 这些rc启动脚本有着类似的用法，它们一般能接受start、stop、 restart、status等参数</span><br><span class=\"line\">* /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行；调用的顺序按xx 从小到大来执行</span><br><span class=\"line\">* 如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作 为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行</span><br></pre></td></tr></table></figure>\n<h1 id=\"5建立终端\"><a class=\"markdownIt-Anchor\" href=\"#5建立终端\"></a> 5.建立终端</h1>\n<ul>\n<li>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统</li>\n<li>通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1:2345:respawn:/sbin/mingetty tty1</span><br><span class=\"line\">2:2345:respawn:/sbin/mingetty tty2</span><br><span class=\"line\">3:2345:respawn:/sbin/mingetty tty3</span><br><span class=\"line\">4:2345:respawn:/sbin/mingetty tty4</span><br><span class=\"line\">5:2345:respawn:/sbin/mingetty tty5</span><br><span class=\"line\">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure>\n<p>从 上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示 一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用 户的身份。</p>\n<h1 id=\"6登录系统启动完成\"><a class=\"markdownIt-Anchor\" href=\"#6登录系统启动完成\"></a> 6.登录系统，启动完成</h1>\n<ul>\n<li>当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了</li>\n<li>Linux 的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。</li>\n<li>在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息\n<ul>\n<li>对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它；然后如果用户的主目录中存在.bash_profile文件，就执行它</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"登录时自动运行程序\"><a class=\"markdownIt-Anchor\" href=\"#登录时自动运行程序\"></a> 登录时自动运行程序</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户登录时，bash首先自动执行系统管理员建立的全局登录script ：/etc/profile。</span><br><span class=\"line\">然后bash在用户起始目录下按顺序查找三个特殊文件中的一个：/.bash_profile、/.bash_login、 /.profile，但只执行最先找到的一个。</span><br><span class=\"line\">因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序（类似于DOS下的Autoexec.bat）</span><br></pre></td></tr></table></figure>\n<h2 id=\"退出登录时自动运行程序\"><a class=\"markdownIt-Anchor\" href=\"#退出登录时自动运行程序\"></a> 退出登录时自动运行程序</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">退出登录时，bash自动执行个人的退出登录脚本/.bash_logout。</span><br><span class=\"line\">例如，在/.bash_logout中加入命令&quot;tar －cvzf c.source.tgz ＊.c&quot;，则在每次退出登录时自动执行 &quot;tar&quot; 命令备份 ＊.c 文件。</span><br></pre></td></tr></table></figure>\n<h1 id=\"rcd目录\"><a class=\"markdownIt-Anchor\" href=\"#rcd目录\"></a> rc.d目录</h1>\n<blockquote>\n<p>执行==ls -l /etc/rc.d==命令，会有刚提到的目录，说明如下：</p>\n</blockquote>\n<ol>\n<li>init.d</li>\n</ol>\n<ul>\n<li>这个不是文件，是一个目录，这个目录下面存放着各各服务的控制脚本，这下面的文件和你安装了些什么软件包有关系。</li>\n<li>etc/rc.d/rcX.d下的文件和这个init.d下面的文件是通过软连接相连的</li>\n</ul>\n<ol start=\"2\">\n<li>rc</li>\n<li>rc.loca</li>\n</ol>\n<blockquote>\n<p>可以将启动命令写到这个文件中，让开机启动服务完毕之后，==最后==启动这个服务</p>\n</blockquote>\n<ol start=\"4\">\n<li>rc.sysini</li>\n</ol>\n<blockquote>\n<p>这个文件是在boot的时候就被执行的脚本，它的任务是初始化系统的网络，设定hostname，欢迎信息表示，时钟设置，挂载文件系统等。</p>\n</blockquote>\n<ol start=\"5\">\n<li>rcX.d</li>\n</ol>\n<blockquote>\n<p>在察看这个文件的时候注意3点：</p>\n</blockquote>\n<ul>\n<li>ls -l 察看它们的详细信息，看看他们的link指向</li>\n<li>ls -l 察看它们的文件名的头字母，形式应该是这样的[S或K &lt;数字&gt; &lt;名称&gt;]的形势。==S代表启动==，==K代表停止==。<br>\n即：开机的时候，以S开头的脚本文件别执行，已被开机运行；以K开头的文件不被执行，这个文件所控制的服务也不被执行，这个文件控制的服务也不被开机运行</li>\n<li>打开link指向的文件，文件头有类似“# chkconfig: 2345 10 90”一行，这一行就指定了其启动和的优先级</li>\n</ul>\n<h1 id=\"控制服务的一些工具\"><a class=\"markdownIt-Anchor\" href=\"#控制服务的一些工具\"></a> 控制服务的一些工具</h1>\n<h2 id=\"chkconfig\"><a class=\"markdownIt-Anchor\" href=\"#chkconfig\"></a> chkconfig</h2>\n<h2 id=\"setup\"><a class=\"markdownIt-Anchor\" href=\"#setup\"></a> setup</h2>\n<blockquote>\n<p>是系统综合的配置工具，命令行下也可以用</p>\n</blockquote>\n<h2 id=\"system-config-services\"><a class=\"markdownIt-Anchor\" href=\"#system-config-services\"></a> system-config-services</h2>\n<blockquote>\n<p>如果你安装了gnome这样的窗口桌面系统，你也可以使用这个工具来体验下鼠标点击带来的方便。</p>\n</blockquote>\n<h1 id=\"linux设置服务自启动的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#linux设置服务自启动的三种方式\"></a> Linux设置服务自启动的三种方式</h1>\n<h2 id=\"ln-s\"><a class=\"markdownIt-Anchor\" href=\"#ln-s\"></a> ln -s</h2>\n<blockquote>\n<p>ln -s                 在/etc/rc.d/rc*.d目录中建立/etc/init.d/服务的软链接(*代表0～6七个运行级别之一）</p>\n</blockquote>\n<blockquote>\n<p>etc/rc[0<sub>6].d其实是/etc/rc.d/rc[0</sub>6].d的软连接，主要是为了保持和Unix的兼容性才做此策</p>\n</blockquote>\n<blockquote>\n<p>例如：etc/rc[0<sub>6].d其实是/etc/rc.d/rc[0</sub>6].d的软连接，主要是为了保持和Unix的兼容性才做此策</p>\n</blockquote>\n<p>文件位于/etc/rc.d/init.d下,名为apached，如果要服务自启动，则：</p>\n<ul>\n<li>#chmod +x /etc/rc.d/init.d/apached //设置文件的属性为可执行</li>\n<li>#ln -s /etc/rc.d/init.d/apached /etc/rc3.d/S90apache //建立软连接,快捷方式</li>\n<li>#ln -s /etc/rc.d/init.d/apached /etc/rc0.d/K20apache</li>\n</ul>\n<h2 id=\"chkonfig\"><a class=\"markdownIt-Anchor\" href=\"#chkonfig\"></a> chkonfig</h2>\n<blockquote>\n<p>命令行运行级别设置</p>\n</blockquote>\n<blockquote>\n<p>如果需要自启动某些服务，只需使用chkconfig 服务名 on即可，若想关闭，将on改为off<br>\n在默认情况下，chkconfig会自启动2345这四个级别，如果想自定义可以加上–level选项</p>\n</blockquote>\n<h2 id=\"ntsysv\"><a class=\"markdownIt-Anchor\" href=\"#ntsysv\"></a> ntsysv</h2>\n<blockquote>\n<p>伪图形运行级别设置</p>\n</blockquote>\n<blockquote>\n<p>启动ntsysv有两种方式，一是直接在命令行中输入ntsysv，二是使用setup命令，然后选择系统服务</p>\n</blockquote>\n<h1 id=\"常见的守护进程\"><a class=\"markdownIt-Anchor\" href=\"#常见的守护进程\"></a> 常见的守护进程</h1>\n<blockquote>\n<p>在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定.</p>\n</blockquote>\n<p>常见的守护进程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amd：自动安装NFS守护进程</span><br><span class=\"line\">apmd:高级电源管理守护进程</span><br><span class=\"line\">arpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库</span><br><span class=\"line\">autofs：自动安装管理进程automount，与NFS相关，依赖于NIS</span><br><span class=\"line\">crond：Linux下的计划任务的守护进程</span><br><span class=\"line\">named：DNS服务器</span><br><span class=\"line\">netfs：安装NFS、Samba和NetWare网络文件系统</span><br><span class=\"line\">network：激活已配置网络接口的脚本程序</span><br><span class=\"line\">nfs：打开NFS服务</span><br><span class=\"line\">portmap：RPC portmap管理器，它管理基于RPC服务的连接</span><br><span class=\"line\">sendmail：邮件服务器sendmail</span><br><span class=\"line\">smb：Samba文件共享/打印服务</span><br><span class=\"line\">syslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本</span><br><span class=\"line\">xfs：X Window字型服务器，为本地和远程X服务器提供字型集</span><br><span class=\"line\">Xinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.cnblogs.com/GO-NO-1/p/9084713.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/GO-NO-1/p/9084713.html</a></p>\n<p>[toc]</p>\n<h1 id=\"启动顺序概述\"><a class=\"markdownIt-Anchor\" href=\"#启动顺序概述\"></a> 启动顺序概述</h1>\n<p>当用户打开PC的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导 Linux，Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc 当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这 样就完成了从开机到登录的整个启动过程。</p>\n<h1 id=\"0bios加电自检\"><a class=\"markdownIt-Anchor\" href=\"#0bios加电自检\"></a> 0.BIOS加电自检</h1>\n<ul>\n<li>首先被启动执行的就是这个BIOS（BasicInput/Output System）程序。访问硬盘先头512Bit的MBR（Master Boot Record）</li>\n<li>经BIOS的控制，将MBR中的Boot Record调入内存中。这里就要说说Linux的Boot程序了，Linux的Boot程序有GRUB和LILO，而CentOS默认的Boot程序是GRUB</li>\n<li>通过Boot程序，访问硬盘中的Linux内核程序</li>\n<li>将内核程序调入内存中</li>\n</ul>\n<h1 id=\"1内核的引导核内引导\"><a class=\"markdownIt-Anchor\" href=\"#1内核的引导核内引导\"></a> 1.内核的引导(核内引导)</h1>\n<blockquote>\n<p>Red Hat可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权， 然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。</p>\n</blockquote>\n<p>内核程序调用完成后，通过内核访问硬盘中将要用到的其他文件。<br>\n内核第一个执行的文件是/sbin/init，而这个文件的设置和定义文件是/etc/inittab这个文件，也就是说/sbin/init按照/etc/inittab的定义来执行下一步的启动</p>\n<h1 id=\"2运行init\"><a class=\"markdownIt-Anchor\" href=\"#2运行init\"></a> 2.运行init</h1>\n<ol>\n<li>init是一个由内核启动的用户级进程。它的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序</li>\n<li>init程序需 要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成</li>\n<li>inittab的格式如下。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id:runlevel:action:process</span><br><span class=\"line\">* id:是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。</span><br><span class=\"line\">* runlevel: 是init所处于的运行级别的标识，一般使用0－6以及S或s。</span><br><span class=\"line\"> - 0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模 式，6为重启；S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现</span><br><span class=\"line\"> - runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行</span><br><span class=\"line\">* action:描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等</span><br><span class=\"line\">* process为具体的执行程序。程序后面可以带参数</span><br></pre></td></tr></table></figure>\n<p>加载内核 执行init程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* /etc/rc.d/rc.sysinit  #由init执行的第一个脚本</span><br><span class=\"line\"> - 主要做在各个运行模式中相同的初始化工作，包括： 调入keymap以及系统字体 启动swapping 设置主机名、设置NIS域名检查(fsck)并mount文件系统打开quota 装载声卡模块设置系统时钟等等</span><br><span class=\"line\">* /etc/rc.d/rc $RUNLEVEL #$RUNLEVEL为缺省的运行模式</span><br><span class=\"line\">* /etc/rc.d/rc.local #相应级别服务启动之后、在执行该文件(其实也可以把需要执行的命令写到该文件中) </span><br><span class=\"line\">* /sbin/mingetty # 等待用户登录</span><br></pre></td></tr></table></figure>\n<h1 id=\"3系统初始化\"><a class=\"markdownIt-Anchor\" href=\"#3系统初始化\"></a> 3.系统初始化</h1>\n<p>在init的配置文件中有这么一行:si::sysinit:/etc/rc.d/rc.sysinit<br>\n,它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分 区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>\n<h1 id=\"4启动对应运行级别的守护进程\"><a class=\"markdownIt-Anchor\" href=\"#4启动对应运行级别的守护进程\"></a> 4.启动对应运行级别的守护进程</h1>\n<p>在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。</p>\n<p>以运行级别3为例，init将执行配置文件inittab中的以下这行：<br>\n==l5:5:wait:/etc/rc.d/rc 5==</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d /rc5.d/目录下的所有的rc启动脚本</span><br><span class=\"line\">* /etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本， 真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下</span><br><span class=\"line\">* 这些rc启动脚本有着类似的用法，它们一般能接受start、stop、 restart、status等参数</span><br><span class=\"line\">* /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行；调用的顺序按xx 从小到大来执行</span><br><span class=\"line\">* 如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作 为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行</span><br></pre></td></tr></table></figure>\n<h1 id=\"5建立终端\"><a class=\"markdownIt-Anchor\" href=\"#5建立终端\"></a> 5.建立终端</h1>\n<ul>\n<li>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统</li>\n<li>通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1:2345:respawn:/sbin/mingetty tty1</span><br><span class=\"line\">2:2345:respawn:/sbin/mingetty tty2</span><br><span class=\"line\">3:2345:respawn:/sbin/mingetty tty3</span><br><span class=\"line\">4:2345:respawn:/sbin/mingetty tty4</span><br><span class=\"line\">5:2345:respawn:/sbin/mingetty tty5</span><br><span class=\"line\">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure>\n<p>从 上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示 一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用 户的身份。</p>\n<h1 id=\"6登录系统启动完成\"><a class=\"markdownIt-Anchor\" href=\"#6登录系统启动完成\"></a> 6.登录系统，启动完成</h1>\n<ul>\n<li>当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了</li>\n<li>Linux 的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。</li>\n<li>在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息\n<ul>\n<li>对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它；然后如果用户的主目录中存在.bash_profile文件，就执行它</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"登录时自动运行程序\"><a class=\"markdownIt-Anchor\" href=\"#登录时自动运行程序\"></a> 登录时自动运行程序</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户登录时，bash首先自动执行系统管理员建立的全局登录script ：/etc/profile。</span><br><span class=\"line\">然后bash在用户起始目录下按顺序查找三个特殊文件中的一个：/.bash_profile、/.bash_login、 /.profile，但只执行最先找到的一个。</span><br><span class=\"line\">因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序（类似于DOS下的Autoexec.bat）</span><br></pre></td></tr></table></figure>\n<h2 id=\"退出登录时自动运行程序\"><a class=\"markdownIt-Anchor\" href=\"#退出登录时自动运行程序\"></a> 退出登录时自动运行程序</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">退出登录时，bash自动执行个人的退出登录脚本/.bash_logout。</span><br><span class=\"line\">例如，在/.bash_logout中加入命令&quot;tar －cvzf c.source.tgz ＊.c&quot;，则在每次退出登录时自动执行 &quot;tar&quot; 命令备份 ＊.c 文件。</span><br></pre></td></tr></table></figure>\n<h1 id=\"rcd目录\"><a class=\"markdownIt-Anchor\" href=\"#rcd目录\"></a> rc.d目录</h1>\n<blockquote>\n<p>执行==ls -l /etc/rc.d==命令，会有刚提到的目录，说明如下：</p>\n</blockquote>\n<ol>\n<li>init.d</li>\n</ol>\n<ul>\n<li>这个不是文件，是一个目录，这个目录下面存放着各各服务的控制脚本，这下面的文件和你安装了些什么软件包有关系。</li>\n<li>etc/rc.d/rcX.d下的文件和这个init.d下面的文件是通过软连接相连的</li>\n</ul>\n<ol start=\"2\">\n<li>rc</li>\n<li>rc.loca</li>\n</ol>\n<blockquote>\n<p>可以将启动命令写到这个文件中，让开机启动服务完毕之后，==最后==启动这个服务</p>\n</blockquote>\n<ol start=\"4\">\n<li>rc.sysini</li>\n</ol>\n<blockquote>\n<p>这个文件是在boot的时候就被执行的脚本，它的任务是初始化系统的网络，设定hostname，欢迎信息表示，时钟设置，挂载文件系统等。</p>\n</blockquote>\n<ol start=\"5\">\n<li>rcX.d</li>\n</ol>\n<blockquote>\n<p>在察看这个文件的时候注意3点：</p>\n</blockquote>\n<ul>\n<li>ls -l 察看它们的详细信息，看看他们的link指向</li>\n<li>ls -l 察看它们的文件名的头字母，形式应该是这样的[S或K &lt;数字&gt; &lt;名称&gt;]的形势。==S代表启动==，==K代表停止==。<br>\n即：开机的时候，以S开头的脚本文件别执行，已被开机运行；以K开头的文件不被执行，这个文件所控制的服务也不被执行，这个文件控制的服务也不被开机运行</li>\n<li>打开link指向的文件，文件头有类似“# chkconfig: 2345 10 90”一行，这一行就指定了其启动和的优先级</li>\n</ul>\n<h1 id=\"控制服务的一些工具\"><a class=\"markdownIt-Anchor\" href=\"#控制服务的一些工具\"></a> 控制服务的一些工具</h1>\n<h2 id=\"chkconfig\"><a class=\"markdownIt-Anchor\" href=\"#chkconfig\"></a> chkconfig</h2>\n<h2 id=\"setup\"><a class=\"markdownIt-Anchor\" href=\"#setup\"></a> setup</h2>\n<blockquote>\n<p>是系统综合的配置工具，命令行下也可以用</p>\n</blockquote>\n<h2 id=\"system-config-services\"><a class=\"markdownIt-Anchor\" href=\"#system-config-services\"></a> system-config-services</h2>\n<blockquote>\n<p>如果你安装了gnome这样的窗口桌面系统，你也可以使用这个工具来体验下鼠标点击带来的方便。</p>\n</blockquote>\n<h1 id=\"linux设置服务自启动的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#linux设置服务自启动的三种方式\"></a> Linux设置服务自启动的三种方式</h1>\n<h2 id=\"ln-s\"><a class=\"markdownIt-Anchor\" href=\"#ln-s\"></a> ln -s</h2>\n<blockquote>\n<p>ln -s                 在/etc/rc.d/rc*.d目录中建立/etc/init.d/服务的软链接(*代表0～6七个运行级别之一）</p>\n</blockquote>\n<blockquote>\n<p>etc/rc[0<sub>6].d其实是/etc/rc.d/rc[0</sub>6].d的软连接，主要是为了保持和Unix的兼容性才做此策</p>\n</blockquote>\n<blockquote>\n<p>例如：etc/rc[0<sub>6].d其实是/etc/rc.d/rc[0</sub>6].d的软连接，主要是为了保持和Unix的兼容性才做此策</p>\n</blockquote>\n<p>文件位于/etc/rc.d/init.d下,名为apached，如果要服务自启动，则：</p>\n<ul>\n<li>#chmod +x /etc/rc.d/init.d/apached //设置文件的属性为可执行</li>\n<li>#ln -s /etc/rc.d/init.d/apached /etc/rc3.d/S90apache //建立软连接,快捷方式</li>\n<li>#ln -s /etc/rc.d/init.d/apached /etc/rc0.d/K20apache</li>\n</ul>\n<h2 id=\"chkonfig\"><a class=\"markdownIt-Anchor\" href=\"#chkonfig\"></a> chkonfig</h2>\n<blockquote>\n<p>命令行运行级别设置</p>\n</blockquote>\n<blockquote>\n<p>如果需要自启动某些服务，只需使用chkconfig 服务名 on即可，若想关闭，将on改为off<br>\n在默认情况下，chkconfig会自启动2345这四个级别，如果想自定义可以加上–level选项</p>\n</blockquote>\n<h2 id=\"ntsysv\"><a class=\"markdownIt-Anchor\" href=\"#ntsysv\"></a> ntsysv</h2>\n<blockquote>\n<p>伪图形运行级别设置</p>\n</blockquote>\n<blockquote>\n<p>启动ntsysv有两种方式，一是直接在命令行中输入ntsysv，二是使用setup命令，然后选择系统服务</p>\n</blockquote>\n<h1 id=\"常见的守护进程\"><a class=\"markdownIt-Anchor\" href=\"#常见的守护进程\"></a> 常见的守护进程</h1>\n<blockquote>\n<p>在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定.</p>\n</blockquote>\n<p>常见的守护进程:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amd：自动安装NFS守护进程</span><br><span class=\"line\">apmd:高级电源管理守护进程</span><br><span class=\"line\">arpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库</span><br><span class=\"line\">autofs：自动安装管理进程automount，与NFS相关，依赖于NIS</span><br><span class=\"line\">crond：Linux下的计划任务的守护进程</span><br><span class=\"line\">named：DNS服务器</span><br><span class=\"line\">netfs：安装NFS、Samba和NetWare网络文件系统</span><br><span class=\"line\">network：激活已配置网络接口的脚本程序</span><br><span class=\"line\">nfs：打开NFS服务</span><br><span class=\"line\">portmap：RPC portmap管理器，它管理基于RPC服务的连接</span><br><span class=\"line\">sendmail：邮件服务器sendmail</span><br><span class=\"line\">smb：Samba文件共享/打印服务</span><br><span class=\"line\">syslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本</span><br><span class=\"line\">xfs：X Window字型服务器，为本地和远程X服务器提供字型集</span><br><span class=\"line\">Xinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务</span><br></pre></td></tr></table></figure>"},{"title":"Node API学习","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 \nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 \nNode.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n~~~\n中文网址：http://nodejs.cn/\n英文网址：https://nodejs.org/en/\n\n其他相关网址：\nhttps://www.npmjs.com/\nhttps://github.com/\n~~~\n\nhttp://nodejs.cn/api/\n\n---\n\n[toc]\n\n## node命令用法\n~~~\nnode [options] [v8 options] [script.js | -e \"script\"] [arguments]\n~~~\n## assert (断言)\n> assert 模块提供了一组简单的断言测试集合，可被用于测试不变量。 该模块在代码中可通过 require('assert') 使用。 assert 不是一个测试框架，也无意成为通用的断言库。 \n## Buffer\n> 在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。\n\n> 现在 TypedArray 已经被添加进 ES6 中，Buffer 类以一种更优与更适合 Node.js 用例的方式实现了 Uint8Array API。\n\n> Buffer 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。 ==Buffer 的大小在其创建时就已确定，且不能调整大小==。\n\n> Buffer 类在 Node.js 中是一个全局变量，因此无需 require('buffer').Buffer。\n\n## C/C++ 插件\n> Node.js 插件是用 C 或 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行于 Node.js 的 JavaScript 和 C/C++ 库之间提供接口。\n\n* V8：Node.js 当前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h）==(V8在线文档) https://v8docs.nodesource.com/==\n* libuv：实现了 Node.js 的事件循环、工作线程、与平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器和系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 鼓励插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。\n* 内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C/C++ API。 其中最重要的是 node::ObjectWrap 类。\n* Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 有目的地再导出，并且通过插件被用于不同的场景\n\n## child_process (子进程)\n> child_process 模块提供了衍生子进程的能力\n\n## Cluster\n\n## CLI(命令行选项)\n> Node.js 自带了各种命令行选项。 这些选项对外暴露了内置调试、多种执行脚本的方式、以及其他有用的运行时选项。\n\n> 要在终端中查看本文档作为操作手册，运行 man node\n\n## console (控制台)\n> console 模块提供了一个简单的调试控制台，它与 Web 浏览器提供的 JavaScript 控制台的机制类似。\n\n~~~\nconsole.time(label) //启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。\nconsole.timeEnd(label)  //停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout\nconsole.trace(message[, ...args])   //打印字符串 'Trace :' 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。\n~~~\n\n## Crypto (加密)\n\n## debugger (调试器)\n> Node.js 包含一个进程外的调试工具，可以通过基于 TCP 的协议和内置调试客户端访问。 要使用它，可以带上 debug 参数启动 Node.js，并带上需要调试的脚本的路径；然后会显示一个提示，表明成功启动调试器\n\n## DNS (域名服务器)\n\n## Error 错误\nNode.js 中运行的应用程序一般会遇到以下四类错误：\n* 标准的 JavaScript 错误：\n     1. <EvalError> : 当调用 eval() 失败时抛出。\n     2. <SyntaxError> : 当 JavaScript 语法错误时抛出。\n     3. <RangeError> : 当一个值不在预期范围内时抛出。\n     4. <ReferenceError> : 当使用未定义的变量时抛出。\n     5. <TypeError> : 当传入错误类型的参数时抛出。\n     6. <URIError> : 当一个全局的 URI 处理函数被误用时抛出。\n* 由底层操作系的触发的系统错误，例如试图打开一个不存在的文件、试图向一个已关闭的 socket 发送数据等\n* 由应用程序代码触发的用户自定义的错误。\n* 断言错误是错误的一个特殊的类，每当 Node.js 检测到一个不应该发生的异常逻辑时会触发。 这类错误通常由 assert 模块触发。\n\n> JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。\n\n> ==开发者必须查阅各个方法的文档以明确在错误发生时这些方法是如何冒泡的。==\n\n## events (事件)\n> 大多数 Node.js 核心 API 都是采用惯用的异步事件驱动架构，其中某些类型的对象（称为触发器）会周期性地触发命名事件来调用函数对象（监听器）。\n\n> ==所有能触发事件的对象都是 EventEmitter 类的实例==。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数附加到会被对象触发的命名事件上。==当 EventEmitter 对象触发一个事件时，所有附加在特定事件上的函数都被同步地调用。==\n\n> 当新的监听器被添加时，所有的 EventEmitter 会触发 'newListener' 事件；当移除已存在的监听器时，则触发 'removeListener'。\n\n> 每个事件默认可以注册最多 10 个监听器。可以通过一定方法设置。\n\n~~~js\n//此方法可用来自定义事件\nconst EventEmitter = require('events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('发生了一个事件！');\n});\nmyEmitter.emit('event');\n~~~\n#### 异步与同步\n> EventListener 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式.\n\n* eventEmitter.on() //监听器会在==每次==触发命名事件时被调用\n* eventEmitter.once() //注册一个对于特定事件被调用==最多一次==的监听器\n\n#### 错误事件\n> 当 EventEmitter 实例中发生错误时，会触发一个 'error' 事件.为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器\n\n## fs (文件系统)\n> 文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require('fs') 使用该模块。 ==所有的方法都有异步和同步的形式==\n\n> 异步形式始终以完成==回调作为它最后一个参数==。 传给完成回调的参数取决于具体方法，但==第一个参数总是留给异常==。 如果操作成功完成，则第一个参数会是 null 或 undefined。\n\n> 当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。\n\n#### 同步和异步的比较\n~~~\n//同步的方式\nconst fs = require('fs'); \nfs.unlinkSync('/tmp/hello');\nconsole.log('successfully deleted /tmp/hello');\n\n//异步方式\nconst fs = require('fs'); \nfs.unlink('/tmp/hello', (err) => {\n  if (err) throw err;\n  console.log('successfully deleted /tmp/hello');\n});\n~~~\n* 异步方法不保证执行顺序\n* 异步方法之间如果有执行顺序，则正确的方法是把回调链起来\n* 强烈推荐开发者使用这些函数的异步版本。 同步版本会阻塞整个进程，直到它们完成\n\n## 全局变量\n~~~\n* __dirname     //当前模块的目录名。 等同于 __filename 的 path.dirname()\n* __filename    //当前模块的文件名。 这是当前模块文件的解析后的绝对路径\n* exports       //module.exports 的一个简短的引用\n* module        //当前模块的引用。 具体地说，module.exports 用于定义一个模块导出什么，且通过 require() 引入\n* require.resolve() //使用内部的 require() 机制来查找模块的位置，但不会加载模块，只返回解析后的文件名\n~~~\n\n## http\n> Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。 比如，大块编码的消息。 该接口从不缓存整个请求或响应，所以用户能够流化数据。\n\n## https\n> HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。\n\n## module (模块)\n> Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）","source":"_posts/node/Node API学习.md","raw":"---\ntitle: Node API学习\ntags:\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 \nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 \nNode.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n~~~\n中文网址：http://nodejs.cn/\n英文网址：https://nodejs.org/en/\n\n其他相关网址：\nhttps://www.npmjs.com/\nhttps://github.com/\n~~~\n\nhttp://nodejs.cn/api/\n\n---\n\n[toc]\n\n## node命令用法\n~~~\nnode [options] [v8 options] [script.js | -e \"script\"] [arguments]\n~~~\n## assert (断言)\n> assert 模块提供了一组简单的断言测试集合，可被用于测试不变量。 该模块在代码中可通过 require('assert') 使用。 assert 不是一个测试框架，也无意成为通用的断言库。 \n## Buffer\n> 在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。\n\n> 现在 TypedArray 已经被添加进 ES6 中，Buffer 类以一种更优与更适合 Node.js 用例的方式实现了 Uint8Array API。\n\n> Buffer 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。 ==Buffer 的大小在其创建时就已确定，且不能调整大小==。\n\n> Buffer 类在 Node.js 中是一个全局变量，因此无需 require('buffer').Buffer。\n\n## C/C++ 插件\n> Node.js 插件是用 C 或 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行于 Node.js 的 JavaScript 和 C/C++ 库之间提供接口。\n\n* V8：Node.js 当前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h）==(V8在线文档) https://v8docs.nodesource.com/==\n* libuv：实现了 Node.js 的事件循环、工作线程、与平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器和系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 鼓励插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。\n* 内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C/C++ API。 其中最重要的是 node::ObjectWrap 类。\n* Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 有目的地再导出，并且通过插件被用于不同的场景\n\n## child_process (子进程)\n> child_process 模块提供了衍生子进程的能力\n\n## Cluster\n\n## CLI(命令行选项)\n> Node.js 自带了各种命令行选项。 这些选项对外暴露了内置调试、多种执行脚本的方式、以及其他有用的运行时选项。\n\n> 要在终端中查看本文档作为操作手册，运行 man node\n\n## console (控制台)\n> console 模块提供了一个简单的调试控制台，它与 Web 浏览器提供的 JavaScript 控制台的机制类似。\n\n~~~\nconsole.time(label) //启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。\nconsole.timeEnd(label)  //停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout\nconsole.trace(message[, ...args])   //打印字符串 'Trace :' 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。\n~~~\n\n## Crypto (加密)\n\n## debugger (调试器)\n> Node.js 包含一个进程外的调试工具，可以通过基于 TCP 的协议和内置调试客户端访问。 要使用它，可以带上 debug 参数启动 Node.js，并带上需要调试的脚本的路径；然后会显示一个提示，表明成功启动调试器\n\n## DNS (域名服务器)\n\n## Error 错误\nNode.js 中运行的应用程序一般会遇到以下四类错误：\n* 标准的 JavaScript 错误：\n     1. <EvalError> : 当调用 eval() 失败时抛出。\n     2. <SyntaxError> : 当 JavaScript 语法错误时抛出。\n     3. <RangeError> : 当一个值不在预期范围内时抛出。\n     4. <ReferenceError> : 当使用未定义的变量时抛出。\n     5. <TypeError> : 当传入错误类型的参数时抛出。\n     6. <URIError> : 当一个全局的 URI 处理函数被误用时抛出。\n* 由底层操作系的触发的系统错误，例如试图打开一个不存在的文件、试图向一个已关闭的 socket 发送数据等\n* 由应用程序代码触发的用户自定义的错误。\n* 断言错误是错误的一个特殊的类，每当 Node.js 检测到一个不应该发生的异常逻辑时会触发。 这类错误通常由 assert 模块触发。\n\n> JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。\n\n> ==开发者必须查阅各个方法的文档以明确在错误发生时这些方法是如何冒泡的。==\n\n## events (事件)\n> 大多数 Node.js 核心 API 都是采用惯用的异步事件驱动架构，其中某些类型的对象（称为触发器）会周期性地触发命名事件来调用函数对象（监听器）。\n\n> ==所有能触发事件的对象都是 EventEmitter 类的实例==。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数附加到会被对象触发的命名事件上。==当 EventEmitter 对象触发一个事件时，所有附加在特定事件上的函数都被同步地调用。==\n\n> 当新的监听器被添加时，所有的 EventEmitter 会触发 'newListener' 事件；当移除已存在的监听器时，则触发 'removeListener'。\n\n> 每个事件默认可以注册最多 10 个监听器。可以通过一定方法设置。\n\n~~~js\n//此方法可用来自定义事件\nconst EventEmitter = require('events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('发生了一个事件！');\n});\nmyEmitter.emit('event');\n~~~\n#### 异步与同步\n> EventListener 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式.\n\n* eventEmitter.on() //监听器会在==每次==触发命名事件时被调用\n* eventEmitter.once() //注册一个对于特定事件被调用==最多一次==的监听器\n\n#### 错误事件\n> 当 EventEmitter 实例中发生错误时，会触发一个 'error' 事件.为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器\n\n## fs (文件系统)\n> 文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require('fs') 使用该模块。 ==所有的方法都有异步和同步的形式==\n\n> 异步形式始终以完成==回调作为它最后一个参数==。 传给完成回调的参数取决于具体方法，但==第一个参数总是留给异常==。 如果操作成功完成，则第一个参数会是 null 或 undefined。\n\n> 当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。\n\n#### 同步和异步的比较\n~~~\n//同步的方式\nconst fs = require('fs'); \nfs.unlinkSync('/tmp/hello');\nconsole.log('successfully deleted /tmp/hello');\n\n//异步方式\nconst fs = require('fs'); \nfs.unlink('/tmp/hello', (err) => {\n  if (err) throw err;\n  console.log('successfully deleted /tmp/hello');\n});\n~~~\n* 异步方法不保证执行顺序\n* 异步方法之间如果有执行顺序，则正确的方法是把回调链起来\n* 强烈推荐开发者使用这些函数的异步版本。 同步版本会阻塞整个进程，直到它们完成\n\n## 全局变量\n~~~\n* __dirname     //当前模块的目录名。 等同于 __filename 的 path.dirname()\n* __filename    //当前模块的文件名。 这是当前模块文件的解析后的绝对路径\n* exports       //module.exports 的一个简短的引用\n* module        //当前模块的引用。 具体地说，module.exports 用于定义一个模块导出什么，且通过 require() 引入\n* require.resolve() //使用内部的 require() 机制来查找模块的位置，但不会加载模块，只返回解析后的文件名\n~~~\n\n## http\n> Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。 比如，大块编码的消息。 该接口从不缓存整个请求或响应，所以用户能够流化数据。\n\n## https\n> HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。\n\n## module (模块)\n> Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）","slug":"node-Node-API学习","published":1,"updated":"2019-02-14T06:44:20.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3j00dj5b8hdcg3k66b","content":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>\nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br>\nNode.js 的包管理器 npm，是全球最大的开源库生态系统。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">中文网址：http://nodejs.cn/</span><br><span class=\"line\">英文网址：https://nodejs.org/en/</span><br><span class=\"line\"></span><br><span class=\"line\">其他相关网址：</span><br><span class=\"line\">https://www.npmjs.com/</span><br><span class=\"line\">https://github.com/</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a></p>\n<hr>\n<p>[toc]</p>\n<h2 id=\"node命令用法\"><a class=\"markdownIt-Anchor\" href=\"#node命令用法\"></a> node命令用法</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node [options] [v8 options] [script.js | -e &quot;script&quot;] [arguments]</span><br></pre></td></tr></table></figure>\n<h2 id=\"assert-断言\"><a class=\"markdownIt-Anchor\" href=\"#assert-断言\"></a> assert (断言)</h2>\n<blockquote>\n<p>assert 模块提供了一组简单的断言测试集合，可被用于测试不变量。 该模块在代码中可通过 require(‘assert’) 使用。 assert 不是一个测试框架，也无意成为通用的断言库。</p>\n</blockquote>\n<h2 id=\"buffer\"><a class=\"markdownIt-Anchor\" href=\"#buffer\"></a> Buffer</h2>\n<blockquote>\n<p>在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。</p>\n</blockquote>\n<blockquote>\n<p>现在 TypedArray 已经被添加进 ES6 中，Buffer 类以一种更优与更适合 Node.js 用例的方式实现了 Uint8Array API。</p>\n</blockquote>\n<blockquote>\n<p>Buffer 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。 ==Buffer 的大小在其创建时就已确定，且不能调整大小==。</p>\n</blockquote>\n<blockquote>\n<p>Buffer 类在 Node.js 中是一个全局变量，因此无需 require(‘buffer’).Buffer。</p>\n</blockquote>\n<h2 id=\"cc-插件\"><a class=\"markdownIt-Anchor\" href=\"#cc-插件\"></a> C/C++ 插件</h2>\n<blockquote>\n<p>Node.js 插件是用 C 或 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行于 Node.js 的 JavaScript 和 C/C++ 库之间提供接口。</p>\n</blockquote>\n<ul>\n<li>V8：Node.js 当前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h）==(V8在线文档) <a href=\"https://v8docs.nodesource.com/==\" target=\"_blank\" rel=\"noopener\">https://v8docs.nodesource.com/==</a></li>\n<li>libuv：实现了 Node.js 的事件循环、工作线程、与平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器和系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 鼓励插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。</li>\n<li>内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C/C++ API。 其中最重要的是 node::ObjectWrap 类。</li>\n<li>Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 有目的地再导出，并且通过插件被用于不同的场景</li>\n</ul>\n<h2 id=\"child_process-子进程\"><a class=\"markdownIt-Anchor\" href=\"#child_process-子进程\"></a> child_process (子进程)</h2>\n<blockquote>\n<p>child_process 模块提供了衍生子进程的能力</p>\n</blockquote>\n<h2 id=\"cluster\"><a class=\"markdownIt-Anchor\" href=\"#cluster\"></a> Cluster</h2>\n<h2 id=\"cli命令行选项\"><a class=\"markdownIt-Anchor\" href=\"#cli命令行选项\"></a> CLI(命令行选项)</h2>\n<blockquote>\n<p>Node.js 自带了各种命令行选项。 这些选项对外暴露了内置调试、多种执行脚本的方式、以及其他有用的运行时选项。</p>\n</blockquote>\n<blockquote>\n<p>要在终端中查看本文档作为操作手册，运行 man node</p>\n</blockquote>\n<h2 id=\"console-控制台\"><a class=\"markdownIt-Anchor\" href=\"#console-控制台\"></a> console (控制台)</h2>\n<blockquote>\n<p>console 模块提供了一个简单的调试控制台，它与 Web 浏览器提供的 JavaScript 控制台的机制类似。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.time(label) //启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。</span><br><span class=\"line\">console.timeEnd(label)  //停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout</span><br><span class=\"line\">console.trace(message[, ...args])   //打印字符串 &apos;Trace :&apos; 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。</span><br></pre></td></tr></table></figure>\n<h2 id=\"crypto-加密\"><a class=\"markdownIt-Anchor\" href=\"#crypto-加密\"></a> Crypto (加密)</h2>\n<h2 id=\"debugger-调试器\"><a class=\"markdownIt-Anchor\" href=\"#debugger-调试器\"></a> debugger (调试器)</h2>\n<blockquote>\n<p>Node.js 包含一个进程外的调试工具，可以通过基于 TCP 的协议和内置调试客户端访问。 要使用它，可以带上 debug 参数启动 Node.js，并带上需要调试的脚本的路径；然后会显示一个提示，表明成功启动调试器</p>\n</blockquote>\n<h2 id=\"dns-域名服务器\"><a class=\"markdownIt-Anchor\" href=\"#dns-域名服务器\"></a> DNS (域名服务器)</h2>\n<h2 id=\"error-错误\"><a class=\"markdownIt-Anchor\" href=\"#error-错误\"></a> Error 错误</h2>\n<p>Node.js 中运行的应用程序一般会遇到以下四类错误：</p>\n<ul>\n<li>标准的 JavaScript 错误：\n<ol>\n<li><evalerror> : 当调用 eval() 失败时抛出。</evalerror></li>\n<li><syntaxerror> : 当 JavaScript 语法错误时抛出。</syntaxerror></li>\n<li><rangeerror> : 当一个值不在预期范围内时抛出。</rangeerror></li>\n<li><referenceerror> : 当使用未定义的变量时抛出。</referenceerror></li>\n<li><typeerror> : 当传入错误类型的参数时抛出。</typeerror></li>\n<li><urierror> : 当一个全局的 URI 处理函数被误用时抛出。</urierror></li>\n</ol>\n</li>\n<li>由底层操作系的触发的系统错误，例如试图打开一个不存在的文件、试图向一个已关闭的 socket 发送数据等</li>\n<li>由应用程序代码触发的用户自定义的错误。</li>\n<li>断言错误是错误的一个特殊的类，每当 Node.js 检测到一个不应该发生的异常逻辑时会触发。 这类错误通常由 assert 模块触发。</li>\n</ul>\n<blockquote>\n<p>JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。</p>\n</blockquote>\n<blockquote>\n<p>==开发者必须查阅各个方法的文档以明确在错误发生时这些方法是如何冒泡的。==</p>\n</blockquote>\n<h2 id=\"events-事件\"><a class=\"markdownIt-Anchor\" href=\"#events-事件\"></a> events (事件)</h2>\n<blockquote>\n<p>大多数 Node.js 核心 API 都是采用惯用的异步事件驱动架构，其中某些类型的对象（称为触发器）会周期性地触发命名事件来调用函数对象（监听器）。</p>\n</blockquote>\n<blockquote>\n<p>==所有能触发事件的对象都是 EventEmitter 类的实例==。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数附加到会被对象触发的命名事件上。==当 EventEmitter 对象触发一个事件时，所有附加在特定事件上的函数都被同步地调用。==</p>\n</blockquote>\n<blockquote>\n<p>当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。</p>\n</blockquote>\n<blockquote>\n<p>每个事件默认可以注册最多 10 个监听器。可以通过一定方法设置。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此方法可用来自定义事件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEmitter</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myEmitter = <span class=\"keyword\">new</span> MyEmitter();</span><br><span class=\"line\">myEmitter.on(<span class=\"string\">'event'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生了一个事件！'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myEmitter.emit(<span class=\"string\">'event'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步与同步\"><a class=\"markdownIt-Anchor\" href=\"#异步与同步\"></a> 异步与同步</h4>\n<blockquote>\n<p>EventListener 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式.</p>\n</blockquote>\n<ul>\n<li>eventEmitter.on() //监听器会在==每次==触发命名事件时被调用</li>\n<li>eventEmitter.once() //注册一个对于特定事件被调用==最多一次==的监听器</li>\n</ul>\n<h4 id=\"错误事件\"><a class=\"markdownIt-Anchor\" href=\"#错误事件\"></a> 错误事件</h4>\n<blockquote>\n<p>当 EventEmitter 实例中发生错误时，会触发一个 ‘error’ 事件.为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器</p>\n</blockquote>\n<h2 id=\"fs-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#fs-文件系统\"></a> fs (文件系统)</h2>\n<blockquote>\n<p>文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require(‘fs’) 使用该模块。 ==所有的方法都有异步和同步的形式==</p>\n</blockquote>\n<blockquote>\n<p>异步形式始终以完成==回调作为它最后一个参数==。 传给完成回调的参数取决于具体方法，但==第一个参数总是留给异常==。 如果操作成功完成，则第一个参数会是 null 或 undefined。</p>\n</blockquote>\n<blockquote>\n<p>当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。</p>\n</blockquote>\n<h4 id=\"同步和异步的比较\"><a class=\"markdownIt-Anchor\" href=\"#同步和异步的比较\"></a> 同步和异步的比较</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//同步的方式</span><br><span class=\"line\">const fs = require(&apos;fs&apos;); </span><br><span class=\"line\">fs.unlinkSync(&apos;/tmp/hello&apos;);</span><br><span class=\"line\">console.log(&apos;successfully deleted /tmp/hello&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//异步方式</span><br><span class=\"line\">const fs = require(&apos;fs&apos;); </span><br><span class=\"line\">fs.unlink(&apos;/tmp/hello&apos;, (err) =&gt; &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&apos;successfully deleted /tmp/hello&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>异步方法不保证执行顺序</li>\n<li>异步方法之间如果有执行顺序，则正确的方法是把回调链起来</li>\n<li>强烈推荐开发者使用这些函数的异步版本。 同步版本会阻塞整个进程，直到它们完成</li>\n</ul>\n<h2 id=\"全局变量\"><a class=\"markdownIt-Anchor\" href=\"#全局变量\"></a> 全局变量</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* __dirname     //当前模块的目录名。 等同于 __filename 的 path.dirname()</span><br><span class=\"line\">* __filename    //当前模块的文件名。 这是当前模块文件的解析后的绝对路径</span><br><span class=\"line\">* exports       //module.exports 的一个简短的引用</span><br><span class=\"line\">* module        //当前模块的引用。 具体地说，module.exports 用于定义一个模块导出什么，且通过 require() 引入</span><br><span class=\"line\">* require.resolve() //使用内部的 require() 机制来查找模块的位置，但不会加载模块，只返回解析后的文件名</span><br></pre></td></tr></table></figure>\n<h2 id=\"http\"><a class=\"markdownIt-Anchor\" href=\"#http\"></a> http</h2>\n<blockquote>\n<p>Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。 比如，大块编码的消息。 该接口从不缓存整个请求或响应，所以用户能够流化数据。</p>\n</blockquote>\n<h2 id=\"https\"><a class=\"markdownIt-Anchor\" href=\"#https\"></a> https</h2>\n<blockquote>\n<p>HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。</p>\n</blockquote>\n<h2 id=\"module-模块\"><a class=\"markdownIt-Anchor\" href=\"#module-模块\"></a> module (模块)</h2>\n<blockquote>\n<p>Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>\nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br>\nNode.js 的包管理器 npm，是全球最大的开源库生态系统。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">中文网址：http://nodejs.cn/</span><br><span class=\"line\">英文网址：https://nodejs.org/en/</span><br><span class=\"line\"></span><br><span class=\"line\">其他相关网址：</span><br><span class=\"line\">https://www.npmjs.com/</span><br><span class=\"line\">https://github.com/</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a></p>\n<hr>\n<p>[toc]</p>\n<h2 id=\"node命令用法\"><a class=\"markdownIt-Anchor\" href=\"#node命令用法\"></a> node命令用法</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node [options] [v8 options] [script.js | -e &quot;script&quot;] [arguments]</span><br></pre></td></tr></table></figure>\n<h2 id=\"assert-断言\"><a class=\"markdownIt-Anchor\" href=\"#assert-断言\"></a> assert (断言)</h2>\n<blockquote>\n<p>assert 模块提供了一组简单的断言测试集合，可被用于测试不变量。 该模块在代码中可通过 require(‘assert’) 使用。 assert 不是一个测试框架，也无意成为通用的断言库。</p>\n</blockquote>\n<h2 id=\"buffer\"><a class=\"markdownIt-Anchor\" href=\"#buffer\"></a> Buffer</h2>\n<blockquote>\n<p>在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流和文件系统操作等场景中处理二进制数据流。</p>\n</blockquote>\n<blockquote>\n<p>现在 TypedArray 已经被添加进 ES6 中，Buffer 类以一种更优与更适合 Node.js 用例的方式实现了 Uint8Array API。</p>\n</blockquote>\n<blockquote>\n<p>Buffer 类的实例类似于整数数组，除了其是大小固定的、且在 V8 堆外分配物理内存。 ==Buffer 的大小在其创建时就已确定，且不能调整大小==。</p>\n</blockquote>\n<blockquote>\n<p>Buffer 类在 Node.js 中是一个全局变量，因此无需 require(‘buffer’).Buffer。</p>\n</blockquote>\n<h2 id=\"cc-插件\"><a class=\"markdownIt-Anchor\" href=\"#cc-插件\"></a> C/C++ 插件</h2>\n<blockquote>\n<p>Node.js 插件是用 C 或 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行于 Node.js 的 JavaScript 和 C/C++ 库之间提供接口。</p>\n</blockquote>\n<ul>\n<li>V8：Node.js 当前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h）==(V8在线文档) <a href=\"https://v8docs.nodesource.com/==\" target=\"_blank\" rel=\"noopener\">https://v8docs.nodesource.com/==</a></li>\n<li>libuv：实现了 Node.js 的事件循环、工作线程、与平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器和系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 鼓励插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。</li>\n<li>内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C/C++ API。 其中最重要的是 node::ObjectWrap 类。</li>\n<li>Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 有目的地再导出，并且通过插件被用于不同的场景</li>\n</ul>\n<h2 id=\"child_process-子进程\"><a class=\"markdownIt-Anchor\" href=\"#child_process-子进程\"></a> child_process (子进程)</h2>\n<blockquote>\n<p>child_process 模块提供了衍生子进程的能力</p>\n</blockquote>\n<h2 id=\"cluster\"><a class=\"markdownIt-Anchor\" href=\"#cluster\"></a> Cluster</h2>\n<h2 id=\"cli命令行选项\"><a class=\"markdownIt-Anchor\" href=\"#cli命令行选项\"></a> CLI(命令行选项)</h2>\n<blockquote>\n<p>Node.js 自带了各种命令行选项。 这些选项对外暴露了内置调试、多种执行脚本的方式、以及其他有用的运行时选项。</p>\n</blockquote>\n<blockquote>\n<p>要在终端中查看本文档作为操作手册，运行 man node</p>\n</blockquote>\n<h2 id=\"console-控制台\"><a class=\"markdownIt-Anchor\" href=\"#console-控制台\"></a> console (控制台)</h2>\n<blockquote>\n<p>console 模块提供了一个简单的调试控制台，它与 Web 浏览器提供的 JavaScript 控制台的机制类似。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.time(label) //启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。</span><br><span class=\"line\">console.timeEnd(label)  //停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout</span><br><span class=\"line\">console.trace(message[, ...args])   //打印字符串 &apos;Trace :&apos; 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。</span><br></pre></td></tr></table></figure>\n<h2 id=\"crypto-加密\"><a class=\"markdownIt-Anchor\" href=\"#crypto-加密\"></a> Crypto (加密)</h2>\n<h2 id=\"debugger-调试器\"><a class=\"markdownIt-Anchor\" href=\"#debugger-调试器\"></a> debugger (调试器)</h2>\n<blockquote>\n<p>Node.js 包含一个进程外的调试工具，可以通过基于 TCP 的协议和内置调试客户端访问。 要使用它，可以带上 debug 参数启动 Node.js，并带上需要调试的脚本的路径；然后会显示一个提示，表明成功启动调试器</p>\n</blockquote>\n<h2 id=\"dns-域名服务器\"><a class=\"markdownIt-Anchor\" href=\"#dns-域名服务器\"></a> DNS (域名服务器)</h2>\n<h2 id=\"error-错误\"><a class=\"markdownIt-Anchor\" href=\"#error-错误\"></a> Error 错误</h2>\n<p>Node.js 中运行的应用程序一般会遇到以下四类错误：</p>\n<ul>\n<li>标准的 JavaScript 错误：\n<ol>\n<li><evalerror> : 当调用 eval() 失败时抛出。</evalerror></li>\n<li><syntaxerror> : 当 JavaScript 语法错误时抛出。</syntaxerror></li>\n<li><rangeerror> : 当一个值不在预期范围内时抛出。</rangeerror></li>\n<li><referenceerror> : 当使用未定义的变量时抛出。</referenceerror></li>\n<li><typeerror> : 当传入错误类型的参数时抛出。</typeerror></li>\n<li><urierror> : 当一个全局的 URI 处理函数被误用时抛出。</urierror></li>\n</ol>\n</li>\n<li>由底层操作系的触发的系统错误，例如试图打开一个不存在的文件、试图向一个已关闭的 socket 发送数据等</li>\n<li>由应用程序代码触发的用户自定义的错误。</li>\n<li>断言错误是错误的一个特殊的类，每当 Node.js 检测到一个不应该发生的异常逻辑时会触发。 这类错误通常由 assert 模块触发。</li>\n</ul>\n<blockquote>\n<p>JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。</p>\n</blockquote>\n<blockquote>\n<p>==开发者必须查阅各个方法的文档以明确在错误发生时这些方法是如何冒泡的。==</p>\n</blockquote>\n<h2 id=\"events-事件\"><a class=\"markdownIt-Anchor\" href=\"#events-事件\"></a> events (事件)</h2>\n<blockquote>\n<p>大多数 Node.js 核心 API 都是采用惯用的异步事件驱动架构，其中某些类型的对象（称为触发器）会周期性地触发命名事件来调用函数对象（监听器）。</p>\n</blockquote>\n<blockquote>\n<p>==所有能触发事件的对象都是 EventEmitter 类的实例==。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数附加到会被对象触发的命名事件上。==当 EventEmitter 对象触发一个事件时，所有附加在特定事件上的函数都被同步地调用。==</p>\n</blockquote>\n<blockquote>\n<p>当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。</p>\n</blockquote>\n<blockquote>\n<p>每个事件默认可以注册最多 10 个监听器。可以通过一定方法设置。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此方法可用来自定义事件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEmitter</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventEmitter</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myEmitter = <span class=\"keyword\">new</span> MyEmitter();</span><br><span class=\"line\">myEmitter.on(<span class=\"string\">'event'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生了一个事件！'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myEmitter.emit(<span class=\"string\">'event'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步与同步\"><a class=\"markdownIt-Anchor\" href=\"#异步与同步\"></a> 异步与同步</h4>\n<blockquote>\n<p>EventListener 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式.</p>\n</blockquote>\n<ul>\n<li>eventEmitter.on() //监听器会在==每次==触发命名事件时被调用</li>\n<li>eventEmitter.once() //注册一个对于特定事件被调用==最多一次==的监听器</li>\n</ul>\n<h4 id=\"错误事件\"><a class=\"markdownIt-Anchor\" href=\"#错误事件\"></a> 错误事件</h4>\n<blockquote>\n<p>当 EventEmitter 实例中发生错误时，会触发一个 ‘error’ 事件.为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器</p>\n</blockquote>\n<h2 id=\"fs-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#fs-文件系统\"></a> fs (文件系统)</h2>\n<blockquote>\n<p>文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require(‘fs’) 使用该模块。 ==所有的方法都有异步和同步的形式==</p>\n</blockquote>\n<blockquote>\n<p>异步形式始终以完成==回调作为它最后一个参数==。 传给完成回调的参数取决于具体方法，但==第一个参数总是留给异常==。 如果操作成功完成，则第一个参数会是 null 或 undefined。</p>\n</blockquote>\n<blockquote>\n<p>当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。</p>\n</blockquote>\n<h4 id=\"同步和异步的比较\"><a class=\"markdownIt-Anchor\" href=\"#同步和异步的比较\"></a> 同步和异步的比较</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//同步的方式</span><br><span class=\"line\">const fs = require(&apos;fs&apos;); </span><br><span class=\"line\">fs.unlinkSync(&apos;/tmp/hello&apos;);</span><br><span class=\"line\">console.log(&apos;successfully deleted /tmp/hello&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//异步方式</span><br><span class=\"line\">const fs = require(&apos;fs&apos;); </span><br><span class=\"line\">fs.unlink(&apos;/tmp/hello&apos;, (err) =&gt; &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&apos;successfully deleted /tmp/hello&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>异步方法不保证执行顺序</li>\n<li>异步方法之间如果有执行顺序，则正确的方法是把回调链起来</li>\n<li>强烈推荐开发者使用这些函数的异步版本。 同步版本会阻塞整个进程，直到它们完成</li>\n</ul>\n<h2 id=\"全局变量\"><a class=\"markdownIt-Anchor\" href=\"#全局变量\"></a> 全局变量</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* __dirname     //当前模块的目录名。 等同于 __filename 的 path.dirname()</span><br><span class=\"line\">* __filename    //当前模块的文件名。 这是当前模块文件的解析后的绝对路径</span><br><span class=\"line\">* exports       //module.exports 的一个简短的引用</span><br><span class=\"line\">* module        //当前模块的引用。 具体地说，module.exports 用于定义一个模块导出什么，且通过 require() 引入</span><br><span class=\"line\">* require.resolve() //使用内部的 require() 机制来查找模块的位置，但不会加载模块，只返回解析后的文件名</span><br></pre></td></tr></table></figure>\n<h2 id=\"http\"><a class=\"markdownIt-Anchor\" href=\"#http\"></a> http</h2>\n<blockquote>\n<p>Node.js 中的 HTTP 接口被设计为支持以往较难使用的协议的许多特性。 比如，大块编码的消息。 该接口从不缓存整个请求或响应，所以用户能够流化数据。</p>\n</blockquote>\n<h2 id=\"https\"><a class=\"markdownIt-Anchor\" href=\"#https\"></a> https</h2>\n<blockquote>\n<p>HTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。</p>\n</blockquote>\n<h2 id=\"module-模块\"><a class=\"markdownIt-Anchor\" href=\"#module-模块\"></a> module (模块)</h2>\n<blockquote>\n<p>Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）</p>\n</blockquote>\n"},{"title":"NodeJS快速入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\nhttp://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/\n\n[toc]\n\n## Node中标准回调函数\n~~~js\nfunction(err,data){\n\n}\n第一个参数为err是错误信息\n第二个参数为data是返回的数据\n~~~\n\n## 进程管理\n\n> process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。\n\n> 使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。\n\n~~~\n* process.cwd();            //查看应用程序当前目录\n* process.chdir(\"目录\");    //改变应用程序目录\n* stdout是标准输出流,作用就是将内容打印到输出设备上\n    console.log = function(d){\n        process.stdout.write(d+'\\n');\n    } \n* stderr是标准错误流,用来打印错误信息,可以通过它来捕获错误信息     //process.stderr.write(输入内容);\n* stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容\n    process.stdin.on('readable', function() {\n      var chunk = process.stdin.read();\n      if (chunk !== null) {\n        process.stdout.write('data: ' + chunk);\n      }\n    });\n* process.exit(code);   //需要在程序内杀死进程，退出程序时使用，参数code为退出后返回的代码，如果省略则默认返回0；\n* process.on()；        //此方法可监听进程事件\n  exit事件：//当进程要退出之前，会触发exit事件。通过监听exit事件，我们可就以在进程退出前进行一些清理工作： \n        process.on(\"exit\",function(code){//参数code表示退出码 \n          console.log(\"I am tired...\")//进行一些清理工作\n        }); \n    uncaughtException事件:  //如果进程发生了未捕捉的异常，会触发uncaughtException事件。通过监听这个事件，可以 让进程优雅的退出\n        process.on(\"uncaughtException\",function(err){\n            console.log(err);\n        });\n        throw new Error(\"我故意的...\"); //故意抛出一个异常\n* 设置编码\n  process.stdin.setEncoding(编码);\n  process.stdout.setEncoding(编码);\n  process.stderr.setEncoding(编码);\n~~~\n\n## 子进程\n> ==node.js是基于单线程模型架构==，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了==child_process模块，通过多进程来实现对多核CPU的利用==\n\n> child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。\n1. spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出\n~~~\nvar child_process = require('child_process');\nvar child = child_process.spawn( command );\nchild.stdout.on('data', function(data) {\n  console.log(data);\n});\n通过执行命令得到返回结果\n~~~\n2. exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数\n~~~\nvar child_process = require('child_process');\nchild_process.exec( command , function(err, stdout , stderr ) {\n  console.log( stdout );\n});\n~~~\n3. execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件\n~~~\nvar child_process = require('child_process');\nchild_process.execFile( file , function(err, stdout , stderr ) {\n  console.log( stdout );\n});\n~~~\n4. ==fork函数可直接运行Node.js模块==，所以我们可以直接通过指定模块路径而直接进行操作.==该方法是spawn()的特殊情景，用于派生Node进程==\n~~~\nvar child_process = require('child_process');\nchild_process.fork( modulePath );\n~~~\n\n\n## 文件I/O\n> node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。\n\n> fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。\n---\n\n* fs.writeFile(filename, data, callback)\n> 异步的将数据写入一个文件\n如果文件已经存在则会被替换;数据参数可以是string或者是Buffer,编码格式参数可选，默认为\"utf8\"\n~~~\nvar fs= require(\"fs\"); \nfs.writeFile('test.txt', 'Hello Node', function (err) {\n   if (err) throw err;\n   console.log('Saved successfully'); //文件被保存\n}); \n~~~\n\n* fs.appendFile(文件名,数据,编码,回调函数(err));\n> 将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件;编码格式默认为\"utf8\"\n~~~\nvar fs= require(\"fs\"); \nfs.appendFile('test.txt', 'data to append', function (err) {\n   if (err) throw err;  \n    console.log('The \"data to append\" was appended to file!'); \n});\n~~~\n\n* fs.exists(文件，回调函数(exists));    //exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在\n* fs.rename(旧文件，新文件，回调函数(err)); ==//修改文件名称==\n* fs.rename(oldPath,newPath,function (err); ==//移动文件==\n* fs.readFile(文件,[编码],回调函数);    //读取文件内容\n* fs.unlink(文件,回调函数(err)); ==//删除文件==\n* fs.mkdir(路径，权限，回调函数(err)); //创建目录；\n~~~\n权限：默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作\n~~~\n\n* fs.rmdir(路径，回调函数(err)); //删除目录\n* fs.readdir(目录,回调函数(err,files));//读取目录下所有的文件\n\n## url处理\n> node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。\n\n* url.parse('http://www.baidu.com');    //解析url，返回一个json格式的数组\n* url.parse('http://www.baidu.com?page=1',true);//当==第二个==参数为true时，会将查询条件也解析成json格式的对象。\n* url.parse('http://www.baidu.com/news',false,true);当==第三个==参数为true，解析时会将url的\"//\"和第一个\"/\"之间的部分解析为主机名\n* url.format({\n                protocol: 'http:',\n                hostname:'www.baidu.com',\n                port:'80',\n                pathname :'/news',\n                query:{page:1}\n                }\n  );\n==**作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址**==\n* url.resolve('http://example.com/two', '/one')；//组装路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径。==结果：=='http://example.com/one'\n\n## path优化\n> 本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率\n\n* path.normalize('/path///normalize/hi/..');//将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与..外，还能去掉多余的斜杠\n* path.join('///you', '/are', '//beautiful');//结果：'/you/are/beautiful'。join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐\n* path.dirname('/foo/strong/cool/nice'); //用来返回路径中的目录名\n* basename函数可返回路径中的最后一部分，并且可以对其进行条件排除.\n1. path.basename('路径字符串');\n2. path.basename('路径字符串', '[ext]')<排除[ext]后缀字符串>;\n*  path.extname('index.html'); //返回路径中文件的扩展名\n\n## 字符串转换 \n> Query String模块用于==实现URL参数字符串与参数对象之间的互相转换==，提供了\"stringify\"、\"parse\"等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助\n\n### 序列化\n--- \n* querystring.stringify({foo:'bar',cool:['xux', 'yys']}); //结果：foo=bar&cool=xux&cool=yys。\n~~~\n作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（\"&\"）和分配符（\"=\"））\n~~~\n* querystring.stringify(\"对象\"，\"分隔符\"，\"分配符\")\n~~~\nquerystring.stringify({foo:'bar',cool:['xux', 'yys']},'*','$');\n结果：'foo$bar*cool$xux*cool$yys'\n~~~\n\n### 反序列化\n---\n* querystring.parse('foo=bar&cool=xux&cool=yys');\n~~~\n运行结果：{ foo: 'bar', cool: ['xux', 'yys']}\nparse函数的作用就是反序列化字符串（默认是由\"=\"、\"&\"拼接而成），转换得到一个对象类型\n~~~\n* querystring.parse('foo@bar$cool@xux$cool@yys','@','$');\n~~~\n运行结果：{ foo: '', bar: 'cool', xux: 'cool', yys: '' }\n~~~\n\n## 实用工具\n>util模块。util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证\n\n* util.inspect(object,[showHidden],[depth],[colors])； //将任意对象转换为字符串的函数，通常用于调试和错误输出\n* format函数\n~~~\n1. 如果占位符没有相对应的参数，占位符将不会被替换\n2. 如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔\n3. 如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串\n~~~\n* util.isArray(object);  //判断对象是否为数组类型，是则返回ture,否则为fals\n* util.isDate(object); //判断对象是否为日期类型，是则返回ture,否则返回false\n* util.isRegExp(object); //判断对象是否为正则类型，是则返回ture,否则返回false","source":"_posts/node/NodeJS快速入门.md","raw":"---\ntitle: NodeJS快速入门\ntags:\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\nhttp://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/\n\n[toc]\n\n## Node中标准回调函数\n~~~js\nfunction(err,data){\n\n}\n第一个参数为err是错误信息\n第二个参数为data是返回的数据\n~~~\n\n## 进程管理\n\n> process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。\n\n> 使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。\n\n~~~\n* process.cwd();            //查看应用程序当前目录\n* process.chdir(\"目录\");    //改变应用程序目录\n* stdout是标准输出流,作用就是将内容打印到输出设备上\n    console.log = function(d){\n        process.stdout.write(d+'\\n');\n    } \n* stderr是标准错误流,用来打印错误信息,可以通过它来捕获错误信息     //process.stderr.write(输入内容);\n* stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容\n    process.stdin.on('readable', function() {\n      var chunk = process.stdin.read();\n      if (chunk !== null) {\n        process.stdout.write('data: ' + chunk);\n      }\n    });\n* process.exit(code);   //需要在程序内杀死进程，退出程序时使用，参数code为退出后返回的代码，如果省略则默认返回0；\n* process.on()；        //此方法可监听进程事件\n  exit事件：//当进程要退出之前，会触发exit事件。通过监听exit事件，我们可就以在进程退出前进行一些清理工作： \n        process.on(\"exit\",function(code){//参数code表示退出码 \n          console.log(\"I am tired...\")//进行一些清理工作\n        }); \n    uncaughtException事件:  //如果进程发生了未捕捉的异常，会触发uncaughtException事件。通过监听这个事件，可以 让进程优雅的退出\n        process.on(\"uncaughtException\",function(err){\n            console.log(err);\n        });\n        throw new Error(\"我故意的...\"); //故意抛出一个异常\n* 设置编码\n  process.stdin.setEncoding(编码);\n  process.stdout.setEncoding(编码);\n  process.stderr.setEncoding(编码);\n~~~\n\n## 子进程\n> ==node.js是基于单线程模型架构==，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了==child_process模块，通过多进程来实现对多核CPU的利用==\n\n> child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。\n1. spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出\n~~~\nvar child_process = require('child_process');\nvar child = child_process.spawn( command );\nchild.stdout.on('data', function(data) {\n  console.log(data);\n});\n通过执行命令得到返回结果\n~~~\n2. exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数\n~~~\nvar child_process = require('child_process');\nchild_process.exec( command , function(err, stdout , stderr ) {\n  console.log( stdout );\n});\n~~~\n3. execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件\n~~~\nvar child_process = require('child_process');\nchild_process.execFile( file , function(err, stdout , stderr ) {\n  console.log( stdout );\n});\n~~~\n4. ==fork函数可直接运行Node.js模块==，所以我们可以直接通过指定模块路径而直接进行操作.==该方法是spawn()的特殊情景，用于派生Node进程==\n~~~\nvar child_process = require('child_process');\nchild_process.fork( modulePath );\n~~~\n\n\n## 文件I/O\n> node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。\n\n> fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。\n---\n\n* fs.writeFile(filename, data, callback)\n> 异步的将数据写入一个文件\n如果文件已经存在则会被替换;数据参数可以是string或者是Buffer,编码格式参数可选，默认为\"utf8\"\n~~~\nvar fs= require(\"fs\"); \nfs.writeFile('test.txt', 'Hello Node', function (err) {\n   if (err) throw err;\n   console.log('Saved successfully'); //文件被保存\n}); \n~~~\n\n* fs.appendFile(文件名,数据,编码,回调函数(err));\n> 将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件;编码格式默认为\"utf8\"\n~~~\nvar fs= require(\"fs\"); \nfs.appendFile('test.txt', 'data to append', function (err) {\n   if (err) throw err;  \n    console.log('The \"data to append\" was appended to file!'); \n});\n~~~\n\n* fs.exists(文件，回调函数(exists));    //exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在\n* fs.rename(旧文件，新文件，回调函数(err)); ==//修改文件名称==\n* fs.rename(oldPath,newPath,function (err); ==//移动文件==\n* fs.readFile(文件,[编码],回调函数);    //读取文件内容\n* fs.unlink(文件,回调函数(err)); ==//删除文件==\n* fs.mkdir(路径，权限，回调函数(err)); //创建目录；\n~~~\n权限：默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作\n~~~\n\n* fs.rmdir(路径，回调函数(err)); //删除目录\n* fs.readdir(目录,回调函数(err,files));//读取目录下所有的文件\n\n## url处理\n> node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。\n\n* url.parse('http://www.baidu.com');    //解析url，返回一个json格式的数组\n* url.parse('http://www.baidu.com?page=1',true);//当==第二个==参数为true时，会将查询条件也解析成json格式的对象。\n* url.parse('http://www.baidu.com/news',false,true);当==第三个==参数为true，解析时会将url的\"//\"和第一个\"/\"之间的部分解析为主机名\n* url.format({\n                protocol: 'http:',\n                hostname:'www.baidu.com',\n                port:'80',\n                pathname :'/news',\n                query:{page:1}\n                }\n  );\n==**作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址**==\n* url.resolve('http://example.com/two', '/one')；//组装路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径。==结果：=='http://example.com/one'\n\n## path优化\n> 本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率\n\n* path.normalize('/path///normalize/hi/..');//将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与..外，还能去掉多余的斜杠\n* path.join('///you', '/are', '//beautiful');//结果：'/you/are/beautiful'。join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐\n* path.dirname('/foo/strong/cool/nice'); //用来返回路径中的目录名\n* basename函数可返回路径中的最后一部分，并且可以对其进行条件排除.\n1. path.basename('路径字符串');\n2. path.basename('路径字符串', '[ext]')<排除[ext]后缀字符串>;\n*  path.extname('index.html'); //返回路径中文件的扩展名\n\n## 字符串转换 \n> Query String模块用于==实现URL参数字符串与参数对象之间的互相转换==，提供了\"stringify\"、\"parse\"等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助\n\n### 序列化\n--- \n* querystring.stringify({foo:'bar',cool:['xux', 'yys']}); //结果：foo=bar&cool=xux&cool=yys。\n~~~\n作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（\"&\"）和分配符（\"=\"））\n~~~\n* querystring.stringify(\"对象\"，\"分隔符\"，\"分配符\")\n~~~\nquerystring.stringify({foo:'bar',cool:['xux', 'yys']},'*','$');\n结果：'foo$bar*cool$xux*cool$yys'\n~~~\n\n### 反序列化\n---\n* querystring.parse('foo=bar&cool=xux&cool=yys');\n~~~\n运行结果：{ foo: 'bar', cool: ['xux', 'yys']}\nparse函数的作用就是反序列化字符串（默认是由\"=\"、\"&\"拼接而成），转换得到一个对象类型\n~~~\n* querystring.parse('foo@bar$cool@xux$cool@yys','@','$');\n~~~\n运行结果：{ foo: '', bar: 'cool', xux: 'cool', yys: '' }\n~~~\n\n## 实用工具\n>util模块。util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证\n\n* util.inspect(object,[showHidden],[depth],[colors])； //将任意对象转换为字符串的函数，通常用于调试和错误输出\n* format函数\n~~~\n1. 如果占位符没有相对应的参数，占位符将不会被替换\n2. 如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔\n3. 如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串\n~~~\n* util.isArray(object);  //判断对象是否为数组类型，是则返回ture,否则为fals\n* util.isDate(object); //判断对象是否为日期类型，是则返回ture,否则返回false\n* util.isRegExp(object); //判断对象是否为正则类型，是则返回ture,否则返回false","slug":"node-NodeJS快速入门","published":1,"updated":"2019-02-14T06:43:38.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3k00dm5b8h1o3bisik","content":"<p><a href=\"http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/\" target=\"_blank\" rel=\"noopener\">http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/</a></p>\n<p>[toc]</p>\n<h2 id=\"node中标准回调函数\"><a class=\"markdownIt-Anchor\" href=\"#node中标准回调函数\"></a> Node中标准回调函数</h2>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">第一个参数为err是错误信息</span><br><span class=\"line\">第二个参数为data是返回的数据</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程管理\"><a class=\"markdownIt-Anchor\" href=\"#进程管理\"></a> 进程管理</h2>\n<blockquote>\n<p>process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。</p>\n</blockquote>\n<blockquote>\n<p>使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* process.cwd();            //查看应用程序当前目录</span><br><span class=\"line\">* process.chdir(&quot;目录&quot;);    //改变应用程序目录</span><br><span class=\"line\">* stdout是标准输出流,作用就是将内容打印到输出设备上</span><br><span class=\"line\">    console.log = function(d)&#123;</span><br><span class=\"line\">        process.stdout.write(d+&apos;\\n&apos;);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">* stderr是标准错误流,用来打印错误信息,可以通过它来捕获错误信息     //process.stderr.write(输入内容);</span><br><span class=\"line\">* stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容</span><br><span class=\"line\">    process.stdin.on(&apos;readable&apos;, function() &#123;</span><br><span class=\"line\">      var chunk = process.stdin.read();</span><br><span class=\"line\">      if (chunk !== null) &#123;</span><br><span class=\"line\">        process.stdout.write(&apos;data: &apos; + chunk);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">* process.exit(code);   //需要在程序内杀死进程，退出程序时使用，参数code为退出后返回的代码，如果省略则默认返回0；</span><br><span class=\"line\">* process.on()；        //此方法可监听进程事件</span><br><span class=\"line\">  exit事件：//当进程要退出之前，会触发exit事件。通过监听exit事件，我们可就以在进程退出前进行一些清理工作： </span><br><span class=\"line\">        process.on(&quot;exit&quot;,function(code)&#123;//参数code表示退出码 </span><br><span class=\"line\">          console.log(&quot;I am tired...&quot;)//进行一些清理工作</span><br><span class=\"line\">        &#125;); </span><br><span class=\"line\">    uncaughtException事件:  //如果进程发生了未捕捉的异常，会触发uncaughtException事件。通过监听这个事件，可以 让进程优雅的退出</span><br><span class=\"line\">        process.on(&quot;uncaughtException&quot;,function(err)&#123;</span><br><span class=\"line\">            console.log(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        throw new Error(&quot;我故意的...&quot;); //故意抛出一个异常</span><br><span class=\"line\">* 设置编码</span><br><span class=\"line\">  process.stdin.setEncoding(编码);</span><br><span class=\"line\">  process.stdout.setEncoding(编码);</span><br><span class=\"line\">  process.stderr.setEncoding(编码);</span><br></pre></td></tr></table></figure>\n<h2 id=\"子进程\"><a class=\"markdownIt-Anchor\" href=\"#子进程\"></a> 子进程</h2>\n<blockquote>\n<p>==node.js是基于单线程模型架构==，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了==child_process模块，通过多进程来实现对多核CPU的利用==</p>\n</blockquote>\n<blockquote>\n<p>child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。</p>\n</blockquote>\n<ol>\n<li>spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">var child = child_process.spawn( command );</span><br><span class=\"line\">child.stdout.on(&apos;data&apos;, function(data) &#123;</span><br><span class=\"line\">  console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">通过执行命令得到返回结果</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">child_process.exec( command , function(err, stdout , stderr ) &#123;</span><br><span class=\"line\">  console.log( stdout );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">child_process.execFile( file , function(err, stdout , stderr ) &#123;</span><br><span class=\"line\">  console.log( stdout );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>==fork函数可直接运行Node.js模块==，所以我们可以直接通过指定模块路径而直接进行操作.==该方法是spawn()的特殊情景，用于派生Node进程==</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">child_process.fork( modulePath );</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件io\"><a class=\"markdownIt-Anchor\" href=\"#文件io\"></a> 文件I/O</h2>\n<blockquote>\n<p>node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。</p>\n</blockquote>\n<blockquote>\n<p>fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。</p>\n</blockquote>\n<hr>\n<ul>\n<li>fs.writeFile(filename, data, callback)</li>\n</ul>\n<blockquote>\n<p>异步的将数据写入一个文件<br>\n如果文件已经存在则会被替换;数据参数可以是string或者是Buffer,编码格式参数可选，默认为&quot;utf8&quot;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs= require(&quot;fs&quot;); </span><br><span class=\"line\">fs.writeFile(&apos;test.txt&apos;, &apos;Hello Node&apos;, function (err) &#123;</span><br><span class=\"line\">   if (err) throw err;</span><br><span class=\"line\">   console.log(&apos;Saved successfully&apos;); //文件被保存</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fs.appendFile(文件名,数据,编码,回调函数(err));</li>\n</ul>\n<blockquote>\n<p>将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件;编码格式默认为&quot;utf8&quot;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs= require(&quot;fs&quot;); </span><br><span class=\"line\">fs.appendFile(&apos;test.txt&apos;, &apos;data to append&apos;, function (err) &#123;</span><br><span class=\"line\">   if (err) throw err;  </span><br><span class=\"line\">    console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fs.exists(文件，回调函数(exists));    //exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在</li>\n<li>fs.rename(旧文件，新文件，回调函数(err)); ==//修改文件名称==</li>\n<li>fs.rename(oldPath,newPath,function (err); ==//移动文件==</li>\n<li>fs.readFile(文件,[编码],回调函数);    //读取文件内容</li>\n<li>fs.unlink(文件,回调函数(err)); ==//删除文件==</li>\n<li>fs.mkdir(路径，权限，回调函数(err)); //创建目录；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">权限：默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fs.rmdir(路径，回调函数(err)); //删除目录</li>\n<li>fs.readdir(目录,回调函数(err,files));//读取目录下所有的文件</li>\n</ul>\n<h2 id=\"url处理\"><a class=\"markdownIt-Anchor\" href=\"#url处理\"></a> url处理</h2>\n<blockquote>\n<p>node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。</p>\n</blockquote>\n<ul>\n<li>url.parse(‘<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>’);    //解析url，返回一个json格式的数组</li>\n<li>url.parse(‘<a href=\"http://www.baidu.com?page=1\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com?page=1</a>’,true);//当==第二个==参数为true时，会将查询条件也解析成json格式的对象。</li>\n<li>url.parse(‘<a href=\"http://www.baidu.com/news\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/news</a>’,false,true);当==第三个==参数为true，解析时会将url的&quot;//“和第一个”/&quot;之间的部分解析为主机名</li>\n<li>url.format({<br>\nprotocol: ‘http:’,<br>\nhostname:‘<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a>’,<br>\nport:‘80’,<br>\npathname :’/news’,<br>\nquery:{page:1}<br>\n}<br>\n);<br>\n==<strong>作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址</strong>==</li>\n<li>url.resolve(‘<a href=\"http://example.com/two\" target=\"_blank\" rel=\"noopener\">http://example.com/two</a>’, ‘/one’)；//组装路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径。==结果：==‘<a href=\"http://example.com/one\" target=\"_blank\" rel=\"noopener\">http://example.com/one</a>’</li>\n</ul>\n<h2 id=\"path优化\"><a class=\"markdownIt-Anchor\" href=\"#path优化\"></a> path优化</h2>\n<blockquote>\n<p>本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率</p>\n</blockquote>\n<ul>\n<li>path.normalize(’/path///normalize/hi/…’);//将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与…外，还能去掉多余的斜杠</li>\n<li>path.join(’///you’, ‘/are’, ‘//beautiful’);//结果：’/you/are/beautiful’。join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐</li>\n<li>path.dirname(’/foo/strong/cool/nice’); //用来返回路径中的目录名</li>\n<li>basename函数可返回路径中的最后一部分，并且可以对其进行条件排除.</li>\n</ul>\n<ol>\n<li>path.basename(‘路径字符串’);</li>\n<li>path.basename(‘路径字符串’, ‘[ext]’)&lt;排除[ext]后缀字符串&gt;;</li>\n</ol>\n<ul>\n<li>path.extname(‘index.html’); //返回路径中文件的扩展名</li>\n</ul>\n<h2 id=\"字符串转换\"><a class=\"markdownIt-Anchor\" href=\"#字符串转换\"></a> 字符串转换</h2>\n<blockquote>\n<p>Query String模块用于==实现URL参数字符串与参数对象之间的互相转换==，提供了&quot;stringify&quot;、&quot;parse&quot;等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助</p>\n</blockquote>\n<h3 id=\"序列化\"><a class=\"markdownIt-Anchor\" href=\"#序列化\"></a> 序列化</h3>\n<hr>\n<ul>\n<li>querystring.stringify({foo:‘bar’,cool:[‘xux’, ‘yys’]}); //结果：foo=bar&amp;cool=xux&amp;cool=yys。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（&quot;&amp;&quot;）和分配符（&quot;=&quot;））</span><br></pre></td></tr></table></figure>\n<ul>\n<li>querystring.stringify(“对象”，“分隔符”，“分配符”)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">querystring.stringify(&#123;foo:&apos;bar&apos;,cool:[&apos;xux&apos;, &apos;yys&apos;]&#125;,&apos;*&apos;,&apos;$&apos;);</span><br><span class=\"line\">结果：&apos;foo$bar*cool$xux*cool$yys&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"反序列化\"><a class=\"markdownIt-Anchor\" href=\"#反序列化\"></a> 反序列化</h3>\n<hr>\n<ul>\n<li>querystring.parse(‘foo=bar&amp;cool=xux&amp;cool=yys’);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：&#123; foo: &apos;bar&apos;, cool: [&apos;xux&apos;, &apos;yys&apos;]&#125;</span><br><span class=\"line\">parse函数的作用就是反序列化字符串（默认是由&quot;=&quot;、&quot;&amp;&quot;拼接而成），转换得到一个对象类型</span><br></pre></td></tr></table></figure>\n<ul>\n<li>querystring.parse(‘foo@bar<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi mathvariant=\"normal\">@</mi><mi>x</mi><mi>u</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">cool@xux</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">@</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">x</span></span></span></span>cool@yys’,’@’,’$’);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：&#123; foo: &apos;&apos;, bar: &apos;cool&apos;, xux: &apos;cool&apos;, yys: &apos;&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实用工具\"><a class=\"markdownIt-Anchor\" href=\"#实用工具\"></a> 实用工具</h2>\n<blockquote>\n<p>util模块。util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证</p>\n</blockquote>\n<ul>\n<li>util.inspect(object,[showHidden],[depth],[colors])； //将任意对象转换为字符串的函数，通常用于调试和错误输出</li>\n<li>format函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果占位符没有相对应的参数，占位符将不会被替换</span><br><span class=\"line\">2. 如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔</span><br><span class=\"line\">3. 如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串</span><br></pre></td></tr></table></figure>\n<ul>\n<li>util.isArray(object);  //判断对象是否为数组类型，是则返回ture,否则为fals</li>\n<li>util.isDate(object); //判断对象是否为日期类型，是则返回ture,否则返回false</li>\n<li>util.isRegExp(object); //判断对象是否为正则类型，是则返回ture,否则返回false</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/\" target=\"_blank\" rel=\"noopener\">http://cw.hubwiz.com/card/c/5359f6f6ec7452081a7873d8/1/1/2/</a></p>\n<p>[toc]</p>\n<h2 id=\"node中标准回调函数\"><a class=\"markdownIt-Anchor\" href=\"#node中标准回调函数\"></a> Node中标准回调函数</h2>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">第一个参数为err是错误信息</span><br><span class=\"line\">第二个参数为data是返回的数据</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程管理\"><a class=\"markdownIt-Anchor\" href=\"#进程管理\"></a> 进程管理</h2>\n<blockquote>\n<p>process是一个全局内置对象，可以在代码中的任何位置访问此对象，这个对象代表我们的node.js代码宿主的操作系统进程对象。</p>\n</blockquote>\n<blockquote>\n<p>使用process对象可以截获进程的异常、退出等事件，也可以获取进程的当前目录、环境变量、内存占用等信息，还可以执行进程退出、工作目录切换等操作。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* process.cwd();            //查看应用程序当前目录</span><br><span class=\"line\">* process.chdir(&quot;目录&quot;);    //改变应用程序目录</span><br><span class=\"line\">* stdout是标准输出流,作用就是将内容打印到输出设备上</span><br><span class=\"line\">    console.log = function(d)&#123;</span><br><span class=\"line\">        process.stdout.write(d+&apos;\\n&apos;);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">* stderr是标准错误流,用来打印错误信息,可以通过它来捕获错误信息     //process.stderr.write(输入内容);</span><br><span class=\"line\">* stdin是进程的输入流,我们可以通过注册事件的方式来获取输入的内容</span><br><span class=\"line\">    process.stdin.on(&apos;readable&apos;, function() &#123;</span><br><span class=\"line\">      var chunk = process.stdin.read();</span><br><span class=\"line\">      if (chunk !== null) &#123;</span><br><span class=\"line\">        process.stdout.write(&apos;data: &apos; + chunk);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">* process.exit(code);   //需要在程序内杀死进程，退出程序时使用，参数code为退出后返回的代码，如果省略则默认返回0；</span><br><span class=\"line\">* process.on()；        //此方法可监听进程事件</span><br><span class=\"line\">  exit事件：//当进程要退出之前，会触发exit事件。通过监听exit事件，我们可就以在进程退出前进行一些清理工作： </span><br><span class=\"line\">        process.on(&quot;exit&quot;,function(code)&#123;//参数code表示退出码 </span><br><span class=\"line\">          console.log(&quot;I am tired...&quot;)//进行一些清理工作</span><br><span class=\"line\">        &#125;); </span><br><span class=\"line\">    uncaughtException事件:  //如果进程发生了未捕捉的异常，会触发uncaughtException事件。通过监听这个事件，可以 让进程优雅的退出</span><br><span class=\"line\">        process.on(&quot;uncaughtException&quot;,function(err)&#123;</span><br><span class=\"line\">            console.log(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        throw new Error(&quot;我故意的...&quot;); //故意抛出一个异常</span><br><span class=\"line\">* 设置编码</span><br><span class=\"line\">  process.stdin.setEncoding(编码);</span><br><span class=\"line\">  process.stdout.setEncoding(编码);</span><br><span class=\"line\">  process.stderr.setEncoding(编码);</span><br></pre></td></tr></table></figure>\n<h2 id=\"子进程\"><a class=\"markdownIt-Anchor\" href=\"#子进程\"></a> 子进程</h2>\n<blockquote>\n<p>==node.js是基于单线程模型架构==，这样的设计可以带来高效的CPU利用率，但是无法却利用多个核心的CPU，为了解决这个问题，node.js提供了==child_process模块，通过多进程来实现对多核CPU的利用==</p>\n</blockquote>\n<blockquote>\n<p>child_process模块提供了四个创建子进程的函数，分别是spawn，exec，execFile和fork。</p>\n</blockquote>\n<ol>\n<li>spawn函数用给定的命令发布一个子进程，只能运行指定的程序，参数需要在列表中给出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">var child = child_process.spawn( command );</span><br><span class=\"line\">child.stdout.on(&apos;data&apos;, function(data) &#123;</span><br><span class=\"line\">  console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">通过执行命令得到返回结果</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>exec也是一个创建子进程的函数，与spawn函数不同它可以直接接受一个回调函数作为参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">child_process.exec( command , function(err, stdout , stderr ) &#123;</span><br><span class=\"line\">  console.log( stdout );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>execFile函数与exec函数类似，但execFile函数更显得精简，因为它可以直接执行所指定的文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">child_process.execFile( file , function(err, stdout , stderr ) &#123;</span><br><span class=\"line\">  console.log( stdout );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>==fork函数可直接运行Node.js模块==，所以我们可以直接通过指定模块路径而直接进行操作.==该方法是spawn()的特殊情景，用于派生Node进程==</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child_process = require(&apos;child_process&apos;);</span><br><span class=\"line\">child_process.fork( modulePath );</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件io\"><a class=\"markdownIt-Anchor\" href=\"#文件io\"></a> 文件I/O</h2>\n<blockquote>\n<p>node.js中提供一个名为fs的模块来支持I/O操作，fs模块的文件I/O是对标准POSIX函数的简单封装。</p>\n</blockquote>\n<blockquote>\n<p>fs模块不但提供异步的文件操作，还提供相应的同步操作方法，需要指出的是，nodejs采用异步I/O正是为了避免I/O时的等待时间，提高CPU的利用率，所以在选择使用异步或同步方法的时候需要权衡取舍。</p>\n</blockquote>\n<hr>\n<ul>\n<li>fs.writeFile(filename, data, callback)</li>\n</ul>\n<blockquote>\n<p>异步的将数据写入一个文件<br>\n如果文件已经存在则会被替换;数据参数可以是string或者是Buffer,编码格式参数可选，默认为&quot;utf8&quot;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs= require(&quot;fs&quot;); </span><br><span class=\"line\">fs.writeFile(&apos;test.txt&apos;, &apos;Hello Node&apos;, function (err) &#123;</span><br><span class=\"line\">   if (err) throw err;</span><br><span class=\"line\">   console.log(&apos;Saved successfully&apos;); //文件被保存</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fs.appendFile(文件名,数据,编码,回调函数(err));</li>\n</ul>\n<blockquote>\n<p>将新的内容追加到已有的文件中，如果文件不存在，则会创建一个新的文件;编码格式默认为&quot;utf8&quot;</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs= require(&quot;fs&quot;); </span><br><span class=\"line\">fs.appendFile(&apos;test.txt&apos;, &apos;data to append&apos;, function (err) &#123;</span><br><span class=\"line\">   if (err) throw err;  </span><br><span class=\"line\">    console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fs.exists(文件，回调函数(exists));    //exists的回调函数只有一个参数，类型为布尔型，通过它来表示文件是否存在</li>\n<li>fs.rename(旧文件，新文件，回调函数(err)); ==//修改文件名称==</li>\n<li>fs.rename(oldPath,newPath,function (err); ==//移动文件==</li>\n<li>fs.readFile(文件,[编码],回调函数);    //读取文件内容</li>\n<li>fs.unlink(文件,回调函数(err)); ==//删除文件==</li>\n<li>fs.mkdir(路径，权限，回调函数(err)); //创建目录；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">权限：默认为0777，表示文件所有者、文件所有者所在的组的用户、所有用户，都有权限进行读、写、执行的操作</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fs.rmdir(路径，回调函数(err)); //删除目录</li>\n<li>fs.readdir(目录,回调函数(err,files));//读取目录下所有的文件</li>\n</ul>\n<h2 id=\"url处理\"><a class=\"markdownIt-Anchor\" href=\"#url处理\"></a> url处理</h2>\n<blockquote>\n<p>node.js为互联网而生，和url打交道是无法避免的了，url模块提供一些基础的url处理。</p>\n</blockquote>\n<ul>\n<li>url.parse(‘<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a>’);    //解析url，返回一个json格式的数组</li>\n<li>url.parse(‘<a href=\"http://www.baidu.com?page=1\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com?page=1</a>’,true);//当==第二个==参数为true时，会将查询条件也解析成json格式的对象。</li>\n<li>url.parse(‘<a href=\"http://www.baidu.com/news\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/news</a>’,false,true);当==第三个==参数为true，解析时会将url的&quot;//“和第一个”/&quot;之间的部分解析为主机名</li>\n<li>url.format({<br>\nprotocol: ‘http:’,<br>\nhostname:‘<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a>’,<br>\nport:‘80’,<br>\npathname :’/news’,<br>\nquery:{page:1}<br>\n}<br>\n);<br>\n==<strong>作用与parse相反，它的参数是一个JSON对象，返回一个组装好的url地址</strong>==</li>\n<li>url.resolve(‘<a href=\"http://example.com/two\" target=\"_blank\" rel=\"noopener\">http://example.com/two</a>’, ‘/one’)；//组装路径，第一个路径是开始的路径或者说当前路径，第二个则是想要去往的路径。==结果：==‘<a href=\"http://example.com/one\" target=\"_blank\" rel=\"noopener\">http://example.com/one</a>’</li>\n</ul>\n<h2 id=\"path优化\"><a class=\"markdownIt-Anchor\" href=\"#path优化\"></a> path优化</h2>\n<blockquote>\n<p>本模块包含一套用于处理和转换文件路径的工具集,用于处理目录的对象，提高用户开发效率</p>\n</blockquote>\n<ul>\n<li>path.normalize(’/path///normalize/hi/…’);//将不符合规范的路径经过格式化转换为标准路径,解析路径中的.与…外，还能去掉多余的斜杠</li>\n<li>path.join(’///you’, ‘/are’, ‘//beautiful’);//结果：’/you/are/beautiful’。join函数将传入的多个路径拼接为标准路径并将其格式化，返回规范后的路径，避免手工拼接路径字符串的繁琐</li>\n<li>path.dirname(’/foo/strong/cool/nice’); //用来返回路径中的目录名</li>\n<li>basename函数可返回路径中的最后一部分，并且可以对其进行条件排除.</li>\n</ul>\n<ol>\n<li>path.basename(‘路径字符串’);</li>\n<li>path.basename(‘路径字符串’, ‘[ext]’)&lt;排除[ext]后缀字符串&gt;;</li>\n</ol>\n<ul>\n<li>path.extname(‘index.html’); //返回路径中文件的扩展名</li>\n</ul>\n<h2 id=\"字符串转换\"><a class=\"markdownIt-Anchor\" href=\"#字符串转换\"></a> 字符串转换</h2>\n<blockquote>\n<p>Query String模块用于==实现URL参数字符串与参数对象之间的互相转换==，提供了&quot;stringify&quot;、&quot;parse&quot;等一些实用函数来针对字符串进行处理，通过序列化和反序列化，来更好的应对实际开发中的条件需求，对于逻辑的处理也提供了很好的帮助</p>\n</blockquote>\n<h3 id=\"序列化\"><a class=\"markdownIt-Anchor\" href=\"#序列化\"></a> 序列化</h3>\n<hr>\n<ul>\n<li>querystring.stringify({foo:‘bar’,cool:[‘xux’, ‘yys’]}); //结果：foo=bar&amp;cool=xux&amp;cool=yys。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用就是序列化对象，也就是说将对象类型转换成一个字符串类型（默认的分割符（&quot;&amp;&quot;）和分配符（&quot;=&quot;））</span><br></pre></td></tr></table></figure>\n<ul>\n<li>querystring.stringify(“对象”，“分隔符”，“分配符”)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">querystring.stringify(&#123;foo:&apos;bar&apos;,cool:[&apos;xux&apos;, &apos;yys&apos;]&#125;,&apos;*&apos;,&apos;$&apos;);</span><br><span class=\"line\">结果：&apos;foo$bar*cool$xux*cool$yys&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"反序列化\"><a class=\"markdownIt-Anchor\" href=\"#反序列化\"></a> 反序列化</h3>\n<hr>\n<ul>\n<li>querystring.parse(‘foo=bar&amp;cool=xux&amp;cool=yys’);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：&#123; foo: &apos;bar&apos;, cool: [&apos;xux&apos;, &apos;yys&apos;]&#125;</span><br><span class=\"line\">parse函数的作用就是反序列化字符串（默认是由&quot;=&quot;、&quot;&amp;&quot;拼接而成），转换得到一个对象类型</span><br></pre></td></tr></table></figure>\n<ul>\n<li>querystring.parse(‘foo@bar<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi mathvariant=\"normal\">@</mi><mi>x</mi><mi>u</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">cool@xux</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">@</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">x</span></span></span></span>cool@yys’,’@’,’$’);</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行结果：&#123; foo: &apos;&apos;, bar: &apos;cool&apos;, xux: &apos;cool&apos;, yys: &apos;&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实用工具\"><a class=\"markdownIt-Anchor\" href=\"#实用工具\"></a> 实用工具</h2>\n<blockquote>\n<p>util模块。util模块呢，是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的一些功能过于精简的不足。并且还提供了一系列常用工具，用来对数据的输出和验证</p>\n</blockquote>\n<ul>\n<li>util.inspect(object,[showHidden],[depth],[colors])； //将任意对象转换为字符串的函数，通常用于调试和错误输出</li>\n<li>format函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果占位符没有相对应的参数，占位符将不会被替换</span><br><span class=\"line\">2. 如果有多个参数占位符，额外的参数将会调用util.inspect()转换为字符串。这些字符串被连接在一起，并且以空格分隔</span><br><span class=\"line\">3. 如果第一个参数是一个非格式化字符串，则会把所有的参数转成字符串并以空格隔开拼接在一块，而且返回该字符串</span><br></pre></td></tr></table></figure>\n<ul>\n<li>util.isArray(object);  //判断对象是否为数组类型，是则返回ture,否则为fals</li>\n<li>util.isDate(object); //判断对象是否为日期类型，是则返回ture,否则返回false</li>\n<li>util.isRegExp(object); //判断对象是否为正则类型，是则返回ture,否则返回false</li>\n</ul>\n"},{"title":"Express入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n~~~\n中文网站：http://www.expressjs.com.cn/\n~~~\n\n# 安装\n* 方法1:命令行模式\n~~~\n1. 确定已安装nodejs\n2. mkdir 项目名称；cd 项目名称\n3. npm init     //为应用创建一个 package.json 文件,然后根据提示操作或者一路回车\n4. npm install express --save   //安装 Express 并将其保存到依赖列表中\n5. 新建index.js文件进行编写\n~~~\n* 方法2:webstorm\n~~~\n1. npm install express -g //全局安装express\n2. webstorm中选择Node.js Expresss App,然后创建\n~~~\n* 方法3:Express 应用生成器\n~~~\n1. 安装生成器：npm install express-generator -g\n2. 查看express 命令的用法：express -h\n3. 创建项目：express 项目名称\n4. 安装依赖：npm install\n~~~\n* 运行：node index.js\n* 访问： http://localhost:3000/ \n\n# 静态文件\n* 通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等\n* 将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了，如：app.use(express.static('public'))，这样public下面的文件就可以直接访问了，如：http://localhost:3000/images/kitten.jpg\n* 通过为静态资源目录指定一个挂载路径的方式来实现访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在），如：\n~~~\n* app.use('/static', express.static('public'));\n* 访问：http://localhost:3000/static/images/kitten.jpg\n~~~\n# 常见问题\n1. 如何处理 404 \n~~~\nExpress 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件\n~~~\n2. 如何设置一个错误处理器\n~~~\n错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)\n~~~\n3. 如何渲染纯 HTML 文件\n~~~\n无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件\n~~~\n\n# 路由\n学习网址：http://www.expressjs.com.cn/guide/routing.html\n* 路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问\n* 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行\n* 路由的定义由如下结构组成：\n~~~\napp.METHOD(PATH, HANDLER)\n其中，\napp 是一个 express 实例；\nMETHOD 是某个 HTTP 请求方式中的一个；\nPATH 是服务器端的路径；\nHANDLER 是当路由匹配到时需要执行的函数\n~~~\n* app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件\n~~~\n//来自 “/secret” 的请求，不管使用 GET、POST、PUT等方法请求，句柄都会得到执行\napp.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...');\n  next(); // pass control to the next handler\n});\n~~~\n1. 路由路径：路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式\n2. 路由句柄：可以为请求处理提供多个回调函数，其行为类似 中间件；路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合\n~~~\napp.get('/example/b', function (req, res, next) {\n  console.log('response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from B!');\n});\n//混合方式\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\n  console.log('response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from D!');\n});\n~~~\n3. 响应方法：下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起\n\n方法|描述\n----|-----\nres.download()|提示下载文件。\nres.end()|终结响应处理流程。\nres.json()|发送一个 JSON 格式的响应。\nres.jsonp()|发送一个支持 JSONP 的 JSON 格式的响应。\nres.redirect()|重定向请求。\nres.render()|渲染视图模板。\nres.send()|发送各种类型的响应。\nres.sendFile|以八位字节流的形式发送文件。\nres.sendStatus()|设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。\n\n* app.route()：可使用 app.route() 创建路由路径的链式路由句柄\n~~~\napp.route('/book')\n  .get(function(req, res) {\n    res.send('Get a random book');\n  })\n  .post(function(req, res) {\n    res.send('Add a book');\n  })\n  .put(function(req, res) {\n    res.send('Update the book');\n  });\n~~~\n* express.Router:可使用 express.Router 类创建模块化、可挂载的路由句柄。推荐。定于格式如下：\n~~~\n//brid.js\nvar express = require('express');\nvar router = express.Router();\n\n// 该路由使用的中间件  可选\nrouter.use(function timeLog(req, res, next) {\n  console.log('Time: ', Date.now());\n  next();\n});\n \n// 定义 about 页面的路由\nrouter.get('/about', function(req, res) {\n  res.send('About birds');\n});\n\nmodule.exports = router;\n\n//加载使用\nvar birds = require('./birds');\n...\napp.use('/birds', birds);\n~~~\n\n# 中间件\n> Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件\n\n> 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量；如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起\n\n> 中间件的功能：执行任何代码；修改请求和响应对象；终结请求-响应循环；调用堆栈中的下一个中间件\n\nExpress 应用中间件种类：\n1. 应用级中间件\n2. 路由级中间件\n3. 错误处理中间件\n4. 内置中间件\n5. 第三方中间件\n\n## 应用级中间件\n应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写\n* 中间件系统的路由句柄可以为路径定义多个路由\n* 各路由之间通过next()逐次调用\n* 调用过程中如果某个路由句柄已经终止了请求-响应循环，则后面的路由及其句柄不会执行，也不会报错\n* 如果需要在中间件栈中跳过剩余中间件，调用 next('route') 方法将控制权交给下一个路由； next('route') 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效\n~~~\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next('route');\n  // 否则将控制权交给栈中下一个中间件\n  else next(); //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render('regular');\n});\n\n// 处理 /user/:id， 渲染一个特殊页面\napp.get('/user/:id', function (req, res, next) {\n  res.render('special');\n});\n~~~\n\n## 路由级中间件\n* 路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router(),使用：var router = express.Router();\n* 路由级使用 router.use() 或 router.VERB() 加载\n* 需要将路由挂载至应用，通过 app.use挂载\n\n## 错误处理中间件\n错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误\n\n## 内置中间件\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了\n\nexpress.static(root, [options])\n* 参数 root 指提供静态资源的根目录\n* 可选的 options 参数拥有如下属性\n\n属性|描述|类型|缺省值\n---|---|---|---\ndotfiles|是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”|String\t|“ignore”\netag|是否启用 etag 生成\t|Boolean|true\nextensions|设置文件扩展名备份选项|Array|[]\nindex|发送目录索引文件，设置为 false 禁用目录索引|Mixed|“index.html”\nlastModified|设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false|Boolean|true\nmaxAge|以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性|Number|0\nredirect|当路径为目录时，重定向至 “/”|Boolean|\ttrue\nsetHeaders|设置 HTTP 头以提供文件的函数|\tFunction\t \n\n## 第三方中间件\n* 通过使用第三方中间件从而为 Express 应用增加更多功能\n* 安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载\n\n# 在 Express 中使用模板引擎\n需要在应用中进行如下设置才能让 Express 渲染模板文件：\n* views, 放模板文件的目录，比如： app.set('views', './views')\n* view engine, 模板引擎，比如： app.set('view engine', 'jade')\n* 安装相应的模板引擎 npm 软件包:npm install jade --save\n\n# 错误处理\n* 在其他 app.use() 和路由调用后，最后定义错误处理中间件\n* next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄\n\n# 调试 Express\n* debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开\n* 在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。webstorm中默认已设置\n* 设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志\n\n# 集成数据库\n为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可\n## MySQL\nnpm install mysql --save\n~~~\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'dbuser',\n  password : 's3kreee7'\n});\n\nconnection.connect();\n\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n\nconnection.end();\n~~~\n## MongoDB\nnpm install mongoskin\n~~~\nvar db = require('mongoskin').db('localhost:27017/animals');\n\ndb.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n~~~\n## SQLite\nnpm install sqlite3\n~~~\nvar sqlite3 = require('sqlite3').verbose();\nvar db = new sqlite3.Database(':memory:');\n\ndb.serialize(function() {\n\n  db.run('CREATE TABLE lorem (info TEXT)');\n  var stmt = db.prepare('INSERT INTO lorem VALUES (?)');\n\n  for (var i = 0; i < 10; i++) {\n    stmt.run('Ipsum ' + i);\n  }\n\n  stmt.finalize();\n\n  db.each('SELECT rowid AS id, info FROM lorem', function(err, row) {\n    console.log(row.id + ': ' + row.info);\n  });\n});\n\ndb.close();\n~~~\n\n## 中文API\nhttp://www.expressjs.com.cn/4x/api.html","source":"_posts/前端开发/Express入门.md","raw":"---\ntitle: Express入门\ntags:\n  - Express\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n~~~\n中文网站：http://www.expressjs.com.cn/\n~~~\n\n# 安装\n* 方法1:命令行模式\n~~~\n1. 确定已安装nodejs\n2. mkdir 项目名称；cd 项目名称\n3. npm init     //为应用创建一个 package.json 文件,然后根据提示操作或者一路回车\n4. npm install express --save   //安装 Express 并将其保存到依赖列表中\n5. 新建index.js文件进行编写\n~~~\n* 方法2:webstorm\n~~~\n1. npm install express -g //全局安装express\n2. webstorm中选择Node.js Expresss App,然后创建\n~~~\n* 方法3:Express 应用生成器\n~~~\n1. 安装生成器：npm install express-generator -g\n2. 查看express 命令的用法：express -h\n3. 创建项目：express 项目名称\n4. 安装依赖：npm install\n~~~\n* 运行：node index.js\n* 访问： http://localhost:3000/ \n\n# 静态文件\n* 通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等\n* 将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了，如：app.use(express.static('public'))，这样public下面的文件就可以直接访问了，如：http://localhost:3000/images/kitten.jpg\n* 通过为静态资源目录指定一个挂载路径的方式来实现访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在），如：\n~~~\n* app.use('/static', express.static('public'));\n* 访问：http://localhost:3000/static/images/kitten.jpg\n~~~\n# 常见问题\n1. 如何处理 404 \n~~~\nExpress 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件\n~~~\n2. 如何设置一个错误处理器\n~~~\n错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)\n~~~\n3. 如何渲染纯 HTML 文件\n~~~\n无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件\n~~~\n\n# 路由\n学习网址：http://www.expressjs.com.cn/guide/routing.html\n* 路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问\n* 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行\n* 路由的定义由如下结构组成：\n~~~\napp.METHOD(PATH, HANDLER)\n其中，\napp 是一个 express 实例；\nMETHOD 是某个 HTTP 请求方式中的一个；\nPATH 是服务器端的路径；\nHANDLER 是当路由匹配到时需要执行的函数\n~~~\n* app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件\n~~~\n//来自 “/secret” 的请求，不管使用 GET、POST、PUT等方法请求，句柄都会得到执行\napp.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...');\n  next(); // pass control to the next handler\n});\n~~~\n1. 路由路径：路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式\n2. 路由句柄：可以为请求处理提供多个回调函数，其行为类似 中间件；路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合\n~~~\napp.get('/example/b', function (req, res, next) {\n  console.log('response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from B!');\n});\n//混合方式\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\n  console.log('response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from D!');\n});\n~~~\n3. 响应方法：下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起\n\n方法|描述\n----|-----\nres.download()|提示下载文件。\nres.end()|终结响应处理流程。\nres.json()|发送一个 JSON 格式的响应。\nres.jsonp()|发送一个支持 JSONP 的 JSON 格式的响应。\nres.redirect()|重定向请求。\nres.render()|渲染视图模板。\nres.send()|发送各种类型的响应。\nres.sendFile|以八位字节流的形式发送文件。\nres.sendStatus()|设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。\n\n* app.route()：可使用 app.route() 创建路由路径的链式路由句柄\n~~~\napp.route('/book')\n  .get(function(req, res) {\n    res.send('Get a random book');\n  })\n  .post(function(req, res) {\n    res.send('Add a book');\n  })\n  .put(function(req, res) {\n    res.send('Update the book');\n  });\n~~~\n* express.Router:可使用 express.Router 类创建模块化、可挂载的路由句柄。推荐。定于格式如下：\n~~~\n//brid.js\nvar express = require('express');\nvar router = express.Router();\n\n// 该路由使用的中间件  可选\nrouter.use(function timeLog(req, res, next) {\n  console.log('Time: ', Date.now());\n  next();\n});\n \n// 定义 about 页面的路由\nrouter.get('/about', function(req, res) {\n  res.send('About birds');\n});\n\nmodule.exports = router;\n\n//加载使用\nvar birds = require('./birds');\n...\napp.use('/birds', birds);\n~~~\n\n# 中间件\n> Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件\n\n> 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量；如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起\n\n> 中间件的功能：执行任何代码；修改请求和响应对象；终结请求-响应循环；调用堆栈中的下一个中间件\n\nExpress 应用中间件种类：\n1. 应用级中间件\n2. 路由级中间件\n3. 错误处理中间件\n4. 内置中间件\n5. 第三方中间件\n\n## 应用级中间件\n应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写\n* 中间件系统的路由句柄可以为路径定义多个路由\n* 各路由之间通过next()逐次调用\n* 调用过程中如果某个路由句柄已经终止了请求-响应循环，则后面的路由及其句柄不会执行，也不会报错\n* 如果需要在中间件栈中跳过剩余中间件，调用 next('route') 方法将控制权交给下一个路由； next('route') 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效\n~~~\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next('route');\n  // 否则将控制权交给栈中下一个中间件\n  else next(); //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render('regular');\n});\n\n// 处理 /user/:id， 渲染一个特殊页面\napp.get('/user/:id', function (req, res, next) {\n  res.render('special');\n});\n~~~\n\n## 路由级中间件\n* 路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router(),使用：var router = express.Router();\n* 路由级使用 router.use() 或 router.VERB() 加载\n* 需要将路由挂载至应用，通过 app.use挂载\n\n## 错误处理中间件\n错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误\n\n## 内置中间件\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了\n\nexpress.static(root, [options])\n* 参数 root 指提供静态资源的根目录\n* 可选的 options 参数拥有如下属性\n\n属性|描述|类型|缺省值\n---|---|---|---\ndotfiles|是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”|String\t|“ignore”\netag|是否启用 etag 生成\t|Boolean|true\nextensions|设置文件扩展名备份选项|Array|[]\nindex|发送目录索引文件，设置为 false 禁用目录索引|Mixed|“index.html”\nlastModified|设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false|Boolean|true\nmaxAge|以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性|Number|0\nredirect|当路径为目录时，重定向至 “/”|Boolean|\ttrue\nsetHeaders|设置 HTTP 头以提供文件的函数|\tFunction\t \n\n## 第三方中间件\n* 通过使用第三方中间件从而为 Express 应用增加更多功能\n* 安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载\n\n# 在 Express 中使用模板引擎\n需要在应用中进行如下设置才能让 Express 渲染模板文件：\n* views, 放模板文件的目录，比如： app.set('views', './views')\n* view engine, 模板引擎，比如： app.set('view engine', 'jade')\n* 安装相应的模板引擎 npm 软件包:npm install jade --save\n\n# 错误处理\n* 在其他 app.use() 和路由调用后，最后定义错误处理中间件\n* next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄\n\n# 调试 Express\n* debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开\n* 在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。webstorm中默认已设置\n* 设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志\n\n# 集成数据库\n为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可\n## MySQL\nnpm install mysql --save\n~~~\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'dbuser',\n  password : 's3kreee7'\n});\n\nconnection.connect();\n\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n\nconnection.end();\n~~~\n## MongoDB\nnpm install mongoskin\n~~~\nvar db = require('mongoskin').db('localhost:27017/animals');\n\ndb.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n~~~\n## SQLite\nnpm install sqlite3\n~~~\nvar sqlite3 = require('sqlite3').verbose();\nvar db = new sqlite3.Database(':memory:');\n\ndb.serialize(function() {\n\n  db.run('CREATE TABLE lorem (info TEXT)');\n  var stmt = db.prepare('INSERT INTO lorem VALUES (?)');\n\n  for (var i = 0; i < 10; i++) {\n    stmt.run('Ipsum ' + i);\n  }\n\n  stmt.finalize();\n\n  db.each('SELECT rowid AS id, info FROM lorem', function(err, row) {\n    console.log(row.id + ': ' + row.info);\n  });\n});\n\ndb.close();\n~~~\n\n## 中文API\nhttp://www.expressjs.com.cn/4x/api.html","slug":"前端开发-Express入门","published":1,"updated":"2019-02-14T06:05:52.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3l00dp5b8h4bvkjv2o","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">中文网站：http://www.expressjs.com.cn/</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<ul>\n<li>方法1:命令行模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 确定已安装nodejs</span><br><span class=\"line\">2. mkdir 项目名称；cd 项目名称</span><br><span class=\"line\">3. npm init     //为应用创建一个 package.json 文件,然后根据提示操作或者一路回车</span><br><span class=\"line\">4. npm install express --save   //安装 Express 并将其保存到依赖列表中</span><br><span class=\"line\">5. 新建index.js文件进行编写</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法2:webstorm</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. npm install express -g //全局安装express</span><br><span class=\"line\">2. webstorm中选择Node.js Expresss App,然后创建</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法3:Express 应用生成器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 安装生成器：npm install express-generator -g</span><br><span class=\"line\">2. 查看express 命令的用法：express -h</span><br><span class=\"line\">3. 创建项目：express 项目名称</span><br><span class=\"line\">4. 安装依赖：npm install</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行：node index.js</li>\n<li>访问： <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a></li>\n</ul>\n<h1 id=\"静态文件\"><a class=\"markdownIt-Anchor\" href=\"#静态文件\"></a> 静态文件</h1>\n<ul>\n<li>通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等</li>\n<li>将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了，如：app.use(express.static(‘public’))，这样public下面的文件就可以直接访问了，如：<a href=\"http://localhost:3000/images/kitten.jpg\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/images/kitten.jpg</a></li>\n<li>通过为静态资源目录指定一个挂载路径的方式来实现访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在），如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* app.use(&apos;/static&apos;, express.static(&apos;public&apos;));</span><br><span class=\"line\">* 访问：http://localhost:3000/static/images/kitten.jpg</span><br></pre></td></tr></table></figure>\n<h1 id=\"常见问题\"><a class=\"markdownIt-Anchor\" href=\"#常见问题\"></a> 常见问题</h1>\n<ol>\n<li>如何处理 404</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>如何设置一个错误处理器</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>如何渲染纯 HTML 文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件</span><br></pre></td></tr></table></figure>\n<h1 id=\"路由\"><a class=\"markdownIt-Anchor\" href=\"#路由\"></a> 路由</h1>\n<p>学习网址：<a href=\"http://www.expressjs.com.cn/guide/routing.html\" target=\"_blank\" rel=\"noopener\">http://www.expressjs.com.cn/guide/routing.html</a></p>\n<ul>\n<li>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问</li>\n<li>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行</li>\n<li>路由的定义由如下结构组成：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.METHOD(PATH, HANDLER)</span><br><span class=\"line\">其中，</span><br><span class=\"line\">app 是一个 express 实例；</span><br><span class=\"line\">METHOD 是某个 HTTP 请求方式中的一个；</span><br><span class=\"line\">PATH 是服务器端的路径；</span><br><span class=\"line\">HANDLER 是当路由匹配到时需要执行的函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//来自 “/secret” 的请求，不管使用 GET、POST、PUT等方法请求，句柄都会得到执行</span><br><span class=\"line\">app.all(&apos;/secret&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;Accessing the secret section ...&apos;);</span><br><span class=\"line\">  next(); // pass control to the next handler</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>路由路径：路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式</li>\n<li>路由句柄：可以为请求处理提供多个回调函数，其行为类似 中间件；路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/example/b&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;response will be sent by the next function ...&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;, function (req, res) &#123;</span><br><span class=\"line\">  res.send(&apos;Hello from B!&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//混合方式</span><br><span class=\"line\">app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;response will be sent by the next function ...&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;, function (req, res) &#123;</span><br><span class=\"line\">  res.send(&apos;Hello from D!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>响应方法：下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>res.download()</td>\n<td>提示下载文件。</td>\n</tr>\n<tr>\n<td>res.end()</td>\n<td>终结响应处理流程。</td>\n</tr>\n<tr>\n<td>res.json()</td>\n<td>发送一个 JSON 格式的响应。</td>\n</tr>\n<tr>\n<td>res.jsonp()</td>\n<td>发送一个支持 JSONP 的 JSON 格式的响应。</td>\n</tr>\n<tr>\n<td>res.redirect()</td>\n<td>重定向请求。</td>\n</tr>\n<tr>\n<td>res.render()</td>\n<td>渲染视图模板。</td>\n</tr>\n<tr>\n<td>res.send()</td>\n<td>发送各种类型的响应。</td>\n</tr>\n<tr>\n<td>res.sendFile</td>\n<td>以八位字节流的形式发送文件。</td>\n</tr>\n<tr>\n<td>res.sendStatus()</td>\n<td>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>app.route()：可使用 app.route() 创建路由路径的链式路由句柄</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.route(&apos;/book&apos;)</span><br><span class=\"line\">  .get(function(req, res) &#123;</span><br><span class=\"line\">    res.send(&apos;Get a random book&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .post(function(req, res) &#123;</span><br><span class=\"line\">    res.send(&apos;Add a book&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .put(function(req, res) &#123;</span><br><span class=\"line\">    res.send(&apos;Update the book&apos;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>express.Router:可使用 express.Router 类创建模块化、可挂载的路由句柄。推荐。定于格式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//brid.js</span><br><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">// 该路由使用的中间件  可选</span><br><span class=\"line\">router.use(function timeLog(req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;Time: &apos;, Date.now());</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 定义 about 页面的路由</span><br><span class=\"line\">router.get(&apos;/about&apos;, function(req, res) &#123;</span><br><span class=\"line\">  res.send(&apos;About birds&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = router;</span><br><span class=\"line\"></span><br><span class=\"line\">//加载使用</span><br><span class=\"line\">var birds = require(&apos;./birds&apos;);</span><br><span class=\"line\">...</span><br><span class=\"line\">app.use(&apos;/birds&apos;, birds);</span><br></pre></td></tr></table></figure>\n<h1 id=\"中间件\"><a class=\"markdownIt-Anchor\" href=\"#中间件\"></a> 中间件</h1>\n<blockquote>\n<p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件</p>\n</blockquote>\n<blockquote>\n<p>中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量；如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起</p>\n</blockquote>\n<blockquote>\n<p>中间件的功能：执行任何代码；修改请求和响应对象；终结请求-响应循环；调用堆栈中的下一个中间件</p>\n</blockquote>\n<p>Express 应用中间件种类：</p>\n<ol>\n<li>应用级中间件</li>\n<li>路由级中间件</li>\n<li>错误处理中间件</li>\n<li>内置中间件</li>\n<li>第三方中间件</li>\n</ol>\n<h2 id=\"应用级中间件\"><a class=\"markdownIt-Anchor\" href=\"#应用级中间件\"></a> 应用级中间件</h2>\n<p>应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写</p>\n<ul>\n<li>中间件系统的路由句柄可以为路径定义多个路由</li>\n<li>各路由之间通过next()逐次调用</li>\n<li>调用过程中如果某个路由句柄已经终止了请求-响应循环，则后面的路由及其句柄不会执行，也不会报错</li>\n<li>如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由； next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span><br><span class=\"line\">app.get(&apos;/user/:id&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  // 如果 user id 为 0, 跳到下一个路由</span><br><span class=\"line\">  if (req.params.id == 0) next(&apos;route&apos;);</span><br><span class=\"line\">  // 否则将控制权交给栈中下一个中间件</span><br><span class=\"line\">  else next(); //</span><br><span class=\"line\">&#125;, function (req, res, next) &#123;</span><br><span class=\"line\">  // 渲染常规页面</span><br><span class=\"line\">  res.render(&apos;regular&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 处理 /user/:id， 渲染一个特殊页面</span><br><span class=\"line\">app.get(&apos;/user/:id&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  res.render(&apos;special&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由级中间件\"><a class=\"markdownIt-Anchor\" href=\"#路由级中间件\"></a> 路由级中间件</h2>\n<ul>\n<li>路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router(),使用：var router = express.Router();</li>\n<li>路由级使用 router.use() 或 router.VERB() 加载</li>\n<li>需要将路由挂载至应用，通过 app.use挂载</li>\n</ul>\n<h2 id=\"错误处理中间件\"><a class=\"markdownIt-Anchor\" href=\"#错误处理中间件\"></a> 错误处理中间件</h2>\n<p>错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误</p>\n<h2 id=\"内置中间件\"><a class=\"markdownIt-Anchor\" href=\"#内置中间件\"></a> 内置中间件</h2>\n<p>从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了</p>\n<p>express.static(root, [options])</p>\n<ul>\n<li>参数 root 指提供静态资源的根目录</li>\n<li>可选的 options 参数拥有如下属性</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n<th>缺省值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dotfiles</td>\n<td>是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”</td>\n<td>String</td>\n<td>“ignore”</td>\n</tr>\n<tr>\n<td>etag</td>\n<td>是否启用 etag 生成</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>设置文件扩展名备份选项</td>\n<td>Array</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>index</td>\n<td>发送目录索引文件，设置为 false 禁用目录索引</td>\n<td>Mixed</td>\n<td>“index.html”</td>\n</tr>\n<tr>\n<td>lastModified</td>\n<td>设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>当路径为目录时，重定向至 “/”</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>setHeaders</td>\n<td>设置 HTTP 头以提供文件的函数</td>\n<td>Function</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"第三方中间件\"><a class=\"markdownIt-Anchor\" href=\"#第三方中间件\"></a> 第三方中间件</h2>\n<ul>\n<li>通过使用第三方中间件从而为 Express 应用增加更多功能</li>\n<li>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载</li>\n</ul>\n<h1 id=\"在-express-中使用模板引擎\"><a class=\"markdownIt-Anchor\" href=\"#在-express-中使用模板引擎\"></a> 在 Express 中使用模板引擎</h1>\n<p>需要在应用中进行如下设置才能让 Express 渲染模板文件：</p>\n<ul>\n<li>views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’)</li>\n<li>view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)</li>\n<li>安装相应的模板引擎 npm 软件包:npm install jade --save</li>\n</ul>\n<h1 id=\"错误处理\"><a class=\"markdownIt-Anchor\" href=\"#错误处理\"></a> 错误处理</h1>\n<ul>\n<li>在其他 app.use() 和路由调用后，最后定义错误处理中间件</li>\n<li>next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄</li>\n</ul>\n<h1 id=\"调试-express\"><a class=\"markdownIt-Anchor\" href=\"#调试-express\"></a> 调试 Express</h1>\n<ul>\n<li>debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开</li>\n<li>在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。webstorm中默认已设置</li>\n<li>设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志</li>\n</ul>\n<h1 id=\"集成数据库\"><a class=\"markdownIt-Anchor\" href=\"#集成数据库\"></a> 集成数据库</h1>\n<p>为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可</p>\n<h2 id=\"mysql\"><a class=\"markdownIt-Anchor\" href=\"#mysql\"></a> MySQL</h2>\n<p>npm install mysql --save</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      = require(&apos;mysql&apos;);</span><br><span class=\"line\">var connection = mysql.createConnection(&#123;</span><br><span class=\"line\">  host     : &apos;localhost&apos;,</span><br><span class=\"line\">  user     : &apos;dbuser&apos;,</span><br><span class=\"line\">  password : &apos;s3kreee7&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.connect();</span><br><span class=\"line\"></span><br><span class=\"line\">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&apos;The solution is: &apos;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n<h2 id=\"mongodb\"><a class=\"markdownIt-Anchor\" href=\"#mongodb\"></a> MongoDB</h2>\n<p>npm install mongoskin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var db = require(&apos;mongoskin&apos;).db(&apos;localhost:27017/animals&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">db.collection(&apos;mamals&apos;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"sqlite\"><a class=\"markdownIt-Anchor\" href=\"#sqlite\"></a> SQLite</h2>\n<p>npm install sqlite3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sqlite3 = require(&apos;sqlite3&apos;).verbose();</span><br><span class=\"line\">var db = new sqlite3.Database(&apos;:memory:&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">db.serialize(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  db.run(&apos;CREATE TABLE lorem (info TEXT)&apos;);</span><br><span class=\"line\">  var stmt = db.prepare(&apos;INSERT INTO lorem VALUES (?)&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    stmt.run(&apos;Ipsum &apos; + i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  stmt.finalize();</span><br><span class=\"line\"></span><br><span class=\"line\">  db.each(&apos;SELECT rowid AS id, info FROM lorem&apos;, function(err, row) &#123;</span><br><span class=\"line\">    console.log(row.id + &apos;: &apos; + row.info);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">db.close();</span><br></pre></td></tr></table></figure>\n<h2 id=\"中文api\"><a class=\"markdownIt-Anchor\" href=\"#中文api\"></a> 中文API</h2>\n<p><a href=\"http://www.expressjs.com.cn/4x/api.html\" target=\"_blank\" rel=\"noopener\">http://www.expressjs.com.cn/4x/api.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">中文网站：http://www.expressjs.com.cn/</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<ul>\n<li>方法1:命令行模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 确定已安装nodejs</span><br><span class=\"line\">2. mkdir 项目名称；cd 项目名称</span><br><span class=\"line\">3. npm init     //为应用创建一个 package.json 文件,然后根据提示操作或者一路回车</span><br><span class=\"line\">4. npm install express --save   //安装 Express 并将其保存到依赖列表中</span><br><span class=\"line\">5. 新建index.js文件进行编写</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法2:webstorm</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. npm install express -g //全局安装express</span><br><span class=\"line\">2. webstorm中选择Node.js Expresss App,然后创建</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法3:Express 应用生成器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 安装生成器：npm install express-generator -g</span><br><span class=\"line\">2. 查看express 命令的用法：express -h</span><br><span class=\"line\">3. 创建项目：express 项目名称</span><br><span class=\"line\">4. 安装依赖：npm install</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行：node index.js</li>\n<li>访问： <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a></li>\n</ul>\n<h1 id=\"静态文件\"><a class=\"markdownIt-Anchor\" href=\"#静态文件\"></a> 静态文件</h1>\n<ul>\n<li>通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等</li>\n<li>将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了，如：app.use(express.static(‘public’))，这样public下面的文件就可以直接访问了，如：<a href=\"http://localhost:3000/images/kitten.jpg\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/images/kitten.jpg</a></li>\n<li>通过为静态资源目录指定一个挂载路径的方式来实现访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在），如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* app.use(&apos;/static&apos;, express.static(&apos;public&apos;));</span><br><span class=\"line\">* 访问：http://localhost:3000/static/images/kitten.jpg</span><br></pre></td></tr></table></figure>\n<h1 id=\"常见问题\"><a class=\"markdownIt-Anchor\" href=\"#常见问题\"></a> 常见问题</h1>\n<ol>\n<li>如何处理 404</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>如何设置一个错误处理器</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>如何渲染纯 HTML 文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件</span><br></pre></td></tr></table></figure>\n<h1 id=\"路由\"><a class=\"markdownIt-Anchor\" href=\"#路由\"></a> 路由</h1>\n<p>学习网址：<a href=\"http://www.expressjs.com.cn/guide/routing.html\" target=\"_blank\" rel=\"noopener\">http://www.expressjs.com.cn/guide/routing.html</a></p>\n<ul>\n<li>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问</li>\n<li>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行</li>\n<li>路由的定义由如下结构组成：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.METHOD(PATH, HANDLER)</span><br><span class=\"line\">其中，</span><br><span class=\"line\">app 是一个 express 实例；</span><br><span class=\"line\">METHOD 是某个 HTTP 请求方式中的一个；</span><br><span class=\"line\">PATH 是服务器端的路径；</span><br><span class=\"line\">HANDLER 是当路由匹配到时需要执行的函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//来自 “/secret” 的请求，不管使用 GET、POST、PUT等方法请求，句柄都会得到执行</span><br><span class=\"line\">app.all(&apos;/secret&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;Accessing the secret section ...&apos;);</span><br><span class=\"line\">  next(); // pass control to the next handler</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>路由路径：路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式</li>\n<li>路由句柄：可以为请求处理提供多个回调函数，其行为类似 中间件；路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/example/b&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;response will be sent by the next function ...&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;, function (req, res) &#123;</span><br><span class=\"line\">  res.send(&apos;Hello from B!&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//混合方式</span><br><span class=\"line\">app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;response will be sent by the next function ...&apos;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;, function (req, res) &#123;</span><br><span class=\"line\">  res.send(&apos;Hello from D!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>响应方法：下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>res.download()</td>\n<td>提示下载文件。</td>\n</tr>\n<tr>\n<td>res.end()</td>\n<td>终结响应处理流程。</td>\n</tr>\n<tr>\n<td>res.json()</td>\n<td>发送一个 JSON 格式的响应。</td>\n</tr>\n<tr>\n<td>res.jsonp()</td>\n<td>发送一个支持 JSONP 的 JSON 格式的响应。</td>\n</tr>\n<tr>\n<td>res.redirect()</td>\n<td>重定向请求。</td>\n</tr>\n<tr>\n<td>res.render()</td>\n<td>渲染视图模板。</td>\n</tr>\n<tr>\n<td>res.send()</td>\n<td>发送各种类型的响应。</td>\n</tr>\n<tr>\n<td>res.sendFile</td>\n<td>以八位字节流的形式发送文件。</td>\n</tr>\n<tr>\n<td>res.sendStatus()</td>\n<td>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>app.route()：可使用 app.route() 创建路由路径的链式路由句柄</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.route(&apos;/book&apos;)</span><br><span class=\"line\">  .get(function(req, res) &#123;</span><br><span class=\"line\">    res.send(&apos;Get a random book&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .post(function(req, res) &#123;</span><br><span class=\"line\">    res.send(&apos;Add a book&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .put(function(req, res) &#123;</span><br><span class=\"line\">    res.send(&apos;Update the book&apos;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>express.Router:可使用 express.Router 类创建模块化、可挂载的路由句柄。推荐。定于格式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//brid.js</span><br><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">// 该路由使用的中间件  可选</span><br><span class=\"line\">router.use(function timeLog(req, res, next) &#123;</span><br><span class=\"line\">  console.log(&apos;Time: &apos;, Date.now());</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 定义 about 页面的路由</span><br><span class=\"line\">router.get(&apos;/about&apos;, function(req, res) &#123;</span><br><span class=\"line\">  res.send(&apos;About birds&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = router;</span><br><span class=\"line\"></span><br><span class=\"line\">//加载使用</span><br><span class=\"line\">var birds = require(&apos;./birds&apos;);</span><br><span class=\"line\">...</span><br><span class=\"line\">app.use(&apos;/birds&apos;, birds);</span><br></pre></td></tr></table></figure>\n<h1 id=\"中间件\"><a class=\"markdownIt-Anchor\" href=\"#中间件\"></a> 中间件</h1>\n<blockquote>\n<p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件</p>\n</blockquote>\n<blockquote>\n<p>中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量；如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起</p>\n</blockquote>\n<blockquote>\n<p>中间件的功能：执行任何代码；修改请求和响应对象；终结请求-响应循环；调用堆栈中的下一个中间件</p>\n</blockquote>\n<p>Express 应用中间件种类：</p>\n<ol>\n<li>应用级中间件</li>\n<li>路由级中间件</li>\n<li>错误处理中间件</li>\n<li>内置中间件</li>\n<li>第三方中间件</li>\n</ol>\n<h2 id=\"应用级中间件\"><a class=\"markdownIt-Anchor\" href=\"#应用级中间件\"></a> 应用级中间件</h2>\n<p>应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写</p>\n<ul>\n<li>中间件系统的路由句柄可以为路径定义多个路由</li>\n<li>各路由之间通过next()逐次调用</li>\n<li>调用过程中如果某个路由句柄已经终止了请求-响应循环，则后面的路由及其句柄不会执行，也不会报错</li>\n<li>如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由； next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span><br><span class=\"line\">app.get(&apos;/user/:id&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  // 如果 user id 为 0, 跳到下一个路由</span><br><span class=\"line\">  if (req.params.id == 0) next(&apos;route&apos;);</span><br><span class=\"line\">  // 否则将控制权交给栈中下一个中间件</span><br><span class=\"line\">  else next(); //</span><br><span class=\"line\">&#125;, function (req, res, next) &#123;</span><br><span class=\"line\">  // 渲染常规页面</span><br><span class=\"line\">  res.render(&apos;regular&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 处理 /user/:id， 渲染一个特殊页面</span><br><span class=\"line\">app.get(&apos;/user/:id&apos;, function (req, res, next) &#123;</span><br><span class=\"line\">  res.render(&apos;special&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由级中间件\"><a class=\"markdownIt-Anchor\" href=\"#路由级中间件\"></a> 路由级中间件</h2>\n<ul>\n<li>路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router(),使用：var router = express.Router();</li>\n<li>路由级使用 router.use() 或 router.VERB() 加载</li>\n<li>需要将路由挂载至应用，通过 app.use挂载</li>\n</ul>\n<h2 id=\"错误处理中间件\"><a class=\"markdownIt-Anchor\" href=\"#错误处理中间件\"></a> 错误处理中间件</h2>\n<p>错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误</p>\n<h2 id=\"内置中间件\"><a class=\"markdownIt-Anchor\" href=\"#内置中间件\"></a> 内置中间件</h2>\n<p>从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了</p>\n<p>express.static(root, [options])</p>\n<ul>\n<li>参数 root 指提供静态资源的根目录</li>\n<li>可选的 options 参数拥有如下属性</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n<th>缺省值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dotfiles</td>\n<td>是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”</td>\n<td>String</td>\n<td>“ignore”</td>\n</tr>\n<tr>\n<td>etag</td>\n<td>是否启用 etag 生成</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>设置文件扩展名备份选项</td>\n<td>Array</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>index</td>\n<td>发送目录索引文件，设置为 false 禁用目录索引</td>\n<td>Mixed</td>\n<td>“index.html”</td>\n</tr>\n<tr>\n<td>lastModified</td>\n<td>设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>当路径为目录时，重定向至 “/”</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>setHeaders</td>\n<td>设置 HTTP 头以提供文件的函数</td>\n<td>Function</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"第三方中间件\"><a class=\"markdownIt-Anchor\" href=\"#第三方中间件\"></a> 第三方中间件</h2>\n<ul>\n<li>通过使用第三方中间件从而为 Express 应用增加更多功能</li>\n<li>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载</li>\n</ul>\n<h1 id=\"在-express-中使用模板引擎\"><a class=\"markdownIt-Anchor\" href=\"#在-express-中使用模板引擎\"></a> 在 Express 中使用模板引擎</h1>\n<p>需要在应用中进行如下设置才能让 Express 渲染模板文件：</p>\n<ul>\n<li>views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’)</li>\n<li>view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)</li>\n<li>安装相应的模板引擎 npm 软件包:npm install jade --save</li>\n</ul>\n<h1 id=\"错误处理\"><a class=\"markdownIt-Anchor\" href=\"#错误处理\"></a> 错误处理</h1>\n<ul>\n<li>在其他 app.use() 和路由调用后，最后定义错误处理中间件</li>\n<li>next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄</li>\n</ul>\n<h1 id=\"调试-express\"><a class=\"markdownIt-Anchor\" href=\"#调试-express\"></a> 调试 Express</h1>\n<ul>\n<li>debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开</li>\n<li>在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。webstorm中默认已设置</li>\n<li>设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志</li>\n</ul>\n<h1 id=\"集成数据库\"><a class=\"markdownIt-Anchor\" href=\"#集成数据库\"></a> 集成数据库</h1>\n<p>为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可</p>\n<h2 id=\"mysql\"><a class=\"markdownIt-Anchor\" href=\"#mysql\"></a> MySQL</h2>\n<p>npm install mysql --save</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      = require(&apos;mysql&apos;);</span><br><span class=\"line\">var connection = mysql.createConnection(&#123;</span><br><span class=\"line\">  host     : &apos;localhost&apos;,</span><br><span class=\"line\">  user     : &apos;dbuser&apos;,</span><br><span class=\"line\">  password : &apos;s3kreee7&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.connect();</span><br><span class=\"line\"></span><br><span class=\"line\">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&apos;The solution is: &apos;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n<h2 id=\"mongodb\"><a class=\"markdownIt-Anchor\" href=\"#mongodb\"></a> MongoDB</h2>\n<p>npm install mongoskin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var db = require(&apos;mongoskin&apos;).db(&apos;localhost:27017/animals&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">db.collection(&apos;mamals&apos;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"sqlite\"><a class=\"markdownIt-Anchor\" href=\"#sqlite\"></a> SQLite</h2>\n<p>npm install sqlite3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sqlite3 = require(&apos;sqlite3&apos;).verbose();</span><br><span class=\"line\">var db = new sqlite3.Database(&apos;:memory:&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">db.serialize(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  db.run(&apos;CREATE TABLE lorem (info TEXT)&apos;);</span><br><span class=\"line\">  var stmt = db.prepare(&apos;INSERT INTO lorem VALUES (?)&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    stmt.run(&apos;Ipsum &apos; + i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  stmt.finalize();</span><br><span class=\"line\"></span><br><span class=\"line\">  db.each(&apos;SELECT rowid AS id, info FROM lorem&apos;, function(err, row) &#123;</span><br><span class=\"line\">    console.log(row.id + &apos;: &apos; + row.info);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">db.close();</span><br></pre></td></tr></table></figure>\n<h2 id=\"中文api\"><a class=\"markdownIt-Anchor\" href=\"#中文api\"></a> 中文API</h2>\n<p><a href=\"http://www.expressjs.com.cn/4x/api.html\" target=\"_blank\" rel=\"noopener\">http://www.expressjs.com.cn/4x/api.html</a></p>\n"},{"title":"grunt入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\nGrunt中文网：http://www.gruntjs.net/\n\n# 简介\n> Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt配合Node.js有相应的版本要求，如：Grunt 0.4.x 必须配合Node.js >= 0.8.0版本使用\n\n> 奇数版本号的 Node.js 被认为是不稳定的开发版\n\n# Grunt-CLI\n## 简介\n安装：npm install -g grunt-cli \n\n注意：\n1. 安装grunt-cli并不等于安装了 Grunt！\n2. Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。\n\n运行原理：\n1. 每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。\n2. 如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。\n\n一份新的 Grunt项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile\n\n## package.json: \npackage.json字段全解：http://blog.csdn.net/woxueliuyun/article/details/39294375\n1. 被npm用于存储项目的元数据便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内\n2. package.json应当放置于项目的根目录中，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交\n3. 在目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖\n4. 为项目添加package.json文件的方式：\n- 大部分 grunt-init 模版都会自动创建特定于项目的package.json文件\n- npm init命令会创建一个基本的package.json文件\n- 复制下面的案例，并根据需要做扩充，参考https://npmjs.org/doc/json.html\n~~~\n{\n \"name\": \"my-project-name\",\n \"version\": \"0.1.0\",\n \"devDependencies\": {\n      \"grunt\": \"~0.4.1\",\n      \"grunt-contrib-jshint\": \"~0.6.0\",\n      \"grunt-contrib-nodeunit\": \"~0.2.0\",\n      \"grunt-contrib-uglify\": \"~0.2.2\"\n }\n}\n~~~\n\n## Gruntfile:\n1. 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的\n2. Gruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级\n3. Gruntfile由以下几部分构成：\"wrapper\" 函数；项目与任务配置；加载grunt插件和任务；自定义任务\n- \"wrapper\"函数:\n每一份 Gruntfile（和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：\n~~~\nmodule.exports = function(grunt) {\n // Do grunt-related things in here\n};\n~~~\n- 项目与任务配置:大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig方法，如package.json文件\n- 加载grunt插件和任务:像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：\n~~~\n// 加载能够提供\"uglify\"任务的插件。\ngrunt.loadNpmTasks('grunt-contrib-uglify');\n~~~\n注意： grunt --help 命令将列出所有可用的任务。\n- 自定义任务:通过定义 default 任务，可以让Grunt默认执行一个或多个任务\n\nGruntfile.js文件示例：\n~~~\nmodule.exports = function(grunt) {\n    // Project configuration.\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'), //package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中\n        uglify: {\n            options: {\n                banner: '/*! <%= pkg.name %> <%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n'\n            },\n            build: {\n                src: 'src/<%= pkg.name %>.js',\n                dest: 'build/<%= pkg.name %>.min.js'\n            }\n        }\n    }); \n    // 加载包含 \"uglify\" 任务的插件。\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    // 默认被执行的任务列表。\n    grunt.registerTask('default', ['uglify']);\n};\n~~~\n\nGurnt CLI参数：\n~~~\n--help, -h ==Display help text\n--base, -b ==Specify an alternate base path. By default, all file paths are relative to the Gruntfile.\n==Alternative to grunt.file.setBase(...)\n--no-color ==Disable colored output.\n--gruntfile ==Specify an alternate Gruntfile.\n==By default,grunt looks in the current or parent directories for the nearest Gruntfile.(js/coffee) file.\n--debug, -d ==Enable debugging mode for tasks that support it.\n--stack ==Print a stack trace when exiting with a warning or fatal error.\n--force, -f ==A way to force your way past warnings.Want a suggestion? Don't use this option, fix your code.\n--tasks ==Additional directory paths to scan for task and \"extra\" files.Alternative to grunt.loadTasks(...)\n--npm ==Npm-installed grunt plugins to scan for task and \"extra\" files.Alternative to grunt.loadNpmTasks(...)\n--no-write ==Disable writing files (dry run).\n--verbose, -v ==Verbose mode. A lot more information output.\n--version, -V ==Print the grunt version. Combine with --verbose for more info.\n--completion ==Output shell auto-completion rules. See the grunt-cli documentation for more information.\n~~~\n\n# 安装Gurnt和Gurnt插件\n## 安装命令\n* npm install grunt --save-dev  \n* npm install grunt ==[@VERSION]== --save-dev  \n\n## Gurnt插件\n> http://gruntjs.com/plugins \n\n> Grunt官方插件列表，其中带星号的为官方维护的插件\n\n创建插件：\n1. 通过 npm install -g grunt-init 命令安装 grunt-init 。\n2. 通过 git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 命令安装grunt插件模版。\n3. 在一个空的目录中执行 grunt-init gruntplugin 。\n4. 执行 npm install 命令以准备开发环境。\n5. 为你的插件书写代码。\n6. 执行 npm publish 命令将你创建的 Grunt 插件提发布npm\n\n注意：\n1. grunt-contrib\" 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间\n2. Grunt默认隐藏error stack traces，但可--stack启用方便调试自己的task;在bash中可通过alias grunt='grunt --stack'创建别名默认记录下stack trace\n3. 存储任务文件：建议使用几个常用npm模块（例如 temporary、tmp）来调用操作系统级别的临时目录功能\n4. 避免改变当前工作目录：process.cwd()\n- 默认包含gruntfile文件的目录被设置为当前工作目录。用户可在自己的gruntfile中通过grunt.file.setBase()改变改变当前工作目录，但是插件不应该改变它\n- path.resolve('foo') 可以被用来获取'foo' 相对于 Gruntfile 所在目录的绝对路径\n5. Grunt常用插件\n* grunt-contrib-uglify：压缩js代码\n* grunt-contrib-concat：合并js文件\n* grunt-contrib-qunit：单元测试\n* grunt-contrib-jshint：js代码检查\n* grunt-contrib-watch：监控文件修改并重新执行注册的任务\n\n# Task\n> Grunt就只支持两种任务：基本的Task以及MultiTasks\n\n> 区别是基本的Task的任务配置只有一个，而MultiTasks则有多个。大多数的grunt插件任务都是MultiTasks\n\n## Task的创建\n* grunt注册任务的格式:\n~~~\ngrunt.registerTask(taskName, [description, ] taskList)\n~~~\n* grunt默认任务:\n~~~\n//如果运行Grunt时没有指定任何任务，它将自动执行'jshint'、'qunit'、'concat' 和 'uglify' 任务\ngrunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']); \n~~~\n* grunt任务带参数的格式:\n~~~\ngrunt.registerTask('dist', ['concat:distArg', 'uglify:distArg']); \n~~~\n1. 当一个基本任务执行时，Grunt并不会检查配置和环境 -- 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数\n2. 如果你的任务并没有遵循 \"多任务\" 结构，那就使用自定义任务，在一个任务内部，执行其他的任务，使用grunt.task.run('bar', 'baz');\n3. 任务还可以依赖于其他任务的成功执行。注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败\n\n## Task的配置\nGrunt的task配置都是在 Gruntfile 中的grunt.initConfig方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。\n\n在一个任务配置中:\n* options属性可以用来指定覆盖内置属性的默认。\n* 每一个目标（target）中还可以拥有一个专门针对此目标（target）的options属性\n* 目标（target）级的options将会覆盖任务级的options\n~~~\ngrunt.initConfig({\n    concat: { =================Task\n        options: {\n         // 这里是任务级的Options，覆盖默认值\n        },\n        foo: { =================Target，并非子任务\n            options: {\n            // \"foo\" target options may go here, overriding task-level options.\n            },\n        },\n        bar: {\n        // No options specified; this target will use task-level options.\n        },\n    },\n});\n~~~\n## 文件\n由于大多的任务都是执行文件操作，Grunt有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义src-dest(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。\n\n详见：http://www.gruntjs.net/configuring-tasks\n\n\n# 项目实战\nNodejs和CLI安装好之后，参考：http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html\n1. mkdir testProject  -> cd testProject\n2. 创建package.json文件\n\npackage.json官方文档:https://docs.npmjs.com/json\n- A: npm init ==自动创建pachage.json文件\n- B: 手动创建package.json文件，添加项目/模块的描述信息 \n3. 安装Grunt和Grunt插件：\n- 手动添加，修改package.json文件，然后执行npm install\n{\n\"name\": \"my-project\",\n\"version\": \"0.1.0\",\n\"devDependencies\": {\n\"grunt\": \"~0.4.1\",\n\"grunt-contrib-cssmin\": \"~0.7.0\" //其中\"~0.7.0\"代表安装该插件的某个特定版本，如果只需安装最新版本，可以改成\"*\"\n}\n}\n- 自动安装： 其中--save-dev，表示将它作为你的项目依赖添加到package.json文件中devDependencies内\n~~~\nnpm install grunt --save-dev //安装最新版的Grunt\nnpm install grunt-contrib-cssmin --save-dev //安装我们所需要的插件\n~~~\n4. 创建Gruntfile.js文件：\n~~~\nmodule.exports = function(grunt) {\n    // 配置任务参数\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'),\n        cssmin: {\n            combine: {\n                files: {\n                    'css/release/compress.css': ['css/*.css'] // 指定合并的CSS文件 ['css/base.css', 'css/global.css']\n                }\n            },\n            minify: {\n                options: {\n                    keepSpecialComments: 0, /* 删除所有注释 */\n                    banner: '/* minified css file */'\n                },\n                files: {\n                    'css/release/master.min.css': ['css/master.css']\n                }\n            }\n        }\n    });\n    // 插件加载（加载 \"cssmin\" 模块）\n    grunt.loadNpmTasks('grunt-contrib-cssmin');\n    // 自定义任务：通过定义 default 任务，可以让Grunt默认执行一个或多个任务。\n    grunt.registerTask('default', ['cssmin']);\n};\n~~~\n5. 执行：\n* grunt //执行配置中所有的任务\n* grunt cssmin //执行特定的任务\n6. 测试：\n* 在项目文件夹中创建个子文件夹，命名为：CSS\n* 在里面创建base.css和master.css，2个CSS文件，你可以随便写点内容在里面。\n* 在命令行中执行grunt，看到如下提示说明执行成功：\n~~~\nRunning \"cssmin:combine\" (cssmin) task\nFile css/release/compress.css created.\nRunning \"cssmin:minify\" (cssmin) task\nFile css/release/master.min.css created.\nDone, without errors.\n~~~\n\n# JSDoc&Grunt\ngrunt-jsdoc是一个Grunt的插件。这个插件集成了JsDoc Toolkit 3，并且你能够通过配置Grunt任务来生成API文档\n\n补充：grunt-jsdoc-plugin是同一个开发者，但是区别是grunt-jsdoc是基于JsDoc Toolkit 3而grunt-jsdoc-plugin是基于JsDoc Toolkit 2的\n\n安装:\n1. 已安装好JAVA且配置好了Java环境变量\n2. npm install grunt-jsdoc --save-dev //安装jsdoc插件\n\ngrunt-jsdoc的grunt任务配置\n~~~\ngrunt.initConfig({\n    jsdoc : {\n        dist : {\n            src: ['src/*.js', 'test/*.js'],\n            options: {\n                destination: 'doc'\n            }\n        }\n    }\n});\n~~~\n参数说明：\n~~~\nsrc: 要自动生成API文档的源文件路径数组\njsdoc: jsdoc的bin文件夹目录\noptions: jsdoc单独使用的配置项\ndestination： 必填，指定文档输出路径\nconfigure： jsdoc配置文件路径\ntemplate： 文档模板路径\nprivate： 是否在文档中输出private成员，默认为true\n~~~\n更多参数：参考官方文档：Command-line arguments to JSDoc: http://usejsdoc.org/about-commandline.html\n\n# Grunt.js和Gulp.js工作方式的区别\n* Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务...就这样反复下去。\n* 在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因\n","source":"_posts/前端开发/grunt入门.md","raw":"---\ntitle: grunt入门\ntags:\n  - 工具\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\nGrunt中文网：http://www.gruntjs.net/\n\n# 简介\n> Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt配合Node.js有相应的版本要求，如：Grunt 0.4.x 必须配合Node.js >= 0.8.0版本使用\n\n> 奇数版本号的 Node.js 被认为是不稳定的开发版\n\n# Grunt-CLI\n## 简介\n安装：npm install -g grunt-cli \n\n注意：\n1. 安装grunt-cli并不等于安装了 Grunt！\n2. Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。\n\n运行原理：\n1. 每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。\n2. 如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。\n\n一份新的 Grunt项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile\n\n## package.json: \npackage.json字段全解：http://blog.csdn.net/woxueliuyun/article/details/39294375\n1. 被npm用于存储项目的元数据便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内\n2. package.json应当放置于项目的根目录中，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交\n3. 在目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖\n4. 为项目添加package.json文件的方式：\n- 大部分 grunt-init 模版都会自动创建特定于项目的package.json文件\n- npm init命令会创建一个基本的package.json文件\n- 复制下面的案例，并根据需要做扩充，参考https://npmjs.org/doc/json.html\n~~~\n{\n \"name\": \"my-project-name\",\n \"version\": \"0.1.0\",\n \"devDependencies\": {\n      \"grunt\": \"~0.4.1\",\n      \"grunt-contrib-jshint\": \"~0.6.0\",\n      \"grunt-contrib-nodeunit\": \"~0.2.0\",\n      \"grunt-contrib-uglify\": \"~0.2.2\"\n }\n}\n~~~\n\n## Gruntfile:\n1. 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的\n2. Gruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级\n3. Gruntfile由以下几部分构成：\"wrapper\" 函数；项目与任务配置；加载grunt插件和任务；自定义任务\n- \"wrapper\"函数:\n每一份 Gruntfile（和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：\n~~~\nmodule.exports = function(grunt) {\n // Do grunt-related things in here\n};\n~~~\n- 项目与任务配置:大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig方法，如package.json文件\n- 加载grunt插件和任务:像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：\n~~~\n// 加载能够提供\"uglify\"任务的插件。\ngrunt.loadNpmTasks('grunt-contrib-uglify');\n~~~\n注意： grunt --help 命令将列出所有可用的任务。\n- 自定义任务:通过定义 default 任务，可以让Grunt默认执行一个或多个任务\n\nGruntfile.js文件示例：\n~~~\nmodule.exports = function(grunt) {\n    // Project configuration.\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'), //package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中\n        uglify: {\n            options: {\n                banner: '/*! <%= pkg.name %> <%= grunt.template.today(\"yyyy-mm-dd\") %> */\\n'\n            },\n            build: {\n                src: 'src/<%= pkg.name %>.js',\n                dest: 'build/<%= pkg.name %>.min.js'\n            }\n        }\n    }); \n    // 加载包含 \"uglify\" 任务的插件。\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    // 默认被执行的任务列表。\n    grunt.registerTask('default', ['uglify']);\n};\n~~~\n\nGurnt CLI参数：\n~~~\n--help, -h ==Display help text\n--base, -b ==Specify an alternate base path. By default, all file paths are relative to the Gruntfile.\n==Alternative to grunt.file.setBase(...)\n--no-color ==Disable colored output.\n--gruntfile ==Specify an alternate Gruntfile.\n==By default,grunt looks in the current or parent directories for the nearest Gruntfile.(js/coffee) file.\n--debug, -d ==Enable debugging mode for tasks that support it.\n--stack ==Print a stack trace when exiting with a warning or fatal error.\n--force, -f ==A way to force your way past warnings.Want a suggestion? Don't use this option, fix your code.\n--tasks ==Additional directory paths to scan for task and \"extra\" files.Alternative to grunt.loadTasks(...)\n--npm ==Npm-installed grunt plugins to scan for task and \"extra\" files.Alternative to grunt.loadNpmTasks(...)\n--no-write ==Disable writing files (dry run).\n--verbose, -v ==Verbose mode. A lot more information output.\n--version, -V ==Print the grunt version. Combine with --verbose for more info.\n--completion ==Output shell auto-completion rules. See the grunt-cli documentation for more information.\n~~~\n\n# 安装Gurnt和Gurnt插件\n## 安装命令\n* npm install grunt --save-dev  \n* npm install grunt ==[@VERSION]== --save-dev  \n\n## Gurnt插件\n> http://gruntjs.com/plugins \n\n> Grunt官方插件列表，其中带星号的为官方维护的插件\n\n创建插件：\n1. 通过 npm install -g grunt-init 命令安装 grunt-init 。\n2. 通过 git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 命令安装grunt插件模版。\n3. 在一个空的目录中执行 grunt-init gruntplugin 。\n4. 执行 npm install 命令以准备开发环境。\n5. 为你的插件书写代码。\n6. 执行 npm publish 命令将你创建的 Grunt 插件提发布npm\n\n注意：\n1. grunt-contrib\" 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间\n2. Grunt默认隐藏error stack traces，但可--stack启用方便调试自己的task;在bash中可通过alias grunt='grunt --stack'创建别名默认记录下stack trace\n3. 存储任务文件：建议使用几个常用npm模块（例如 temporary、tmp）来调用操作系统级别的临时目录功能\n4. 避免改变当前工作目录：process.cwd()\n- 默认包含gruntfile文件的目录被设置为当前工作目录。用户可在自己的gruntfile中通过grunt.file.setBase()改变改变当前工作目录，但是插件不应该改变它\n- path.resolve('foo') 可以被用来获取'foo' 相对于 Gruntfile 所在目录的绝对路径\n5. Grunt常用插件\n* grunt-contrib-uglify：压缩js代码\n* grunt-contrib-concat：合并js文件\n* grunt-contrib-qunit：单元测试\n* grunt-contrib-jshint：js代码检查\n* grunt-contrib-watch：监控文件修改并重新执行注册的任务\n\n# Task\n> Grunt就只支持两种任务：基本的Task以及MultiTasks\n\n> 区别是基本的Task的任务配置只有一个，而MultiTasks则有多个。大多数的grunt插件任务都是MultiTasks\n\n## Task的创建\n* grunt注册任务的格式:\n~~~\ngrunt.registerTask(taskName, [description, ] taskList)\n~~~\n* grunt默认任务:\n~~~\n//如果运行Grunt时没有指定任何任务，它将自动执行'jshint'、'qunit'、'concat' 和 'uglify' 任务\ngrunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']); \n~~~\n* grunt任务带参数的格式:\n~~~\ngrunt.registerTask('dist', ['concat:distArg', 'uglify:distArg']); \n~~~\n1. 当一个基本任务执行时，Grunt并不会检查配置和环境 -- 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数\n2. 如果你的任务并没有遵循 \"多任务\" 结构，那就使用自定义任务，在一个任务内部，执行其他的任务，使用grunt.task.run('bar', 'baz');\n3. 任务还可以依赖于其他任务的成功执行。注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败\n\n## Task的配置\nGrunt的task配置都是在 Gruntfile 中的grunt.initConfig方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。\n\n在一个任务配置中:\n* options属性可以用来指定覆盖内置属性的默认。\n* 每一个目标（target）中还可以拥有一个专门针对此目标（target）的options属性\n* 目标（target）级的options将会覆盖任务级的options\n~~~\ngrunt.initConfig({\n    concat: { =================Task\n        options: {\n         // 这里是任务级的Options，覆盖默认值\n        },\n        foo: { =================Target，并非子任务\n            options: {\n            // \"foo\" target options may go here, overriding task-level options.\n            },\n        },\n        bar: {\n        // No options specified; this target will use task-level options.\n        },\n    },\n});\n~~~\n## 文件\n由于大多的任务都是执行文件操作，Grunt有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义src-dest(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。\n\n详见：http://www.gruntjs.net/configuring-tasks\n\n\n# 项目实战\nNodejs和CLI安装好之后，参考：http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html\n1. mkdir testProject  -> cd testProject\n2. 创建package.json文件\n\npackage.json官方文档:https://docs.npmjs.com/json\n- A: npm init ==自动创建pachage.json文件\n- B: 手动创建package.json文件，添加项目/模块的描述信息 \n3. 安装Grunt和Grunt插件：\n- 手动添加，修改package.json文件，然后执行npm install\n{\n\"name\": \"my-project\",\n\"version\": \"0.1.0\",\n\"devDependencies\": {\n\"grunt\": \"~0.4.1\",\n\"grunt-contrib-cssmin\": \"~0.7.0\" //其中\"~0.7.0\"代表安装该插件的某个特定版本，如果只需安装最新版本，可以改成\"*\"\n}\n}\n- 自动安装： 其中--save-dev，表示将它作为你的项目依赖添加到package.json文件中devDependencies内\n~~~\nnpm install grunt --save-dev //安装最新版的Grunt\nnpm install grunt-contrib-cssmin --save-dev //安装我们所需要的插件\n~~~\n4. 创建Gruntfile.js文件：\n~~~\nmodule.exports = function(grunt) {\n    // 配置任务参数\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'),\n        cssmin: {\n            combine: {\n                files: {\n                    'css/release/compress.css': ['css/*.css'] // 指定合并的CSS文件 ['css/base.css', 'css/global.css']\n                }\n            },\n            minify: {\n                options: {\n                    keepSpecialComments: 0, /* 删除所有注释 */\n                    banner: '/* minified css file */'\n                },\n                files: {\n                    'css/release/master.min.css': ['css/master.css']\n                }\n            }\n        }\n    });\n    // 插件加载（加载 \"cssmin\" 模块）\n    grunt.loadNpmTasks('grunt-contrib-cssmin');\n    // 自定义任务：通过定义 default 任务，可以让Grunt默认执行一个或多个任务。\n    grunt.registerTask('default', ['cssmin']);\n};\n~~~\n5. 执行：\n* grunt //执行配置中所有的任务\n* grunt cssmin //执行特定的任务\n6. 测试：\n* 在项目文件夹中创建个子文件夹，命名为：CSS\n* 在里面创建base.css和master.css，2个CSS文件，你可以随便写点内容在里面。\n* 在命令行中执行grunt，看到如下提示说明执行成功：\n~~~\nRunning \"cssmin:combine\" (cssmin) task\nFile css/release/compress.css created.\nRunning \"cssmin:minify\" (cssmin) task\nFile css/release/master.min.css created.\nDone, without errors.\n~~~\n\n# JSDoc&Grunt\ngrunt-jsdoc是一个Grunt的插件。这个插件集成了JsDoc Toolkit 3，并且你能够通过配置Grunt任务来生成API文档\n\n补充：grunt-jsdoc-plugin是同一个开发者，但是区别是grunt-jsdoc是基于JsDoc Toolkit 3而grunt-jsdoc-plugin是基于JsDoc Toolkit 2的\n\n安装:\n1. 已安装好JAVA且配置好了Java环境变量\n2. npm install grunt-jsdoc --save-dev //安装jsdoc插件\n\ngrunt-jsdoc的grunt任务配置\n~~~\ngrunt.initConfig({\n    jsdoc : {\n        dist : {\n            src: ['src/*.js', 'test/*.js'],\n            options: {\n                destination: 'doc'\n            }\n        }\n    }\n});\n~~~\n参数说明：\n~~~\nsrc: 要自动生成API文档的源文件路径数组\njsdoc: jsdoc的bin文件夹目录\noptions: jsdoc单独使用的配置项\ndestination： 必填，指定文档输出路径\nconfigure： jsdoc配置文件路径\ntemplate： 文档模板路径\nprivate： 是否在文档中输出private成员，默认为true\n~~~\n更多参数：参考官方文档：Command-line arguments to JSDoc: http://usejsdoc.org/about-commandline.html\n\n# Grunt.js和Gulp.js工作方式的区别\n* Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务...就这样反复下去。\n* 在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因\n","slug":"前端开发-grunt入门","published":1,"updated":"2019-02-14T06:27:28.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3m00ds5b8h0pcp3ryu","content":"<p>[toc]</p>\n<p>Grunt中文网：<a href=\"http://www.gruntjs.net/\" target=\"_blank\" rel=\"noopener\">http://www.gruntjs.net/</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt配合Node.js有相应的版本要求，如：Grunt 0.4.x 必须配合Node.js &gt;= 0.8.0版本使用</p>\n</blockquote>\n<blockquote>\n<p>奇数版本号的 Node.js 被认为是不稳定的开发版</p>\n</blockquote>\n<h1 id=\"grunt-cli\"><a class=\"markdownIt-Anchor\" href=\"#grunt-cli\"></a> Grunt-CLI</h1>\n<h2 id=\"简介-2\"><a class=\"markdownIt-Anchor\" href=\"#简介-2\"></a> 简介</h2>\n<p>安装：npm install -g grunt-cli</p>\n<p>注意：</p>\n<ol>\n<li>安装grunt-cli并不等于安装了 Grunt！</li>\n<li>Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。</li>\n</ol>\n<p>运行原理：</p>\n<ol>\n<li>每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。</li>\n<li>如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。</li>\n</ol>\n<p>一份新的 Grunt项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile</p>\n<h2 id=\"packagejson\"><a class=\"markdownIt-Anchor\" href=\"#packagejson\"></a> package.json:</h2>\n<p>package.json字段全解：<a href=\"http://blog.csdn.net/woxueliuyun/article/details/39294375\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/woxueliuyun/article/details/39294375</a></p>\n<ol>\n<li>被npm用于存储项目的元数据便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内</li>\n<li>package.json应当放置于项目的根目录中，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交</li>\n<li>在目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖</li>\n<li>为项目添加package.json文件的方式：</li>\n</ol>\n<ul>\n<li>大部分 grunt-init 模版都会自动创建特定于项目的package.json文件</li>\n<li>npm init命令会创建一个基本的package.json文件</li>\n<li>复制下面的案例，并根据需要做扩充，参考https://npmjs.org/doc/json.html</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;name&quot;: &quot;my-project-name&quot;,</span><br><span class=\"line\"> &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\"> &quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">      &quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class=\"line\">      &quot;grunt-contrib-jshint&quot;: &quot;~0.6.0&quot;,</span><br><span class=\"line\">      &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;,</span><br><span class=\"line\">      &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"gruntfile\"><a class=\"markdownIt-Anchor\" href=\"#gruntfile\"></a> Gruntfile:</h2>\n<ol>\n<li>此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的</li>\n<li>Gruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级</li>\n<li>Gruntfile由以下几部分构成：“wrapper” 函数；项目与任务配置；加载grunt插件和任务；自定义任务</li>\n</ol>\n<ul>\n<li>&quot;wrapper&quot;函数:<br>\n每一份 Gruntfile（和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(grunt) &#123;</span><br><span class=\"line\"> // Do grunt-related things in here</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>项目与任务配置:大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig方法，如package.json文件</li>\n<li>加载grunt插件和任务:像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 加载能够提供&quot;uglify&quot;任务的插件。</span><br><span class=\"line\">grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br></pre></td></tr></table></figure>\n<p>注意： grunt --help 命令将列出所有可用的任务。</p>\n<ul>\n<li>自定义任务:通过定义 default 任务，可以让Grunt默认执行一个或多个任务</li>\n</ul>\n<p>Gruntfile.js文件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(grunt) &#123;</span><br><span class=\"line\">    // Project configuration.</span><br><span class=\"line\">    grunt.initConfig(&#123;</span><br><span class=\"line\">        pkg: grunt.file.readJSON(&apos;package.json&apos;), //package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中</span><br><span class=\"line\">        uglify: &#123;</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&apos;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            build: &#123;</span><br><span class=\"line\">                src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;,</span><br><span class=\"line\">                dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    // 加载包含 &quot;uglify&quot; 任务的插件。</span><br><span class=\"line\">    grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br><span class=\"line\">    // 默认被执行的任务列表。</span><br><span class=\"line\">    grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Gurnt CLI参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--help, -h ==Display help text</span><br><span class=\"line\">--base, -b ==Specify an alternate base path. By default, all file paths are relative to the Gruntfile.</span><br><span class=\"line\">==Alternative to grunt.file.setBase(...)</span><br><span class=\"line\">--no-color ==Disable colored output.</span><br><span class=\"line\">--gruntfile ==Specify an alternate Gruntfile.</span><br><span class=\"line\">==By default,grunt looks in the current or parent directories for the nearest Gruntfile.(js/coffee) file.</span><br><span class=\"line\">--debug, -d ==Enable debugging mode for tasks that support it.</span><br><span class=\"line\">--stack ==Print a stack trace when exiting with a warning or fatal error.</span><br><span class=\"line\">--force, -f ==A way to force your way past warnings.Want a suggestion? Don&apos;t use this option, fix your code.</span><br><span class=\"line\">--tasks ==Additional directory paths to scan for task and &quot;extra&quot; files.Alternative to grunt.loadTasks(...)</span><br><span class=\"line\">--npm ==Npm-installed grunt plugins to scan for task and &quot;extra&quot; files.Alternative to grunt.loadNpmTasks(...)</span><br><span class=\"line\">--no-write ==Disable writing files (dry run).</span><br><span class=\"line\">--verbose, -v ==Verbose mode. A lot more information output.</span><br><span class=\"line\">--version, -V ==Print the grunt version. Combine with --verbose for more info.</span><br><span class=\"line\">--completion ==Output shell auto-completion rules. See the grunt-cli documentation for more information.</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装gurnt和gurnt插件\"><a class=\"markdownIt-Anchor\" href=\"#安装gurnt和gurnt插件\"></a> 安装Gurnt和Gurnt插件</h1>\n<h2 id=\"安装命令\"><a class=\"markdownIt-Anchor\" href=\"#安装命令\"></a> 安装命令</h2>\n<ul>\n<li>npm install grunt --save-dev</li>\n<li>npm install grunt ==[@VERSION]== --save-dev</li>\n</ul>\n<h2 id=\"gurnt插件\"><a class=\"markdownIt-Anchor\" href=\"#gurnt插件\"></a> Gurnt插件</h2>\n<blockquote>\n<p><a href=\"http://gruntjs.com/plugins\" target=\"_blank\" rel=\"noopener\">http://gruntjs.com/plugins</a></p>\n</blockquote>\n<blockquote>\n<p>Grunt官方插件列表，其中带星号的为官方维护的插件</p>\n</blockquote>\n<p>创建插件：</p>\n<ol>\n<li>通过 npm install -g grunt-init 命令安装 grunt-init 。</li>\n<li>通过 git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 命令安装grunt插件模版。</li>\n<li>在一个空的目录中执行 grunt-init gruntplugin 。</li>\n<li>执行 npm install 命令以准备开发环境。</li>\n<li>为你的插件书写代码。</li>\n<li>执行 npm publish 命令将你创建的 Grunt 插件提发布npm</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>grunt-contrib&quot; 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间</li>\n<li>Grunt默认隐藏error stack traces，但可–stack启用方便调试自己的task;在bash中可通过alias grunt='grunt --stack’创建别名默认记录下stack trace</li>\n<li>存储任务文件：建议使用几个常用npm模块（例如 temporary、tmp）来调用操作系统级别的临时目录功能</li>\n<li>避免改变当前工作目录：process.cwd()</li>\n</ol>\n<ul>\n<li>默认包含gruntfile文件的目录被设置为当前工作目录。用户可在自己的gruntfile中通过grunt.file.setBase()改变改变当前工作目录，但是插件不应该改变它</li>\n<li>path.resolve(‘foo’) 可以被用来获取’foo’ 相对于 Gruntfile 所在目录的绝对路径</li>\n</ul>\n<ol start=\"5\">\n<li>Grunt常用插件</li>\n</ol>\n<ul>\n<li>grunt-contrib-uglify：压缩js代码</li>\n<li>grunt-contrib-concat：合并js文件</li>\n<li>grunt-contrib-qunit：单元测试</li>\n<li>grunt-contrib-jshint：js代码检查</li>\n<li>grunt-contrib-watch：监控文件修改并重新执行注册的任务</li>\n</ul>\n<h1 id=\"task\"><a class=\"markdownIt-Anchor\" href=\"#task\"></a> Task</h1>\n<blockquote>\n<p>Grunt就只支持两种任务：基本的Task以及MultiTasks</p>\n</blockquote>\n<blockquote>\n<p>区别是基本的Task的任务配置只有一个，而MultiTasks则有多个。大多数的grunt插件任务都是MultiTasks</p>\n</blockquote>\n<h2 id=\"task的创建\"><a class=\"markdownIt-Anchor\" href=\"#task的创建\"></a> Task的创建</h2>\n<ul>\n<li>grunt注册任务的格式:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.registerTask(taskName, [description, ] taskList)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>grunt默认任务:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果运行Grunt时没有指定任何任务，它将自动执行&apos;jshint&apos;、&apos;qunit&apos;、&apos;concat&apos; 和 &apos;uglify&apos; 任务</span><br><span class=\"line\">grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;qunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>grunt任务带参数的格式:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.registerTask(&apos;dist&apos;, [&apos;concat:distArg&apos;, &apos;uglify:distArg&apos;]);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当一个基本任务执行时，Grunt并不会检查配置和环境 – 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数</li>\n<li>如果你的任务并没有遵循 “多任务” 结构，那就使用自定义任务，在一个任务内部，执行其他的任务，使用grunt.task.run(‘bar’, ‘baz’);</li>\n<li>任务还可以依赖于其他任务的成功执行。注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败</li>\n</ol>\n<h2 id=\"task的配置\"><a class=\"markdownIt-Anchor\" href=\"#task的配置\"></a> Task的配置</h2>\n<p>Grunt的task配置都是在 Gruntfile 中的grunt.initConfig方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。</p>\n<p>在一个任务配置中:</p>\n<ul>\n<li>options属性可以用来指定覆盖内置属性的默认。</li>\n<li>每一个目标（target）中还可以拥有一个专门针对此目标（target）的options属性</li>\n<li>目标（target）级的options将会覆盖任务级的options</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.initConfig(&#123;</span><br><span class=\"line\">    concat: &#123; =================Task</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">         // 这里是任务级的Options，覆盖默认值</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        foo: &#123; =================Target，并非子任务</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">            // &quot;foo&quot; target options may go here, overriding task-level options.</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bar: &#123;</span><br><span class=\"line\">        // No options specified; this target will use task-level options.</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件\"><a class=\"markdownIt-Anchor\" href=\"#文件\"></a> 文件</h2>\n<p>由于大多的任务都是执行文件操作，Grunt有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义src-dest(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。</p>\n<p>详见：<a href=\"http://www.gruntjs.net/configuring-tasks\" target=\"_blank\" rel=\"noopener\">http://www.gruntjs.net/configuring-tasks</a></p>\n<h1 id=\"项目实战\"><a class=\"markdownIt-Anchor\" href=\"#项目实战\"></a> 项目实战</h1>\n<p>Nodejs和CLI安装好之后，参考：<a href=\"http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html\" target=\"_blank\" rel=\"noopener\">http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html</a></p>\n<ol>\n<li>mkdir testProject  -&gt; cd testProject</li>\n<li>创建package.json文件</li>\n</ol>\n<p>package.json官方文档:<a href=\"https://docs.npmjs.com/json\" target=\"_blank\" rel=\"noopener\">https://docs.npmjs.com/json</a></p>\n<ul>\n<li>A: npm init ==自动创建pachage.json文件</li>\n<li>B: 手动创建package.json文件，添加项目/模块的描述信息</li>\n</ul>\n<ol start=\"3\">\n<li>安装Grunt和Grunt插件：</li>\n</ol>\n<ul>\n<li>手动添加，修改package.json文件，然后执行npm install<br>\n{<br>\n“name”: “my-project”,<br>\n“version”: “0.1.0”,<br>\n“devDependencies”: {<br>\n“grunt”: “~0.4.1”,<br>\n“grunt-contrib-cssmin”: “~0.7.0” //其中&quot;~0.7.0&quot;代表安装该插件的某个特定版本，如果只需安装最新版本，可以改成&quot;*&quot;<br>\n}<br>\n}</li>\n<li>自动安装： 其中–save-dev，表示将它作为你的项目依赖添加到package.json文件中devDependencies内</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install grunt --save-dev //安装最新版的Grunt</span><br><span class=\"line\">npm install grunt-contrib-cssmin --save-dev //安装我们所需要的插件</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>创建Gruntfile.js文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(grunt) &#123;</span><br><span class=\"line\">    // 配置任务参数</span><br><span class=\"line\">    grunt.initConfig(&#123;</span><br><span class=\"line\">        pkg: grunt.file.readJSON(&apos;package.json&apos;),</span><br><span class=\"line\">        cssmin: &#123;</span><br><span class=\"line\">            combine: &#123;</span><br><span class=\"line\">                files: &#123;</span><br><span class=\"line\">                    &apos;css/release/compress.css&apos;: [&apos;css/*.css&apos;] // 指定合并的CSS文件 [&apos;css/base.css&apos;, &apos;css/global.css&apos;]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            minify: &#123;</span><br><span class=\"line\">                options: &#123;</span><br><span class=\"line\">                    keepSpecialComments: 0, /* 删除所有注释 */</span><br><span class=\"line\">                    banner: &apos;/* minified css file */&apos;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                files: &#123;</span><br><span class=\"line\">                    &apos;css/release/master.min.css&apos;: [&apos;css/master.css&apos;]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 插件加载（加载 &quot;cssmin&quot; 模块）</span><br><span class=\"line\">    grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;);</span><br><span class=\"line\">    // 自定义任务：通过定义 default 任务，可以让Grunt默认执行一个或多个任务。</span><br><span class=\"line\">    grunt.registerTask(&apos;default&apos;, [&apos;cssmin&apos;]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>执行：</li>\n</ol>\n<ul>\n<li>grunt //执行配置中所有的任务</li>\n<li>grunt cssmin //执行特定的任务</li>\n</ul>\n<ol start=\"6\">\n<li>测试：</li>\n</ol>\n<ul>\n<li>在项目文件夹中创建个子文件夹，命名为：CSS</li>\n<li>在里面创建base.css和master.css，2个CSS文件，你可以随便写点内容在里面。</li>\n<li>在命令行中执行grunt，看到如下提示说明执行成功：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Running &quot;cssmin:combine&quot; (cssmin) task</span><br><span class=\"line\">File css/release/compress.css created.</span><br><span class=\"line\">Running &quot;cssmin:minify&quot; (cssmin) task</span><br><span class=\"line\">File css/release/master.min.css created.</span><br><span class=\"line\">Done, without errors.</span><br></pre></td></tr></table></figure>\n<h1 id=\"jsdocgrunt\"><a class=\"markdownIt-Anchor\" href=\"#jsdocgrunt\"></a> JSDoc&amp;Grunt</h1>\n<p>grunt-jsdoc是一个Grunt的插件。这个插件集成了JsDoc Toolkit 3，并且你能够通过配置Grunt任务来生成API文档</p>\n<p>补充：grunt-jsdoc-plugin是同一个开发者，但是区别是grunt-jsdoc是基于JsDoc Toolkit 3而grunt-jsdoc-plugin是基于JsDoc Toolkit 2的</p>\n<p>安装:</p>\n<ol>\n<li>已安装好JAVA且配置好了Java环境变量</li>\n<li>npm install grunt-jsdoc --save-dev //安装jsdoc插件</li>\n</ol>\n<p>grunt-jsdoc的grunt任务配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.initConfig(&#123;</span><br><span class=\"line\">    jsdoc : &#123;</span><br><span class=\"line\">        dist : &#123;</span><br><span class=\"line\">            src: [&apos;src/*.js&apos;, &apos;test/*.js&apos;],</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                destination: &apos;doc&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src: 要自动生成API文档的源文件路径数组</span><br><span class=\"line\">jsdoc: jsdoc的bin文件夹目录</span><br><span class=\"line\">options: jsdoc单独使用的配置项</span><br><span class=\"line\">destination： 必填，指定文档输出路径</span><br><span class=\"line\">configure： jsdoc配置文件路径</span><br><span class=\"line\">template： 文档模板路径</span><br><span class=\"line\">private： 是否在文档中输出private成员，默认为true</span><br></pre></td></tr></table></figure>\n<p>更多参数：参考官方文档：Command-line arguments to JSDoc: <a href=\"http://usejsdoc.org/about-commandline.html\" target=\"_blank\" rel=\"noopener\">http://usejsdoc.org/about-commandline.html</a></p>\n<h1 id=\"gruntjs和gulpjs工作方式的区别\"><a class=\"markdownIt-Anchor\" href=\"#gruntjs和gulpjs工作方式的区别\"></a> Grunt.js和Gulp.js工作方式的区别</h1>\n<ul>\n<li>Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。</li>\n<li>在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p>Grunt中文网：<a href=\"http://www.gruntjs.net/\" target=\"_blank\" rel=\"noopener\">http://www.gruntjs.net/</a></p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt配合Node.js有相应的版本要求，如：Grunt 0.4.x 必须配合Node.js &gt;= 0.8.0版本使用</p>\n</blockquote>\n<blockquote>\n<p>奇数版本号的 Node.js 被认为是不稳定的开发版</p>\n</blockquote>\n<h1 id=\"grunt-cli\"><a class=\"markdownIt-Anchor\" href=\"#grunt-cli\"></a> Grunt-CLI</h1>\n<h2 id=\"简介-2\"><a class=\"markdownIt-Anchor\" href=\"#简介-2\"></a> 简介</h2>\n<p>安装：npm install -g grunt-cli</p>\n<p>注意：</p>\n<ol>\n<li>安装grunt-cli并不等于安装了 Grunt！</li>\n<li>Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。</li>\n</ol>\n<p>运行原理：</p>\n<ol>\n<li>每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。</li>\n<li>如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。</li>\n</ol>\n<p>一份新的 Grunt项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile</p>\n<h2 id=\"packagejson\"><a class=\"markdownIt-Anchor\" href=\"#packagejson\"></a> package.json:</h2>\n<p>package.json字段全解：<a href=\"http://blog.csdn.net/woxueliuyun/article/details/39294375\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/woxueliuyun/article/details/39294375</a></p>\n<ol>\n<li>被npm用于存储项目的元数据便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内</li>\n<li>package.json应当放置于项目的根目录中，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交</li>\n<li>在目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖</li>\n<li>为项目添加package.json文件的方式：</li>\n</ol>\n<ul>\n<li>大部分 grunt-init 模版都会自动创建特定于项目的package.json文件</li>\n<li>npm init命令会创建一个基本的package.json文件</li>\n<li>复制下面的案例，并根据需要做扩充，参考https://npmjs.org/doc/json.html</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;name&quot;: &quot;my-project-name&quot;,</span><br><span class=\"line\"> &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\"> &quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">      &quot;grunt&quot;: &quot;~0.4.1&quot;,</span><br><span class=\"line\">      &quot;grunt-contrib-jshint&quot;: &quot;~0.6.0&quot;,</span><br><span class=\"line\">      &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;,</span><br><span class=\"line\">      &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"gruntfile\"><a class=\"markdownIt-Anchor\" href=\"#gruntfile\"></a> Gruntfile:</h2>\n<ol>\n<li>此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的</li>\n<li>Gruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级</li>\n<li>Gruntfile由以下几部分构成：“wrapper” 函数；项目与任务配置；加载grunt插件和任务；自定义任务</li>\n</ol>\n<ul>\n<li>&quot;wrapper&quot;函数:<br>\n每一份 Gruntfile（和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(grunt) &#123;</span><br><span class=\"line\"> // Do grunt-related things in here</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>项目与任务配置:大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig方法，如package.json文件</li>\n<li>加载grunt插件和任务:像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 加载能够提供&quot;uglify&quot;任务的插件。</span><br><span class=\"line\">grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br></pre></td></tr></table></figure>\n<p>注意： grunt --help 命令将列出所有可用的任务。</p>\n<ul>\n<li>自定义任务:通过定义 default 任务，可以让Grunt默认执行一个或多个任务</li>\n</ul>\n<p>Gruntfile.js文件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(grunt) &#123;</span><br><span class=\"line\">    // Project configuration.</span><br><span class=\"line\">    grunt.initConfig(&#123;</span><br><span class=\"line\">        pkg: grunt.file.readJSON(&apos;package.json&apos;), //package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中</span><br><span class=\"line\">        uglify: &#123;</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&apos;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            build: &#123;</span><br><span class=\"line\">                src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;,</span><br><span class=\"line\">                dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    // 加载包含 &quot;uglify&quot; 任务的插件。</span><br><span class=\"line\">    grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br><span class=\"line\">    // 默认被执行的任务列表。</span><br><span class=\"line\">    grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Gurnt CLI参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--help, -h ==Display help text</span><br><span class=\"line\">--base, -b ==Specify an alternate base path. By default, all file paths are relative to the Gruntfile.</span><br><span class=\"line\">==Alternative to grunt.file.setBase(...)</span><br><span class=\"line\">--no-color ==Disable colored output.</span><br><span class=\"line\">--gruntfile ==Specify an alternate Gruntfile.</span><br><span class=\"line\">==By default,grunt looks in the current or parent directories for the nearest Gruntfile.(js/coffee) file.</span><br><span class=\"line\">--debug, -d ==Enable debugging mode for tasks that support it.</span><br><span class=\"line\">--stack ==Print a stack trace when exiting with a warning or fatal error.</span><br><span class=\"line\">--force, -f ==A way to force your way past warnings.Want a suggestion? Don&apos;t use this option, fix your code.</span><br><span class=\"line\">--tasks ==Additional directory paths to scan for task and &quot;extra&quot; files.Alternative to grunt.loadTasks(...)</span><br><span class=\"line\">--npm ==Npm-installed grunt plugins to scan for task and &quot;extra&quot; files.Alternative to grunt.loadNpmTasks(...)</span><br><span class=\"line\">--no-write ==Disable writing files (dry run).</span><br><span class=\"line\">--verbose, -v ==Verbose mode. A lot more information output.</span><br><span class=\"line\">--version, -V ==Print the grunt version. Combine with --verbose for more info.</span><br><span class=\"line\">--completion ==Output shell auto-completion rules. See the grunt-cli documentation for more information.</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装gurnt和gurnt插件\"><a class=\"markdownIt-Anchor\" href=\"#安装gurnt和gurnt插件\"></a> 安装Gurnt和Gurnt插件</h1>\n<h2 id=\"安装命令\"><a class=\"markdownIt-Anchor\" href=\"#安装命令\"></a> 安装命令</h2>\n<ul>\n<li>npm install grunt --save-dev</li>\n<li>npm install grunt ==[@VERSION]== --save-dev</li>\n</ul>\n<h2 id=\"gurnt插件\"><a class=\"markdownIt-Anchor\" href=\"#gurnt插件\"></a> Gurnt插件</h2>\n<blockquote>\n<p><a href=\"http://gruntjs.com/plugins\" target=\"_blank\" rel=\"noopener\">http://gruntjs.com/plugins</a></p>\n</blockquote>\n<blockquote>\n<p>Grunt官方插件列表，其中带星号的为官方维护的插件</p>\n</blockquote>\n<p>创建插件：</p>\n<ol>\n<li>通过 npm install -g grunt-init 命令安装 grunt-init 。</li>\n<li>通过 git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 命令安装grunt插件模版。</li>\n<li>在一个空的目录中执行 grunt-init gruntplugin 。</li>\n<li>执行 npm install 命令以准备开发环境。</li>\n<li>为你的插件书写代码。</li>\n<li>执行 npm publish 命令将你创建的 Grunt 插件提发布npm</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>grunt-contrib&quot; 命名空间保留给 Grunt 团队维护的task使用，请给你自己的task起一个合适名字，并且避免使用被保留的命名空间</li>\n<li>Grunt默认隐藏error stack traces，但可–stack启用方便调试自己的task;在bash中可通过alias grunt='grunt --stack’创建别名默认记录下stack trace</li>\n<li>存储任务文件：建议使用几个常用npm模块（例如 temporary、tmp）来调用操作系统级别的临时目录功能</li>\n<li>避免改变当前工作目录：process.cwd()</li>\n</ol>\n<ul>\n<li>默认包含gruntfile文件的目录被设置为当前工作目录。用户可在自己的gruntfile中通过grunt.file.setBase()改变改变当前工作目录，但是插件不应该改变它</li>\n<li>path.resolve(‘foo’) 可以被用来获取’foo’ 相对于 Gruntfile 所在目录的绝对路径</li>\n</ul>\n<ol start=\"5\">\n<li>Grunt常用插件</li>\n</ol>\n<ul>\n<li>grunt-contrib-uglify：压缩js代码</li>\n<li>grunt-contrib-concat：合并js文件</li>\n<li>grunt-contrib-qunit：单元测试</li>\n<li>grunt-contrib-jshint：js代码检查</li>\n<li>grunt-contrib-watch：监控文件修改并重新执行注册的任务</li>\n</ul>\n<h1 id=\"task\"><a class=\"markdownIt-Anchor\" href=\"#task\"></a> Task</h1>\n<blockquote>\n<p>Grunt就只支持两种任务：基本的Task以及MultiTasks</p>\n</blockquote>\n<blockquote>\n<p>区别是基本的Task的任务配置只有一个，而MultiTasks则有多个。大多数的grunt插件任务都是MultiTasks</p>\n</blockquote>\n<h2 id=\"task的创建\"><a class=\"markdownIt-Anchor\" href=\"#task的创建\"></a> Task的创建</h2>\n<ul>\n<li>grunt注册任务的格式:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.registerTask(taskName, [description, ] taskList)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>grunt默认任务:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果运行Grunt时没有指定任何任务，它将自动执行&apos;jshint&apos;、&apos;qunit&apos;、&apos;concat&apos; 和 &apos;uglify&apos; 任务</span><br><span class=\"line\">grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;qunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>grunt任务带参数的格式:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.registerTask(&apos;dist&apos;, [&apos;concat:distArg&apos;, &apos;uglify:distArg&apos;]);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当一个基本任务执行时，Grunt并不会检查配置和环境 – 它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数</li>\n<li>如果你的任务并没有遵循 “多任务” 结构，那就使用自定义任务，在一个任务内部，执行其他的任务，使用grunt.task.run(‘bar’, ‘baz’);</li>\n<li>任务还可以依赖于其他任务的成功执行。注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行，并且没有失败</li>\n</ol>\n<h2 id=\"task的配置\"><a class=\"markdownIt-Anchor\" href=\"#task的配置\"></a> Task的配置</h2>\n<p>Grunt的task配置都是在 Gruntfile 中的grunt.initConfig方法中指定的。此配置主要是以任务名称命名的属性，也可以包含其他任意数据。一旦这些代表任意数据的属性与任务所需要的属性相冲突，就将被忽略。</p>\n<p>在一个任务配置中:</p>\n<ul>\n<li>options属性可以用来指定覆盖内置属性的默认。</li>\n<li>每一个目标（target）中还可以拥有一个专门针对此目标（target）的options属性</li>\n<li>目标（target）级的options将会覆盖任务级的options</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.initConfig(&#123;</span><br><span class=\"line\">    concat: &#123; =================Task</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">         // 这里是任务级的Options，覆盖默认值</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        foo: &#123; =================Target，并非子任务</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">            // &quot;foo&quot; target options may go here, overriding task-level options.</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        bar: &#123;</span><br><span class=\"line\">        // No options specified; this target will use task-level options.</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件\"><a class=\"markdownIt-Anchor\" href=\"#文件\"></a> 文件</h2>\n<p>由于大多的任务都是执行文件操作，Grunt有一个强大的抽象层用于声明任务应该操作哪些文件。这里有好几种定义src-dest(源文件-目标文件)文件映射的方式，均提供了不同程度的描述和控制操作方式。任何一种多任务（multi-task）都能理解下面的格式，所以你只需要选择满足你需求的格式就行。</p>\n<p>详见：<a href=\"http://www.gruntjs.net/configuring-tasks\" target=\"_blank\" rel=\"noopener\">http://www.gruntjs.net/configuring-tasks</a></p>\n<h1 id=\"项目实战\"><a class=\"markdownIt-Anchor\" href=\"#项目实战\"></a> 项目实战</h1>\n<p>Nodejs和CLI安装好之后，参考：<a href=\"http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html\" target=\"_blank\" rel=\"noopener\">http://www.bluesdream.com/blog/windows-installs-the-grunt-and-instructions.html</a></p>\n<ol>\n<li>mkdir testProject  -&gt; cd testProject</li>\n<li>创建package.json文件</li>\n</ol>\n<p>package.json官方文档:<a href=\"https://docs.npmjs.com/json\" target=\"_blank\" rel=\"noopener\">https://docs.npmjs.com/json</a></p>\n<ul>\n<li>A: npm init ==自动创建pachage.json文件</li>\n<li>B: 手动创建package.json文件，添加项目/模块的描述信息</li>\n</ul>\n<ol start=\"3\">\n<li>安装Grunt和Grunt插件：</li>\n</ol>\n<ul>\n<li>手动添加，修改package.json文件，然后执行npm install<br>\n{<br>\n“name”: “my-project”,<br>\n“version”: “0.1.0”,<br>\n“devDependencies”: {<br>\n“grunt”: “~0.4.1”,<br>\n“grunt-contrib-cssmin”: “~0.7.0” //其中&quot;~0.7.0&quot;代表安装该插件的某个特定版本，如果只需安装最新版本，可以改成&quot;*&quot;<br>\n}<br>\n}</li>\n<li>自动安装： 其中–save-dev，表示将它作为你的项目依赖添加到package.json文件中devDependencies内</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install grunt --save-dev //安装最新版的Grunt</span><br><span class=\"line\">npm install grunt-contrib-cssmin --save-dev //安装我们所需要的插件</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>创建Gruntfile.js文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(grunt) &#123;</span><br><span class=\"line\">    // 配置任务参数</span><br><span class=\"line\">    grunt.initConfig(&#123;</span><br><span class=\"line\">        pkg: grunt.file.readJSON(&apos;package.json&apos;),</span><br><span class=\"line\">        cssmin: &#123;</span><br><span class=\"line\">            combine: &#123;</span><br><span class=\"line\">                files: &#123;</span><br><span class=\"line\">                    &apos;css/release/compress.css&apos;: [&apos;css/*.css&apos;] // 指定合并的CSS文件 [&apos;css/base.css&apos;, &apos;css/global.css&apos;]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            minify: &#123;</span><br><span class=\"line\">                options: &#123;</span><br><span class=\"line\">                    keepSpecialComments: 0, /* 删除所有注释 */</span><br><span class=\"line\">                    banner: &apos;/* minified css file */&apos;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                files: &#123;</span><br><span class=\"line\">                    &apos;css/release/master.min.css&apos;: [&apos;css/master.css&apos;]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 插件加载（加载 &quot;cssmin&quot; 模块）</span><br><span class=\"line\">    grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;);</span><br><span class=\"line\">    // 自定义任务：通过定义 default 任务，可以让Grunt默认执行一个或多个任务。</span><br><span class=\"line\">    grunt.registerTask(&apos;default&apos;, [&apos;cssmin&apos;]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>执行：</li>\n</ol>\n<ul>\n<li>grunt //执行配置中所有的任务</li>\n<li>grunt cssmin //执行特定的任务</li>\n</ul>\n<ol start=\"6\">\n<li>测试：</li>\n</ol>\n<ul>\n<li>在项目文件夹中创建个子文件夹，命名为：CSS</li>\n<li>在里面创建base.css和master.css，2个CSS文件，你可以随便写点内容在里面。</li>\n<li>在命令行中执行grunt，看到如下提示说明执行成功：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Running &quot;cssmin:combine&quot; (cssmin) task</span><br><span class=\"line\">File css/release/compress.css created.</span><br><span class=\"line\">Running &quot;cssmin:minify&quot; (cssmin) task</span><br><span class=\"line\">File css/release/master.min.css created.</span><br><span class=\"line\">Done, without errors.</span><br></pre></td></tr></table></figure>\n<h1 id=\"jsdocgrunt\"><a class=\"markdownIt-Anchor\" href=\"#jsdocgrunt\"></a> JSDoc&amp;Grunt</h1>\n<p>grunt-jsdoc是一个Grunt的插件。这个插件集成了JsDoc Toolkit 3，并且你能够通过配置Grunt任务来生成API文档</p>\n<p>补充：grunt-jsdoc-plugin是同一个开发者，但是区别是grunt-jsdoc是基于JsDoc Toolkit 3而grunt-jsdoc-plugin是基于JsDoc Toolkit 2的</p>\n<p>安装:</p>\n<ol>\n<li>已安装好JAVA且配置好了Java环境变量</li>\n<li>npm install grunt-jsdoc --save-dev //安装jsdoc插件</li>\n</ol>\n<p>grunt-jsdoc的grunt任务配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grunt.initConfig(&#123;</span><br><span class=\"line\">    jsdoc : &#123;</span><br><span class=\"line\">        dist : &#123;</span><br><span class=\"line\">            src: [&apos;src/*.js&apos;, &apos;test/*.js&apos;],</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                destination: &apos;doc&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src: 要自动生成API文档的源文件路径数组</span><br><span class=\"line\">jsdoc: jsdoc的bin文件夹目录</span><br><span class=\"line\">options: jsdoc单独使用的配置项</span><br><span class=\"line\">destination： 必填，指定文档输出路径</span><br><span class=\"line\">configure： jsdoc配置文件路径</span><br><span class=\"line\">template： 文档模板路径</span><br><span class=\"line\">private： 是否在文档中输出private成员，默认为true</span><br></pre></td></tr></table></figure>\n<p>更多参数：参考官方文档：Command-line arguments to JSDoc: <a href=\"http://usejsdoc.org/about-commandline.html\" target=\"_blank\" rel=\"noopener\">http://usejsdoc.org/about-commandline.html</a></p>\n<h1 id=\"gruntjs和gulpjs工作方式的区别\"><a class=\"markdownIt-Anchor\" href=\"#gruntjs和gulpjs工作方式的区别\"></a> Grunt.js和Gulp.js工作方式的区别</h1>\n<ul>\n<li>Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。</li>\n<li>在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因</li>\n</ul>\n"},{"title":"gulp入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n# 简介\ngulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快\n~~~\nGulp官网 http://gulpjs.com/\nGulp中文网 http://www.gulpjs.com.cn/\nGulp中文文档 https://github.com/lisposter/gulp-docs-zh-cn\nGulp插件网 http://gulpjs.com/plugins/\nAwesome Gulp https://github.com/alferov/awesome-gulp\nStuQ-Gulp实战和原理解析 http://i5ting.github.io/stuq-gulp/\n~~~\n# 工作流程\ngulp的使用流程一般是这样子的：\n1. 通过gulp.src()方法获取到我们想要处理的文件流，22. 把文件流通过pipe方法导入到gulp的插件中\n3. 把经过插件处理后的流再通过pipe方法导入到gulp.dest()中\n4. gulp.dest()方法则把流中的内容写入到文件中\n\n==注意：== 给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名。==生成的文件名是由导入到它的文件流决定的==\n\n# 安装\ngulp基于node.js，要通过nodejs的npm安装gulp，所以先要安装nodejs环境\n* 全局方式：npm install -g gulp\n* gulp的项目中单独安装一次：npm install gulp\n* 安装的时候把gulp写进项目package.json文件的依赖中：npm install --save-dev gulp\n\n在全局安装gulp后，还需要在项目中本地安装一次，是为了版本的灵活性，仅供参考\n\n# 开始使用gulp\n1. 建立gulpfile.js文件\n此时我们的目录结构是这样子的：\n~~~\n├── gulpfile.js\n├── node_modules\n│ └── gulp\n└── package.json\n~~~~\n最简gulpfile.js:\n~~~\nvar gulp = require('gulp');\ngulp.task('default',function(){\n    console.log('hello world');\n});\n~~~\n\n2. 运行gulp任务\n切换到存放gulpfile.js文件的目录\n* 执行gulp命令:会执行任务名为default的默认任务\n* gulp task1:执行task1任务\n\n# gulpfile.js文件\n全局配置config：当gulpfile.js太大时就不好维护了，此时可以将需要在gulpfile中引用的参数，放到这里，包括一些路径，功能的开关等，如：\n~~~\nmodule.exports = {\n    name : '.....',\n    devPath : '.....',    //项目根路径，根路径下可以包含多个项目\n    prodPath : '....', //生产路径根路径\n    sassPath : '.....', //SASS包含文件路径\n    rmHtmlWhitespace : false,//html中是否去除空格\n    webpackEntry : {\n        index : 'index.js'//js合并\n    },\n    server : {\n        port : 8088\n    }\n};\n~~~\n意下这里使用了module.exports，这是nodejs的语法。在gulpfile中将会用require引用config。\n~~~\nvar config = require('./config');//加载项目配置\n~~~\n使用举例：\n~~~\n//引入gulp，项目文件中安装的gulp的引入方式\nvar gulp =require('gulp');\n\n//引入组件\nvar jshint = require(\"gulp-jshint\");\nvar gutil = require(\"gulp-util\");\nvar sass= require(\"gulp-sass\");\nvar concat = require(\"gulp-concat\");\nvar uglify = require(\"gulp-uglify\");\nvar rename = require(\"gulp-rename\");\n\nvar path = require(\"path\");\nvar del = require(\"del\");\n\n//你也许会想要在编译文件之前删除一些文件\ngulp.task('clean', function(cb) {\n    return del(['build/**/*'], cb);\n});\n\n//检查脚本\ngulp.task('lint',function () {\n    gulp.src('./src/javascript/**/*.js')\n        .pipe(jshint())\n        .pipe(jshint.reporter('default'));\n});\n\n//编译sass\n//sass 任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中\ngulp.task('sass',function () {\n    gulp.src(\"./src/scss/**/*.scss\")\n        .pipe(sass({outputStyle: 'compact'}))\n        .pipe(gulp.dest(\"./build/css\"));\n});\n\n//合并，压缩文件\n//scipts 任务会合并js 目录下的所有js文件并输出到dist目录中，然后gulp会重命名。压缩合并的文件，也输出到dist/目录\ngulp.task('scripts',function () {\n    gulp.src('./src/javascript/**/*.js')\n        .pipe(concat('all.js'))\n        .pipe(gulp.dest('./dest'))\n        .pipe(rename(\"all.min.js\"))\n        .pipe(uglify())\n        .pipe(gulp.dest(\"./build\"))\n});\n\n//这时，我们创建了一个基于其他任务的default任务。\n//使用.run()方法关联和运行我们上面定义的任务，使用.watch() 方法去坚挺制定目录的文件变化,当有文件变化时，会运行回调定义的其他任务。\ngulp.task('default',function(){\n    //将你的默认的任务代码放在这里\n    gulp.run('lint','sass','scripts');\n    //监听文件变化\n    gulp.watch(\"\",function () {\n        gulp.run('lint','sass','scripts');\n    });\n});\n~~~\n\n# gulp的API介绍\n更多API介绍： http://www.gulpjs.com.cn/docs/api/\n## gulp.src()\ngulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息 \n~~~\ngulp.src(globs[, options])\n\n* globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组\n* options为可选参数\n~~~\n\n* 当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：\n~~~\ngulp.src('app/src/**/*.css') //此时base的值为 app/src\n~~~\n\nGulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：\n~~~\n* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾\n** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。\n? 匹配文件路径中的一个字符(不会匹配路径分隔符)\n[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法\n!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的\n?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?\n+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+\n*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*\n@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)\n~~~\n==注意：== 不能在数组中的第一个元素中使用排除模式\n\n使用举例：\n~~~\n//使用数组的方式来匹配多种文件\ngulp.src(['js/*.js','css/*.css','*.html'])\n\ngulp.src([*.js,'!b*.js']) //匹配所有js文件，但排除掉以b开头的js文件\ngulp.src(['!b*.js',*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中\n~~~\n\n## gulp.dest()\ngulp.dest()方法是用来写文件的，其语法为：\n~~~\ngulp.dest(path[,options])\n\n* path为写入文件的路径\n* options为一个可选的参数对象，通常我们不需要用到\n~~~\n* 生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径\n\n## gulp.task()\ngulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为：\n~~~\ngulp.task(name[, deps], fn)\n* name 为任务名\n* deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数\n* fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。\n~~~\n使用举例：\n~~~\ngulp.task('mytask', ['array', 'of', 'task', 'names'], function() { //定义一个有依赖的任务\n  // Do something\n});\n~~~\n1. 如果任务相互之间没有依赖，任务会按你书写的顺序来执行\n2. 如果有依赖的话则会先执行依赖的任务\n3. 如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务\n\n## gulp.watch()\ngulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为\n~~~\ngulp.watch(glob[, opts], tasks)\n* glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。\n* opts 为一个可选的配置对象，通常不需要用到\n* tasks 为文件变化后要执行的任务，为一个数组\n~~~\n~~~\ngulp.task('uglify',function(){\n  //do something\n});\ngulp.task('reload',function(){\n  //do something\n});\ngulp.watch('js/**/*.js', ['uglify','reload']);\n~~~\n\n# 一些常用的gulp插件\n## 自动加载插件pulp-load-plugins\n* 这个插件能自动帮你加载package.json文件里的gulp插件\n* gulp-load-plugins是通过package.json文件来加载插件\n* gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件\n* 定义及启用\n~~~\nvar gulp = require('gulp');\n//加载gulp-load-plugins插件，并马上运行它\nvar plugins = require('gulp-load-plugins')();\n~~~\n* 使用举例：\n~~~\nplugins.rename          //gulp-rename插件的使用 \n~~~\n## 重命名插件gulp-rename\n~~~\ngulp.task('rename', function () {\n    gulp.src('js/jquery.js')\n    .pipe(uglify())  //压缩\n    .pipe(rename('jquery.min.js')) //会将jquery.js重命名为jquery.min.js\n    .pipe(gulp.dest('js')); \n});\n~~~\n## js文件压缩插件gulp-uglify\n~~~\nvar gulp = require('gulp'),\n    uglify = require(\"gulp-uglify\");\n \ngulp.task('minify-js', function () {\n    gulp.src('js/*.js') // 要压缩的js文件\n    .pipe(uglify())  //使用uglify进行压缩,更多配置请参考：\n    .pipe(gulp.dest('dist/js')); //压缩后的路径\n});\n~~~\n## css文件压缩插件gulp-minify-css\n~~~\nvar gulp = require('gulp'),\n    minifyCss = require(\"gulp-minify-css\");\n \ngulp.task('minify-css', function () {\n    gulp.src('css/*.css') // 要压缩的css文件\n    .pipe(minifyCss()) //压缩css\n    .pipe(gulp.dest('dist/css'));\n});\n~~~\n## html文件压缩插件gulp-minify-html\n~~~\nvar gulp = require('gulp'),\n    minifyHtml = require(\"gulp-minify-html\");\n \ngulp.task('minify-html', function () {\n    gulp.src('html/*.html') // 要压缩的html文件\n    .pipe(minifyHtml()) //压缩\n    .pipe(gulp.dest('dist/html'));\n});\n~~~\n## js代码检查插件\n~~~\nvar gulp = require('gulp'),\n    jshint = require(\"gulp-jshint\");\n \ngulp.task('jsLint', function () {\n    gulp.src('js/*.js')\n    .pipe(jshint())\n    .pipe(jshint.reporter()); // 输出检查结果\n});\n~~~\n## 文件合并插件gulp-concat\n~~~\nvar gulp = require('gulp'),\n    concat = require(\"gulp-concat\");\n \ngulp.task('concat', function () {\n    gulp.src('js/*.js')  //要合并的文件\n    .pipe(concat('all.js'))  // 合并匹配到的js文件并命名为 \"all.js\"\n    .pipe(gulp.dest('dist/js'));\n});\n~~~ \n\n## 图片压缩插件\n~~~\nvar gulp = require('gulp');\nvar imagemin = require('gulp-imagemin');\nvar pngquant = require('imagemin-pngquant'); //png图片压缩插件\n\ngulp.task('default', function () {\n    return gulp.src('src/images/*')\n        .pipe(imagemin({\n            progressive: true,\n            use: [pngquant()] //使用pngquant来压缩png图片\n        }))\n        .pipe(gulp.dest('dist'));\n});\n~~~\n","source":"_posts/前端开发/gulp入门.md","raw":"---\ntitle: gulp入门\ntags:\n  - 工具\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n# 简介\ngulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快\n~~~\nGulp官网 http://gulpjs.com/\nGulp中文网 http://www.gulpjs.com.cn/\nGulp中文文档 https://github.com/lisposter/gulp-docs-zh-cn\nGulp插件网 http://gulpjs.com/plugins/\nAwesome Gulp https://github.com/alferov/awesome-gulp\nStuQ-Gulp实战和原理解析 http://i5ting.github.io/stuq-gulp/\n~~~\n# 工作流程\ngulp的使用流程一般是这样子的：\n1. 通过gulp.src()方法获取到我们想要处理的文件流，22. 把文件流通过pipe方法导入到gulp的插件中\n3. 把经过插件处理后的流再通过pipe方法导入到gulp.dest()中\n4. gulp.dest()方法则把流中的内容写入到文件中\n\n==注意：== 给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名。==生成的文件名是由导入到它的文件流决定的==\n\n# 安装\ngulp基于node.js，要通过nodejs的npm安装gulp，所以先要安装nodejs环境\n* 全局方式：npm install -g gulp\n* gulp的项目中单独安装一次：npm install gulp\n* 安装的时候把gulp写进项目package.json文件的依赖中：npm install --save-dev gulp\n\n在全局安装gulp后，还需要在项目中本地安装一次，是为了版本的灵活性，仅供参考\n\n# 开始使用gulp\n1. 建立gulpfile.js文件\n此时我们的目录结构是这样子的：\n~~~\n├── gulpfile.js\n├── node_modules\n│ └── gulp\n└── package.json\n~~~~\n最简gulpfile.js:\n~~~\nvar gulp = require('gulp');\ngulp.task('default',function(){\n    console.log('hello world');\n});\n~~~\n\n2. 运行gulp任务\n切换到存放gulpfile.js文件的目录\n* 执行gulp命令:会执行任务名为default的默认任务\n* gulp task1:执行task1任务\n\n# gulpfile.js文件\n全局配置config：当gulpfile.js太大时就不好维护了，此时可以将需要在gulpfile中引用的参数，放到这里，包括一些路径，功能的开关等，如：\n~~~\nmodule.exports = {\n    name : '.....',\n    devPath : '.....',    //项目根路径，根路径下可以包含多个项目\n    prodPath : '....', //生产路径根路径\n    sassPath : '.....', //SASS包含文件路径\n    rmHtmlWhitespace : false,//html中是否去除空格\n    webpackEntry : {\n        index : 'index.js'//js合并\n    },\n    server : {\n        port : 8088\n    }\n};\n~~~\n意下这里使用了module.exports，这是nodejs的语法。在gulpfile中将会用require引用config。\n~~~\nvar config = require('./config');//加载项目配置\n~~~\n使用举例：\n~~~\n//引入gulp，项目文件中安装的gulp的引入方式\nvar gulp =require('gulp');\n\n//引入组件\nvar jshint = require(\"gulp-jshint\");\nvar gutil = require(\"gulp-util\");\nvar sass= require(\"gulp-sass\");\nvar concat = require(\"gulp-concat\");\nvar uglify = require(\"gulp-uglify\");\nvar rename = require(\"gulp-rename\");\n\nvar path = require(\"path\");\nvar del = require(\"del\");\n\n//你也许会想要在编译文件之前删除一些文件\ngulp.task('clean', function(cb) {\n    return del(['build/**/*'], cb);\n});\n\n//检查脚本\ngulp.task('lint',function () {\n    gulp.src('./src/javascript/**/*.js')\n        .pipe(jshint())\n        .pipe(jshint.reporter('default'));\n});\n\n//编译sass\n//sass 任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中\ngulp.task('sass',function () {\n    gulp.src(\"./src/scss/**/*.scss\")\n        .pipe(sass({outputStyle: 'compact'}))\n        .pipe(gulp.dest(\"./build/css\"));\n});\n\n//合并，压缩文件\n//scipts 任务会合并js 目录下的所有js文件并输出到dist目录中，然后gulp会重命名。压缩合并的文件，也输出到dist/目录\ngulp.task('scripts',function () {\n    gulp.src('./src/javascript/**/*.js')\n        .pipe(concat('all.js'))\n        .pipe(gulp.dest('./dest'))\n        .pipe(rename(\"all.min.js\"))\n        .pipe(uglify())\n        .pipe(gulp.dest(\"./build\"))\n});\n\n//这时，我们创建了一个基于其他任务的default任务。\n//使用.run()方法关联和运行我们上面定义的任务，使用.watch() 方法去坚挺制定目录的文件变化,当有文件变化时，会运行回调定义的其他任务。\ngulp.task('default',function(){\n    //将你的默认的任务代码放在这里\n    gulp.run('lint','sass','scripts');\n    //监听文件变化\n    gulp.watch(\"\",function () {\n        gulp.run('lint','sass','scripts');\n    });\n});\n~~~\n\n# gulp的API介绍\n更多API介绍： http://www.gulpjs.com.cn/docs/api/\n## gulp.src()\ngulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息 \n~~~\ngulp.src(globs[, options])\n\n* globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组\n* options为可选参数\n~~~\n\n* 当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：\n~~~\ngulp.src('app/src/**/*.css') //此时base的值为 app/src\n~~~\n\nGulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：\n~~~\n* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾\n** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。\n? 匹配文件路径中的一个字符(不会匹配路径分隔符)\n[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法\n!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的\n?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?\n+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+\n*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*\n@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)\n~~~\n==注意：== 不能在数组中的第一个元素中使用排除模式\n\n使用举例：\n~~~\n//使用数组的方式来匹配多种文件\ngulp.src(['js/*.js','css/*.css','*.html'])\n\ngulp.src([*.js,'!b*.js']) //匹配所有js文件，但排除掉以b开头的js文件\ngulp.src(['!b*.js',*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中\n~~~\n\n## gulp.dest()\ngulp.dest()方法是用来写文件的，其语法为：\n~~~\ngulp.dest(path[,options])\n\n* path为写入文件的路径\n* options为一个可选的参数对象，通常我们不需要用到\n~~~\n* 生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径\n\n## gulp.task()\ngulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为：\n~~~\ngulp.task(name[, deps], fn)\n* name 为任务名\n* deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数\n* fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。\n~~~\n使用举例：\n~~~\ngulp.task('mytask', ['array', 'of', 'task', 'names'], function() { //定义一个有依赖的任务\n  // Do something\n});\n~~~\n1. 如果任务相互之间没有依赖，任务会按你书写的顺序来执行\n2. 如果有依赖的话则会先执行依赖的任务\n3. 如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务\n\n## gulp.watch()\ngulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为\n~~~\ngulp.watch(glob[, opts], tasks)\n* glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。\n* opts 为一个可选的配置对象，通常不需要用到\n* tasks 为文件变化后要执行的任务，为一个数组\n~~~\n~~~\ngulp.task('uglify',function(){\n  //do something\n});\ngulp.task('reload',function(){\n  //do something\n});\ngulp.watch('js/**/*.js', ['uglify','reload']);\n~~~\n\n# 一些常用的gulp插件\n## 自动加载插件pulp-load-plugins\n* 这个插件能自动帮你加载package.json文件里的gulp插件\n* gulp-load-plugins是通过package.json文件来加载插件\n* gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件\n* 定义及启用\n~~~\nvar gulp = require('gulp');\n//加载gulp-load-plugins插件，并马上运行它\nvar plugins = require('gulp-load-plugins')();\n~~~\n* 使用举例：\n~~~\nplugins.rename          //gulp-rename插件的使用 \n~~~\n## 重命名插件gulp-rename\n~~~\ngulp.task('rename', function () {\n    gulp.src('js/jquery.js')\n    .pipe(uglify())  //压缩\n    .pipe(rename('jquery.min.js')) //会将jquery.js重命名为jquery.min.js\n    .pipe(gulp.dest('js')); \n});\n~~~\n## js文件压缩插件gulp-uglify\n~~~\nvar gulp = require('gulp'),\n    uglify = require(\"gulp-uglify\");\n \ngulp.task('minify-js', function () {\n    gulp.src('js/*.js') // 要压缩的js文件\n    .pipe(uglify())  //使用uglify进行压缩,更多配置请参考：\n    .pipe(gulp.dest('dist/js')); //压缩后的路径\n});\n~~~\n## css文件压缩插件gulp-minify-css\n~~~\nvar gulp = require('gulp'),\n    minifyCss = require(\"gulp-minify-css\");\n \ngulp.task('minify-css', function () {\n    gulp.src('css/*.css') // 要压缩的css文件\n    .pipe(minifyCss()) //压缩css\n    .pipe(gulp.dest('dist/css'));\n});\n~~~\n## html文件压缩插件gulp-minify-html\n~~~\nvar gulp = require('gulp'),\n    minifyHtml = require(\"gulp-minify-html\");\n \ngulp.task('minify-html', function () {\n    gulp.src('html/*.html') // 要压缩的html文件\n    .pipe(minifyHtml()) //压缩\n    .pipe(gulp.dest('dist/html'));\n});\n~~~\n## js代码检查插件\n~~~\nvar gulp = require('gulp'),\n    jshint = require(\"gulp-jshint\");\n \ngulp.task('jsLint', function () {\n    gulp.src('js/*.js')\n    .pipe(jshint())\n    .pipe(jshint.reporter()); // 输出检查结果\n});\n~~~\n## 文件合并插件gulp-concat\n~~~\nvar gulp = require('gulp'),\n    concat = require(\"gulp-concat\");\n \ngulp.task('concat', function () {\n    gulp.src('js/*.js')  //要合并的文件\n    .pipe(concat('all.js'))  // 合并匹配到的js文件并命名为 \"all.js\"\n    .pipe(gulp.dest('dist/js'));\n});\n~~~ \n\n## 图片压缩插件\n~~~\nvar gulp = require('gulp');\nvar imagemin = require('gulp-imagemin');\nvar pngquant = require('imagemin-pngquant'); //png图片压缩插件\n\ngulp.task('default', function () {\n    return gulp.src('src/images/*')\n        .pipe(imagemin({\n            progressive: true,\n            use: [pngquant()] //使用pngquant来压缩png图片\n        }))\n        .pipe(gulp.dest('dist'));\n});\n~~~\n","slug":"前端开发-gulp入门","published":1,"updated":"2019-02-14T06:26:29.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3n00dv5b8hhtj73axo","content":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gulp官网 http://gulpjs.com/</span><br><span class=\"line\">Gulp中文网 http://www.gulpjs.com.cn/</span><br><span class=\"line\">Gulp中文文档 https://github.com/lisposter/gulp-docs-zh-cn</span><br><span class=\"line\">Gulp插件网 http://gulpjs.com/plugins/</span><br><span class=\"line\">Awesome Gulp https://github.com/alferov/awesome-gulp</span><br><span class=\"line\">StuQ-Gulp实战和原理解析 http://i5ting.github.io/stuq-gulp/</span><br></pre></td></tr></table></figure>\n<h1 id=\"工作流程\"><a class=\"markdownIt-Anchor\" href=\"#工作流程\"></a> 工作流程</h1>\n<p>gulp的使用流程一般是这样子的：</p>\n<ol>\n<li>通过gulp.src()方法获取到我们想要处理的文件流，22. 把文件流通过pipe方法导入到gulp的插件中</li>\n<li>把经过插件处理后的流再通过pipe方法导入到gulp.dest()中</li>\n<li>gulp.dest()方法则把流中的内容写入到文件中</li>\n</ol>\n<p>==注意：== 给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名。==生成的文件名是由导入到它的文件流决定的==</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>gulp基于node.js，要通过nodejs的npm安装gulp，所以先要安装nodejs环境</p>\n<ul>\n<li>全局方式：npm install -g gulp</li>\n<li>gulp的项目中单独安装一次：npm install gulp</li>\n<li>安装的时候把gulp写进项目package.json文件的依赖中：npm install --save-dev gulp</li>\n</ul>\n<p>在全局安装gulp后，还需要在项目中本地安装一次，是为了版本的灵活性，仅供参考</p>\n<h1 id=\"开始使用gulp\"><a class=\"markdownIt-Anchor\" href=\"#开始使用gulp\"></a> 开始使用gulp</h1>\n<ol>\n<li>建立gulpfile.js文件<br>\n此时我们的目录结构是这样子的：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│ └── gulp</span><br><span class=\"line\">└── package.json</span><br><span class=\"line\">~</span><br></pre></td></tr></table></figure>\n<p>最简gulpfile.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;);</span><br><span class=\"line\">gulp.task(&apos;default&apos;,function()&#123;</span><br><span class=\"line\">    console.log(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>运行gulp任务<br>\n切换到存放gulpfile.js文件的目录</li>\n</ol>\n<ul>\n<li>执行gulp命令:会执行任务名为default的默认任务</li>\n<li>gulp task1:执行task1任务</li>\n</ul>\n<h1 id=\"gulpfilejs文件\"><a class=\"markdownIt-Anchor\" href=\"#gulpfilejs文件\"></a> gulpfile.js文件</h1>\n<p>全局配置config：当gulpfile.js太大时就不好维护了，此时可以将需要在gulpfile中引用的参数，放到这里，包括一些路径，功能的开关等，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    name : &apos;.....&apos;,</span><br><span class=\"line\">    devPath : &apos;.....&apos;,    //项目根路径，根路径下可以包含多个项目</span><br><span class=\"line\">    prodPath : &apos;....&apos;, //生产路径根路径</span><br><span class=\"line\">    sassPath : &apos;.....&apos;, //SASS包含文件路径</span><br><span class=\"line\">    rmHtmlWhitespace : false,//html中是否去除空格</span><br><span class=\"line\">    webpackEntry : &#123;</span><br><span class=\"line\">        index : &apos;index.js&apos;//js合并</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    server : &#123;</span><br><span class=\"line\">        port : 8088</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>意下这里使用了module.exports，这是nodejs的语法。在gulpfile中将会用require引用config。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var config = require(&apos;./config&apos;);//加载项目配置</span><br></pre></td></tr></table></figure>\n<p>使用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//引入gulp，项目文件中安装的gulp的引入方式</span><br><span class=\"line\">var gulp =require(&apos;gulp&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//引入组件</span><br><span class=\"line\">var jshint = require(&quot;gulp-jshint&quot;);</span><br><span class=\"line\">var gutil = require(&quot;gulp-util&quot;);</span><br><span class=\"line\">var sass= require(&quot;gulp-sass&quot;);</span><br><span class=\"line\">var concat = require(&quot;gulp-concat&quot;);</span><br><span class=\"line\">var uglify = require(&quot;gulp-uglify&quot;);</span><br><span class=\"line\">var rename = require(&quot;gulp-rename&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var path = require(&quot;path&quot;);</span><br><span class=\"line\">var del = require(&quot;del&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//你也许会想要在编译文件之前删除一些文件</span><br><span class=\"line\">gulp.task(&apos;clean&apos;, function(cb) &#123;</span><br><span class=\"line\">    return del([&apos;build/**/*&apos;], cb);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//检查脚本</span><br><span class=\"line\">gulp.task(&apos;lint&apos;,function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;./src/javascript/**/*.js&apos;)</span><br><span class=\"line\">        .pipe(jshint())</span><br><span class=\"line\">        .pipe(jshint.reporter(&apos;default&apos;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编译sass</span><br><span class=\"line\">//sass 任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中</span><br><span class=\"line\">gulp.task(&apos;sass&apos;,function () &#123;</span><br><span class=\"line\">    gulp.src(&quot;./src/scss/**/*.scss&quot;)</span><br><span class=\"line\">        .pipe(sass(&#123;outputStyle: &apos;compact&apos;&#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(&quot;./build/css&quot;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//合并，压缩文件</span><br><span class=\"line\">//scipts 任务会合并js 目录下的所有js文件并输出到dist目录中，然后gulp会重命名。压缩合并的文件，也输出到dist/目录</span><br><span class=\"line\">gulp.task(&apos;scripts&apos;,function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;./src/javascript/**/*.js&apos;)</span><br><span class=\"line\">        .pipe(concat(&apos;all.js&apos;))</span><br><span class=\"line\">        .pipe(gulp.dest(&apos;./dest&apos;))</span><br><span class=\"line\">        .pipe(rename(&quot;all.min.js&quot;))</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(gulp.dest(&quot;./build&quot;))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//这时，我们创建了一个基于其他任务的default任务。</span><br><span class=\"line\">//使用.run()方法关联和运行我们上面定义的任务，使用.watch() 方法去坚挺制定目录的文件变化,当有文件变化时，会运行回调定义的其他任务。</span><br><span class=\"line\">gulp.task(&apos;default&apos;,function()&#123;</span><br><span class=\"line\">    //将你的默认的任务代码放在这里</span><br><span class=\"line\">    gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;);</span><br><span class=\"line\">    //监听文件变化</span><br><span class=\"line\">    gulp.watch(&quot;&quot;,function () &#123;</span><br><span class=\"line\">        gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"gulp的api介绍\"><a class=\"markdownIt-Anchor\" href=\"#gulp的api介绍\"></a> gulp的API介绍</h1>\n<p>更多API介绍： <a href=\"http://www.gulpjs.com.cn/docs/api/\" target=\"_blank\" rel=\"noopener\">http://www.gulpjs.com.cn/docs/api/</a></p>\n<h2 id=\"gulpsrc\"><a class=\"markdownIt-Anchor\" href=\"#gulpsrc\"></a> gulp.src()</h2>\n<p>gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(globs[, options])</span><br><span class=\"line\"></span><br><span class=\"line\">* globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组</span><br><span class=\"line\">* options为可选参数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(&apos;app/src/**/*.css&apos;) //此时base的值为 app/src</span><br></pre></td></tr></table></figure>\n<p>Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾</span><br><span class=\"line\">** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</span><br><span class=\"line\">? 匹配文件路径中的一个字符(不会匹配路径分隔符)</span><br><span class=\"line\">[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法</span><br><span class=\"line\">!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</span><br><span class=\"line\">?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?</span><br><span class=\"line\">+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+</span><br><span class=\"line\">*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*</span><br><span class=\"line\">@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)</span><br></pre></td></tr></table></figure>\n<p>==注意：== 不能在数组中的第一个元素中使用排除模式</p>\n<p>使用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用数组的方式来匹配多种文件</span><br><span class=\"line\">gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件</span><br><span class=\"line\">gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span><br></pre></td></tr></table></figure>\n<h2 id=\"gulpdest\"><a class=\"markdownIt-Anchor\" href=\"#gulpdest\"></a> gulp.dest()</h2>\n<p>gulp.dest()方法是用来写文件的，其语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.dest(path[,options])</span><br><span class=\"line\"></span><br><span class=\"line\">* path为写入文件的路径</span><br><span class=\"line\">* options为一个可选的参数对象，通常我们不需要用到</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径</li>\n</ul>\n<h2 id=\"gulptask\"><a class=\"markdownIt-Anchor\" href=\"#gulptask\"></a> gulp.task()</h2>\n<p>gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(name[, deps], fn)</span><br><span class=\"line\">* name 为任务名</span><br><span class=\"line\">* deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</span><br><span class=\"line\">* fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</span><br></pre></td></tr></table></figure>\n<p>使用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; //定义一个有依赖的任务</span><br><span class=\"line\">  // Do something</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果任务相互之间没有依赖，任务会按你书写的顺序来执行</li>\n<li>如果有依赖的话则会先执行依赖的任务</li>\n<li>如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务</li>\n</ol>\n<h2 id=\"gulpwatch\"><a class=\"markdownIt-Anchor\" href=\"#gulpwatch\"></a> gulp.watch()</h2>\n<p>gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.watch(glob[, opts], tasks)</span><br><span class=\"line\">* glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。</span><br><span class=\"line\">* opts 为一个可选的配置对象，通常不需要用到</span><br><span class=\"line\">* tasks 为文件变化后要执行的任务，为一个数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;uglify&apos;,function()&#123;</span><br><span class=\"line\">  //do something</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(&apos;reload&apos;,function()&#123;</span><br><span class=\"line\">  //do something</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</span><br></pre></td></tr></table></figure>\n<h1 id=\"一些常用的gulp插件\"><a class=\"markdownIt-Anchor\" href=\"#一些常用的gulp插件\"></a> 一些常用的gulp插件</h1>\n<h2 id=\"自动加载插件pulp-load-plugins\"><a class=\"markdownIt-Anchor\" href=\"#自动加载插件pulp-load-plugins\"></a> 自动加载插件pulp-load-plugins</h2>\n<ul>\n<li>这个插件能自动帮你加载package.json文件里的gulp插件</li>\n<li>gulp-load-plugins是通过package.json文件来加载插件</li>\n<li>gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件</li>\n<li>定义及启用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;);</span><br><span class=\"line\">//加载gulp-load-plugins插件，并马上运行它</span><br><span class=\"line\">var plugins = require(&apos;gulp-load-plugins&apos;)();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用举例：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins.rename          //gulp-rename插件的使用</span><br></pre></td></tr></table></figure>\n<h2 id=\"重命名插件gulp-rename\"><a class=\"markdownIt-Anchor\" href=\"#重命名插件gulp-rename\"></a> 重命名插件gulp-rename</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;rename&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/jquery.js&apos;)</span><br><span class=\"line\">    .pipe(uglify())  //压缩</span><br><span class=\"line\">    .pipe(rename(&apos;jquery.min.js&apos;)) //会将jquery.js重命名为jquery.min.js</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;js&apos;)); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"js文件压缩插件gulp-uglify\"><a class=\"markdownIt-Anchor\" href=\"#js文件压缩插件gulp-uglify\"></a> js文件压缩插件gulp-uglify</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    uglify = require(&quot;gulp-uglify&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;minify-js&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/*.js&apos;) // 要压缩的js文件</span><br><span class=\"line\">    .pipe(uglify())  //使用uglify进行压缩,更多配置请参考：</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"css文件压缩插件gulp-minify-css\"><a class=\"markdownIt-Anchor\" href=\"#css文件压缩插件gulp-minify-css\"></a> css文件压缩插件gulp-minify-css</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    minifyCss = require(&quot;gulp-minify-css&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;minify-css&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;css/*.css&apos;) // 要压缩的css文件</span><br><span class=\"line\">    .pipe(minifyCss()) //压缩css</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/css&apos;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"html文件压缩插件gulp-minify-html\"><a class=\"markdownIt-Anchor\" href=\"#html文件压缩插件gulp-minify-html\"></a> html文件压缩插件gulp-minify-html</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    minifyHtml = require(&quot;gulp-minify-html&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;minify-html&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;html/*.html&apos;) // 要压缩的html文件</span><br><span class=\"line\">    .pipe(minifyHtml()) //压缩</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/html&apos;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"js代码检查插件\"><a class=\"markdownIt-Anchor\" href=\"#js代码检查插件\"></a> js代码检查插件</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    jshint = require(&quot;gulp-jshint&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;jsLint&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/*.js&apos;)</span><br><span class=\"line\">    .pipe(jshint())</span><br><span class=\"line\">    .pipe(jshint.reporter()); // 输出检查结果</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件合并插件gulp-concat\"><a class=\"markdownIt-Anchor\" href=\"#文件合并插件gulp-concat\"></a> 文件合并插件gulp-concat</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    concat = require(&quot;gulp-concat&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;concat&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/*.js&apos;)  //要合并的文件</span><br><span class=\"line\">    .pipe(concat(&apos;all.js&apos;))  // 合并匹配到的js文件并命名为 &quot;all.js&quot;</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/js&apos;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\">## 图片压缩插件</span><br></pre></td></tr></table></figure>\n<p>var gulp = require(‘gulp’);<br>\nvar imagemin = require(‘gulp-imagemin’);<br>\nvar pngquant = require(‘imagemin-pngquant’); //png图片压缩插件</p>\n<p>gulp.task(‘default’, function () {<br>\nreturn gulp.src(‘src/images/*’)<br>\n.pipe(imagemin({<br>\nprogressive: true,<br>\nuse: [pngquant()] //使用pngquant来压缩png图片<br>\n}))<br>\n.pipe(gulp.dest(‘dist’));<br>\n});</p>\n<pre class=\"highlight\"><code class=\"\"></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p>gulpjs是一个前端构建工具，与gruntjs相比，gulpjs无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulpjs使用的是nodejs中stream来读取和操作数据，其速度更快</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gulp官网 http://gulpjs.com/</span><br><span class=\"line\">Gulp中文网 http://www.gulpjs.com.cn/</span><br><span class=\"line\">Gulp中文文档 https://github.com/lisposter/gulp-docs-zh-cn</span><br><span class=\"line\">Gulp插件网 http://gulpjs.com/plugins/</span><br><span class=\"line\">Awesome Gulp https://github.com/alferov/awesome-gulp</span><br><span class=\"line\">StuQ-Gulp实战和原理解析 http://i5ting.github.io/stuq-gulp/</span><br></pre></td></tr></table></figure>\n<h1 id=\"工作流程\"><a class=\"markdownIt-Anchor\" href=\"#工作流程\"></a> 工作流程</h1>\n<p>gulp的使用流程一般是这样子的：</p>\n<ol>\n<li>通过gulp.src()方法获取到我们想要处理的文件流，22. 把文件流通过pipe方法导入到gulp的插件中</li>\n<li>把经过插件处理后的流再通过pipe方法导入到gulp.dest()中</li>\n<li>gulp.dest()方法则把流中的内容写入到文件中</li>\n</ol>\n<p>==注意：== 给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名。==生成的文件名是由导入到它的文件流决定的==</p>\n<h1 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h1>\n<p>gulp基于node.js，要通过nodejs的npm安装gulp，所以先要安装nodejs环境</p>\n<ul>\n<li>全局方式：npm install -g gulp</li>\n<li>gulp的项目中单独安装一次：npm install gulp</li>\n<li>安装的时候把gulp写进项目package.json文件的依赖中：npm install --save-dev gulp</li>\n</ul>\n<p>在全局安装gulp后，还需要在项目中本地安装一次，是为了版本的灵活性，仅供参考</p>\n<h1 id=\"开始使用gulp\"><a class=\"markdownIt-Anchor\" href=\"#开始使用gulp\"></a> 开始使用gulp</h1>\n<ol>\n<li>建立gulpfile.js文件<br>\n此时我们的目录结构是这样子的：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│ └── gulp</span><br><span class=\"line\">└── package.json</span><br><span class=\"line\">~</span><br></pre></td></tr></table></figure>\n<p>最简gulpfile.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;);</span><br><span class=\"line\">gulp.task(&apos;default&apos;,function()&#123;</span><br><span class=\"line\">    console.log(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>运行gulp任务<br>\n切换到存放gulpfile.js文件的目录</li>\n</ol>\n<ul>\n<li>执行gulp命令:会执行任务名为default的默认任务</li>\n<li>gulp task1:执行task1任务</li>\n</ul>\n<h1 id=\"gulpfilejs文件\"><a class=\"markdownIt-Anchor\" href=\"#gulpfilejs文件\"></a> gulpfile.js文件</h1>\n<p>全局配置config：当gulpfile.js太大时就不好维护了，此时可以将需要在gulpfile中引用的参数，放到这里，包括一些路径，功能的开关等，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    name : &apos;.....&apos;,</span><br><span class=\"line\">    devPath : &apos;.....&apos;,    //项目根路径，根路径下可以包含多个项目</span><br><span class=\"line\">    prodPath : &apos;....&apos;, //生产路径根路径</span><br><span class=\"line\">    sassPath : &apos;.....&apos;, //SASS包含文件路径</span><br><span class=\"line\">    rmHtmlWhitespace : false,//html中是否去除空格</span><br><span class=\"line\">    webpackEntry : &#123;</span><br><span class=\"line\">        index : &apos;index.js&apos;//js合并</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    server : &#123;</span><br><span class=\"line\">        port : 8088</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>意下这里使用了module.exports，这是nodejs的语法。在gulpfile中将会用require引用config。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var config = require(&apos;./config&apos;);//加载项目配置</span><br></pre></td></tr></table></figure>\n<p>使用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//引入gulp，项目文件中安装的gulp的引入方式</span><br><span class=\"line\">var gulp =require(&apos;gulp&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//引入组件</span><br><span class=\"line\">var jshint = require(&quot;gulp-jshint&quot;);</span><br><span class=\"line\">var gutil = require(&quot;gulp-util&quot;);</span><br><span class=\"line\">var sass= require(&quot;gulp-sass&quot;);</span><br><span class=\"line\">var concat = require(&quot;gulp-concat&quot;);</span><br><span class=\"line\">var uglify = require(&quot;gulp-uglify&quot;);</span><br><span class=\"line\">var rename = require(&quot;gulp-rename&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var path = require(&quot;path&quot;);</span><br><span class=\"line\">var del = require(&quot;del&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//你也许会想要在编译文件之前删除一些文件</span><br><span class=\"line\">gulp.task(&apos;clean&apos;, function(cb) &#123;</span><br><span class=\"line\">    return del([&apos;build/**/*&apos;], cb);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//检查脚本</span><br><span class=\"line\">gulp.task(&apos;lint&apos;,function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;./src/javascript/**/*.js&apos;)</span><br><span class=\"line\">        .pipe(jshint())</span><br><span class=\"line\">        .pipe(jshint.reporter(&apos;default&apos;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编译sass</span><br><span class=\"line\">//sass 任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中</span><br><span class=\"line\">gulp.task(&apos;sass&apos;,function () &#123;</span><br><span class=\"line\">    gulp.src(&quot;./src/scss/**/*.scss&quot;)</span><br><span class=\"line\">        .pipe(sass(&#123;outputStyle: &apos;compact&apos;&#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(&quot;./build/css&quot;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//合并，压缩文件</span><br><span class=\"line\">//scipts 任务会合并js 目录下的所有js文件并输出到dist目录中，然后gulp会重命名。压缩合并的文件，也输出到dist/目录</span><br><span class=\"line\">gulp.task(&apos;scripts&apos;,function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;./src/javascript/**/*.js&apos;)</span><br><span class=\"line\">        .pipe(concat(&apos;all.js&apos;))</span><br><span class=\"line\">        .pipe(gulp.dest(&apos;./dest&apos;))</span><br><span class=\"line\">        .pipe(rename(&quot;all.min.js&quot;))</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(gulp.dest(&quot;./build&quot;))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//这时，我们创建了一个基于其他任务的default任务。</span><br><span class=\"line\">//使用.run()方法关联和运行我们上面定义的任务，使用.watch() 方法去坚挺制定目录的文件变化,当有文件变化时，会运行回调定义的其他任务。</span><br><span class=\"line\">gulp.task(&apos;default&apos;,function()&#123;</span><br><span class=\"line\">    //将你的默认的任务代码放在这里</span><br><span class=\"line\">    gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;);</span><br><span class=\"line\">    //监听文件变化</span><br><span class=\"line\">    gulp.watch(&quot;&quot;,function () &#123;</span><br><span class=\"line\">        gulp.run(&apos;lint&apos;,&apos;sass&apos;,&apos;scripts&apos;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"gulp的api介绍\"><a class=\"markdownIt-Anchor\" href=\"#gulp的api介绍\"></a> gulp的API介绍</h1>\n<p>更多API介绍： <a href=\"http://www.gulpjs.com.cn/docs/api/\" target=\"_blank\" rel=\"noopener\">http://www.gulpjs.com.cn/docs/api/</a></p>\n<h2 id=\"gulpsrc\"><a class=\"markdownIt-Anchor\" href=\"#gulpsrc\"></a> gulp.src()</h2>\n<p>gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(globs[, options])</span><br><span class=\"line\"></span><br><span class=\"line\">* globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组</span><br><span class=\"line\">* options为可选参数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(&apos;app/src/**/*.css&apos;) //此时base的值为 app/src</span><br></pre></td></tr></table></figure>\n<p>Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾</span><br><span class=\"line\">** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</span><br><span class=\"line\">? 匹配文件路径中的一个字符(不会匹配路径分隔符)</span><br><span class=\"line\">[...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法</span><br><span class=\"line\">!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</span><br><span class=\"line\">?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?</span><br><span class=\"line\">+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+</span><br><span class=\"line\">*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)*</span><br><span class=\"line\">@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)</span><br></pre></td></tr></table></figure>\n<p>==注意：== 不能在数组中的第一个元素中使用排除模式</p>\n<p>使用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用数组的方式来匹配多种文件</span><br><span class=\"line\">gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件</span><br><span class=\"line\">gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span><br></pre></td></tr></table></figure>\n<h2 id=\"gulpdest\"><a class=\"markdownIt-Anchor\" href=\"#gulpdest\"></a> gulp.dest()</h2>\n<p>gulp.dest()方法是用来写文件的，其语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.dest(path[,options])</span><br><span class=\"line\"></span><br><span class=\"line\">* path为写入文件的路径</span><br><span class=\"line\">* options为一个可选的参数对象，通常我们不需要用到</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径</li>\n</ul>\n<h2 id=\"gulptask\"><a class=\"markdownIt-Anchor\" href=\"#gulptask\"></a> gulp.task()</h2>\n<p>gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(name[, deps], fn)</span><br><span class=\"line\">* name 为任务名</span><br><span class=\"line\">* deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</span><br><span class=\"line\">* fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</span><br></pre></td></tr></table></figure>\n<p>使用举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; //定义一个有依赖的任务</span><br><span class=\"line\">  // Do something</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果任务相互之间没有依赖，任务会按你书写的顺序来执行</li>\n<li>如果有依赖的话则会先执行依赖的任务</li>\n<li>如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务</li>\n</ol>\n<h2 id=\"gulpwatch\"><a class=\"markdownIt-Anchor\" href=\"#gulpwatch\"></a> gulp.watch()</h2>\n<p>gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.watch(glob[, opts], tasks)</span><br><span class=\"line\">* glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。</span><br><span class=\"line\">* opts 为一个可选的配置对象，通常不需要用到</span><br><span class=\"line\">* tasks 为文件变化后要执行的任务，为一个数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;uglify&apos;,function()&#123;</span><br><span class=\"line\">  //do something</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(&apos;reload&apos;,function()&#123;</span><br><span class=\"line\">  //do something</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</span><br></pre></td></tr></table></figure>\n<h1 id=\"一些常用的gulp插件\"><a class=\"markdownIt-Anchor\" href=\"#一些常用的gulp插件\"></a> 一些常用的gulp插件</h1>\n<h2 id=\"自动加载插件pulp-load-plugins\"><a class=\"markdownIt-Anchor\" href=\"#自动加载插件pulp-load-plugins\"></a> 自动加载插件pulp-load-plugins</h2>\n<ul>\n<li>这个插件能自动帮你加载package.json文件里的gulp插件</li>\n<li>gulp-load-plugins是通过package.json文件来加载插件</li>\n<li>gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件</li>\n<li>定义及启用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;);</span><br><span class=\"line\">//加载gulp-load-plugins插件，并马上运行它</span><br><span class=\"line\">var plugins = require(&apos;gulp-load-plugins&apos;)();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用举例：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins.rename          //gulp-rename插件的使用</span><br></pre></td></tr></table></figure>\n<h2 id=\"重命名插件gulp-rename\"><a class=\"markdownIt-Anchor\" href=\"#重命名插件gulp-rename\"></a> 重命名插件gulp-rename</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(&apos;rename&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/jquery.js&apos;)</span><br><span class=\"line\">    .pipe(uglify())  //压缩</span><br><span class=\"line\">    .pipe(rename(&apos;jquery.min.js&apos;)) //会将jquery.js重命名为jquery.min.js</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;js&apos;)); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"js文件压缩插件gulp-uglify\"><a class=\"markdownIt-Anchor\" href=\"#js文件压缩插件gulp-uglify\"></a> js文件压缩插件gulp-uglify</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    uglify = require(&quot;gulp-uglify&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;minify-js&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/*.js&apos;) // 要压缩的js文件</span><br><span class=\"line\">    .pipe(uglify())  //使用uglify进行压缩,更多配置请参考：</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"css文件压缩插件gulp-minify-css\"><a class=\"markdownIt-Anchor\" href=\"#css文件压缩插件gulp-minify-css\"></a> css文件压缩插件gulp-minify-css</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    minifyCss = require(&quot;gulp-minify-css&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;minify-css&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;css/*.css&apos;) // 要压缩的css文件</span><br><span class=\"line\">    .pipe(minifyCss()) //压缩css</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/css&apos;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"html文件压缩插件gulp-minify-html\"><a class=\"markdownIt-Anchor\" href=\"#html文件压缩插件gulp-minify-html\"></a> html文件压缩插件gulp-minify-html</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    minifyHtml = require(&quot;gulp-minify-html&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;minify-html&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;html/*.html&apos;) // 要压缩的html文件</span><br><span class=\"line\">    .pipe(minifyHtml()) //压缩</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/html&apos;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"js代码检查插件\"><a class=\"markdownIt-Anchor\" href=\"#js代码检查插件\"></a> js代码检查插件</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    jshint = require(&quot;gulp-jshint&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;jsLint&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/*.js&apos;)</span><br><span class=\"line\">    .pipe(jshint())</span><br><span class=\"line\">    .pipe(jshint.reporter()); // 输出检查结果</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件合并插件gulp-concat\"><a class=\"markdownIt-Anchor\" href=\"#文件合并插件gulp-concat\"></a> 文件合并插件gulp-concat</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&apos;gulp&apos;),</span><br><span class=\"line\">    concat = require(&quot;gulp-concat&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.task(&apos;concat&apos;, function () &#123;</span><br><span class=\"line\">    gulp.src(&apos;js/*.js&apos;)  //要合并的文件</span><br><span class=\"line\">    .pipe(concat(&apos;all.js&apos;))  // 合并匹配到的js文件并命名为 &quot;all.js&quot;</span><br><span class=\"line\">    .pipe(gulp.dest(&apos;dist/js&apos;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\">## 图片压缩插件</span><br></pre></td></tr></table></figure>\n<p>var gulp = require(‘gulp’);<br>\nvar imagemin = require(‘gulp-imagemin’);<br>\nvar pngquant = require(‘imagemin-pngquant’); //png图片压缩插件</p>\n<p>gulp.task(‘default’, function () {<br>\nreturn gulp.src(‘src/images/*’)<br>\n.pipe(imagemin({<br>\nprogressive: true,<br>\nuse: [pngquant()] //使用pngquant来压缩png图片<br>\n}))<br>\n.pipe(gulp.dest(‘dist’));<br>\n});</p>\n<pre class=\"highlight\"><code class=\"\"></code></pre>\n"},{"title":"Vue入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"~~~\nhttps://cn.vuejs.org/\nhttps://vuejs.org/\nhttps://cn.vuejs.org/v2/api/\n~~~\n\n# 简介\n> Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的。是个人维护项目\n\n> Vue.js是数据驱动的，你无需手动操作DOM\n\n> 通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新\n\n> 使用Vue.js时，也可以结合其他库一起使用，比如jQuery\n\n使用Vue的过程就是定义MVVM各个组成部分的过程的过程\n1. 定义View\n~~~\n<div id=\"app\">\n    {{ message }}\n</div>\n~~~\n2. 定义Model，如： \n~~~\nvar exampleData = {\n    message: 'Hello World!'\n}\n~~~\n3. 创建一个Vue实例或\"ViewModel\"，它用于连接View和Model\n~~~\nnew Vue({\n    el: '#app',\n    data: exampleData\n})\n~~~\n\n# Vue实例\n## 构造器\n每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的：\n~~~\nvar vm = new Vue({\n  // 选项\n})\n~~~\n实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项,具体API查看：https://cn.vuejs.org/v2/api/\n\n## 属性和方法\n* 每个 Vue 实例都会代理其 data 对象里所有的属性\n* ==只有这些被代理的属性是响应的==\n* 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新\n* Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分\n\n\n## 实例生命周期\n每个 Vue 实例在被创建之前都要经过一系列的初始化过程\n\n![image](http://note.youdao.com/yws/api/personal/file/WEB57f1826aa9ca7087a82b38e583419433?method=download&shareKey=33f8412154b6172b3bf4b99f8bcf0a40)\n\n# Vue.js的常用指令\nVue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）\n\n* 用 key 管理可复用的元素:添加一个具有唯一值的 key 属性,来声明“这两个元素是完全独立的——不要复用它们”\n\nVue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：\n\n##  v-if指令\n条件渲染指令，它根据表达式的真假来删除和插入元素\n~~~\n<h1 v-if=\"age >= 25\">Age: {{ age }}</h1>\n~~~\n## v-show指令\n控制显示／隐藏，true／false\n* 和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性\n~~~\n<h1 v-show=\"age >= 25\">Age: {{ age }}</h1>\n~~~\n## v-else指令\n* 可以用v-else指令为v-if或v-show添加一个“else块”\n* v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别\n~~~\n<h1 v-show=\"name.indexOf('keep') >= 0\">Name: {{ name }}</h1>\n<h1 v-else>Sex: {{ sex }}</h1>\n~~~\n## v-for指令\n~~~\n<ul>\n    <li v-for=\"value in json\">\n        {{value}} {{$index}} {{$key}}\n    </li>\n     <li v-for=\"(k,v) in json\">\n        {{k}} {{v}} {{$index}} {{$key}}\n    </li>\n</ul>\n~~~\n## v-bind指令\n* 如果属性中要绑定Vue数据，最好用绑定的方式\n* v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute）\n~~~\n<img v-bind:src=\"{{url}} alt=\"\"/>\"//后台不会报错误，不绑定后台会报错，界面不影响\n~~~\n* class\n\n用法一：其值为数组形式，数组中的值为Vue的data中定义的属性，而vue中属性对应的值为真正的css样式\n~~~\n.astyle{ color:red}\n.bstyle{ background-color:bule}\n<script>\n    new Vue(){\n        data:{\n            a:\"astyle\",\n            b:\"bstyle\"\n        }\n    }\n</script>\n<div id=\"box\">\n    <strong :class=\"[a,b]\">测试文字</strong>\n</div>\n~~~\n方式二：其值为json格式，json的key为真正的css样式名称，value为true/false／data中的属性\n~~~\n<div id=\"box\">\n    <strong :class=\"{astyle:true,bstyle:a}\">测试文字</strong>\n</div>\n~~~\n方式三：class的值直接是data的一个json数据\n~~~\nnew Vue(){\n    data:{\n       jsonData:{\n            astyle:true,\n            bstyle:false\n       }\n    }\n}\n<div id=\"box\">\n    <strong :class=\"jsonData\">测试文字</strong>\n</div>\n~~~\n* style：复合样式采用的是驼峰命名法\n\n方法一：\n~~~\n<strong :style=\"color:red\">文字</strong>\n~~~\n方式二：\n~~~\nnew Vue(){\n    data:{\n        astyle:{color:'red'},\n        bstyle:{backgroudColor:'blue'}\n    }\n}\n<div id=\"box\">\n    <strong :style=\"[astyle,bstyle]]\">测试文字</strong>\n</div>\n~~~\n方式三：官方推荐\n~~~\nnew Vue(){\n    data:{\n        jsonData:{\n            color:'red',\n            backgroudColor:'blue'\n        }\n    }\n}\n<div id=\"box\">\n    <strong :style=\"jsonData\">测试文字</strong>\n</div>\n~~~\n## v-on指令\n用于监听DOM事件\n~~~\n<script>\nnew Vue(){\n    methods:{\n        show:function(){alert(124);}\n    }\n}\n</script>\n\n<input type=\"button\" value=\"弹框\" v-on:click=\"show()\"\n~~~\n\n==知识点==：v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号 \n\n## v-model\n表单元素的双向绑定，它会根据控件类型自动选取正确的方法来更新元素\n~~~\n<input v-model=\"message.trim\" placeholder=\"edit me\">\n<p>Message is: {{ message }}</p>\n~~~\n* .number:将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）,如：<input v-model.number=\"age\" type=\"number\">\n* .trim：自动过滤用户输入的首尾空格\n* .lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 ，但可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步\n\n\n# 事件\n## 事件修饰符\n~~~\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n~~~\n### 事件冒泡阻止\n1. 传递事件$event，ev.cancleBubble=true;\n2. @click.stop\n\n### 默认行为\n如网页中添加了右键事件后，系统还有默认右键事件\n1. 传递事件$event，ev.preventDefault();\n2. @contextmenu.prevent\n\n### 键盘事件\n1. 传递事件$event，ev.keyCode，判断后进行操作\n2. @keyup.键值，如：@keyup.13\n3. @keyup.键盘键面值，如：@keyup.enter\n\n## 按键修饰符\n~~~\n<input v-on:keyup.13=\"submit\">\n~~~\n全部的按键别名：\n~~~\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n~~~\n\n# 模版语法\nmsg类似为js变量,Mustache中可以进行JS编程，如申明变量，条件判断等\n~~~\n* 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：{{msg}} 数据更新模版变化\n* {{*msg}} 只绑定一次\n* {{{msg}}}  HTML转义，html语法会翻译\n~~~\n\n# 计算属性\n* 在模板中放入太多的逻辑会让模板过重且难以维护，应当考虑使用计算属性\n* 可以像绑定普通属性一样在模板中绑定计算属性\n* 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,==这也是计算属性和methods的区别，需依据具体情况使用==\n~~~\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n});\n~~~\n* 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter \n~~~\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n\n在运行 vm.fullName = 'John Doe' 时， setter 会被调用\n~~~\n\n# 过滤器\n> 过滤模版数据\n~~~\n{{msg|filterA 参数|filterB 参数|...}}\n~~~\n\n系统默认提供过滤器，如：\n~~~\n* {{'welcome'|uppercase}}\n* {{'welcome'|lowercase}}\n* {{'welcome'|capitalize}}\n* {{'welcome'|currency}}\n* {{'welcome'|currency \"$\"}}    //传参\n* {{ message | filterA('arg1', arg2) }}  //穿参\n~~~\n\n# 交互\nVue本身不支持Ajax框架，需引入官方库vue-resource,支持get、post、jsonp\n* get\n~~~\nmethods:{\n    getFun:function(){\n        this.$http.get(\"a.txt\").then(function(res){\n            console.log(res.data);\n        },function(res){\n            console.log(res.status);\n        });\n    },\n    //传递参数\n    get2Fun:function(){\n        this.$http.get(\"a.php\",{a:1,b:2}}).then(function(res){\n            console.log(res.data);\n        },function(res){\n            console.log(res.status);\n        });\n    }\n}\n~~~\n* post\n~~~\nmethods:{\n    postFun:function(){\n        this.$http.post(\"a.php\",{a:1,b:2},{emulateJSON:true}).then(function(res){\n            console.log(res.data);\n        },function(res){\n            console.log(res.status);\n        });\n    }\n}\n~~~\n* jsonp\n~~~\nmethods:{\n    postFun:function(){\n        this.$http.jsonp(\n            \"https://www.baidu....\",\n            {a:1},\n            {jsonp:''cb''}//callback 名字\n        )\n        .then(function(res){\n                console.log(res.data);\n            },function(res){\n                console.log(res.status);\n            }\n        );\n    }\n}\n~~~\n\n# 组件\n## 使用组件\n* 要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：\n~~~\nVue.component('my-component', {\n  // 选项\n})\n~~~\n* Vue.js建议自定义标签名：==小写，并且包含一个短杠==\n* 要确保在初始化根实例 之前 注册了组件\n* 局部注册\n~~~\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\nnew Vue({\n  // ...\n  components: {\n    // <my-component> 将只在父模板可用\n    'my-component': Child\n  }\n})\n~~~\n\n## 组件通信\n在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息\n\n### Prop\n~~~\nVue.component('child', {\n  // 声明 props\n  props: ['myMessage'],\n  // 就像 data 一样，prop 可以用在模板内\n  // 同样也可以在 vm 实例中像 “this.myMessage” 这样使用\n  template: '<span>{{ myMessage }}</span>'\n})\n\n<child my-message=\"hello!\"></child>   //传入属性值\n~~~\n* HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名\n* 每次父组件更新时，子组件的所有 prop 都会更新为最新值,不应该在子组件内部改变 prop,如果有改变的需要，可通过A.定义一个局部变量;B.定义一个计算属性\n\nProp验证\n~~~\nVue.component('example', {\n  props: {\n    // 基础类型检测 （`null` 意思是任何类型都可以）\n    propA: Number,\n    // 多种类型\n    propB: [String, Number],\n    // 必传且是字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 数字，有默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 数组／对象的默认值应当由一个工厂函数返回\n    propE: {\n      type: Object,\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        return value > 10\n      }\n    }\n  }\n})\n~~~\ntype 可以：String/Number/Boolean/Function/Object/Array\n\n### 自定义事件\n每个 Vue 实例都实现了事件接口(Events interface)，即：\n* 使用 $on(eventName) 监听事件\n* 使用 $emit(eventName) 触发事件\n~~~\n<div id=\"counter-event-example\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n~~~\n\n### 非父子组件通信\n~~~\nvar bus = new Vue()\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function (id) {\n  // ...\n})\n~~~\n\n## 使用Slot分发内容\n* 为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程被称为 内容分发\n* 使用特殊的 <slot> 元素作为原始内容的插槽\n* 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译\n~~~\n<!-- 无效,试图在父组件模板内将一个指令绑定到子组件的属性/方法 -->\n<child-component v-show=\"someChildProperty\"></child-component>\n~~~\n如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：\n~~~\nVue.component('child-component', {\n  // 有效，因为是在正确的作用域内\n  template: '<div v-show=\"someChildProperty\">Child</div>',\n  data: function () {\n    return {\n      someChildProperty: true\n    }\n  }\n})\n~~~","source":"_posts/前端开发/vue入门.md","raw":"---\ntitle: Vue入门\ntags:\n  - Vue \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n~~~\nhttps://cn.vuejs.org/\nhttps://vuejs.org/\nhttps://cn.vuejs.org/v2/api/\n~~~\n\n# 简介\n> Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的。是个人维护项目\n\n> Vue.js是数据驱动的，你无需手动操作DOM\n\n> 通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新\n\n> 使用Vue.js时，也可以结合其他库一起使用，比如jQuery\n\n使用Vue的过程就是定义MVVM各个组成部分的过程的过程\n1. 定义View\n~~~\n<div id=\"app\">\n    {{ message }}\n</div>\n~~~\n2. 定义Model，如： \n~~~\nvar exampleData = {\n    message: 'Hello World!'\n}\n~~~\n3. 创建一个Vue实例或\"ViewModel\"，它用于连接View和Model\n~~~\nnew Vue({\n    el: '#app',\n    data: exampleData\n})\n~~~\n\n# Vue实例\n## 构造器\n每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的：\n~~~\nvar vm = new Vue({\n  // 选项\n})\n~~~\n实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项,具体API查看：https://cn.vuejs.org/v2/api/\n\n## 属性和方法\n* 每个 Vue 实例都会代理其 data 对象里所有的属性\n* ==只有这些被代理的属性是响应的==\n* 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新\n* Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分\n\n\n## 实例生命周期\n每个 Vue 实例在被创建之前都要经过一系列的初始化过程\n\n![image](http://note.youdao.com/yws/api/personal/file/WEB57f1826aa9ca7087a82b38e583419433?method=download&shareKey=33f8412154b6172b3bf4b99f8bcf0a40)\n\n# Vue.js的常用指令\nVue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）\n\n* 用 key 管理可复用的元素:添加一个具有唯一值的 key 属性,来声明“这两个元素是完全独立的——不要复用它们”\n\nVue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：\n\n##  v-if指令\n条件渲染指令，它根据表达式的真假来删除和插入元素\n~~~\n<h1 v-if=\"age >= 25\">Age: {{ age }}</h1>\n~~~\n## v-show指令\n控制显示／隐藏，true／false\n* 和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性\n~~~\n<h1 v-show=\"age >= 25\">Age: {{ age }}</h1>\n~~~\n## v-else指令\n* 可以用v-else指令为v-if或v-show添加一个“else块”\n* v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别\n~~~\n<h1 v-show=\"name.indexOf('keep') >= 0\">Name: {{ name }}</h1>\n<h1 v-else>Sex: {{ sex }}</h1>\n~~~\n## v-for指令\n~~~\n<ul>\n    <li v-for=\"value in json\">\n        {{value}} {{$index}} {{$key}}\n    </li>\n     <li v-for=\"(k,v) in json\">\n        {{k}} {{v}} {{$index}} {{$key}}\n    </li>\n</ul>\n~~~\n## v-bind指令\n* 如果属性中要绑定Vue数据，最好用绑定的方式\n* v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute）\n~~~\n<img v-bind:src=\"{{url}} alt=\"\"/>\"//后台不会报错误，不绑定后台会报错，界面不影响\n~~~\n* class\n\n用法一：其值为数组形式，数组中的值为Vue的data中定义的属性，而vue中属性对应的值为真正的css样式\n~~~\n.astyle{ color:red}\n.bstyle{ background-color:bule}\n<script>\n    new Vue(){\n        data:{\n            a:\"astyle\",\n            b:\"bstyle\"\n        }\n    }\n</script>\n<div id=\"box\">\n    <strong :class=\"[a,b]\">测试文字</strong>\n</div>\n~~~\n方式二：其值为json格式，json的key为真正的css样式名称，value为true/false／data中的属性\n~~~\n<div id=\"box\">\n    <strong :class=\"{astyle:true,bstyle:a}\">测试文字</strong>\n</div>\n~~~\n方式三：class的值直接是data的一个json数据\n~~~\nnew Vue(){\n    data:{\n       jsonData:{\n            astyle:true,\n            bstyle:false\n       }\n    }\n}\n<div id=\"box\">\n    <strong :class=\"jsonData\">测试文字</strong>\n</div>\n~~~\n* style：复合样式采用的是驼峰命名法\n\n方法一：\n~~~\n<strong :style=\"color:red\">文字</strong>\n~~~\n方式二：\n~~~\nnew Vue(){\n    data:{\n        astyle:{color:'red'},\n        bstyle:{backgroudColor:'blue'}\n    }\n}\n<div id=\"box\">\n    <strong :style=\"[astyle,bstyle]]\">测试文字</strong>\n</div>\n~~~\n方式三：官方推荐\n~~~\nnew Vue(){\n    data:{\n        jsonData:{\n            color:'red',\n            backgroudColor:'blue'\n        }\n    }\n}\n<div id=\"box\">\n    <strong :style=\"jsonData\">测试文字</strong>\n</div>\n~~~\n## v-on指令\n用于监听DOM事件\n~~~\n<script>\nnew Vue(){\n    methods:{\n        show:function(){alert(124);}\n    }\n}\n</script>\n\n<input type=\"button\" value=\"弹框\" v-on:click=\"show()\"\n~~~\n\n==知识点==：v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号 \n\n## v-model\n表单元素的双向绑定，它会根据控件类型自动选取正确的方法来更新元素\n~~~\n<input v-model=\"message.trim\" placeholder=\"edit me\">\n<p>Message is: {{ message }}</p>\n~~~\n* .number:将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）,如：<input v-model.number=\"age\" type=\"number\">\n* .trim：自动过滤用户输入的首尾空格\n* .lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 ，但可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步\n\n\n# 事件\n## 事件修饰符\n~~~\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n~~~\n### 事件冒泡阻止\n1. 传递事件$event，ev.cancleBubble=true;\n2. @click.stop\n\n### 默认行为\n如网页中添加了右键事件后，系统还有默认右键事件\n1. 传递事件$event，ev.preventDefault();\n2. @contextmenu.prevent\n\n### 键盘事件\n1. 传递事件$event，ev.keyCode，判断后进行操作\n2. @keyup.键值，如：@keyup.13\n3. @keyup.键盘键面值，如：@keyup.enter\n\n## 按键修饰符\n~~~\n<input v-on:keyup.13=\"submit\">\n~~~\n全部的按键别名：\n~~~\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n~~~\n\n# 模版语法\nmsg类似为js变量,Mustache中可以进行JS编程，如申明变量，条件判断等\n~~~\n* 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：{{msg}} 数据更新模版变化\n* {{*msg}} 只绑定一次\n* {{{msg}}}  HTML转义，html语法会翻译\n~~~\n\n# 计算属性\n* 在模板中放入太多的逻辑会让模板过重且难以维护，应当考虑使用计算属性\n* 可以像绑定普通属性一样在模板中绑定计算属性\n* 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,==这也是计算属性和methods的区别，需依据具体情况使用==\n~~~\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n});\n~~~\n* 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter \n~~~\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n\n在运行 vm.fullName = 'John Doe' 时， setter 会被调用\n~~~\n\n# 过滤器\n> 过滤模版数据\n~~~\n{{msg|filterA 参数|filterB 参数|...}}\n~~~\n\n系统默认提供过滤器，如：\n~~~\n* {{'welcome'|uppercase}}\n* {{'welcome'|lowercase}}\n* {{'welcome'|capitalize}}\n* {{'welcome'|currency}}\n* {{'welcome'|currency \"$\"}}    //传参\n* {{ message | filterA('arg1', arg2) }}  //穿参\n~~~\n\n# 交互\nVue本身不支持Ajax框架，需引入官方库vue-resource,支持get、post、jsonp\n* get\n~~~\nmethods:{\n    getFun:function(){\n        this.$http.get(\"a.txt\").then(function(res){\n            console.log(res.data);\n        },function(res){\n            console.log(res.status);\n        });\n    },\n    //传递参数\n    get2Fun:function(){\n        this.$http.get(\"a.php\",{a:1,b:2}}).then(function(res){\n            console.log(res.data);\n        },function(res){\n            console.log(res.status);\n        });\n    }\n}\n~~~\n* post\n~~~\nmethods:{\n    postFun:function(){\n        this.$http.post(\"a.php\",{a:1,b:2},{emulateJSON:true}).then(function(res){\n            console.log(res.data);\n        },function(res){\n            console.log(res.status);\n        });\n    }\n}\n~~~\n* jsonp\n~~~\nmethods:{\n    postFun:function(){\n        this.$http.jsonp(\n            \"https://www.baidu....\",\n            {a:1},\n            {jsonp:''cb''}//callback 名字\n        )\n        .then(function(res){\n                console.log(res.data);\n            },function(res){\n                console.log(res.status);\n            }\n        );\n    }\n}\n~~~\n\n# 组件\n## 使用组件\n* 要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：\n~~~\nVue.component('my-component', {\n  // 选项\n})\n~~~\n* Vue.js建议自定义标签名：==小写，并且包含一个短杠==\n* 要确保在初始化根实例 之前 注册了组件\n* 局部注册\n~~~\nvar Child = {\n  template: '<div>A custom component!</div>'\n}\nnew Vue({\n  // ...\n  components: {\n    // <my-component> 将只在父模板可用\n    'my-component': Child\n  }\n})\n~~~\n\n## 组件通信\n在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息\n\n### Prop\n~~~\nVue.component('child', {\n  // 声明 props\n  props: ['myMessage'],\n  // 就像 data 一样，prop 可以用在模板内\n  // 同样也可以在 vm 实例中像 “this.myMessage” 这样使用\n  template: '<span>{{ myMessage }}</span>'\n})\n\n<child my-message=\"hello!\"></child>   //传入属性值\n~~~\n* HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名\n* 每次父组件更新时，子组件的所有 prop 都会更新为最新值,不应该在子组件内部改变 prop,如果有改变的需要，可通过A.定义一个局部变量;B.定义一个计算属性\n\nProp验证\n~~~\nVue.component('example', {\n  props: {\n    // 基础类型检测 （`null` 意思是任何类型都可以）\n    propA: Number,\n    // 多种类型\n    propB: [String, Number],\n    // 必传且是字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 数字，有默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 数组／对象的默认值应当由一个工厂函数返回\n    propE: {\n      type: Object,\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        return value > 10\n      }\n    }\n  }\n})\n~~~\ntype 可以：String/Number/Boolean/Function/Object/Array\n\n### 自定义事件\n每个 Vue 实例都实现了事件接口(Events interface)，即：\n* 使用 $on(eventName) 监听事件\n* 使用 $emit(eventName) 触发事件\n~~~\n<div id=\"counter-event-example\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n\nVue.component('button-counter', {\n  template: '<button v-on:click=\"increment\">{{ counter }}</button>',\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    increment: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  },\n})\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n~~~\n\n### 非父子组件通信\n~~~\nvar bus = new Vue()\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function (id) {\n  // ...\n})\n~~~\n\n## 使用Slot分发内容\n* 为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程被称为 内容分发\n* 使用特殊的 <slot> 元素作为原始内容的插槽\n* 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译\n~~~\n<!-- 无效,试图在父组件模板内将一个指令绑定到子组件的属性/方法 -->\n<child-component v-show=\"someChildProperty\"></child-component>\n~~~\n如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：\n~~~\nVue.component('child-component', {\n  // 有效，因为是在正确的作用域内\n  template: '<div v-show=\"someChildProperty\">Child</div>',\n  data: function () {\n    return {\n      someChildProperty: true\n    }\n  }\n})\n~~~","slug":"前端开发-vue入门","published":1,"updated":"2019-02-14T07:58:16.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3r00dy5b8h2j8h737s","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/</span><br><span class=\"line\">https://vuejs.org/</span><br><span class=\"line\">https://cn.vuejs.org/v2/api/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的。是个人维护项目</p>\n</blockquote>\n<blockquote>\n<p>Vue.js是数据驱动的，你无需手动操作DOM</p>\n</blockquote>\n<blockquote>\n<p>通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新</p>\n</blockquote>\n<blockquote>\n<p>使用Vue.js时，也可以结合其他库一起使用，比如jQuery</p>\n</blockquote>\n<p>使用Vue的过程就是定义MVVM各个组成部分的过程的过程</p>\n<ol>\n<li>定义View</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>定义Model，如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exampleData = &#123;</span><br><span class=\"line\">    message: &apos;Hello World!&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建一个Vue实例或&quot;ViewModel&quot;，它用于连接View和Model</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &apos;#app&apos;,</span><br><span class=\"line\">    data: exampleData</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue实例\"><a class=\"markdownIt-Anchor\" href=\"#vue实例\"></a> Vue实例</h1>\n<h2 id=\"构造器\"><a class=\"markdownIt-Anchor\" href=\"#构造器\"></a> 构造器</h2>\n<p>每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项,具体API查看：<a href=\"https://cn.vuejs.org/v2/api/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/api/</a></p>\n<h2 id=\"属性和方法\"><a class=\"markdownIt-Anchor\" href=\"#属性和方法\"></a> 属性和方法</h2>\n<ul>\n<li>每个 Vue 实例都会代理其 data 对象里所有的属性</li>\n<li>==只有这些被代理的属性是响应的==</li>\n<li>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新</li>\n<li>Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分</li>\n</ul>\n<h2 id=\"实例生命周期\"><a class=\"markdownIt-Anchor\" href=\"#实例生命周期\"></a> 实例生命周期</h2>\n<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB57f1826aa9ca7087a82b38e583419433?method=download&amp;shareKey=33f8412154b6172b3bf4b99f8bcf0a40\" alt=\"image\"></p>\n<h1 id=\"vuejs的常用指令\"><a class=\"markdownIt-Anchor\" href=\"#vuejs的常用指令\"></a> Vue.js的常用指令</h1>\n<p>Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）</p>\n<ul>\n<li>用 key 管理可复用的元素:添加一个具有唯一值的 key 属性,来声明“这两个元素是完全独立的——不要复用它们”</li>\n</ul>\n<p>Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：</p>\n<h2 id=\"v-if指令\"><a class=\"markdownIt-Anchor\" href=\"#v-if指令\"></a> v-if指令</h2>\n<p>条件渲染指令，它根据表达式的真假来删除和插入元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-show指令\"><a class=\"markdownIt-Anchor\" href=\"#v-show指令\"></a> v-show指令</h2>\n<p>控制显示／隐藏，true／false</p>\n<ul>\n<li>和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-else指令\"><a class=\"markdownIt-Anchor\" href=\"#v-else指令\"></a> v-else指令</h2>\n<ul>\n<li>可以用v-else指令为v-if或v-show添加一个“else块”</li>\n<li>v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-show=&quot;name.indexOf(&apos;keep&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">&lt;h1 v-else&gt;Sex: &#123;&#123; sex &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-for指令\"><a class=\"markdownIt-Anchor\" href=\"#v-for指令\"></a> v-for指令</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;value in json&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;value&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">     &lt;li v-for=&quot;(k,v) in json&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;k&#125;&#125; &#123;&#123;v&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-bind指令\"><a class=\"markdownIt-Anchor\" href=\"#v-bind指令\"></a> v-bind指令</h2>\n<ul>\n<li>如果属性中要绑定Vue数据，最好用绑定的方式</li>\n<li>v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img v-bind:src=&quot;&#123;&#123;url&#125;&#125; alt=&quot;&quot;/&gt;&quot;//后台不会报错误，不绑定后台会报错，界面不影响</span><br></pre></td></tr></table></figure>\n<ul>\n<li>class</li>\n</ul>\n<p>用法一：其值为数组形式，数组中的值为Vue的data中定义的属性，而vue中属性对应的值为真正的css样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.astyle&#123; color:red&#125;</span><br><span class=\"line\">.bstyle&#123; background-color:bule&#125;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue()&#123;</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            a:&quot;astyle&quot;,</span><br><span class=\"line\">            b:&quot;bstyle&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :class=&quot;[a,b]&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>方式二：其值为json格式，json的key为真正的css样式名称，value为true/false／data中的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :class=&quot;&#123;astyle:true,bstyle:a&#125;&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>方式三：class的值直接是data的一个json数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">       jsonData:&#123;</span><br><span class=\"line\">            astyle:true,</span><br><span class=\"line\">            bstyle:false</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :class=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>style：复合样式采用的是驼峰命名法</li>\n</ul>\n<p>方法一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;strong :style=&quot;color:red&quot;&gt;文字&lt;/strong&gt;</span><br></pre></td></tr></table></figure>\n<p>方式二：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">        astyle:&#123;color:&apos;red&apos;&#125;,</span><br><span class=\"line\">        bstyle:&#123;backgroudColor:&apos;blue&apos;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :style=&quot;[astyle,bstyle]]&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>方式三：官方推荐</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">        jsonData:&#123;</span><br><span class=\"line\">            color:&apos;red&apos;,</span><br><span class=\"line\">            backgroudColor:&apos;blue&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :style=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-on指令\"><a class=\"markdownIt-Anchor\" href=\"#v-on指令\"></a> v-on指令</h2>\n<p>用于监听DOM事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">        show:function()&#123;alert(124);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;弹框&quot; v-on:click=&quot;show()&quot;</span><br></pre></td></tr></table></figure>\n<p>==知识点==：v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号</p>\n<h2 id=\"v-model\"><a class=\"markdownIt-Anchor\" href=\"#v-model\"></a> v-model</h2>\n<p>表单元素的双向绑定，它会根据控件类型自动选取正确的方法来更新元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=&quot;message.trim&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class=\"line\">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>.number:将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）,如：<input v-model.number=\"age\" type=\"number\"></li>\n<li>.trim：自动过滤用户输入的首尾空格</li>\n<li>.lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 ，但可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步</li>\n</ul>\n<h1 id=\"事件\"><a class=\"markdownIt-Anchor\" href=\"#事件\"></a> 事件</h1>\n<h2 id=\"事件修饰符\"><a class=\"markdownIt-Anchor\" href=\"#事件修饰符\"></a> 事件修饰符</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件冒泡阻止\"><a class=\"markdownIt-Anchor\" href=\"#事件冒泡阻止\"></a> 事件冒泡阻止</h3>\n<ol>\n<li>传递事件$event，ev.cancleBubble=true;</li>\n<li>@click.stop</li>\n</ol>\n<h3 id=\"默认行为\"><a class=\"markdownIt-Anchor\" href=\"#默认行为\"></a> 默认行为</h3>\n<p>如网页中添加了右键事件后，系统还有默认右键事件</p>\n<ol>\n<li>传递事件$event，ev.preventDefault();</li>\n<li>@contextmenu.prevent</li>\n</ol>\n<h3 id=\"键盘事件\"><a class=\"markdownIt-Anchor\" href=\"#键盘事件\"></a> 键盘事件</h3>\n<ol>\n<li>传递事件$event，ev.keyCode，判断后进行操作</li>\n<li>@keyup.键值，如：@keyup.13</li>\n<li>@keyup.键盘键面值，如：@keyup.enter</li>\n</ol>\n<h2 id=\"按键修饰符\"><a class=\"markdownIt-Anchor\" href=\"#按键修饰符\"></a> 按键修饰符</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>全部的按键别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h1 id=\"模版语法\"><a class=\"markdownIt-Anchor\" href=\"#模版语法\"></a> 模版语法</h1>\n<p>msg类似为js变量,Mustache中可以进行JS编程，如申明变量，条件判断等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：&#123;&#123;msg&#125;&#125; 数据更新模版变化</span><br><span class=\"line\">* &#123;&#123;*msg&#125;&#125; 只绑定一次</span><br><span class=\"line\">* &#123;&#123;&#123;msg&#125;&#125;&#125;  HTML转义，html语法会翻译</span><br></pre></td></tr></table></figure>\n<h1 id=\"计算属性\"><a class=\"markdownIt-Anchor\" href=\"#计算属性\"></a> 计算属性</h1>\n<ul>\n<li>在模板中放入太多的逻辑会让模板过重且难以维护，应当考虑使用计算属性</li>\n<li>可以像绑定普通属性一样在模板中绑定计算属性</li>\n<li>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,==这也是计算属性和methods的区别，需依据具体情况使用==</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // a computed getter</span><br><span class=\"line\">    reversedMessage: function () &#123;</span><br><span class=\"line\">      // `this` points to the vm instance</span><br><span class=\"line\">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  fullName: &#123;</span><br><span class=\"line\">    // getter</span><br><span class=\"line\">    get: function () &#123;</span><br><span class=\"line\">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // setter</span><br><span class=\"line\">    set: function (newValue) &#123;</span><br><span class=\"line\">      var names = newValue.split(&apos; &apos;)</span><br><span class=\"line\">      this.firstName = names[0]</span><br><span class=\"line\">      this.lastName = names[names.length - 1]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">在运行 vm.fullName = &apos;John Doe&apos; 时， setter 会被调用</span><br></pre></td></tr></table></figure>\n<h1 id=\"过滤器\"><a class=\"markdownIt-Anchor\" href=\"#过滤器\"></a> 过滤器</h1>\n<blockquote>\n<p>过滤模版数据</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg|filterA 参数|filterB 参数|...&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>系统默认提供过滤器，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|uppercase&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|lowercase&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|capitalize&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|currency&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|currency &quot;$&quot;&#125;&#125;    //传参</span><br><span class=\"line\">* &#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;  //穿参</span><br></pre></td></tr></table></figure>\n<h1 id=\"交互\"><a class=\"markdownIt-Anchor\" href=\"#交互\"></a> 交互</h1>\n<p>Vue本身不支持Ajax框架，需引入官方库vue-resource,支持get、post、jsonp</p>\n<ul>\n<li>get</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    getFun:function()&#123;</span><br><span class=\"line\">        this.$http.get(&quot;a.txt&quot;).then(function(res)&#123;</span><br><span class=\"line\">            console.log(res.data);</span><br><span class=\"line\">        &#125;,function(res)&#123;</span><br><span class=\"line\">            console.log(res.status);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //传递参数</span><br><span class=\"line\">    get2Fun:function()&#123;</span><br><span class=\"line\">        this.$http.get(&quot;a.php&quot;,&#123;a:1,b:2&#125;&#125;).then(function(res)&#123;</span><br><span class=\"line\">            console.log(res.data);</span><br><span class=\"line\">        &#125;,function(res)&#123;</span><br><span class=\"line\">            console.log(res.status);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>post</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    postFun:function()&#123;</span><br><span class=\"line\">        this.$http.post(&quot;a.php&quot;,&#123;a:1,b:2&#125;,&#123;emulateJSON:true&#125;).then(function(res)&#123;</span><br><span class=\"line\">            console.log(res.data);</span><br><span class=\"line\">        &#125;,function(res)&#123;</span><br><span class=\"line\">            console.log(res.status);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jsonp</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    postFun:function()&#123;</span><br><span class=\"line\">        this.$http.jsonp(</span><br><span class=\"line\">            &quot;https://www.baidu....&quot;,</span><br><span class=\"line\">            &#123;a:1&#125;,</span><br><span class=\"line\">            &#123;jsonp:&apos;&apos;cb&apos;&apos;&#125;//callback 名字</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .then(function(res)&#123;</span><br><span class=\"line\">                console.log(res.data);</span><br><span class=\"line\">            &#125;,function(res)&#123;</span><br><span class=\"line\">                console.log(res.status);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"组件\"><a class=\"markdownIt-Anchor\" href=\"#组件\"></a> 组件</h1>\n<h2 id=\"使用组件\"><a class=\"markdownIt-Anchor\" href=\"#使用组件\"></a> 使用组件</h2>\n<ul>\n<li>要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Vue.js建议自定义标签名：==小写，并且包含一个短杠==</li>\n<li>要确保在初始化根实例 之前 注册了组件</li>\n<li>局部注册</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Child = &#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    // &lt;my-component&gt; 将只在父模板可用</span><br><span class=\"line\">    &apos;my-component&apos;: Child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件通信\"><a class=\"markdownIt-Anchor\" href=\"#组件通信\"></a> 组件通信</h2>\n<p>在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息</p>\n<h3 id=\"prop\"><a class=\"markdownIt-Anchor\" href=\"#prop\"></a> Prop</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;child&apos;, &#123;</span><br><span class=\"line\">  // 声明 props</span><br><span class=\"line\">  props: [&apos;myMessage&apos;],</span><br><span class=\"line\">  // 就像 data 一样，prop 可以用在模板内</span><br><span class=\"line\">  // 同样也可以在 vm 实例中像 “this.myMessage” 这样使用</span><br><span class=\"line\">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;   //传入属性值</span><br></pre></td></tr></table></figure>\n<ul>\n<li>HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名</li>\n<li>每次父组件更新时，子组件的所有 prop 都会更新为最新值,不应该在子组件内部改变 prop,如果有改变的需要，可通过A.定义一个局部变量;B.定义一个计算属性</li>\n</ul>\n<p>Prop验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;example&apos;, &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    // 基础类型检测 （`null` 意思是任何类型都可以）</span><br><span class=\"line\">    propA: Number,</span><br><span class=\"line\">    // 多种类型</span><br><span class=\"line\">    propB: [String, Number],</span><br><span class=\"line\">    // 必传且是字符串</span><br><span class=\"line\">    propC: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 数字，有默认值</span><br><span class=\"line\">    propD: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 100</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 数组／对象的默认值应当由一个工厂函数返回</span><br><span class=\"line\">    propE: &#123;</span><br><span class=\"line\">      type: Object,</span><br><span class=\"line\">      default: function () &#123;</span><br><span class=\"line\">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 自定义验证函数</span><br><span class=\"line\">    propF: &#123;</span><br><span class=\"line\">      validator: function (value) &#123;</span><br><span class=\"line\">        return value &gt; 10</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>type 可以：String/Number/Boolean/Function/Object/Array</p>\n<h3 id=\"自定义事件\"><a class=\"markdownIt-Anchor\" href=\"#自定义事件\"></a> 自定义事件</h3>\n<p>每个 Vue 实例都实现了事件接口(Events interface)，即：</p>\n<ul>\n<li>使用 $on(eventName) 监听事件</li>\n<li>使用 $emit(eventName) 触发事件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;counter-event-example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class=\"line\">  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      counter: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment: function () &#123;</span><br><span class=\"line\">      this.counter += 1</span><br><span class=\"line\">      this.$emit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#counter-event-example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    total: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    incrementTotal: function () &#123;</span><br><span class=\"line\">      this.total += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"非父子组件通信\"><a class=\"markdownIt-Anchor\" href=\"#非父子组件通信\"></a> 非父子组件通信</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bus = new Vue()</span><br><span class=\"line\">// 触发组件 A 中的事件</span><br><span class=\"line\">bus.$emit(&apos;id-selected&apos;, 1)</span><br><span class=\"line\">// 在组件 B 创建的钩子中监听事件</span><br><span class=\"line\">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用slot分发内容\"><a class=\"markdownIt-Anchor\" href=\"#使用slot分发内容\"></a> 使用Slot分发内容</h2>\n<ul>\n<li>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程被称为 内容分发</li>\n<li>使用特殊的 <slot> 元素作为原始内容的插槽</slot></li>\n<li>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 无效,试图在父组件模板内将一个指令绑定到子组件的属性/方法 --&gt;</span><br><span class=\"line\">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>\n<p>如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;child-component&apos;, &#123;</span><br><span class=\"line\">  // 有效，因为是在正确的作用域内</span><br><span class=\"line\">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      someChildProperty: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/</span><br><span class=\"line\">https://vuejs.org/</span><br><span class=\"line\">https://cn.vuejs.org/v2/api/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<blockquote>\n<p>Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的。是个人维护项目</p>\n</blockquote>\n<blockquote>\n<p>Vue.js是数据驱动的，你无需手动操作DOM</p>\n</blockquote>\n<blockquote>\n<p>通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新</p>\n</blockquote>\n<blockquote>\n<p>使用Vue.js时，也可以结合其他库一起使用，比如jQuery</p>\n</blockquote>\n<p>使用Vue的过程就是定义MVVM各个组成部分的过程的过程</p>\n<ol>\n<li>定义View</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>定义Model，如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exampleData = &#123;</span><br><span class=\"line\">    message: &apos;Hello World!&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>创建一个Vue实例或&quot;ViewModel&quot;，它用于连接View和Model</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &apos;#app&apos;,</span><br><span class=\"line\">    data: exampleData</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue实例\"><a class=\"markdownIt-Anchor\" href=\"#vue实例\"></a> Vue实例</h1>\n<h2 id=\"构造器\"><a class=\"markdownIt-Anchor\" href=\"#构造器\"></a> 构造器</h2>\n<p>每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项,具体API查看：<a href=\"https://cn.vuejs.org/v2/api/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/api/</a></p>\n<h2 id=\"属性和方法\"><a class=\"markdownIt-Anchor\" href=\"#属性和方法\"></a> 属性和方法</h2>\n<ul>\n<li>每个 Vue 实例都会代理其 data 对象里所有的属性</li>\n<li>==只有这些被代理的属性是响应的==</li>\n<li>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新</li>\n<li>Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分</li>\n</ul>\n<h2 id=\"实例生命周期\"><a class=\"markdownIt-Anchor\" href=\"#实例生命周期\"></a> 实例生命周期</h2>\n<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB57f1826aa9ca7087a82b38e583419433?method=download&amp;shareKey=33f8412154b6172b3bf4b99f8bcf0a40\" alt=\"image\"></p>\n<h1 id=\"vuejs的常用指令\"><a class=\"markdownIt-Anchor\" href=\"#vuejs的常用指令\"></a> Vue.js的常用指令</h1>\n<p>Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）</p>\n<ul>\n<li>用 key 管理可复用的元素:添加一个具有唯一值的 key 属性,来声明“这两个元素是完全独立的——不要复用它们”</li>\n</ul>\n<p>Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：</p>\n<h2 id=\"v-if指令\"><a class=\"markdownIt-Anchor\" href=\"#v-if指令\"></a> v-if指令</h2>\n<p>条件渲染指令，它根据表达式的真假来删除和插入元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-show指令\"><a class=\"markdownIt-Anchor\" href=\"#v-show指令\"></a> v-show指令</h2>\n<p>控制显示／隐藏，true／false</p>\n<ul>\n<li>和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-else指令\"><a class=\"markdownIt-Anchor\" href=\"#v-else指令\"></a> v-else指令</h2>\n<ul>\n<li>可以用v-else指令为v-if或v-show添加一个“else块”</li>\n<li>v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 v-show=&quot;name.indexOf(&apos;keep&apos;) &gt;= 0&quot;&gt;Name: &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">&lt;h1 v-else&gt;Sex: &#123;&#123; sex &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-for指令\"><a class=\"markdownIt-Anchor\" href=\"#v-for指令\"></a> v-for指令</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;value in json&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;value&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">     &lt;li v-for=&quot;(k,v) in json&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;k&#125;&#125; &#123;&#123;v&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-bind指令\"><a class=\"markdownIt-Anchor\" href=\"#v-bind指令\"></a> v-bind指令</h2>\n<ul>\n<li>如果属性中要绑定Vue数据，最好用绑定的方式</li>\n<li>v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img v-bind:src=&quot;&#123;&#123;url&#125;&#125; alt=&quot;&quot;/&gt;&quot;//后台不会报错误，不绑定后台会报错，界面不影响</span><br></pre></td></tr></table></figure>\n<ul>\n<li>class</li>\n</ul>\n<p>用法一：其值为数组形式，数组中的值为Vue的data中定义的属性，而vue中属性对应的值为真正的css样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.astyle&#123; color:red&#125;</span><br><span class=\"line\">.bstyle&#123; background-color:bule&#125;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue()&#123;</span><br><span class=\"line\">        data:&#123;</span><br><span class=\"line\">            a:&quot;astyle&quot;,</span><br><span class=\"line\">            b:&quot;bstyle&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :class=&quot;[a,b]&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>方式二：其值为json格式，json的key为真正的css样式名称，value为true/false／data中的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :class=&quot;&#123;astyle:true,bstyle:a&#125;&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>方式三：class的值直接是data的一个json数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">       jsonData:&#123;</span><br><span class=\"line\">            astyle:true,</span><br><span class=\"line\">            bstyle:false</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :class=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>style：复合样式采用的是驼峰命名法</li>\n</ul>\n<p>方法一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;strong :style=&quot;color:red&quot;&gt;文字&lt;/strong&gt;</span><br></pre></td></tr></table></figure>\n<p>方式二：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">        astyle:&#123;color:&apos;red&apos;&#125;,</span><br><span class=\"line\">        bstyle:&#123;backgroudColor:&apos;blue&apos;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :style=&quot;[astyle,bstyle]]&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>方式三：官方推荐</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">        jsonData:&#123;</span><br><span class=\"line\">            color:&apos;red&apos;,</span><br><span class=\"line\">            backgroudColor:&apos;blue&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;</span><br><span class=\"line\">    &lt;strong :style=&quot;jsonData&quot;&gt;测试文字&lt;/strong&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"v-on指令\"><a class=\"markdownIt-Anchor\" href=\"#v-on指令\"></a> v-on指令</h2>\n<p>用于监听DOM事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">new Vue()&#123;</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">        show:function()&#123;alert(124);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;弹框&quot; v-on:click=&quot;show()&quot;</span><br></pre></td></tr></table></figure>\n<p>==知识点==：v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号</p>\n<h2 id=\"v-model\"><a class=\"markdownIt-Anchor\" href=\"#v-model\"></a> v-model</h2>\n<p>表单元素的双向绑定，它会根据控件类型自动选取正确的方法来更新元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=&quot;message.trim&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class=\"line\">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>.number:将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）,如：<input v-model.number=\"age\" type=\"number\"></li>\n<li>.trim：自动过滤用户输入的首尾空格</li>\n<li>.lazy：在默认情况下， v-model 在 input 事件中同步输入框的值与数据 ，但可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步</li>\n</ul>\n<h1 id=\"事件\"><a class=\"markdownIt-Anchor\" href=\"#事件\"></a> 事件</h1>\n<h2 id=\"事件修饰符\"><a class=\"markdownIt-Anchor\" href=\"#事件修饰符\"></a> 事件修饰符</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件冒泡阻止\"><a class=\"markdownIt-Anchor\" href=\"#事件冒泡阻止\"></a> 事件冒泡阻止</h3>\n<ol>\n<li>传递事件$event，ev.cancleBubble=true;</li>\n<li>@click.stop</li>\n</ol>\n<h3 id=\"默认行为\"><a class=\"markdownIt-Anchor\" href=\"#默认行为\"></a> 默认行为</h3>\n<p>如网页中添加了右键事件后，系统还有默认右键事件</p>\n<ol>\n<li>传递事件$event，ev.preventDefault();</li>\n<li>@contextmenu.prevent</li>\n</ol>\n<h3 id=\"键盘事件\"><a class=\"markdownIt-Anchor\" href=\"#键盘事件\"></a> 键盘事件</h3>\n<ol>\n<li>传递事件$event，ev.keyCode，判断后进行操作</li>\n<li>@keyup.键值，如：@keyup.13</li>\n<li>@keyup.键盘键面值，如：@keyup.enter</li>\n</ol>\n<h2 id=\"按键修饰符\"><a class=\"markdownIt-Anchor\" href=\"#按键修饰符\"></a> 按键修饰符</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>全部的按键别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h1 id=\"模版语法\"><a class=\"markdownIt-Anchor\" href=\"#模版语法\"></a> 模版语法</h1>\n<p>msg类似为js变量,Mustache中可以进行JS编程，如申明变量，条件判断等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：&#123;&#123;msg&#125;&#125; 数据更新模版变化</span><br><span class=\"line\">* &#123;&#123;*msg&#125;&#125; 只绑定一次</span><br><span class=\"line\">* &#123;&#123;&#123;msg&#125;&#125;&#125;  HTML转义，html语法会翻译</span><br></pre></td></tr></table></figure>\n<h1 id=\"计算属性\"><a class=\"markdownIt-Anchor\" href=\"#计算属性\"></a> 计算属性</h1>\n<ul>\n<li>在模板中放入太多的逻辑会让模板过重且难以维护，应当考虑使用计算属性</li>\n<li>可以像绑定普通属性一样在模板中绑定计算属性</li>\n<li>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,==这也是计算属性和methods的区别，需依据具体情况使用==</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // a computed getter</span><br><span class=\"line\">    reversedMessage: function () &#123;</span><br><span class=\"line\">      // `this` points to the vm instance</span><br><span class=\"line\">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  fullName: &#123;</span><br><span class=\"line\">    // getter</span><br><span class=\"line\">    get: function () &#123;</span><br><span class=\"line\">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // setter</span><br><span class=\"line\">    set: function (newValue) &#123;</span><br><span class=\"line\">      var names = newValue.split(&apos; &apos;)</span><br><span class=\"line\">      this.firstName = names[0]</span><br><span class=\"line\">      this.lastName = names[names.length - 1]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">在运行 vm.fullName = &apos;John Doe&apos; 时， setter 会被调用</span><br></pre></td></tr></table></figure>\n<h1 id=\"过滤器\"><a class=\"markdownIt-Anchor\" href=\"#过滤器\"></a> 过滤器</h1>\n<blockquote>\n<p>过滤模版数据</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg|filterA 参数|filterB 参数|...&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>系统默认提供过滤器，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|uppercase&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|lowercase&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|capitalize&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|currency&#125;&#125;</span><br><span class=\"line\">* &#123;&#123;&apos;welcome&apos;|currency &quot;$&quot;&#125;&#125;    //传参</span><br><span class=\"line\">* &#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;  //穿参</span><br></pre></td></tr></table></figure>\n<h1 id=\"交互\"><a class=\"markdownIt-Anchor\" href=\"#交互\"></a> 交互</h1>\n<p>Vue本身不支持Ajax框架，需引入官方库vue-resource,支持get、post、jsonp</p>\n<ul>\n<li>get</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    getFun:function()&#123;</span><br><span class=\"line\">        this.$http.get(&quot;a.txt&quot;).then(function(res)&#123;</span><br><span class=\"line\">            console.log(res.data);</span><br><span class=\"line\">        &#125;,function(res)&#123;</span><br><span class=\"line\">            console.log(res.status);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //传递参数</span><br><span class=\"line\">    get2Fun:function()&#123;</span><br><span class=\"line\">        this.$http.get(&quot;a.php&quot;,&#123;a:1,b:2&#125;&#125;).then(function(res)&#123;</span><br><span class=\"line\">            console.log(res.data);</span><br><span class=\"line\">        &#125;,function(res)&#123;</span><br><span class=\"line\">            console.log(res.status);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>post</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    postFun:function()&#123;</span><br><span class=\"line\">        this.$http.post(&quot;a.php&quot;,&#123;a:1,b:2&#125;,&#123;emulateJSON:true&#125;).then(function(res)&#123;</span><br><span class=\"line\">            console.log(res.data);</span><br><span class=\"line\">        &#125;,function(res)&#123;</span><br><span class=\"line\">            console.log(res.status);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jsonp</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    postFun:function()&#123;</span><br><span class=\"line\">        this.$http.jsonp(</span><br><span class=\"line\">            &quot;https://www.baidu....&quot;,</span><br><span class=\"line\">            &#123;a:1&#125;,</span><br><span class=\"line\">            &#123;jsonp:&apos;&apos;cb&apos;&apos;&#125;//callback 名字</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .then(function(res)&#123;</span><br><span class=\"line\">                console.log(res.data);</span><br><span class=\"line\">            &#125;,function(res)&#123;</span><br><span class=\"line\">                console.log(res.status);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"组件\"><a class=\"markdownIt-Anchor\" href=\"#组件\"></a> 组件</h1>\n<h2 id=\"使用组件\"><a class=\"markdownIt-Anchor\" href=\"#使用组件\"></a> 使用组件</h2>\n<ul>\n<li>要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Vue.js建议自定义标签名：==小写，并且包含一个短杠==</li>\n<li>要确保在初始化根实例 之前 注册了组件</li>\n<li>局部注册</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Child = &#123;</span><br><span class=\"line\">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    // &lt;my-component&gt; 将只在父模板可用</span><br><span class=\"line\">    &apos;my-component&apos;: Child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件通信\"><a class=\"markdownIt-Anchor\" href=\"#组件通信\"></a> 组件通信</h2>\n<p>在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息</p>\n<h3 id=\"prop\"><a class=\"markdownIt-Anchor\" href=\"#prop\"></a> Prop</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;child&apos;, &#123;</span><br><span class=\"line\">  // 声明 props</span><br><span class=\"line\">  props: [&apos;myMessage&apos;],</span><br><span class=\"line\">  // 就像 data 一样，prop 可以用在模板内</span><br><span class=\"line\">  // 同样也可以在 vm 实例中像 “this.myMessage” 这样使用</span><br><span class=\"line\">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;   //传入属性值</span><br></pre></td></tr></table></figure>\n<ul>\n<li>HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名</li>\n<li>每次父组件更新时，子组件的所有 prop 都会更新为最新值,不应该在子组件内部改变 prop,如果有改变的需要，可通过A.定义一个局部变量;B.定义一个计算属性</li>\n</ul>\n<p>Prop验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;example&apos;, &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    // 基础类型检测 （`null` 意思是任何类型都可以）</span><br><span class=\"line\">    propA: Number,</span><br><span class=\"line\">    // 多种类型</span><br><span class=\"line\">    propB: [String, Number],</span><br><span class=\"line\">    // 必传且是字符串</span><br><span class=\"line\">    propC: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 数字，有默认值</span><br><span class=\"line\">    propD: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 100</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 数组／对象的默认值应当由一个工厂函数返回</span><br><span class=\"line\">    propE: &#123;</span><br><span class=\"line\">      type: Object,</span><br><span class=\"line\">      default: function () &#123;</span><br><span class=\"line\">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 自定义验证函数</span><br><span class=\"line\">    propF: &#123;</span><br><span class=\"line\">      validator: function (value) &#123;</span><br><span class=\"line\">        return value &gt; 10</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>type 可以：String/Number/Boolean/Function/Object/Array</p>\n<h3 id=\"自定义事件\"><a class=\"markdownIt-Anchor\" href=\"#自定义事件\"></a> 自定义事件</h3>\n<p>每个 Vue 实例都实现了事件接口(Events interface)，即：</p>\n<ul>\n<li>使用 $on(eventName) 监听事件</li>\n<li>使用 $emit(eventName) 触发事件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;counter-event-example&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class=\"line\">  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      counter: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment: function () &#123;</span><br><span class=\"line\">      this.counter += 1</span><br><span class=\"line\">      this.$emit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#counter-event-example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    total: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    incrementTotal: function () &#123;</span><br><span class=\"line\">      this.total += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"非父子组件通信\"><a class=\"markdownIt-Anchor\" href=\"#非父子组件通信\"></a> 非父子组件通信</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bus = new Vue()</span><br><span class=\"line\">// 触发组件 A 中的事件</span><br><span class=\"line\">bus.$emit(&apos;id-selected&apos;, 1)</span><br><span class=\"line\">// 在组件 B 创建的钩子中监听事件</span><br><span class=\"line\">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用slot分发内容\"><a class=\"markdownIt-Anchor\" href=\"#使用slot分发内容\"></a> 使用Slot分发内容</h2>\n<ul>\n<li>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程被称为 内容分发</li>\n<li>使用特殊的 <slot> 元素作为原始内容的插槽</slot></li>\n<li>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 无效,试图在父组件模板内将一个指令绑定到子组件的属性/方法 --&gt;</span><br><span class=\"line\">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</span><br></pre></td></tr></table></figure>\n<p>如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;child-component&apos;, &#123;</span><br><span class=\"line\">  // 有效，因为是在正确的作用域内</span><br><span class=\"line\">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      someChildProperty: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"webpack入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-26T08:04:30.000Z","password":null,"_content":"\n[toc]\n\n~~~\nhttp://webpack.org/\nhttps://github.com/webpack-china/webpack.js.org\nhttp://www.css88.com/doc/webpack2/\n~~~\n\n# 简介\n![image](http://note.youdao.com/yws/api/personal/file/WEB7518457dae5c37c455088010c54f1e6c?method=download&shareKey=13db111168a449f1c1833f09e42da606)\nWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。\n\n前身叫browserify，缺点为只能转换js\n\n# 概念\n## 入口(Entry)\n* webpack 将创建所有应用程序的依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point)\n* 入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么\n* 可以将应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件\n\n## 出口(Output)\n* 将所有的资源(assets)归拢在一起后，我们还需要告诉 webpack 在哪里打包我们的应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)\n* 即使可以存在多个入口起点，但只指定一个输出配置\n* 更多配置：http://www.css88.com/doc/webpack2/concepts/output/\n\n## 加载器(Loader)\n* webpack 的目标是，让 webpack 聚焦于项目中的所有资源(asset)，而浏览器不需要关注考虑这些（这并不意味着资源(asset)都必须打包在一起）。webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。而且 webpack 只理解 JavaScript\n* webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中\n* 在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules\n* webparck默认加载的是js，如果要加载如css，需要额外loader\n1. npm install style-loader css-loader -D\n2. 在webpack中，多个loader加载通过！连接，后面的“-loader可以省略”，如：require(\"style!css!./mystyle.css\")\n\n## 插件(Plugins)\n想要使用一个插件，\n1. 需要 require() 它，\n2. 它添加到 plugins 数组中\n3. 多数插件可以通过选项(option)自定义\n4. 由于需要在一个配置中，多次使用一个插件，来针对不同的目的，因此你需要使用 new 来创建插件的实例，并且通过实例来调用插件\n\nwebpack 插件是一个具有 apply 属性的 JavaScript 对象。 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个 compilation 生命周期访问\n\nwebpack.config.js示例：\n~~~\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\nconst webpack = require('webpack'); //to access built-in plugins\nconst path = require('path');\n\nconst config = {\n  entry: './path/to/my/entry/file.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'my-first-webpack.bundle.js'\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, use: 'babel-loader'}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: './src/index.html'})\n  ]\n};\n\nmodule.exports = config;\n~~~\n\n# webpack安装及起步\n## 安装\n* cnpm install webpack-cli -g//webpack的cli环境\n* cnpm install webpack-dev-server //webpack的自带服务器\n\n运行：\n1. 开发环境：webpack\n2. 生产环境：webpack -p //会压缩\n3. 监听模式：webpack -w //自动编译\n4. 开启sourcemaps：webpack -d //方便调试\n\n## 起步\n~~~\nmkdir webpack-demo && cd webpack-demo\nnpm init -y\nnpm install --save-dev webpack\n~~~\n\n创建并编辑app/index.js\n~~~ \nimport _ from 'lodash';\n\nfunction component () {\n  var element = document.createElement('div');\n\n  /* 需要引入 lodash，下一行才能正常工作 */\n  element.innerHTML = _.join(['Hello','webpack'], ' ');\n\n  return element;\n}\n\ndocument.body.appendChild(component());\n~~~\n~~~\nnpm install --save lodash\n~~~\n~~~\n<html>\n  <head>\n    <title>webpack 2 demo</title> \n  </head>\n  <body> \n       <script src=\"dist/bundle.js\"></script>\n  </body>\n</html>\n~~~\n~~~\nwebpack\n查看浏览器index.html页面内容：Hello webpack\n~~~\n\n#代码拆分\n分离资源，实现缓存资源和并行加载资源:\n* 一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改\n* 如果我们将这些库(library)中的代码，保留到与应用程序代码相独立的 bundle 上，我们就可以利用浏览器缓存机制，把这些文件长时间的缓存到用户的机器上\n\n## CSS分割\n要通过webpack打包CSS，像任何其他模块一样将CSS导入JavaScript代码，并使用css-loader（它输出CSS作为JS模块），并可选地应用ExtractTextWebpackPlugin（它提取打包的CSS并输出CSS文件\n\n1. 导入 CSS\n* import 'bootstrap/dist/css/bootstrap.css';\n2. 使用 css-loader:webpack.config.js中配置 css-loader\n~~~\nmodule.exports = {\n    module: {\n        rules: [{\n            test: /\\.css$/,\n            use: 'css-loader'\n        }]\n    }\n}\n~~~\n3. 使用 ExtractTextWebpackPlugin\n* npm install --save-dev extract-text-webpack-plugin\n4. webpack.config.js中添加插件配置\n~~~\nmodule.exports = {\n    module: {\n         rules: [{\n             test: /\\.css$/,\n-            use: 'css-loader'\n+            use: ExtractTextPlugin.extract({\n+                use: 'css-loader'\n+            })\n         }]\n     },\n+    plugins: [\n+        new ExtractTextPlugin('styles.css'),\n+    ]\n} \n~~~\n\n## Libraries分割\n默认会将库文件打包，可通过为库，如moment 添加一个单独的入口点并将其命名为 vendor 来缓解这一情况\n~~~\nvar path = require('path');\n\nmodule.exports = function(env) {\n    return {\n        entry: {\n            main: './index.js',\n            vendor: 'moment'\n        },\n        output: {\n            filename: '[chunkhash].[name].js',\n            path: path.resolve(__dirname, 'dist')\n        }\n    }\n}\n~~~\n运行webpakc生成了两个 bundle，都包含lodash，所以还需要插件\n* CommonsChunkPlugin：它从根本上允许我们从不同的 bundle 中提取所有的公共模块，并且将他们加入公共 bundle 中。如果公共 bundle 不存在，那么它将会创建一个出来\n~~~\nvar webpack = require('webpack');\nvar path = require('path');\n\nmodule.exports = function(env) {\n    return {\n        entry: {\n            main: './index.js',\n            vendor: 'moment'\n        },\n        output: {\n            filename: '[chunkhash].[name].js',\n            path: path.resolve(__dirname, 'dist')\n        },\n        plugins: [\n            new webpack.optimize.CommonsChunkPlugin({\n                name: 'vendor' // 指定公共 bundle 的名字。\n            })\n        ]\n    }\n}\n~~~\n以上完成之后，每次运行的vendor文件的hash码会改变，需在plugins配置如下：\n~~~\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n        names: ['vendor', 'manifest'] // 指定公共 bundle 的名字\n    })\n]\n~~~\n将运行时代码提取到一个单独的 manifest 文件中就解决了\n\n## 生产环境构建\n1. 自动方式\n* 运行webpack -p (也可以运行 webpack --optimize-minimize --define process.env.NODE_ENV=\"'production'\", 他们是等效的). 它会执行如下步骤:\n- - 使用UglifyJsPlugin进行 JS文件压缩\n- - 运行LoaderOptionsPlugin\n- - 设置Node环境变量\n2. 手动方式: 为多环境配置Webpack\n编写一个基本配置文件,把所有公用的功能放在里面。再编写特定环境的文件,使用'webpack-merge'来合并他们\n\nbase.js\n~~~\nmodule.exports = function() {\n    return {\n        entry: { \n            'vendor': './src/vendor.ts',\n            'main': './src/main.ts'\n\n        },\n        output: {\n            path: path.join(__dirname, '/../dist/assets'),\n            filename: '[name].bundle.js',\n            publicPath: publicPath,\n            sourceMapFilename: '[name].map'\n        },\n        resolve: {\n            extensions: ['', '.js', '.json'],\n            modules: [path.join(__dirname, 'src'), 'node_modules']\n\n        },\n        module: {\n            loaders: [{\n                test: /\\.css$/,\n                loaders: ['to-string-loader', 'css-loader']\n            }, {\n                test: /\\.(jpg|png|gif)$/,\n                loader: 'file-loader'\n            }, {\n                test: /\\.(woff|woff2|eot|ttf|svg)$/,\n                loader: 'url-loader?limit=100000'\n            }],\n        },\n        plugins: [\n            new ForkCheckerPlugin(),\n\n            new webpack.optimize.CommonsChunkPlugin({\n                name: ['polyfills', 'vendor'].reverse()\n            }),\n            new HtmlWebpackPlugin({\n                template: 'src/index.html',\n                chunksSortMode: 'dependency'\n            })\n        ],\n    };\n}\n~~~\n使用'webpack-merge'合并这个基础配置和针对环境的特定的配置\n\nprod.js (updated)\n~~~\nconst webpackMerge = require('webpack-merge');\n\nconst commonConfig = require('./base.js');\n\nmodule.exports = function(env) {\n    return webpackMerge(commonConfig(), {\n        plugins: [\n            new webpack.LoaderOptionsPlugin({\n                minimize: true,\n                debug: false\n            }),\n            new webpack.DefinePlugin({\n                'process.env': {\n                    'NODE_ENV': JSON.stringify('prod')\n                }\n            }),\n            new webpack.optimize.UglifyJsPlugin({\n                beautify: false,\n                mangle: {\n                    screw_ie8: true,\n                    keep_fnames: true\n                },\n                compress: {\n                    screw_ie8: true\n                },\n                comments: false\n            })\n        ]\n    })\n}\n~~~\n\n# 缓存\n> 这一块没有理解，需重新看\n为了能够长期缓存webpack生成的静态资源:\n\n1. 使用[chunkhash]向每个文件添加一个依赖于内容的缓存杀手(cache-buster)\n2. 将webpack mainfest提取到一个单独的文件中去\n3. 对于一组依赖关系相同的资源，确保包含引导代码的入口起点模块(entrychunk)不会随时间改变它的哈希值\n4. 当需要在HTML中加载资源时，使用编译器统计信息(compiler stats)来获取文件名\n5. 生成模块清单(chunk manifest)的JSON内容，并在页面资源加载之前内联进HTML中去\n\n* 将开发和生产模式的配置分开，并在开发模式中使用[name].js的文件名， 在生产模式中使用[name].[chunkhash].js文件名\n* 为了在HTML中引用正确的文件,因为有hash生存文件名的一部分，可以使用下面这个插件，从webpack编译统计中提取：\n~~~\n// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = { \n  plugins: [\n    function() {\n      this.plugin(\"done\", function(stats) {\n        require(\"fs\").writeFileSync(\n          path.join(__dirname, \"build\", \"stats.json\"),\n          JSON.stringify(stats.toJson()));\n      });\n    }\n  ]\n};\n~~~\n或者使用插件：https://www.npmjs.com/package/webpack-manifest-plugin\n\n# 开发\n## 调整你的文本编辑器\n* 一些文本编辑器有“safe write”（安全写入）功能，并且默认启用。因此，保存文件后并不总是会导致 webpack 重新编译\n* WebStorm - 在 Preferences > Appearance & Behavior > System Settings 中取消选中 Use \"safe write\"\n\n## Source Maps\n更多配置：http://www.css88.com/doc/webpack2/configuration/devtool/\n~~~\ndevtool:'source-map'\n~~~\n\n## 选择一个工具\n* webpack 可以在 watch mode(监视模式)下使用。在这种模式下，webpack 将监视您的文件，并在更改时重新编译\n* webpack-dev-server 提供了一个易于部署的开发服务器，具有快速的实时重载（live reloading）功能\n* 如果你已经有一个开发服务器并且需要完全的灵活性，可以使用 webpack-dev-middleware 作为中间件\n\n### webpack-dev-server\n1. npm install webpack-dev-server --save-dev\n2. webpack-dev-server --open\n\n### webpack-dev-middleware\nwebpack-dev-middleware 适用于基于链接的中间件环境（connect-based middleware stacks）。如果你已经有一个 Node.js 服务器或者你想要完全控制服务器，这将很实用\n1. npm install express webpack-dev-middleware --save-dev\n2. 使用\n~~~\nvar express = require(\"express\");\nvar webpackDevMiddleware = require(\"webpack-dev-middleware\");\nvar webpack = require(\"webpack\");\nvar webpackConfig = require(\"./webpack.config\");\n\nvar app = express();\nvar compiler = webpack(webpackConfig);\n\napp.use(webpackDevMiddleware(compiler, {\n  publicPath: \"/\" // 大部分情况下和 `output.publicPath`相同\n}));\n\napp.listen(3000, function () {\n  console.log(\"Listening on port 3000!\");\n});\n~~~\n根据你在 output.publicPath 和 output.filename 中设置的内容，你的 bundle 现在应该在 http://localhost:3000/bundle.js 中可以看到了\n3. 默认情况下会使用watch mode。也可以使用 lazy mode，这使得 webpack 只在对入口点进行请求时再进行重新编译\n~~~\napp.use(webpackDevMiddleware(compiler, {\n  lazy: true,\n  filename: \"bundle.js\" // Same as `output.filename` in most cases.\n}));\n~~~\n4. 命令说明\n~~~\n* webpack-dev-server  //默认8080\n* webpack-dev-server --port 8088\n* webpack-dev-server --inline //改变代码之后，自动刷新浏览器\n* webpack-dev-server --hot //热重载（局部更改）\n~~~\n5. 此功能设置在webpack.config.js配置文件中如下：\n~~~\ndevServer:{\n    port:8088,\n    inline:true\n}\n~~~\n6. 也可以配置在package.json文件中，如：\n~~~\n\"scripts\":{\n    \"dev\":\"webpack-dev-server --port 8088 --inline --hot\"\n}\n\n$ run npm dev\n~~~\n7. resolve配置\n* 配置扩展名,即代码中引用的时候可以省略后缀\n~~~\nresolve:{\n    \"extensions\":['','.js','.css','.json']\n}\n~~~\n\n## 配合babel的使用\n以下为react配合webpack的各种依赖库：\n* cnpm install babel-core -D \n* cnpm install babel-preset-es2015 --save-dev\n* cnpm install babel-loader -D\n\n设置js的转换\n1. 通过weback.config.js设置\n~~~\nmoudule:{\n    loaders:[\n        {\n            test:/\\.js$/,\n            loader:'babel',\n            exclude:/node_moudules/\n        }\n    ]\n},\nbabel:{\n    \"presets\":['es2015']\n}\n~~~\n2. 通过.babelrc文件，文件内容为：\n~~~\n{\n    \"presets\":[\"es2015\"]\n}\n~~~\n\n## 配合react使用\n前提：配合babel的配置已经安装\n* cnpm install babel-preset-react -D //babel的react预设，babel可以给其他用，react是支持的一种\n* cnpm install react-hot-loader\n* 设置预设.babelrc\n~~~\n{\n    \"presets\":[\n        [\"es2015\"],\n        [\"react\"]\n    ]\n}\n~~~\n* 预设webpack.config\n\n","source":"_posts/前端开发/webpack入门.md","raw":"---\ntitle: webpack入门\ntags:\n  - 工具\n  - node \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-26 16:04:30\ncategories: 前端\npassword:\n---\n\n[toc]\n\n~~~\nhttp://webpack.org/\nhttps://github.com/webpack-china/webpack.js.org\nhttp://www.css88.com/doc/webpack2/\n~~~\n\n# 简介\n![image](http://note.youdao.com/yws/api/personal/file/WEB7518457dae5c37c455088010c54f1e6c?method=download&shareKey=13db111168a449f1c1833f09e42da606)\nWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。\n\n前身叫browserify，缺点为只能转换js\n\n# 概念\n## 入口(Entry)\n* webpack 将创建所有应用程序的依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point)\n* 入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么\n* 可以将应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件\n\n## 出口(Output)\n* 将所有的资源(assets)归拢在一起后，我们还需要告诉 webpack 在哪里打包我们的应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)\n* 即使可以存在多个入口起点，但只指定一个输出配置\n* 更多配置：http://www.css88.com/doc/webpack2/concepts/output/\n\n## 加载器(Loader)\n* webpack 的目标是，让 webpack 聚焦于项目中的所有资源(asset)，而浏览器不需要关注考虑这些（这并不意味着资源(asset)都必须打包在一起）。webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。而且 webpack 只理解 JavaScript\n* webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中\n* 在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules\n* webparck默认加载的是js，如果要加载如css，需要额外loader\n1. npm install style-loader css-loader -D\n2. 在webpack中，多个loader加载通过！连接，后面的“-loader可以省略”，如：require(\"style!css!./mystyle.css\")\n\n## 插件(Plugins)\n想要使用一个插件，\n1. 需要 require() 它，\n2. 它添加到 plugins 数组中\n3. 多数插件可以通过选项(option)自定义\n4. 由于需要在一个配置中，多次使用一个插件，来针对不同的目的，因此你需要使用 new 来创建插件的实例，并且通过实例来调用插件\n\nwebpack 插件是一个具有 apply 属性的 JavaScript 对象。 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个 compilation 生命周期访问\n\nwebpack.config.js示例：\n~~~\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\nconst webpack = require('webpack'); //to access built-in plugins\nconst path = require('path');\n\nconst config = {\n  entry: './path/to/my/entry/file.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'my-first-webpack.bundle.js'\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, use: 'babel-loader'}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: './src/index.html'})\n  ]\n};\n\nmodule.exports = config;\n~~~\n\n# webpack安装及起步\n## 安装\n* cnpm install webpack-cli -g//webpack的cli环境\n* cnpm install webpack-dev-server //webpack的自带服务器\n\n运行：\n1. 开发环境：webpack\n2. 生产环境：webpack -p //会压缩\n3. 监听模式：webpack -w //自动编译\n4. 开启sourcemaps：webpack -d //方便调试\n\n## 起步\n~~~\nmkdir webpack-demo && cd webpack-demo\nnpm init -y\nnpm install --save-dev webpack\n~~~\n\n创建并编辑app/index.js\n~~~ \nimport _ from 'lodash';\n\nfunction component () {\n  var element = document.createElement('div');\n\n  /* 需要引入 lodash，下一行才能正常工作 */\n  element.innerHTML = _.join(['Hello','webpack'], ' ');\n\n  return element;\n}\n\ndocument.body.appendChild(component());\n~~~\n~~~\nnpm install --save lodash\n~~~\n~~~\n<html>\n  <head>\n    <title>webpack 2 demo</title> \n  </head>\n  <body> \n       <script src=\"dist/bundle.js\"></script>\n  </body>\n</html>\n~~~\n~~~\nwebpack\n查看浏览器index.html页面内容：Hello webpack\n~~~\n\n#代码拆分\n分离资源，实现缓存资源和并行加载资源:\n* 一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改\n* 如果我们将这些库(library)中的代码，保留到与应用程序代码相独立的 bundle 上，我们就可以利用浏览器缓存机制，把这些文件长时间的缓存到用户的机器上\n\n## CSS分割\n要通过webpack打包CSS，像任何其他模块一样将CSS导入JavaScript代码，并使用css-loader（它输出CSS作为JS模块），并可选地应用ExtractTextWebpackPlugin（它提取打包的CSS并输出CSS文件\n\n1. 导入 CSS\n* import 'bootstrap/dist/css/bootstrap.css';\n2. 使用 css-loader:webpack.config.js中配置 css-loader\n~~~\nmodule.exports = {\n    module: {\n        rules: [{\n            test: /\\.css$/,\n            use: 'css-loader'\n        }]\n    }\n}\n~~~\n3. 使用 ExtractTextWebpackPlugin\n* npm install --save-dev extract-text-webpack-plugin\n4. webpack.config.js中添加插件配置\n~~~\nmodule.exports = {\n    module: {\n         rules: [{\n             test: /\\.css$/,\n-            use: 'css-loader'\n+            use: ExtractTextPlugin.extract({\n+                use: 'css-loader'\n+            })\n         }]\n     },\n+    plugins: [\n+        new ExtractTextPlugin('styles.css'),\n+    ]\n} \n~~~\n\n## Libraries分割\n默认会将库文件打包，可通过为库，如moment 添加一个单独的入口点并将其命名为 vendor 来缓解这一情况\n~~~\nvar path = require('path');\n\nmodule.exports = function(env) {\n    return {\n        entry: {\n            main: './index.js',\n            vendor: 'moment'\n        },\n        output: {\n            filename: '[chunkhash].[name].js',\n            path: path.resolve(__dirname, 'dist')\n        }\n    }\n}\n~~~\n运行webpakc生成了两个 bundle，都包含lodash，所以还需要插件\n* CommonsChunkPlugin：它从根本上允许我们从不同的 bundle 中提取所有的公共模块，并且将他们加入公共 bundle 中。如果公共 bundle 不存在，那么它将会创建一个出来\n~~~\nvar webpack = require('webpack');\nvar path = require('path');\n\nmodule.exports = function(env) {\n    return {\n        entry: {\n            main: './index.js',\n            vendor: 'moment'\n        },\n        output: {\n            filename: '[chunkhash].[name].js',\n            path: path.resolve(__dirname, 'dist')\n        },\n        plugins: [\n            new webpack.optimize.CommonsChunkPlugin({\n                name: 'vendor' // 指定公共 bundle 的名字。\n            })\n        ]\n    }\n}\n~~~\n以上完成之后，每次运行的vendor文件的hash码会改变，需在plugins配置如下：\n~~~\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n        names: ['vendor', 'manifest'] // 指定公共 bundle 的名字\n    })\n]\n~~~\n将运行时代码提取到一个单独的 manifest 文件中就解决了\n\n## 生产环境构建\n1. 自动方式\n* 运行webpack -p (也可以运行 webpack --optimize-minimize --define process.env.NODE_ENV=\"'production'\", 他们是等效的). 它会执行如下步骤:\n- - 使用UglifyJsPlugin进行 JS文件压缩\n- - 运行LoaderOptionsPlugin\n- - 设置Node环境变量\n2. 手动方式: 为多环境配置Webpack\n编写一个基本配置文件,把所有公用的功能放在里面。再编写特定环境的文件,使用'webpack-merge'来合并他们\n\nbase.js\n~~~\nmodule.exports = function() {\n    return {\n        entry: { \n            'vendor': './src/vendor.ts',\n            'main': './src/main.ts'\n\n        },\n        output: {\n            path: path.join(__dirname, '/../dist/assets'),\n            filename: '[name].bundle.js',\n            publicPath: publicPath,\n            sourceMapFilename: '[name].map'\n        },\n        resolve: {\n            extensions: ['', '.js', '.json'],\n            modules: [path.join(__dirname, 'src'), 'node_modules']\n\n        },\n        module: {\n            loaders: [{\n                test: /\\.css$/,\n                loaders: ['to-string-loader', 'css-loader']\n            }, {\n                test: /\\.(jpg|png|gif)$/,\n                loader: 'file-loader'\n            }, {\n                test: /\\.(woff|woff2|eot|ttf|svg)$/,\n                loader: 'url-loader?limit=100000'\n            }],\n        },\n        plugins: [\n            new ForkCheckerPlugin(),\n\n            new webpack.optimize.CommonsChunkPlugin({\n                name: ['polyfills', 'vendor'].reverse()\n            }),\n            new HtmlWebpackPlugin({\n                template: 'src/index.html',\n                chunksSortMode: 'dependency'\n            })\n        ],\n    };\n}\n~~~\n使用'webpack-merge'合并这个基础配置和针对环境的特定的配置\n\nprod.js (updated)\n~~~\nconst webpackMerge = require('webpack-merge');\n\nconst commonConfig = require('./base.js');\n\nmodule.exports = function(env) {\n    return webpackMerge(commonConfig(), {\n        plugins: [\n            new webpack.LoaderOptionsPlugin({\n                minimize: true,\n                debug: false\n            }),\n            new webpack.DefinePlugin({\n                'process.env': {\n                    'NODE_ENV': JSON.stringify('prod')\n                }\n            }),\n            new webpack.optimize.UglifyJsPlugin({\n                beautify: false,\n                mangle: {\n                    screw_ie8: true,\n                    keep_fnames: true\n                },\n                compress: {\n                    screw_ie8: true\n                },\n                comments: false\n            })\n        ]\n    })\n}\n~~~\n\n# 缓存\n> 这一块没有理解，需重新看\n为了能够长期缓存webpack生成的静态资源:\n\n1. 使用[chunkhash]向每个文件添加一个依赖于内容的缓存杀手(cache-buster)\n2. 将webpack mainfest提取到一个单独的文件中去\n3. 对于一组依赖关系相同的资源，确保包含引导代码的入口起点模块(entrychunk)不会随时间改变它的哈希值\n4. 当需要在HTML中加载资源时，使用编译器统计信息(compiler stats)来获取文件名\n5. 生成模块清单(chunk manifest)的JSON内容，并在页面资源加载之前内联进HTML中去\n\n* 将开发和生产模式的配置分开，并在开发模式中使用[name].js的文件名， 在生产模式中使用[name].[chunkhash].js文件名\n* 为了在HTML中引用正确的文件,因为有hash生存文件名的一部分，可以使用下面这个插件，从webpack编译统计中提取：\n~~~\n// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = { \n  plugins: [\n    function() {\n      this.plugin(\"done\", function(stats) {\n        require(\"fs\").writeFileSync(\n          path.join(__dirname, \"build\", \"stats.json\"),\n          JSON.stringify(stats.toJson()));\n      });\n    }\n  ]\n};\n~~~\n或者使用插件：https://www.npmjs.com/package/webpack-manifest-plugin\n\n# 开发\n## 调整你的文本编辑器\n* 一些文本编辑器有“safe write”（安全写入）功能，并且默认启用。因此，保存文件后并不总是会导致 webpack 重新编译\n* WebStorm - 在 Preferences > Appearance & Behavior > System Settings 中取消选中 Use \"safe write\"\n\n## Source Maps\n更多配置：http://www.css88.com/doc/webpack2/configuration/devtool/\n~~~\ndevtool:'source-map'\n~~~\n\n## 选择一个工具\n* webpack 可以在 watch mode(监视模式)下使用。在这种模式下，webpack 将监视您的文件，并在更改时重新编译\n* webpack-dev-server 提供了一个易于部署的开发服务器，具有快速的实时重载（live reloading）功能\n* 如果你已经有一个开发服务器并且需要完全的灵活性，可以使用 webpack-dev-middleware 作为中间件\n\n### webpack-dev-server\n1. npm install webpack-dev-server --save-dev\n2. webpack-dev-server --open\n\n### webpack-dev-middleware\nwebpack-dev-middleware 适用于基于链接的中间件环境（connect-based middleware stacks）。如果你已经有一个 Node.js 服务器或者你想要完全控制服务器，这将很实用\n1. npm install express webpack-dev-middleware --save-dev\n2. 使用\n~~~\nvar express = require(\"express\");\nvar webpackDevMiddleware = require(\"webpack-dev-middleware\");\nvar webpack = require(\"webpack\");\nvar webpackConfig = require(\"./webpack.config\");\n\nvar app = express();\nvar compiler = webpack(webpackConfig);\n\napp.use(webpackDevMiddleware(compiler, {\n  publicPath: \"/\" // 大部分情况下和 `output.publicPath`相同\n}));\n\napp.listen(3000, function () {\n  console.log(\"Listening on port 3000!\");\n});\n~~~\n根据你在 output.publicPath 和 output.filename 中设置的内容，你的 bundle 现在应该在 http://localhost:3000/bundle.js 中可以看到了\n3. 默认情况下会使用watch mode。也可以使用 lazy mode，这使得 webpack 只在对入口点进行请求时再进行重新编译\n~~~\napp.use(webpackDevMiddleware(compiler, {\n  lazy: true,\n  filename: \"bundle.js\" // Same as `output.filename` in most cases.\n}));\n~~~\n4. 命令说明\n~~~\n* webpack-dev-server  //默认8080\n* webpack-dev-server --port 8088\n* webpack-dev-server --inline //改变代码之后，自动刷新浏览器\n* webpack-dev-server --hot //热重载（局部更改）\n~~~\n5. 此功能设置在webpack.config.js配置文件中如下：\n~~~\ndevServer:{\n    port:8088,\n    inline:true\n}\n~~~\n6. 也可以配置在package.json文件中，如：\n~~~\n\"scripts\":{\n    \"dev\":\"webpack-dev-server --port 8088 --inline --hot\"\n}\n\n$ run npm dev\n~~~\n7. resolve配置\n* 配置扩展名,即代码中引用的时候可以省略后缀\n~~~\nresolve:{\n    \"extensions\":['','.js','.css','.json']\n}\n~~~\n\n## 配合babel的使用\n以下为react配合webpack的各种依赖库：\n* cnpm install babel-core -D \n* cnpm install babel-preset-es2015 --save-dev\n* cnpm install babel-loader -D\n\n设置js的转换\n1. 通过weback.config.js设置\n~~~\nmoudule:{\n    loaders:[\n        {\n            test:/\\.js$/,\n            loader:'babel',\n            exclude:/node_moudules/\n        }\n    ]\n},\nbabel:{\n    \"presets\":['es2015']\n}\n~~~\n2. 通过.babelrc文件，文件内容为：\n~~~\n{\n    \"presets\":[\"es2015\"]\n}\n~~~\n\n## 配合react使用\n前提：配合babel的配置已经安装\n* cnpm install babel-preset-react -D //babel的react预设，babel可以给其他用，react是支持的一种\n* cnpm install react-hot-loader\n* 设置预设.babelrc\n~~~\n{\n    \"presets\":[\n        [\"es2015\"],\n        [\"react\"]\n    ]\n}\n~~~\n* 预设webpack.config\n\n","slug":"前端开发-webpack入门","published":1,"updated":"2019-02-14T06:25:35.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3s00e15b8hzxuv1jwc","content":"<p>[toc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://webpack.org/</span><br><span class=\"line\">https://github.com/webpack-china/webpack.js.org</span><br><span class=\"line\">http://www.css88.com/doc/webpack2/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB7518457dae5c37c455088010c54f1e6c?method=download&amp;shareKey=13db111168a449f1c1833f09e42da606\" alt=\"image\"><br>\nWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>\n<p>前身叫browserify，缺点为只能转换js</p>\n<h1 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\"></a> 概念</h1>\n<h2 id=\"入口entry\"><a class=\"markdownIt-Anchor\" href=\"#入口entry\"></a> 入口(Entry)</h2>\n<ul>\n<li>webpack 将创建所有应用程序的依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point)</li>\n<li>入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么</li>\n<li>可以将应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件</li>\n</ul>\n<h2 id=\"出口output\"><a class=\"markdownIt-Anchor\" href=\"#出口output\"></a> 出口(Output)</h2>\n<ul>\n<li>将所有的资源(assets)归拢在一起后，我们还需要告诉 webpack 在哪里打包我们的应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)</li>\n<li>即使可以存在多个入口起点，但只指定一个输出配置</li>\n<li>更多配置：<a href=\"http://www.css88.com/doc/webpack2/concepts/output/\" target=\"_blank\" rel=\"noopener\">http://www.css88.com/doc/webpack2/concepts/output/</a></li>\n</ul>\n<h2 id=\"加载器loader\"><a class=\"markdownIt-Anchor\" href=\"#加载器loader\"></a> 加载器(Loader)</h2>\n<ul>\n<li>webpack 的目标是，让 webpack 聚焦于项目中的所有资源(asset)，而浏览器不需要关注考虑这些（这并不意味着资源(asset)都必须打包在一起）。webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。而且 webpack 只理解 JavaScript</li>\n<li>webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中</li>\n<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules</li>\n<li>webparck默认加载的是js，如果要加载如css，需要额外loader</li>\n</ul>\n<ol>\n<li>npm install style-loader css-loader -D</li>\n<li>在webpack中，多个loader加载通过！连接，后面的“-loader可以省略”，如：require(“style!css!./mystyle.css”)</li>\n</ol>\n<h2 id=\"插件plugins\"><a class=\"markdownIt-Anchor\" href=\"#插件plugins\"></a> 插件(Plugins)</h2>\n<p>想要使用一个插件，</p>\n<ol>\n<li>需要 require() 它，</li>\n<li>它添加到 plugins 数组中</li>\n<li>多数插件可以通过选项(option)自定义</li>\n<li>由于需要在一个配置中，多次使用一个插件，来针对不同的目的，因此你需要使用 new 来创建插件的实例，并且通过实例来调用插件</li>\n</ol>\n<p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个 compilation 生命周期访问</p>\n<p>webpack.config.js示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm</span><br><span class=\"line\">const webpack = require(&apos;webpack&apos;); //to access built-in plugins</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class=\"line\">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;test: /\\.(js|jsx)$/, use: &apos;babel-loader&apos;&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<h1 id=\"webpack安装及起步\"><a class=\"markdownIt-Anchor\" href=\"#webpack安装及起步\"></a> webpack安装及起步</h1>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h2>\n<ul>\n<li>cnpm install webpack-cli -g//webpack的cli环境</li>\n<li>cnpm install webpack-dev-server //webpack的自带服务器</li>\n</ul>\n<p>运行：</p>\n<ol>\n<li>开发环境：webpack</li>\n<li>生产环境：webpack -p //会压缩</li>\n<li>监听模式：webpack -w //自动编译</li>\n<li>开启sourcemaps：webpack -d //方便调试</li>\n</ol>\n<h2 id=\"起步\"><a class=\"markdownIt-Anchor\" href=\"#起步\"></a> 起步</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir webpack-demo &amp;&amp; cd webpack-demo</span><br><span class=\"line\">npm init -y</span><br><span class=\"line\">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>\n<p>创建并编辑app/index.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import _ from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function component () &#123;</span><br><span class=\"line\">  var element = document.createElement(&apos;div&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  /* 需要引入 lodash，下一行才能正常工作 */</span><br><span class=\"line\">  element.innerHTML = _.join([&apos;Hello&apos;,&apos;webpack&apos;], &apos; &apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">document.body.appendChild(component());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save lodash</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;webpack 2 demo&lt;/title&gt; </span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt; </span><br><span class=\"line\">       &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack</span><br><span class=\"line\">查看浏览器index.html页面内容：Hello webpack</span><br></pre></td></tr></table></figure>\n<p>#代码拆分<br>\n分离资源，实现缓存资源和并行加载资源:</p>\n<ul>\n<li>一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改</li>\n<li>如果我们将这些库(library)中的代码，保留到与应用程序代码相独立的 bundle 上，我们就可以利用浏览器缓存机制，把这些文件长时间的缓存到用户的机器上</li>\n</ul>\n<h2 id=\"css分割\"><a class=\"markdownIt-Anchor\" href=\"#css分割\"></a> CSS分割</h2>\n<p>要通过webpack打包CSS，像任何其他模块一样将CSS导入JavaScript代码，并使用css-loader（它输出CSS作为JS模块），并可选地应用ExtractTextWebpackPlugin（它提取打包的CSS并输出CSS文件</p>\n<ol>\n<li>导入 CSS</li>\n</ol>\n<ul>\n<li>import ‘bootstrap/dist/css/bootstrap.css’;</li>\n</ul>\n<ol start=\"2\">\n<li>使用 css-loader:webpack.config.js中配置 css-loader</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [&#123;</span><br><span class=\"line\">            test: /\\.css$/,</span><br><span class=\"line\">            use: &apos;css-loader&apos;</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用 ExtractTextWebpackPlugin</li>\n</ol>\n<ul>\n<li>npm install --save-dev extract-text-webpack-plugin</li>\n</ul>\n<ol start=\"4\">\n<li>webpack.config.js中添加插件配置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">         rules: [&#123;</span><br><span class=\"line\">             test: /\\.css$/,</span><br><span class=\"line\">-            use: &apos;css-loader&apos;</span><br><span class=\"line\">+            use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">+                use: &apos;css-loader&apos;</span><br><span class=\"line\">+            &#125;)</span><br><span class=\"line\">         &#125;]</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">+    plugins: [</span><br><span class=\"line\">+        new ExtractTextPlugin(&apos;styles.css&apos;),</span><br><span class=\"line\">+    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"libraries分割\"><a class=\"markdownIt-Anchor\" href=\"#libraries分割\"></a> Libraries分割</h2>\n<p>默认会将库文件打包，可通过为库，如moment 添加一个单独的入口点并将其命名为 vendor 来缓解这一情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function(env) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        entry: &#123;</span><br><span class=\"line\">            main: &apos;./index.js&apos;,</span><br><span class=\"line\">            vendor: &apos;moment&apos;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            filename: &apos;[chunkhash].[name].js&apos;,</span><br><span class=\"line\">            path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行webpakc生成了两个 bundle，都包含lodash，所以还需要插件</p>\n<ul>\n<li>CommonsChunkPlugin：它从根本上允许我们从不同的 bundle 中提取所有的公共模块，并且将他们加入公共 bundle 中。如果公共 bundle 不存在，那么它将会创建一个出来</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpack = require(&apos;webpack&apos;);</span><br><span class=\"line\">var path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function(env) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        entry: &#123;</span><br><span class=\"line\">            main: &apos;./index.js&apos;,</span><br><span class=\"line\">            vendor: &apos;moment&apos;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            filename: &apos;[chunkhash].[name].js&apos;,</span><br><span class=\"line\">            path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">                name: &apos;vendor&apos; // 指定公共 bundle 的名字。</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上完成之后，每次运行的vendor文件的hash码会改变，需在plugins配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">        names: [&apos;vendor&apos;, &apos;manifest&apos;] // 指定公共 bundle 的名字</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>将运行时代码提取到一个单独的 manifest 文件中就解决了</p>\n<h2 id=\"生产环境构建\"><a class=\"markdownIt-Anchor\" href=\"#生产环境构建\"></a> 生产环境构建</h2>\n<ol>\n<li>自动方式</li>\n</ol>\n<ul>\n<li>运行webpack -p (也可以运行 webpack --optimize-minimize --define process.env.NODE_ENV=&quot;‘production’&quot;, 他们是等效的). 它会执行如下步骤:</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>使用UglifyJsPlugin进行 JS文件压缩</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>运行LoaderOptionsPlugin</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>设置Node环境变量</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>手动方式: 为多环境配置Webpack<br>\n编写一个基本配置文件,把所有公用的功能放在里面。再编写特定环境的文件,使用’webpack-merge’来合并他们</li>\n</ol>\n<p>base.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        entry: &#123; </span><br><span class=\"line\">            &apos;vendor&apos;: &apos;./src/vendor.ts&apos;,</span><br><span class=\"line\">            &apos;main&apos;: &apos;./src/main.ts&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            path: path.join(__dirname, &apos;/../dist/assets&apos;),</span><br><span class=\"line\">            filename: &apos;[name].bundle.js&apos;,</span><br><span class=\"line\">            publicPath: publicPath,</span><br><span class=\"line\">            sourceMapFilename: &apos;[name].map&apos;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        resolve: &#123;</span><br><span class=\"line\">            extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;],</span><br><span class=\"line\">            modules: [path.join(__dirname, &apos;src&apos;), &apos;node_modules&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        module: &#123;</span><br><span class=\"line\">            loaders: [&#123;</span><br><span class=\"line\">                test: /\\.css$/,</span><br><span class=\"line\">                loaders: [&apos;to-string-loader&apos;, &apos;css-loader&apos;]</span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                test: /\\.(jpg|png|gif)$/,</span><br><span class=\"line\">                loader: &apos;file-loader&apos;</span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                test: /\\.(woff|woff2|eot|ttf|svg)$/,</span><br><span class=\"line\">                loader: &apos;url-loader?limit=100000&apos;</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            new ForkCheckerPlugin(),</span><br><span class=\"line\"></span><br><span class=\"line\">            new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">                name: [&apos;polyfills&apos;, &apos;vendor&apos;].reverse()</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">                template: &apos;src/index.html&apos;,</span><br><span class=\"line\">                chunksSortMode: &apos;dependency&apos;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用’webpack-merge’合并这个基础配置和针对环境的特定的配置</p>\n<p>prod.js (updated)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpackMerge = require(&apos;webpack-merge&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const commonConfig = require(&apos;./base.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function(env) &#123;</span><br><span class=\"line\">    return webpackMerge(commonConfig(), &#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            new webpack.LoaderOptionsPlugin(&#123;</span><br><span class=\"line\">                minimize: true,</span><br><span class=\"line\">                debug: false</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">                &apos;process.env&apos;: &#123;</span><br><span class=\"line\">                    &apos;NODE_ENV&apos;: JSON.stringify(&apos;prod&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">                beautify: false,</span><br><span class=\"line\">                mangle: &#123;</span><br><span class=\"line\">                    screw_ie8: true,</span><br><span class=\"line\">                    keep_fnames: true</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                compress: &#123;</span><br><span class=\"line\">                    screw_ie8: true</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                comments: false</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"缓存\"><a class=\"markdownIt-Anchor\" href=\"#缓存\"></a> 缓存</h1>\n<blockquote>\n<p>这一块没有理解，需重新看<br>\n为了能够长期缓存webpack生成的静态资源:</p>\n</blockquote>\n<ol>\n<li>使用[chunkhash]向每个文件添加一个依赖于内容的缓存杀手(cache-buster)</li>\n<li>将webpack mainfest提取到一个单独的文件中去</li>\n<li>对于一组依赖关系相同的资源，确保包含引导代码的入口起点模块(entrychunk)不会随时间改变它的哈希值</li>\n<li>当需要在HTML中加载资源时，使用编译器统计信息(compiler stats)来获取文件名</li>\n<li>生成模块清单(chunk manifest)的JSON内容，并在页面资源加载之前内联进HTML中去</li>\n</ol>\n<ul>\n<li>将开发和生产模式的配置分开，并在开发模式中使用[name].js的文件名， 在生产模式中使用[name].[chunkhash].js文件名</li>\n<li>为了在HTML中引用正确的文件,因为有hash生存文件名的一部分，可以使用下面这个插件，从webpack编译统计中提取：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">const path = require(&quot;path&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    function() &#123;</span><br><span class=\"line\">      this.plugin(&quot;done&quot;, function(stats) &#123;</span><br><span class=\"line\">        require(&quot;fs&quot;).writeFileSync(</span><br><span class=\"line\">          path.join(__dirname, &quot;build&quot;, &quot;stats.json&quot;),</span><br><span class=\"line\">          JSON.stringify(stats.toJson()));</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>或者使用插件：<a href=\"https://www.npmjs.com/package/webpack-manifest-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/webpack-manifest-plugin</a></p>\n<h1 id=\"开发\"><a class=\"markdownIt-Anchor\" href=\"#开发\"></a> 开发</h1>\n<h2 id=\"调整你的文本编辑器\"><a class=\"markdownIt-Anchor\" href=\"#调整你的文本编辑器\"></a> 调整你的文本编辑器</h2>\n<ul>\n<li>一些文本编辑器有“safe write”（安全写入）功能，并且默认启用。因此，保存文件后并不总是会导致 webpack 重新编译</li>\n<li>WebStorm - 在 Preferences &gt; Appearance &amp; Behavior &gt; System Settings 中取消选中 Use “safe write”</li>\n</ul>\n<h2 id=\"source-maps\"><a class=\"markdownIt-Anchor\" href=\"#source-maps\"></a> Source Maps</h2>\n<p>更多配置：<a href=\"http://www.css88.com/doc/webpack2/configuration/devtool/\" target=\"_blank\" rel=\"noopener\">http://www.css88.com/doc/webpack2/configuration/devtool/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtool:&apos;source-map&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择一个工具\"><a class=\"markdownIt-Anchor\" href=\"#选择一个工具\"></a> 选择一个工具</h2>\n<ul>\n<li>webpack 可以在 watch mode(监视模式)下使用。在这种模式下，webpack 将监视您的文件，并在更改时重新编译</li>\n<li>webpack-dev-server 提供了一个易于部署的开发服务器，具有快速的实时重载（live reloading）功能</li>\n<li>如果你已经有一个开发服务器并且需要完全的灵活性，可以使用 webpack-dev-middleware 作为中间件</li>\n</ul>\n<h3 id=\"webpack-dev-server\"><a class=\"markdownIt-Anchor\" href=\"#webpack-dev-server\"></a> webpack-dev-server</h3>\n<ol>\n<li>npm install webpack-dev-server --save-dev</li>\n<li>webpack-dev-server --open</li>\n</ol>\n<h3 id=\"webpack-dev-middleware\"><a class=\"markdownIt-Anchor\" href=\"#webpack-dev-middleware\"></a> webpack-dev-middleware</h3>\n<p>webpack-dev-middleware 适用于基于链接的中间件环境（connect-based middleware stacks）。如果你已经有一个 Node.js 服务器或者你想要完全控制服务器，这将很实用</p>\n<ol>\n<li>npm install express webpack-dev-middleware --save-dev</li>\n<li>使用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&quot;express&quot;);</span><br><span class=\"line\">var webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);</span><br><span class=\"line\">var webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">var webpackConfig = require(&quot;./webpack.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">var compiler = webpack(webpackConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class=\"line\">  publicPath: &quot;/&quot; // 大部分情况下和 `output.publicPath`相同</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000, function () &#123;</span><br><span class=\"line\">  console.log(&quot;Listening on port 3000!&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>根据你在 output.publicPath 和 output.filename 中设置的内容，你的 bundle 现在应该在 <a href=\"http://localhost:3000/bundle.js\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/bundle.js</a> 中可以看到了<br>\n3. 默认情况下会使用watch mode。也可以使用 lazy mode，这使得 webpack 只在对入口点进行请求时再进行重新编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class=\"line\">  lazy: true,</span><br><span class=\"line\">  filename: &quot;bundle.js&quot; // Same as `output.filename` in most cases.</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>命令说明</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* webpack-dev-server  //默认8080</span><br><span class=\"line\">* webpack-dev-server --port 8088</span><br><span class=\"line\">* webpack-dev-server --inline //改变代码之后，自动刷新浏览器</span><br><span class=\"line\">* webpack-dev-server --hot //热重载（局部更改）</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>此功能设置在webpack.config.js配置文件中如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer:&#123;</span><br><span class=\"line\">    port:8088,</span><br><span class=\"line\">    inline:true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>也可以配置在package.json文件中，如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;:&#123;</span><br><span class=\"line\">    &quot;dev&quot;:&quot;webpack-dev-server --port 8088 --inline --hot&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ run npm dev</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>resolve配置</li>\n</ol>\n<ul>\n<li>配置扩展名,即代码中引用的时候可以省略后缀</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve:&#123;</span><br><span class=\"line\">    &quot;extensions&quot;:[&apos;&apos;,&apos;.js&apos;,&apos;.css&apos;,&apos;.json&apos;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配合babel的使用\"><a class=\"markdownIt-Anchor\" href=\"#配合babel的使用\"></a> 配合babel的使用</h2>\n<p>以下为react配合webpack的各种依赖库：</p>\n<ul>\n<li>cnpm install babel-core -D</li>\n<li>cnpm install babel-preset-es2015 --save-dev</li>\n<li>cnpm install babel-loader -D</li>\n</ul>\n<p>设置js的转换</p>\n<ol>\n<li>通过weback.config.js设置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">moudule:&#123;</span><br><span class=\"line\">    loaders:[</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test:/\\.js$/,</span><br><span class=\"line\">            loader:&apos;babel&apos;,</span><br><span class=\"line\">            exclude:/node_moudules/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">babel:&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[&apos;es2015&apos;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过.babelrc文件，文件内容为：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[&quot;es2015&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配合react使用\"><a class=\"markdownIt-Anchor\" href=\"#配合react使用\"></a> 配合react使用</h2>\n<p>前提：配合babel的配置已经安装</p>\n<ul>\n<li>cnpm install babel-preset-react -D //babel的react预设，babel可以给其他用，react是支持的一种</li>\n<li>cnpm install react-hot-loader</li>\n<li>设置预设.babelrc</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[</span><br><span class=\"line\">        [&quot;es2015&quot;],</span><br><span class=\"line\">        [&quot;react&quot;]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>预设webpack.config</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://webpack.org/</span><br><span class=\"line\">https://github.com/webpack-china/webpack.js.org</span><br><span class=\"line\">http://www.css88.com/doc/webpack2/</span><br></pre></td></tr></table></figure>\n<h1 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h1>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB7518457dae5c37c455088010c54f1e6c?method=download&amp;shareKey=13db111168a449f1c1833f09e42da606\" alt=\"image\"><br>\nWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>\n<p>前身叫browserify，缺点为只能转换js</p>\n<h1 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\"></a> 概念</h1>\n<h2 id=\"入口entry\"><a class=\"markdownIt-Anchor\" href=\"#入口entry\"></a> 入口(Entry)</h2>\n<ul>\n<li>webpack 将创建所有应用程序的依赖关系图表(dependency graph)。图表的起点被称之为入口起点(entry point)</li>\n<li>入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么</li>\n<li>可以将应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件</li>\n</ul>\n<h2 id=\"出口output\"><a class=\"markdownIt-Anchor\" href=\"#出口output\"></a> 出口(Output)</h2>\n<ul>\n<li>将所有的资源(assets)归拢在一起后，我们还需要告诉 webpack 在哪里打包我们的应用程序。webpack 的 output 属性描述了如何处理归拢在一起的代码(bundled code)</li>\n<li>即使可以存在多个入口起点，但只指定一个输出配置</li>\n<li>更多配置：<a href=\"http://www.css88.com/doc/webpack2/concepts/output/\" target=\"_blank\" rel=\"noopener\">http://www.css88.com/doc/webpack2/concepts/output/</a></li>\n</ul>\n<h2 id=\"加载器loader\"><a class=\"markdownIt-Anchor\" href=\"#加载器loader\"></a> 加载器(Loader)</h2>\n<ul>\n<li>webpack 的目标是，让 webpack 聚焦于项目中的所有资源(asset)，而浏览器不需要关注考虑这些（这并不意味着资源(asset)都必须打包在一起）。webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。而且 webpack 只理解 JavaScript</li>\n<li>webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中</li>\n<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules</li>\n<li>webparck默认加载的是js，如果要加载如css，需要额外loader</li>\n</ul>\n<ol>\n<li>npm install style-loader css-loader -D</li>\n<li>在webpack中，多个loader加载通过！连接，后面的“-loader可以省略”，如：require(“style!css!./mystyle.css”)</li>\n</ol>\n<h2 id=\"插件plugins\"><a class=\"markdownIt-Anchor\" href=\"#插件plugins\"></a> 插件(Plugins)</h2>\n<p>想要使用一个插件，</p>\n<ol>\n<li>需要 require() 它，</li>\n<li>它添加到 plugins 数组中</li>\n<li>多数插件可以通过选项(option)自定义</li>\n<li>由于需要在一个配置中，多次使用一个插件，来针对不同的目的，因此你需要使用 new 来创建插件的实例，并且通过实例来调用插件</li>\n</ol>\n<p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个 compilation 生命周期访问</p>\n<p>webpack.config.js示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm</span><br><span class=\"line\">const webpack = require(&apos;webpack&apos;); //to access built-in plugins</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class=\"line\">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;test: /\\.(js|jsx)$/, use: &apos;babel-loader&apos;&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<h1 id=\"webpack安装及起步\"><a class=\"markdownIt-Anchor\" href=\"#webpack安装及起步\"></a> webpack安装及起步</h1>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h2>\n<ul>\n<li>cnpm install webpack-cli -g//webpack的cli环境</li>\n<li>cnpm install webpack-dev-server //webpack的自带服务器</li>\n</ul>\n<p>运行：</p>\n<ol>\n<li>开发环境：webpack</li>\n<li>生产环境：webpack -p //会压缩</li>\n<li>监听模式：webpack -w //自动编译</li>\n<li>开启sourcemaps：webpack -d //方便调试</li>\n</ol>\n<h2 id=\"起步\"><a class=\"markdownIt-Anchor\" href=\"#起步\"></a> 起步</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir webpack-demo &amp;&amp; cd webpack-demo</span><br><span class=\"line\">npm init -y</span><br><span class=\"line\">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>\n<p>创建并编辑app/index.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import _ from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function component () &#123;</span><br><span class=\"line\">  var element = document.createElement(&apos;div&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  /* 需要引入 lodash，下一行才能正常工作 */</span><br><span class=\"line\">  element.innerHTML = _.join([&apos;Hello&apos;,&apos;webpack&apos;], &apos; &apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">document.body.appendChild(component());</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save lodash</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;webpack 2 demo&lt;/title&gt; </span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt; </span><br><span class=\"line\">       &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack</span><br><span class=\"line\">查看浏览器index.html页面内容：Hello webpack</span><br></pre></td></tr></table></figure>\n<p>#代码拆分<br>\n分离资源，实现缓存资源和并行加载资源:</p>\n<ul>\n<li>一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改</li>\n<li>如果我们将这些库(library)中的代码，保留到与应用程序代码相独立的 bundle 上，我们就可以利用浏览器缓存机制，把这些文件长时间的缓存到用户的机器上</li>\n</ul>\n<h2 id=\"css分割\"><a class=\"markdownIt-Anchor\" href=\"#css分割\"></a> CSS分割</h2>\n<p>要通过webpack打包CSS，像任何其他模块一样将CSS导入JavaScript代码，并使用css-loader（它输出CSS作为JS模块），并可选地应用ExtractTextWebpackPlugin（它提取打包的CSS并输出CSS文件</p>\n<ol>\n<li>导入 CSS</li>\n</ol>\n<ul>\n<li>import ‘bootstrap/dist/css/bootstrap.css’;</li>\n</ul>\n<ol start=\"2\">\n<li>使用 css-loader:webpack.config.js中配置 css-loader</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [&#123;</span><br><span class=\"line\">            test: /\\.css$/,</span><br><span class=\"line\">            use: &apos;css-loader&apos;</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用 ExtractTextWebpackPlugin</li>\n</ol>\n<ul>\n<li>npm install --save-dev extract-text-webpack-plugin</li>\n</ul>\n<ol start=\"4\">\n<li>webpack.config.js中添加插件配置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">         rules: [&#123;</span><br><span class=\"line\">             test: /\\.css$/,</span><br><span class=\"line\">-            use: &apos;css-loader&apos;</span><br><span class=\"line\">+            use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">+                use: &apos;css-loader&apos;</span><br><span class=\"line\">+            &#125;)</span><br><span class=\"line\">         &#125;]</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">+    plugins: [</span><br><span class=\"line\">+        new ExtractTextPlugin(&apos;styles.css&apos;),</span><br><span class=\"line\">+    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"libraries分割\"><a class=\"markdownIt-Anchor\" href=\"#libraries分割\"></a> Libraries分割</h2>\n<p>默认会将库文件打包，可通过为库，如moment 添加一个单独的入口点并将其命名为 vendor 来缓解这一情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function(env) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        entry: &#123;</span><br><span class=\"line\">            main: &apos;./index.js&apos;,</span><br><span class=\"line\">            vendor: &apos;moment&apos;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            filename: &apos;[chunkhash].[name].js&apos;,</span><br><span class=\"line\">            path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行webpakc生成了两个 bundle，都包含lodash，所以还需要插件</p>\n<ul>\n<li>CommonsChunkPlugin：它从根本上允许我们从不同的 bundle 中提取所有的公共模块，并且将他们加入公共 bundle 中。如果公共 bundle 不存在，那么它将会创建一个出来</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpack = require(&apos;webpack&apos;);</span><br><span class=\"line\">var path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function(env) &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        entry: &#123;</span><br><span class=\"line\">            main: &apos;./index.js&apos;,</span><br><span class=\"line\">            vendor: &apos;moment&apos;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            filename: &apos;[chunkhash].[name].js&apos;,</span><br><span class=\"line\">            path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">                name: &apos;vendor&apos; // 指定公共 bundle 的名字。</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上完成之后，每次运行的vendor文件的hash码会改变，需在plugins配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">        names: [&apos;vendor&apos;, &apos;manifest&apos;] // 指定公共 bundle 的名字</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>将运行时代码提取到一个单独的 manifest 文件中就解决了</p>\n<h2 id=\"生产环境构建\"><a class=\"markdownIt-Anchor\" href=\"#生产环境构建\"></a> 生产环境构建</h2>\n<ol>\n<li>自动方式</li>\n</ol>\n<ul>\n<li>运行webpack -p (也可以运行 webpack --optimize-minimize --define process.env.NODE_ENV=&quot;‘production’&quot;, 他们是等效的). 它会执行如下步骤:</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>使用UglifyJsPlugin进行 JS文件压缩</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>运行LoaderOptionsPlugin</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>设置Node环境变量</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>手动方式: 为多环境配置Webpack<br>\n编写一个基本配置文件,把所有公用的功能放在里面。再编写特定环境的文件,使用’webpack-merge’来合并他们</li>\n</ol>\n<p>base.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        entry: &#123; </span><br><span class=\"line\">            &apos;vendor&apos;: &apos;./src/vendor.ts&apos;,</span><br><span class=\"line\">            &apos;main&apos;: &apos;./src/main.ts&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            path: path.join(__dirname, &apos;/../dist/assets&apos;),</span><br><span class=\"line\">            filename: &apos;[name].bundle.js&apos;,</span><br><span class=\"line\">            publicPath: publicPath,</span><br><span class=\"line\">            sourceMapFilename: &apos;[name].map&apos;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        resolve: &#123;</span><br><span class=\"line\">            extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;],</span><br><span class=\"line\">            modules: [path.join(__dirname, &apos;src&apos;), &apos;node_modules&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        module: &#123;</span><br><span class=\"line\">            loaders: [&#123;</span><br><span class=\"line\">                test: /\\.css$/,</span><br><span class=\"line\">                loaders: [&apos;to-string-loader&apos;, &apos;css-loader&apos;]</span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                test: /\\.(jpg|png|gif)$/,</span><br><span class=\"line\">                loader: &apos;file-loader&apos;</span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                test: /\\.(woff|woff2|eot|ttf|svg)$/,</span><br><span class=\"line\">                loader: &apos;url-loader?limit=100000&apos;</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            new ForkCheckerPlugin(),</span><br><span class=\"line\"></span><br><span class=\"line\">            new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">                name: [&apos;polyfills&apos;, &apos;vendor&apos;].reverse()</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">                template: &apos;src/index.html&apos;,</span><br><span class=\"line\">                chunksSortMode: &apos;dependency&apos;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用’webpack-merge’合并这个基础配置和针对环境的特定的配置</p>\n<p>prod.js (updated)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpackMerge = require(&apos;webpack-merge&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const commonConfig = require(&apos;./base.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function(env) &#123;</span><br><span class=\"line\">    return webpackMerge(commonConfig(), &#123;</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            new webpack.LoaderOptionsPlugin(&#123;</span><br><span class=\"line\">                minimize: true,</span><br><span class=\"line\">                debug: false</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">                &apos;process.env&apos;: &#123;</span><br><span class=\"line\">                    &apos;NODE_ENV&apos;: JSON.stringify(&apos;prod&apos;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">                beautify: false,</span><br><span class=\"line\">                mangle: &#123;</span><br><span class=\"line\">                    screw_ie8: true,</span><br><span class=\"line\">                    keep_fnames: true</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                compress: &#123;</span><br><span class=\"line\">                    screw_ie8: true</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                comments: false</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"缓存\"><a class=\"markdownIt-Anchor\" href=\"#缓存\"></a> 缓存</h1>\n<blockquote>\n<p>这一块没有理解，需重新看<br>\n为了能够长期缓存webpack生成的静态资源:</p>\n</blockquote>\n<ol>\n<li>使用[chunkhash]向每个文件添加一个依赖于内容的缓存杀手(cache-buster)</li>\n<li>将webpack mainfest提取到一个单独的文件中去</li>\n<li>对于一组依赖关系相同的资源，确保包含引导代码的入口起点模块(entrychunk)不会随时间改变它的哈希值</li>\n<li>当需要在HTML中加载资源时，使用编译器统计信息(compiler stats)来获取文件名</li>\n<li>生成模块清单(chunk manifest)的JSON内容，并在页面资源加载之前内联进HTML中去</li>\n</ol>\n<ul>\n<li>将开发和生产模式的配置分开，并在开发模式中使用[name].js的文件名， 在生产模式中使用[name].[chunkhash].js文件名</li>\n<li>为了在HTML中引用正确的文件,因为有hash生存文件名的一部分，可以使用下面这个插件，从webpack编译统计中提取：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">const path = require(&quot;path&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123; </span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    function() &#123;</span><br><span class=\"line\">      this.plugin(&quot;done&quot;, function(stats) &#123;</span><br><span class=\"line\">        require(&quot;fs&quot;).writeFileSync(</span><br><span class=\"line\">          path.join(__dirname, &quot;build&quot;, &quot;stats.json&quot;),</span><br><span class=\"line\">          JSON.stringify(stats.toJson()));</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>或者使用插件：<a href=\"https://www.npmjs.com/package/webpack-manifest-plugin\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/webpack-manifest-plugin</a></p>\n<h1 id=\"开发\"><a class=\"markdownIt-Anchor\" href=\"#开发\"></a> 开发</h1>\n<h2 id=\"调整你的文本编辑器\"><a class=\"markdownIt-Anchor\" href=\"#调整你的文本编辑器\"></a> 调整你的文本编辑器</h2>\n<ul>\n<li>一些文本编辑器有“safe write”（安全写入）功能，并且默认启用。因此，保存文件后并不总是会导致 webpack 重新编译</li>\n<li>WebStorm - 在 Preferences &gt; Appearance &amp; Behavior &gt; System Settings 中取消选中 Use “safe write”</li>\n</ul>\n<h2 id=\"source-maps\"><a class=\"markdownIt-Anchor\" href=\"#source-maps\"></a> Source Maps</h2>\n<p>更多配置：<a href=\"http://www.css88.com/doc/webpack2/configuration/devtool/\" target=\"_blank\" rel=\"noopener\">http://www.css88.com/doc/webpack2/configuration/devtool/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtool:&apos;source-map&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择一个工具\"><a class=\"markdownIt-Anchor\" href=\"#选择一个工具\"></a> 选择一个工具</h2>\n<ul>\n<li>webpack 可以在 watch mode(监视模式)下使用。在这种模式下，webpack 将监视您的文件，并在更改时重新编译</li>\n<li>webpack-dev-server 提供了一个易于部署的开发服务器，具有快速的实时重载（live reloading）功能</li>\n<li>如果你已经有一个开发服务器并且需要完全的灵活性，可以使用 webpack-dev-middleware 作为中间件</li>\n</ul>\n<h3 id=\"webpack-dev-server\"><a class=\"markdownIt-Anchor\" href=\"#webpack-dev-server\"></a> webpack-dev-server</h3>\n<ol>\n<li>npm install webpack-dev-server --save-dev</li>\n<li>webpack-dev-server --open</li>\n</ol>\n<h3 id=\"webpack-dev-middleware\"><a class=\"markdownIt-Anchor\" href=\"#webpack-dev-middleware\"></a> webpack-dev-middleware</h3>\n<p>webpack-dev-middleware 适用于基于链接的中间件环境（connect-based middleware stacks）。如果你已经有一个 Node.js 服务器或者你想要完全控制服务器，这将很实用</p>\n<ol>\n<li>npm install express webpack-dev-middleware --save-dev</li>\n<li>使用</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&quot;express&quot;);</span><br><span class=\"line\">var webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);</span><br><span class=\"line\">var webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">var webpackConfig = require(&quot;./webpack.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var app = express();</span><br><span class=\"line\">var compiler = webpack(webpackConfig);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class=\"line\">  publicPath: &quot;/&quot; // 大部分情况下和 `output.publicPath`相同</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000, function () &#123;</span><br><span class=\"line\">  console.log(&quot;Listening on port 3000!&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>根据你在 output.publicPath 和 output.filename 中设置的内容，你的 bundle 现在应该在 <a href=\"http://localhost:3000/bundle.js\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/bundle.js</a> 中可以看到了<br>\n3. 默认情况下会使用watch mode。也可以使用 lazy mode，这使得 webpack 只在对入口点进行请求时再进行重新编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class=\"line\">  lazy: true,</span><br><span class=\"line\">  filename: &quot;bundle.js&quot; // Same as `output.filename` in most cases.</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>命令说明</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* webpack-dev-server  //默认8080</span><br><span class=\"line\">* webpack-dev-server --port 8088</span><br><span class=\"line\">* webpack-dev-server --inline //改变代码之后，自动刷新浏览器</span><br><span class=\"line\">* webpack-dev-server --hot //热重载（局部更改）</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>此功能设置在webpack.config.js配置文件中如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer:&#123;</span><br><span class=\"line\">    port:8088,</span><br><span class=\"line\">    inline:true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>也可以配置在package.json文件中，如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;:&#123;</span><br><span class=\"line\">    &quot;dev&quot;:&quot;webpack-dev-server --port 8088 --inline --hot&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ run npm dev</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>resolve配置</li>\n</ol>\n<ul>\n<li>配置扩展名,即代码中引用的时候可以省略后缀</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve:&#123;</span><br><span class=\"line\">    &quot;extensions&quot;:[&apos;&apos;,&apos;.js&apos;,&apos;.css&apos;,&apos;.json&apos;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配合babel的使用\"><a class=\"markdownIt-Anchor\" href=\"#配合babel的使用\"></a> 配合babel的使用</h2>\n<p>以下为react配合webpack的各种依赖库：</p>\n<ul>\n<li>cnpm install babel-core -D</li>\n<li>cnpm install babel-preset-es2015 --save-dev</li>\n<li>cnpm install babel-loader -D</li>\n</ul>\n<p>设置js的转换</p>\n<ol>\n<li>通过weback.config.js设置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">moudule:&#123;</span><br><span class=\"line\">    loaders:[</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test:/\\.js$/,</span><br><span class=\"line\">            loader:&apos;babel&apos;,</span><br><span class=\"line\">            exclude:/node_moudules/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">babel:&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[&apos;es2015&apos;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过.babelrc文件，文件内容为：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[&quot;es2015&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配合react使用\"><a class=\"markdownIt-Anchor\" href=\"#配合react使用\"></a> 配合react使用</h2>\n<p>前提：配合babel的配置已经安装</p>\n<ul>\n<li>cnpm install babel-preset-react -D //babel的react预设，babel可以给其他用，react是支持的一种</li>\n<li>cnpm install react-hot-loader</li>\n<li>设置预设.babelrc</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[</span><br><span class=\"line\">        [&quot;es2015&quot;],</span><br><span class=\"line\">        [&quot;react&quot;]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>预设webpack.config</li>\n</ul>\n"},{"title":"oracle","copyright":true,"comments":1,"toc":true,"date":"2018-12-12T15:11:39.000Z","password":null,"_content":"\n官网：https://www.oracle.com/index.html\n版本中字母的含义：c（cloud）、g（grid）、i（internet）\n\n下载：https://www.oracle.com/downloads/，需要登录oracle官网，下载的两个文件解压在一个文件夹中\n\n安装：\n1. 安装Oracle11g出现INS-13001环境不满足最低要求 https://blog.csdn.net/q_sea__/article/details/79012808\n2.  Environment variable: \"PATH\"\n安装时确保不要关机或断电；安装过程中复制文件过程比较耗费时间\n\n完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 \n1) 数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）； \n2) Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区。\n\n在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，称为全局区（SGA）。\n\n\n数据库的创建与监听器的配置54C\n创建数据库:Database Conguration Assistant,可以创建、配置、删除、管理数据库\n全局数据库名称为数据库名称，其至少要有一个Oracle实例引用，该实例由SID唯一标识,如：orcl\n配置Enterprise Manager会占用较大内存，先不配置;注意选择字符集;修改scott和hr的密码\nsys用户为数据库的所有者，system用户为数据库的操作员\n监听器的配置：Net Conguration Assistant，配置完成后在系统服务中查看添加了OracleOraDb11g_home1TNSListener,此服务启动之后就允许外部连接数据库了\nOracleServiceORCL是关于数据库实例的服务，此服务启动之后，数据库才可用\n\noracle常用数据库工具\nOracle Universal Installer：OUI（Oracle全局安装器），用来安装卸载oracle数据库管理系统\nDatabase Conguration Assistant：(DBCA)创建、配置、删除、管理数据库\nNet Conguration Assistant：(NCA)监听器、命名方法、本地网络服务名、目录使用配置\nSQL Plus：基于命令行的oracle官方操作工具\nSQL Devloper：基于Java的图形化的oracle官方操作工具,需人工关联sqldeveloper.exe文件和配置JDK\nPL/SQL Devloper：第三方工具\nTOAD：第三方工具\n\nOracle中的用户、权限与角色\n用户管理：需切换到system用户操作\n    创建用户：create user 用户名 identified by 密码 [account lock|unlock] [password expire];（password expire表示密码立即过期，第一次登录后需修改密码）用户创建后还需授权才能操作数据库\n    修改用户：alter user 用户名 identified by 密码 [account lock|unlock] [password expire];\n    删除用户：drop user 用户名 [cascade];(cascade用来表示删除用户下的所有数据对象)\n权限管理：权限为系统中设置的安全规则或安全策略，分为系统权限（用户能否在数据库上完成某个动作）和对象权限（用户能否在某个数据库对象上完成某种操作）\n    系统权限授予：grant 权限 to user|role [with admin option];(表示可以级联授予)\n    系统权限回收：revoke 权限 from user|role;\n    对象权限授予：grant 权限[(col,...)] on 数据库对象 to user|role [with admin option];\n    对象权限回收：revoke 权限[(col,...)] on 数据库对象 from user|role;\n    对象权限的回收是级联的，系统权限回收是非级联的\n角色管理：角色是权限的集合，用来简化权限管理\n    创建／删除角色：create/drop role 角色;\n    角色上系统权限授予：grant 权限 to role [with admin option];(表示可以级联授予)\n    角色上系统权限回收：revoke 权限 from 角色;\n    角色上对象权限授予：grant 权限[(col,...)] on 数据库对象 to role [with admin option]; \n    角色上对象权限回收：revoke 权限[(col,...)] on 数据库对象 from role;\n    用户角色授予：grant 角色 to 用户;\n    用户角色回收：revoke 角色 from 用户;\n    \nOracle表：由行和列组成的数据库中基本的存储单元，访问其他用户的表需要加用户名作为前缀\n约束：表级别约束和列级别约束，由主键、外键、非空、唯一、检查5种约束\n启用表的只读状态便于备份和导出表：alter table 表名 read only;启用表的读写状态：alter table 表名 read write;\n\nOracle事务:有一组DML组成的逻辑工作单元，有原子性、一致性、独立性和持久性\n\n序列sequence：数值生成器，通常用于生成主键值，\n\ndual是Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用，只有一条记录:'X',习惯上,我们称之为'伪表',他的存在是为了操作上的方便,因为select都是要有特定对象的.\nselect count(*) from dual;\n\n索引和同义词的使用\n索引：通过关联ROWID和关键值来提升查询速度\n同义词：数据库对象的别名，public同义词对所有用户有用，创建需一定权限\n    创建：create [public] synonym 名称 for object;\n    删除：drop [public] synonym 名称 for object;\n\nPL/SQL：是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点\n官网：https://www.oracle.com/technetwork/database/features/plsql/index.html\nPL/SQL developer官网：https://www.allroundautomations.com/\nPLSQL Developer 12 注册码\nproduct code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le \nserial Number：226959 \npassword: xs374ca\n\n配置pl/sql的Database的两种方式：\n确保OracleOraDb11g_home1TNSListener和OracleServiceXXXX服务已启动\n1.登录时直接在Database选项输入数据库信息:在登录时输入数据库信息 ip:端口/数据库名,如：127.0.0.1:1521/ORCL\n2.配置product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\tnsnames.ora文件，添加一下内容到文档最后，登录时输入如ORCL即可登录\nORCL =\n  (DESCRIPTION =\n    (ADDRESS_LIST =\n        (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))\n    )\n    (CONNECT_DATA =\n            (SERVER = DEDICATED)\n        (SERVICE_NAME = ORCL)\n    )\n  )\n  \nhttps://www.jikexueyuan.com/course/oracledb/\n\nhttps://www.oracle.com/technetwork/topics/winsoft-085727.html\n\nhttps://www.cnblogs.com/xiashiwendao/p/7634240.html\n\n严格来讲SQL会分为三种类型:\n\n1、数据操纵语言（DML）：用来操纵数据库中数据的命令。包括：select、insert、update、delete。\n\n2、数据定义语言（DDL）：用来建立数据库、数据库对象和定义列的命令。包括：create、alter、drop。\n\n3、数据控制语言（DCL）：用来控制数据库组件\n\n用select * from tab;来查询用户下的表\n查看表结构用:DESC 表名称 \n \n \nhttps://www.cnblogs.com/adforce/p/3312252.html\n全局数据库名：就是一个数据库的标识，在安装时就要想好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。\n启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间，用户，表了。\n\n查询当前数据库名：select name from v$database;\n\n我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。\n实例名指的是用于响应某个数据库操作的数据库管理系统的名称。她同时也叫SID。实例名是由参数instance_name决定的\n查询当前数据库实例名：select instance_name from v$instance;\n\n\n从oracle9i版本开始，引入了一个新的参数，即数据库服务名。数据库的逻辑表示，它是数据库呈现给客户机的方式。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。\n\n网络服务名(NET SERVICES NAME)\n         它是“连接描述符”简称，连接描述符是网络连接目标特殊格式的描述，它包括网络协议、主机名称或地址、和目标服务\n         在Oracle7和Oracle8版本,目标服务由Oracle系统标识符(SID)来标识，而Oracle8i、Oracle9i则通过数据库服务名来来标识。保存tnsnames.ora文件中在格式如下：\n myDB =\n   (DESCRIPTION =\n     (ADDRESS_LIST =\n       (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.1)(PORT = 1521))\n     )\n     (CONNECT_DATA =\n       (SERVICE_NAME = testDB.ChinaMobile.com)\n     )\n   )  \n\n若要向ORACLE代理商购买ORACLE，是以用户数来算钱的。那么，这个“用户”跟我们在ORACLE中通过\n\nCREATE USER USERNAME IDENTIFIED BY PASSWORD创建的用户是不同概念，“用户数”指的是并发访问用户数，\n\n（我理解是同时间访问同一个内存地址的进程数）。要是我买了8个用户的，可以建几十、上百个用户也没问题，只要峰值达不到并发数就可以了。\n\n打个比方，你的名字叫小明，但是你有很多外号。你父母叫你小明，但是朋友都叫你的外号。\n这里你的父母就是oracle实例，小明就是sid，service name就是你的外号。\nsid用于实例区分各个数据库，service name用于外部链接。\n\n一个Oracle Server由一个Oracle实例和一个Oracle数据库组成。\n即：Oracle Server = Oracle Instance + Oracle Database\n\nOracle实例包括了内存结构(SGA)和一系列后台进程(Background Process),两者合起来称为一个Oracle实例，即：Oracle Instance = SGA + Background Process\n\n\n数据库逻辑组织结构\n表空间、段、区、块\n一个数据库由一个或多个表空间组成，一个表空间只能属于一个数据库\n一个表空间由一个或多个多个数据文件组成，一个数据文件只能属于一个表空间\n一个数据文件由一个或多个操作系统块组成，每一个操作系统块只能数以一个数据文件\n一个表空间可以包含一个或多个段，一个段只能属于一个表空间\n一个段由一个或多个区组成，每一个区只能属于一个段\n一个区由一个或多个Oracle 块组成，每一个Oracle块只能属于一个区\n一个区只能属于一个数据文件，数据文件的空间可以分配到一个或多个区\n一个Oracle 块由一个或多个操作系统块组成，一个操作系统块是一个Oracle块的一部分\n\n\nhttps://blog.csdn.net/prince_lintb/article/details/78772999\n\npl/sql plus： \"／\"表示执行\n\n\nscott库：https://www.2cto.com/database/201805/742911.html\n\nhttps://www.cnblogs.com/adforce/p/3312252.html\nhttp://www.cnblogs.com/kscnchina/p/4570865.html\n\n声明时，变量以v_开头，常量以c_开头\n\nhttps://blog.csdn.net/michaelehome/article/details/79464214\n\nselect userenv('language') from dual;\nNLS_LANG=\"AMERICAN_AMERICA.AL32UTF8\"\n\n字符集：https://www.cnblogs.com/kaishirenshi/p/9018343.html\n\n本地动态sql\n\n\nSQL环境  begin .. end pl/sql环境\n\n一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。","source":"_posts/数据库/2018-12-12-oracle.md","raw":"---\ntitle: oracle\ntags:\n  - Oracle \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-12 23:11:39\ncategories: 数据库\npassword:\n---\n\n官网：https://www.oracle.com/index.html\n版本中字母的含义：c（cloud）、g（grid）、i（internet）\n\n下载：https://www.oracle.com/downloads/，需要登录oracle官网，下载的两个文件解压在一个文件夹中\n\n安装：\n1. 安装Oracle11g出现INS-13001环境不满足最低要求 https://blog.csdn.net/q_sea__/article/details/79012808\n2.  Environment variable: \"PATH\"\n安装时确保不要关机或断电；安装过程中复制文件过程比较耗费时间\n\n完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 \n1) 数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）； \n2) Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区。\n\n在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，称为全局区（SGA）。\n\n\n数据库的创建与监听器的配置54C\n创建数据库:Database Conguration Assistant,可以创建、配置、删除、管理数据库\n全局数据库名称为数据库名称，其至少要有一个Oracle实例引用，该实例由SID唯一标识,如：orcl\n配置Enterprise Manager会占用较大内存，先不配置;注意选择字符集;修改scott和hr的密码\nsys用户为数据库的所有者，system用户为数据库的操作员\n监听器的配置：Net Conguration Assistant，配置完成后在系统服务中查看添加了OracleOraDb11g_home1TNSListener,此服务启动之后就允许外部连接数据库了\nOracleServiceORCL是关于数据库实例的服务，此服务启动之后，数据库才可用\n\noracle常用数据库工具\nOracle Universal Installer：OUI（Oracle全局安装器），用来安装卸载oracle数据库管理系统\nDatabase Conguration Assistant：(DBCA)创建、配置、删除、管理数据库\nNet Conguration Assistant：(NCA)监听器、命名方法、本地网络服务名、目录使用配置\nSQL Plus：基于命令行的oracle官方操作工具\nSQL Devloper：基于Java的图形化的oracle官方操作工具,需人工关联sqldeveloper.exe文件和配置JDK\nPL/SQL Devloper：第三方工具\nTOAD：第三方工具\n\nOracle中的用户、权限与角色\n用户管理：需切换到system用户操作\n    创建用户：create user 用户名 identified by 密码 [account lock|unlock] [password expire];（password expire表示密码立即过期，第一次登录后需修改密码）用户创建后还需授权才能操作数据库\n    修改用户：alter user 用户名 identified by 密码 [account lock|unlock] [password expire];\n    删除用户：drop user 用户名 [cascade];(cascade用来表示删除用户下的所有数据对象)\n权限管理：权限为系统中设置的安全规则或安全策略，分为系统权限（用户能否在数据库上完成某个动作）和对象权限（用户能否在某个数据库对象上完成某种操作）\n    系统权限授予：grant 权限 to user|role [with admin option];(表示可以级联授予)\n    系统权限回收：revoke 权限 from user|role;\n    对象权限授予：grant 权限[(col,...)] on 数据库对象 to user|role [with admin option];\n    对象权限回收：revoke 权限[(col,...)] on 数据库对象 from user|role;\n    对象权限的回收是级联的，系统权限回收是非级联的\n角色管理：角色是权限的集合，用来简化权限管理\n    创建／删除角色：create/drop role 角色;\n    角色上系统权限授予：grant 权限 to role [with admin option];(表示可以级联授予)\n    角色上系统权限回收：revoke 权限 from 角色;\n    角色上对象权限授予：grant 权限[(col,...)] on 数据库对象 to role [with admin option]; \n    角色上对象权限回收：revoke 权限[(col,...)] on 数据库对象 from role;\n    用户角色授予：grant 角色 to 用户;\n    用户角色回收：revoke 角色 from 用户;\n    \nOracle表：由行和列组成的数据库中基本的存储单元，访问其他用户的表需要加用户名作为前缀\n约束：表级别约束和列级别约束，由主键、外键、非空、唯一、检查5种约束\n启用表的只读状态便于备份和导出表：alter table 表名 read only;启用表的读写状态：alter table 表名 read write;\n\nOracle事务:有一组DML组成的逻辑工作单元，有原子性、一致性、独立性和持久性\n\n序列sequence：数值生成器，通常用于生成主键值，\n\ndual是Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用，只有一条记录:'X',习惯上,我们称之为'伪表',他的存在是为了操作上的方便,因为select都是要有特定对象的.\nselect count(*) from dual;\n\n索引和同义词的使用\n索引：通过关联ROWID和关键值来提升查询速度\n同义词：数据库对象的别名，public同义词对所有用户有用，创建需一定权限\n    创建：create [public] synonym 名称 for object;\n    删除：drop [public] synonym 名称 for object;\n\nPL/SQL：是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点\n官网：https://www.oracle.com/technetwork/database/features/plsql/index.html\nPL/SQL developer官网：https://www.allroundautomations.com/\nPLSQL Developer 12 注册码\nproduct code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le \nserial Number：226959 \npassword: xs374ca\n\n配置pl/sql的Database的两种方式：\n确保OracleOraDb11g_home1TNSListener和OracleServiceXXXX服务已启动\n1.登录时直接在Database选项输入数据库信息:在登录时输入数据库信息 ip:端口/数据库名,如：127.0.0.1:1521/ORCL\n2.配置product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\tnsnames.ora文件，添加一下内容到文档最后，登录时输入如ORCL即可登录\nORCL =\n  (DESCRIPTION =\n    (ADDRESS_LIST =\n        (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))\n    )\n    (CONNECT_DATA =\n            (SERVER = DEDICATED)\n        (SERVICE_NAME = ORCL)\n    )\n  )\n  \nhttps://www.jikexueyuan.com/course/oracledb/\n\nhttps://www.oracle.com/technetwork/topics/winsoft-085727.html\n\nhttps://www.cnblogs.com/xiashiwendao/p/7634240.html\n\n严格来讲SQL会分为三种类型:\n\n1、数据操纵语言（DML）：用来操纵数据库中数据的命令。包括：select、insert、update、delete。\n\n2、数据定义语言（DDL）：用来建立数据库、数据库对象和定义列的命令。包括：create、alter、drop。\n\n3、数据控制语言（DCL）：用来控制数据库组件\n\n用select * from tab;来查询用户下的表\n查看表结构用:DESC 表名称 \n \n \nhttps://www.cnblogs.com/adforce/p/3312252.html\n全局数据库名：就是一个数据库的标识，在安装时就要想好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。\n启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间，用户，表了。\n\n查询当前数据库名：select name from v$database;\n\n我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。\n实例名指的是用于响应某个数据库操作的数据库管理系统的名称。她同时也叫SID。实例名是由参数instance_name决定的\n查询当前数据库实例名：select instance_name from v$instance;\n\n\n从oracle9i版本开始，引入了一个新的参数，即数据库服务名。数据库的逻辑表示，它是数据库呈现给客户机的方式。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。\n\n网络服务名(NET SERVICES NAME)\n         它是“连接描述符”简称，连接描述符是网络连接目标特殊格式的描述，它包括网络协议、主机名称或地址、和目标服务\n         在Oracle7和Oracle8版本,目标服务由Oracle系统标识符(SID)来标识，而Oracle8i、Oracle9i则通过数据库服务名来来标识。保存tnsnames.ora文件中在格式如下：\n myDB =\n   (DESCRIPTION =\n     (ADDRESS_LIST =\n       (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.1)(PORT = 1521))\n     )\n     (CONNECT_DATA =\n       (SERVICE_NAME = testDB.ChinaMobile.com)\n     )\n   )  \n\n若要向ORACLE代理商购买ORACLE，是以用户数来算钱的。那么，这个“用户”跟我们在ORACLE中通过\n\nCREATE USER USERNAME IDENTIFIED BY PASSWORD创建的用户是不同概念，“用户数”指的是并发访问用户数，\n\n（我理解是同时间访问同一个内存地址的进程数）。要是我买了8个用户的，可以建几十、上百个用户也没问题，只要峰值达不到并发数就可以了。\n\n打个比方，你的名字叫小明，但是你有很多外号。你父母叫你小明，但是朋友都叫你的外号。\n这里你的父母就是oracle实例，小明就是sid，service name就是你的外号。\nsid用于实例区分各个数据库，service name用于外部链接。\n\n一个Oracle Server由一个Oracle实例和一个Oracle数据库组成。\n即：Oracle Server = Oracle Instance + Oracle Database\n\nOracle实例包括了内存结构(SGA)和一系列后台进程(Background Process),两者合起来称为一个Oracle实例，即：Oracle Instance = SGA + Background Process\n\n\n数据库逻辑组织结构\n表空间、段、区、块\n一个数据库由一个或多个表空间组成，一个表空间只能属于一个数据库\n一个表空间由一个或多个多个数据文件组成，一个数据文件只能属于一个表空间\n一个数据文件由一个或多个操作系统块组成，每一个操作系统块只能数以一个数据文件\n一个表空间可以包含一个或多个段，一个段只能属于一个表空间\n一个段由一个或多个区组成，每一个区只能属于一个段\n一个区由一个或多个Oracle 块组成，每一个Oracle块只能属于一个区\n一个区只能属于一个数据文件，数据文件的空间可以分配到一个或多个区\n一个Oracle 块由一个或多个操作系统块组成，一个操作系统块是一个Oracle块的一部分\n\n\nhttps://blog.csdn.net/prince_lintb/article/details/78772999\n\npl/sql plus： \"／\"表示执行\n\n\nscott库：https://www.2cto.com/database/201805/742911.html\n\nhttps://www.cnblogs.com/adforce/p/3312252.html\nhttp://www.cnblogs.com/kscnchina/p/4570865.html\n\n声明时，变量以v_开头，常量以c_开头\n\nhttps://blog.csdn.net/michaelehome/article/details/79464214\n\nselect userenv('language') from dual;\nNLS_LANG=\"AMERICAN_AMERICA.AL32UTF8\"\n\n字符集：https://www.cnblogs.com/kaishirenshi/p/9018343.html\n\n本地动态sql\n\n\nSQL环境  begin .. end pl/sql环境\n\n一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。","slug":"数据库-2018-12-12-oracle","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue3t00e55b8hd09q45hm","content":"<p>官网：<a href=\"https://www.oracle.com/index.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/index.html</a><br>\n版本中字母的含义：c（cloud）、g（grid）、i（internet）</p>\n<p>下载：<a href=\"https://www.oracle.com/downloads/%EF%BC%8C%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95oracle%E5%AE%98%E7%BD%91%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/downloads/，需要登录oracle官网，下载的两个文件解压在一个文件夹中</a></p>\n<p>安装：</p>\n<ol>\n<li>安装Oracle11g出现INS-13001环境不满足最低要求 <a href=\"https://blog.csdn.net/q_sea__/article/details/79012808\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/q_sea__/article/details/79012808</a></li>\n<li>Environment variable: “PATH”<br>\n安装时确保不要关机或断电；安装过程中复制文件过程比较耗费时间</li>\n</ol>\n<p>完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。</p>\n<ol>\n<li>数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）；</li>\n<li>Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区。</li>\n</ol>\n<p>在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，称为全局区（SGA）。</p>\n<p>数据库的创建与监听器的配置54C<br>\n创建数据库:Database Conguration Assistant,可以创建、配置、删除、管理数据库<br>\n全局数据库名称为数据库名称，其至少要有一个Oracle实例引用，该实例由SID唯一标识,如：orcl<br>\n配置Enterprise Manager会占用较大内存，先不配置;注意选择字符集;修改scott和hr的密码<br>\nsys用户为数据库的所有者，system用户为数据库的操作员<br>\n监听器的配置：Net Conguration Assistant，配置完成后在系统服务中查看添加了OracleOraDb11g_home1TNSListener,此服务启动之后就允许外部连接数据库了<br>\nOracleServiceORCL是关于数据库实例的服务，此服务启动之后，数据库才可用</p>\n<p>oracle常用数据库工具<br>\nOracle Universal Installer：OUI（Oracle全局安装器），用来安装卸载oracle数据库管理系统<br>\nDatabase Conguration Assistant：(DBCA)创建、配置、删除、管理数据库<br>\nNet Conguration Assistant：(NCA)监听器、命名方法、本地网络服务名、目录使用配置<br>\nSQL Plus：基于命令行的oracle官方操作工具<br>\nSQL Devloper：基于Java的图形化的oracle官方操作工具,需人工关联sqldeveloper.exe文件和配置JDK<br>\nPL/SQL Devloper：第三方工具<br>\nTOAD：第三方工具</p>\n<p>Oracle中的用户、权限与角色<br>\n用户管理：需切换到system用户操作<br>\n创建用户：create user 用户名 identified by 密码 [account lock|unlock] [password expire];（password expire表示密码立即过期，第一次登录后需修改密码）用户创建后还需授权才能操作数据库<br>\n修改用户：alter user 用户名 identified by 密码 [account lock|unlock] [password expire];<br>\n删除用户：drop user 用户名 [cascade];(cascade用来表示删除用户下的所有数据对象)<br>\n权限管理：权限为系统中设置的安全规则或安全策略，分为系统权限（用户能否在数据库上完成某个动作）和对象权限（用户能否在某个数据库对象上完成某种操作）<br>\n系统权限授予：grant 权限 to user|role [with admin option];(表示可以级联授予)<br>\n系统权限回收：revoke 权限 from user|role;<br>\n对象权限授予：grant 权限[(col,…)] on 数据库对象 to user|role [with admin option];<br>\n对象权限回收：revoke 权限[(col,…)] on 数据库对象 from user|role;<br>\n对象权限的回收是级联的，系统权限回收是非级联的<br>\n角色管理：角色是权限的集合，用来简化权限管理<br>\n创建／删除角色：create/drop role 角色;<br>\n角色上系统权限授予：grant 权限 to role [with admin option];(表示可以级联授予)<br>\n角色上系统权限回收：revoke 权限 from 角色;<br>\n角色上对象权限授予：grant 权限[(col,…)] on 数据库对象 to role [with admin option];<br>\n角色上对象权限回收：revoke 权限[(col,…)] on 数据库对象 from role;<br>\n用户角色授予：grant 角色 to 用户;<br>\n用户角色回收：revoke 角色 from 用户;</p>\n<p>Oracle表：由行和列组成的数据库中基本的存储单元，访问其他用户的表需要加用户名作为前缀<br>\n约束：表级别约束和列级别约束，由主键、外键、非空、唯一、检查5种约束<br>\n启用表的只读状态便于备份和导出表：alter table 表名 read only;启用表的读写状态：alter table 表名 read write;</p>\n<p>Oracle事务:有一组DML组成的逻辑工作单元，有原子性、一致性、独立性和持久性</p>\n<p>序列sequence：数值生成器，通常用于生成主键值，</p>\n<p>dual是Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用，只有一条记录:‘X’,习惯上,我们称之为’伪表’,他的存在是为了操作上的方便,因为select都是要有特定对象的.<br>\nselect count(*) from dual;</p>\n<p>索引和同义词的使用<br>\n索引：通过关联ROWID和关键值来提升查询速度<br>\n同义词：数据库对象的别名，public同义词对所有用户有用，创建需一定权限<br>\n创建：create [public] synonym 名称 for object;<br>\n删除：drop [public] synonym 名称 for object;</p>\n<p>PL/SQL：是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点<br>\n官网：<a href=\"https://www.oracle.com/technetwork/database/features/plsql/index.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/database/features/plsql/index.html</a><br>\nPL/SQL developer官网：<a href=\"https://www.allroundautomations.com/\" target=\"_blank\" rel=\"noopener\">https://www.allroundautomations.com/</a><br>\nPLSQL Developer 12 注册码<br>\nproduct code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le<br>\nserial Number：226959<br>\npassword: xs374ca</p>\n<p>配置pl/sql的Database的两种方式：<br>\n确保OracleOraDb11g_home1TNSListener和OracleServiceXXXX服务已启动<br>\n1.登录时直接在Database选项输入数据库信息:在登录时输入数据库信息 ip:端口/数据库名,如：127.0.0.1:1521/ORCL<br>\n2.配置product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\tnsnames.ora文件，添加一下内容到文档最后，登录时输入如ORCL即可登录<br>\nORCL =<br>\n(DESCRIPTION =<br>\n(ADDRESS_LIST =<br>\n(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))<br>\n)<br>\n(CONNECT_DATA =<br>\n(SERVER = DEDICATED)<br>\n(SERVICE_NAME = ORCL)<br>\n)<br>\n)</p>\n<p><a href=\"https://www.jikexueyuan.com/course/oracledb/\" target=\"_blank\" rel=\"noopener\">https://www.jikexueyuan.com/course/oracledb/</a></p>\n<p><a href=\"https://www.oracle.com/technetwork/topics/winsoft-085727.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/topics/winsoft-085727.html</a></p>\n<p><a href=\"https://www.cnblogs.com/xiashiwendao/p/7634240.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiashiwendao/p/7634240.html</a></p>\n<p>严格来讲SQL会分为三种类型:</p>\n<p>1、数据操纵语言（DML）：用来操纵数据库中数据的命令。包括：select、insert、update、delete。</p>\n<p>2、数据定义语言（DDL）：用来建立数据库、数据库对象和定义列的命令。包括：create、alter、drop。</p>\n<p>3、数据控制语言（DCL）：用来控制数据库组件</p>\n<p>用select * from tab;来查询用户下的表<br>\n查看表结构用:DESC 表名称</p>\n<p><a href=\"https://www.cnblogs.com/adforce/p/3312252.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/adforce/p/3312252.html</a><br>\n全局数据库名：就是一个数据库的标识，在安装时就要想好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。<br>\n启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间，用户，表了。</p>\n<p>查询当前数据库名：select name from v$database;</p>\n<p>我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。<br>\n实例名指的是用于响应某个数据库操作的数据库管理系统的名称。她同时也叫SID。实例名是由参数instance_name决定的<br>\n查询当前数据库实例名：select instance_name from v$instance;</p>\n<p>从oracle9i版本开始，引入了一个新的参数，即数据库服务名。数据库的逻辑表示，它是数据库呈现给客户机的方式。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。</p>\n<p>网络服务名(NET SERVICES NAME)<br>\n         它是“连接描述符”简称，连接描述符是网络连接目标特殊格式的描述，它包括网络协议、主机名称或地址、和目标服务<br>\n         在Oracle7和Oracle8版本,目标服务由Oracle系统标识符(SID)来标识，而Oracle8i、Oracle9i则通过数据库服务名来来标识。保存tnsnames.ora文件中在格式如下：<br>\n myDB =<br>\n   (DESCRIPTION =<br>\n     (ADDRESS_LIST =<br>\n       (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.1)(PORT = 1521))<br>\n     )<br>\n     (CONNECT_DATA =<br>\n       (SERVICE_NAME = <a href=\"http://testDB.ChinaMobile.com\" target=\"_blank\" rel=\"noopener\">testDB.ChinaMobile.com</a>)<br>\n     )<br>\n   )</p>\n<p>若要向ORACLE代理商购买ORACLE，是以用户数来算钱的。那么，这个“用户”跟我们在ORACLE中通过</p>\n<p>CREATE USER USERNAME IDENTIFIED BY PASSWORD创建的用户是不同概念，“用户数”指的是并发访问用户数，</p>\n<p>（我理解是同时间访问同一个内存地址的进程数）。要是我买了8个用户的，可以建几十、上百个用户也没问题，只要峰值达不到并发数就可以了。</p>\n<p>打个比方，你的名字叫小明，但是你有很多外号。你父母叫你小明，但是朋友都叫你的外号。<br>\n这里你的父母就是oracle实例，小明就是sid，service name就是你的外号。<br>\nsid用于实例区分各个数据库，service name用于外部链接。</p>\n<p>一个Oracle Server由一个Oracle实例和一个Oracle数据库组成。<br>\n即：Oracle Server = Oracle Instance + Oracle Database</p>\n<p>Oracle实例包括了内存结构(SGA)和一系列后台进程(Background Process),两者合起来称为一个Oracle实例，即：Oracle Instance = SGA + Background Process</p>\n<p>数据库逻辑组织结构<br>\n表空间、段、区、块<br>\n一个数据库由一个或多个表空间组成，一个表空间只能属于一个数据库<br>\n一个表空间由一个或多个多个数据文件组成，一个数据文件只能属于一个表空间<br>\n一个数据文件由一个或多个操作系统块组成，每一个操作系统块只能数以一个数据文件<br>\n一个表空间可以包含一个或多个段，一个段只能属于一个表空间<br>\n一个段由一个或多个区组成，每一个区只能属于一个段<br>\n一个区由一个或多个Oracle 块组成，每一个Oracle块只能属于一个区<br>\n一个区只能属于一个数据文件，数据文件的空间可以分配到一个或多个区<br>\n一个Oracle 块由一个或多个操作系统块组成，一个操作系统块是一个Oracle块的一部分</p>\n<p><a href=\"https://blog.csdn.net/prince_lintb/article/details/78772999\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/prince_lintb/article/details/78772999</a></p>\n<p>pl/sql plus： &quot;／&quot;表示执行</p>\n<p>scott库：<a href=\"https://www.2cto.com/database/201805/742911.html\" target=\"_blank\" rel=\"noopener\">https://www.2cto.com/database/201805/742911.html</a></p>\n<p><a href=\"https://www.cnblogs.com/adforce/p/3312252.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/adforce/p/3312252.html</a><br>\n<a href=\"http://www.cnblogs.com/kscnchina/p/4570865.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/kscnchina/p/4570865.html</a></p>\n<p>声明时，变量以v_开头，常量以c_开头</p>\n<p><a href=\"https://blog.csdn.net/michaelehome/article/details/79464214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/michaelehome/article/details/79464214</a></p>\n<p>select userenv(‘language’) from dual;<br>\nNLS_LANG=“AMERICAN_AMERICA.AL32UTF8”</p>\n<p>字符集：<a href=\"https://www.cnblogs.com/kaishirenshi/p/9018343.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kaishirenshi/p/9018343.html</a></p>\n<p>本地动态sql</p>\n<p>SQL环境  begin … end pl/sql环境</p>\n<p>一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"https://www.oracle.com/index.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/index.html</a><br>\n版本中字母的含义：c（cloud）、g（grid）、i（internet）</p>\n<p>下载：<a href=\"https://www.oracle.com/downloads/%EF%BC%8C%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95oracle%E5%AE%98%E7%BD%91%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/downloads/，需要登录oracle官网，下载的两个文件解压在一个文件夹中</a></p>\n<p>安装：</p>\n<ol>\n<li>安装Oracle11g出现INS-13001环境不满足最低要求 <a href=\"https://blog.csdn.net/q_sea__/article/details/79012808\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/q_sea__/article/details/79012808</a></li>\n<li>Environment variable: “PATH”<br>\n安装时确保不要关机或断电；安装过程中复制文件过程比较耗费时间</li>\n</ol>\n<p>完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。</p>\n<ol>\n<li>数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等）；</li>\n<li>Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区。</li>\n</ol>\n<p>在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，称为全局区（SGA）。</p>\n<p>数据库的创建与监听器的配置54C<br>\n创建数据库:Database Conguration Assistant,可以创建、配置、删除、管理数据库<br>\n全局数据库名称为数据库名称，其至少要有一个Oracle实例引用，该实例由SID唯一标识,如：orcl<br>\n配置Enterprise Manager会占用较大内存，先不配置;注意选择字符集;修改scott和hr的密码<br>\nsys用户为数据库的所有者，system用户为数据库的操作员<br>\n监听器的配置：Net Conguration Assistant，配置完成后在系统服务中查看添加了OracleOraDb11g_home1TNSListener,此服务启动之后就允许外部连接数据库了<br>\nOracleServiceORCL是关于数据库实例的服务，此服务启动之后，数据库才可用</p>\n<p>oracle常用数据库工具<br>\nOracle Universal Installer：OUI（Oracle全局安装器），用来安装卸载oracle数据库管理系统<br>\nDatabase Conguration Assistant：(DBCA)创建、配置、删除、管理数据库<br>\nNet Conguration Assistant：(NCA)监听器、命名方法、本地网络服务名、目录使用配置<br>\nSQL Plus：基于命令行的oracle官方操作工具<br>\nSQL Devloper：基于Java的图形化的oracle官方操作工具,需人工关联sqldeveloper.exe文件和配置JDK<br>\nPL/SQL Devloper：第三方工具<br>\nTOAD：第三方工具</p>\n<p>Oracle中的用户、权限与角色<br>\n用户管理：需切换到system用户操作<br>\n创建用户：create user 用户名 identified by 密码 [account lock|unlock] [password expire];（password expire表示密码立即过期，第一次登录后需修改密码）用户创建后还需授权才能操作数据库<br>\n修改用户：alter user 用户名 identified by 密码 [account lock|unlock] [password expire];<br>\n删除用户：drop user 用户名 [cascade];(cascade用来表示删除用户下的所有数据对象)<br>\n权限管理：权限为系统中设置的安全规则或安全策略，分为系统权限（用户能否在数据库上完成某个动作）和对象权限（用户能否在某个数据库对象上完成某种操作）<br>\n系统权限授予：grant 权限 to user|role [with admin option];(表示可以级联授予)<br>\n系统权限回收：revoke 权限 from user|role;<br>\n对象权限授予：grant 权限[(col,…)] on 数据库对象 to user|role [with admin option];<br>\n对象权限回收：revoke 权限[(col,…)] on 数据库对象 from user|role;<br>\n对象权限的回收是级联的，系统权限回收是非级联的<br>\n角色管理：角色是权限的集合，用来简化权限管理<br>\n创建／删除角色：create/drop role 角色;<br>\n角色上系统权限授予：grant 权限 to role [with admin option];(表示可以级联授予)<br>\n角色上系统权限回收：revoke 权限 from 角色;<br>\n角色上对象权限授予：grant 权限[(col,…)] on 数据库对象 to role [with admin option];<br>\n角色上对象权限回收：revoke 权限[(col,…)] on 数据库对象 from role;<br>\n用户角色授予：grant 角色 to 用户;<br>\n用户角色回收：revoke 角色 from 用户;</p>\n<p>Oracle表：由行和列组成的数据库中基本的存储单元，访问其他用户的表需要加用户名作为前缀<br>\n约束：表级别约束和列级别约束，由主键、外键、非空、唯一、检查5种约束<br>\n启用表的只读状态便于备份和导出表：alter table 表名 read only;启用表的读写状态：alter table 表名 read write;</p>\n<p>Oracle事务:有一组DML组成的逻辑工作单元，有原子性、一致性、独立性和持久性</p>\n<p>序列sequence：数值生成器，通常用于生成主键值，</p>\n<p>dual是Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用，只有一条记录:‘X’,习惯上,我们称之为’伪表’,他的存在是为了操作上的方便,因为select都是要有特定对象的.<br>\nselect count(*) from dual;</p>\n<p>索引和同义词的使用<br>\n索引：通过关联ROWID和关键值来提升查询速度<br>\n同义词：数据库对象的别名，public同义词对所有用户有用，创建需一定权限<br>\n创建：create [public] synonym 名称 for object;<br>\n删除：drop [public] synonym 名称 for object;</p>\n<p>PL/SQL：是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点<br>\n官网：<a href=\"https://www.oracle.com/technetwork/database/features/plsql/index.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/database/features/plsql/index.html</a><br>\nPL/SQL developer官网：<a href=\"https://www.allroundautomations.com/\" target=\"_blank\" rel=\"noopener\">https://www.allroundautomations.com/</a><br>\nPLSQL Developer 12 注册码<br>\nproduct code： 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le<br>\nserial Number：226959<br>\npassword: xs374ca</p>\n<p>配置pl/sql的Database的两种方式：<br>\n确保OracleOraDb11g_home1TNSListener和OracleServiceXXXX服务已启动<br>\n1.登录时直接在Database选项输入数据库信息:在登录时输入数据库信息 ip:端口/数据库名,如：127.0.0.1:1521/ORCL<br>\n2.配置product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\tnsnames.ora文件，添加一下内容到文档最后，登录时输入如ORCL即可登录<br>\nORCL =<br>\n(DESCRIPTION =<br>\n(ADDRESS_LIST =<br>\n(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))<br>\n)<br>\n(CONNECT_DATA =<br>\n(SERVER = DEDICATED)<br>\n(SERVICE_NAME = ORCL)<br>\n)<br>\n)</p>\n<p><a href=\"https://www.jikexueyuan.com/course/oracledb/\" target=\"_blank\" rel=\"noopener\">https://www.jikexueyuan.com/course/oracledb/</a></p>\n<p><a href=\"https://www.oracle.com/technetwork/topics/winsoft-085727.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/topics/winsoft-085727.html</a></p>\n<p><a href=\"https://www.cnblogs.com/xiashiwendao/p/7634240.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiashiwendao/p/7634240.html</a></p>\n<p>严格来讲SQL会分为三种类型:</p>\n<p>1、数据操纵语言（DML）：用来操纵数据库中数据的命令。包括：select、insert、update、delete。</p>\n<p>2、数据定义语言（DDL）：用来建立数据库、数据库对象和定义列的命令。包括：create、alter、drop。</p>\n<p>3、数据控制语言（DCL）：用来控制数据库组件</p>\n<p>用select * from tab;来查询用户下的表<br>\n查看表结构用:DESC 表名称</p>\n<p><a href=\"https://www.cnblogs.com/adforce/p/3312252.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/adforce/p/3312252.html</a><br>\n全局数据库名：就是一个数据库的标识，在安装时就要想好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。<br>\n启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间，用户，表了。</p>\n<p>查询当前数据库名：select name from v$database;</p>\n<p>我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。<br>\n实例名指的是用于响应某个数据库操作的数据库管理系统的名称。她同时也叫SID。实例名是由参数instance_name决定的<br>\n查询当前数据库实例名：select instance_name from v$instance;</p>\n<p>从oracle9i版本开始，引入了一个新的参数，即数据库服务名。数据库的逻辑表示，它是数据库呈现给客户机的方式。参数名是SERVICE_NAME。如果数据库有域名，则数据库服务名就是全局数据库名；否则，数据库服务名与数据库名相同。</p>\n<p>网络服务名(NET SERVICES NAME)<br>\n         它是“连接描述符”简称，连接描述符是网络连接目标特殊格式的描述，它包括网络协议、主机名称或地址、和目标服务<br>\n         在Oracle7和Oracle8版本,目标服务由Oracle系统标识符(SID)来标识，而Oracle8i、Oracle9i则通过数据库服务名来来标识。保存tnsnames.ora文件中在格式如下：<br>\n myDB =<br>\n   (DESCRIPTION =<br>\n     (ADDRESS_LIST =<br>\n       (ADDRESS = (PROTOCOL = TCP)(HOST = 10.10.10.1)(PORT = 1521))<br>\n     )<br>\n     (CONNECT_DATA =<br>\n       (SERVICE_NAME = <a href=\"http://testDB.ChinaMobile.com\" target=\"_blank\" rel=\"noopener\">testDB.ChinaMobile.com</a>)<br>\n     )<br>\n   )</p>\n<p>若要向ORACLE代理商购买ORACLE，是以用户数来算钱的。那么，这个“用户”跟我们在ORACLE中通过</p>\n<p>CREATE USER USERNAME IDENTIFIED BY PASSWORD创建的用户是不同概念，“用户数”指的是并发访问用户数，</p>\n<p>（我理解是同时间访问同一个内存地址的进程数）。要是我买了8个用户的，可以建几十、上百个用户也没问题，只要峰值达不到并发数就可以了。</p>\n<p>打个比方，你的名字叫小明，但是你有很多外号。你父母叫你小明，但是朋友都叫你的外号。<br>\n这里你的父母就是oracle实例，小明就是sid，service name就是你的外号。<br>\nsid用于实例区分各个数据库，service name用于外部链接。</p>\n<p>一个Oracle Server由一个Oracle实例和一个Oracle数据库组成。<br>\n即：Oracle Server = Oracle Instance + Oracle Database</p>\n<p>Oracle实例包括了内存结构(SGA)和一系列后台进程(Background Process),两者合起来称为一个Oracle实例，即：Oracle Instance = SGA + Background Process</p>\n<p>数据库逻辑组织结构<br>\n表空间、段、区、块<br>\n一个数据库由一个或多个表空间组成，一个表空间只能属于一个数据库<br>\n一个表空间由一个或多个多个数据文件组成，一个数据文件只能属于一个表空间<br>\n一个数据文件由一个或多个操作系统块组成，每一个操作系统块只能数以一个数据文件<br>\n一个表空间可以包含一个或多个段，一个段只能属于一个表空间<br>\n一个段由一个或多个区组成，每一个区只能属于一个段<br>\n一个区由一个或多个Oracle 块组成，每一个Oracle块只能属于一个区<br>\n一个区只能属于一个数据文件，数据文件的空间可以分配到一个或多个区<br>\n一个Oracle 块由一个或多个操作系统块组成，一个操作系统块是一个Oracle块的一部分</p>\n<p><a href=\"https://blog.csdn.net/prince_lintb/article/details/78772999\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/prince_lintb/article/details/78772999</a></p>\n<p>pl/sql plus： &quot;／&quot;表示执行</p>\n<p>scott库：<a href=\"https://www.2cto.com/database/201805/742911.html\" target=\"_blank\" rel=\"noopener\">https://www.2cto.com/database/201805/742911.html</a></p>\n<p><a href=\"https://www.cnblogs.com/adforce/p/3312252.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/adforce/p/3312252.html</a><br>\n<a href=\"http://www.cnblogs.com/kscnchina/p/4570865.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/kscnchina/p/4570865.html</a></p>\n<p>声明时，变量以v_开头，常量以c_开头</p>\n<p><a href=\"https://blog.csdn.net/michaelehome/article/details/79464214\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/michaelehome/article/details/79464214</a></p>\n<p>select userenv(‘language’) from dual;<br>\nNLS_LANG=“AMERICAN_AMERICA.AL32UTF8”</p>\n<p>字符集：<a href=\"https://www.cnblogs.com/kaishirenshi/p/9018343.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kaishirenshi/p/9018343.html</a></p>\n<p>本地动态sql</p>\n<p>SQL环境  begin … end pl/sql环境</p>\n<p>一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。</p>\n"},{"title":"Shell编程入门","copyright":true,"comments":1,"toc":true,"date":"2018-12-19T07:29:55.000Z","password":null,"_content":"\n# 认识Shell环境\n* Shell是工作在Linux内核与用户之间的==解释程序==，相当于操作系统的“外壳”，是向Linux内核传达用户指令的“翻译官”，通常指BASH（/bin/bash）,常见的还有zsh、tcsh，用于和操作系统内核交互，操作系统内核控制底层硬件\n* windows下的Shell为cmd.exe\n* 查看当前的Shell的命令为：echo $SHELL\n* 可以手动选择Shell环境，直接在Shell中输入shell如：tcsh，相当于新建了一个子环境（父--子进程）\n* shell操作有交互式和非交互式两种\n\n交互式 | 非交互式\n------ | ---------\n人工干预、智能化程度低 | 需提前设计、智能化难度大\n逐条解释执行、效率低 | 批量执行、效率高\n | |方便在后台静悄悄地运行\n \n# shell脚本\n* shell脚本指提前写好的可执行代码，用来完成特定任务的文件，特点为：顺序、批处理，解释型程序\n* shell脚本编写步骤：\n \n1. 理清任务| 自然语言：步骤拆分、顺序化整理\n---------|----------\n2. 编写可执行语句 | 脚本语言：各步骤如何实现\n3. 完善脚本 | 界面友好／结构规范／代码优化\n\n* shell脚本一般以.sh结尾，==第一行 #!/bin/bash== 用来申明Shell环境\n* shell脚本的免交互及输出处理\n    - 免交互：通过选项 ==--stdin== 可以从标准输入读取字串；也可以从键盘或由另一个命令给出\n    ~~~ \n    // 修改root密码\n    passwd --stdin root     //从键盘读入\n    echo 1234567 | passwd --stdin root  //由echo命令给出\n    ~~~\n    - 输出处理：\n        -  忽略无关输出:黑洞设备/dev/null\n        ~~~\n        相当于只能写入、不能读出的单向文件；存放到其中的数据都会丢失，用法：可执行语句 &> /dev/null，如：\n        echo 1234567 | passwd --stdin root &> /dev/null\n        ~~~\n        - 记录错误输出：根据需要，将出错信息保存到指定文件\n        ~~~\n        是针对后台脚本的有效排错手段，适用于不便交互但又需要查看报错的情况，用法：可执行语句 2>/路径／文件，如：\n        useradd root 2>/tmp/err.log\n        ~~~\n* 命令的组合运用\n    - 顺序分割--==使用分号==，格式：命令1；命令2；命令3...,依次执行，只有先后，没有逻辑关系\n    - 逻辑“与”分割--==使用&&==，格式：命令1 && 命令2 && 命令3...,逻辑关系为“而且”（and），期望所有命令都能执行成功，一旦出现失败，后续命令不再执行\n    - 逻辑“或”分割--==使用||==，格式：命令1 || 命令2 || 命令3...,逻辑关系为“或者”（or），任何一条成功都符合期望，只在前面的命令失败时，后续命令才执行\n    - 管道--==使用|==，格式：命令1|命令2，后续命令要能正确处理传来的文本，否则无意义，如：\n    ~~~\n    find /etc -type f | wc -l   //计算／etc下文件数量，将结果交给wc统计行数\n    ~~~\n* shell脚本的运行方式\n    - 作为指定shell解释程序的参数\n    ~~~\n    -sh 代码文件路径    ===     bash 代码文件路径\n    -.  代码文件路径    ===     source  代码文件路径\n    ~~~\n    - 作为可独立运行的脚本程序\n    ~~~\n    为shell代码文件添加x权限，指定脚本路径即可运行.如：\n    chmod +x ／root／first.sh；/root/first.sh\n    ~~~\n# 标准输入输出和重定向\n> Unix/Linux基本思想：普通文件、目录、鼠标、键盘...都是以文件形式存在；要访问硬件设备，必须找对应的设备文件\n\nI/O交互设备\n\n类型|设备文件|文件描述号|默认设备|备注\n----|--------|----------|--------|-----\n标准输入|/dev/stdin|0|键盘|从此设备接收用户输入的数据\n标准输出|/dev/stdout|1|显示器|通过此设备向用户报告正常的命令输出结果\n标准错误输出|/dev/stderr|2|显示器|通过此设备报告执行中的错误信息\n\n重定向：重新指定命令执行是I/O设备的方向\n\n根据I／O方向和类型区分\n\n类型|操作符|用途|举例\n----|------|-----|---\n重定向输入|<|将文本输入来源由键盘改为指定的文件|mial -s 'A Test Mail' root@localhost < /root/mail.txt\n重定向输出|>|将命令行的正常输出保存到文件，而非显示器|echo 'nameserver 8.8.8.8' > /etc/resolv.conf\n重定向输出|>>|与“>”类似，但操作是追加而不是覆盖|\n重定向错误|2>|将命令行的错误输出保存到文件，而非显示器|\n重定向错误|2>>|与“2>”类似，但操作是追加而不是覆盖|\n混合重定向|&>|相当于“>”和“2>”\n\n# 脚本逻辑\n## 变量值及范围控制\n1. 引号在赋值中的应用\n* 双引号\n~~~\n- 在双引号内允许$扩展，可调用其他变量的值\n- 出现特殊字符时，可采用\\符号转义\n- 当变量值不包括空格、制表符时，双引号通常被省略，如：A=CentOS7\n~~~\n* 单引号\n~~~\n- 所有字符均视为该字符本身（无特殊含义）\n- 不允许\\转义\n~~~\n2. read读入变量值\n~~~\n* 基本格式\n - read 变量名.. ..\n - read -p \"提示信息\" 变量名 .. ..  //read -p \"svr5 login\" YOUR_NAME\n - 启用read命令的 -s 选项，可关闭输入回显，适合敏感信息，提高安全性，如密码\n~~~\n3. 变量的作用范围\n* 局部变量：只在定义此变量的shell环境有效；自定义变量默认都是局部变量 \n* 全局变量：在当前shell及所有子shell环境下有效；子shell中若赋值同名变量，与父shell中变量无关\n\n 发布全局变量\n ~~~\n export 局部变量名[=变量值] .. ..\n  - 直接定义／赋值指定的变量，作为全局变量发布\n  - 对已有的局部变量，只需发布不需赋值\n ~~~\n\n## 数值运算及处理\n> bash内置机制仅支持整数运算\n### 基本运算类别\n加减乘除求模  +-*／%\n~~~\n1. expr工具：==expr 数值1 运算符 数值2==  \n乘法操作需转义\n2. 使用$[]表达式： ==$[数值1 运算符 数值2]==  \n* 乘法操作无需转义，运算符两侧可以无空格，引用变量可省略$符号，如：echo $[x+100-Y*2/7]\n* 支持混合运算，乘除优先\n* 支持乘方运算,如：echo $[10**3]\n~~~\n自增表达式\n~~~\n1. 加减乘除求模自增，如：i+=2 或 i=i+2 或 $[i+=2]\n2. 如果步长为1，则支持如： --i，++i/i--，i++\n~~~\nlet命令操作变量\n~~~\n操作变量值运算，并保存新结果，适用于不需要输出的情况，如：let  x++\n~~~\n\n### 使用随机整数\n1. 环境变量RANDOM:随机生成0～32767之间的一个整数\n2. 扩大随机数范围：多个随机数相乘\n3. 缩小随机数范围：取余数，如：$[RANDOM%1000]取0～999的整数\n\n### 整数序列\n使用seq命令\n~~~\n使用格式：默认分隔符为\\n\n- seq 末数  ;默认从1开始，步长为1\n- seq 首数 末数\n- seq 首数 步长 末数\n参数选项：\n  -s：定义分隔符，如：seq -s' ' 3,结果“1  2  3”\n  -w：等宽显示,不足前面补0\n~~~\n\n### bc计算器\n> bc运算器支持高精度的数值运算，输入bc进入交互式预算界面，quit退出，设置scale=n可约束小数位，也支持小数值的比较，大多数Linux系统已内置\n\n使用举例：\n1. echo \"scale=4;123.4*2.5\" | bc\n2. echo \"$A>$B\" | bc\n\n## Shell变量\n* 变量：以固定名称存放的可能会变化的值\n* 定义／赋值变量\n~~~\n变量名=变量值\n1. 如果变量名已存在，则相当于赋值\n2. 等号两边不能有空格\n3. 变量区分大小写\n4. 变量名不能以数字开头，不要使用关键字和特殊字符\n~~~\n* 查看／引用变量：$变量名  或  ${变量名}\n* 取消变量：退出shell变量自动失效 或  ==unset 变量名==  方式手动取消\n\n变量的分类\n1. 存储类型：shell不作为高级编程语言，对存储类型的要求比较松散\n2. 使用类型\n\n类型|说明|备注\n----|---|---\n环境变量| 变量名通常大写，由系统维护，用来设置工作环境，其中只有个别变量用户可以直接修改|配置文件：/etc/profile,~/.bash_profile\n位置变量 | 由bash内置，用来存储在执行脚本时提供的命令行参数|$n,从1开始,当n>10，格式为 ==${n}==\n预定义变量|由bash内置，一类有特殊用途的变量，可以直接调用，但不能直接赋值或修改|参见下表与定义变量定义\n自定义变量|用户自主设置、修改及使用|\n\nenv-列出所有环境变量；\nset-列出所有变量\n\n常见环境变量：PWD,PATH,USER,LOGNAME,UID,SHELL,HOME,PS1,PS2...\n\n变量名 | 含义|备注\n---|---|---\n$0 | 当前所在进程或脚本名\n$$ | 当前运行进程PID\n$? | 命令执行后的状态值，0-正常   1或其他-异常\n$# | 已加载位置变量个数|如传入参数个数判断: if[ $# -ne 2 ]\n$* | 所有位置变量的值\n \n## 条件测试\n###  返回状态值：$?\n### 专用测试工具test\n~~~\n格式：\n* test 选项  参数...\n* [ 选项 参数... ]\n~~~\n### 文件状态检测：test的参数则为文件或目录\n测试选项 | 含义 | 举例\n---|---|---\n-e | 检测对象是否存在Exist |[ -e /etc/test ];echo $?\n-d | 检测对象是否为目录Directory\n-f | 检测对象是否为文件File\n-r | 检测对象是否有可读权限Read\n-w | 检测对象是否有可写权限Write\n-x | 检测对象是否有可执行权限eXcute\n\n### 整数值比较\n测试选项 | 含义 | 举例\n---|---|---\n-eq | 等于Equal |[ $(who\\|wc -l) -eq 10 ]//判断登陆用户数等于10\n-ne | 不等于Not Equal\n-ge | 大于或等于 Greater or Equal\n-le | 小于或等于 Lesser or Equal\n-gt | 大于 Greater Than\n-lt | 小于 Lesser Than\n\n### 组合多个条件\n~~~\n格式：\n* test 测试条件1 -a或-o 测试条件2...\n* [[ 测试条件1 &&或|| 测试条件2...]]\n~~~\n\n### 字符串比较\n~~~\n格式：\n* [ 字符串1 选项  字符串2 ]\n* [ 选项 字符串 ]\n~~~\n测试选项 | 含义 | 举例/说明\n---|--- |---\n= | 两字符串相同 | [ $USER = 'root' ] && echo $USER\n!= | 两字符串不同 |\n-z | 字符串值为空 |  Zero\n-n | 字符串值不为空 | Not zero\n\n### 将条件取反\n~~~\n格式：\n[ ! 测试条件 ]\n举例：\n[ ! 100 -gt 200] && echo YES\n~~~\n \n## 字符串处理\n### 截取字符串\n1. 使用expr命令，==expr substr $var1 起始位置 截取长度==\n2. 使用cut命令\n~~~\n* 命令输出|cut -c 起始位置-结束位置，echo $var1|cut -c 5-6\n* 命令输出|cut -d '分隔符' -f 字段编号....,echo \"CentOS6.5\" |cut -d 't' -f2 //OS6.5，相当于java中的split[2]\n~~~\n3. 使用${}\n~~~\n格式：\n* ${var1:起始位置:截取长度}\n* ${var1::截取长度} //默认从头开始\n~~~\n\n### 字符串替换\n使用${}\n~~~\n格式：\n* ${var1/old/new}   //只替换一个\n* ${var1//old/new}  //替换全部 \n~~~\n\n### tr单字替换工具\n~~~\n格式：\n* 命令输出|tr 'abc' 'ABC'  //abc替换为大写ABC\n* 命令输出|tr -d 'abc'     //删除所有的abc\n~~~\n\n### 路径分割\n* dirname \"路径字符串\":取目录位置\n* basename \"路径字符串\":取基本名称\n\n### 使用随机字符串\n* 随机数变量：RANDOM\n* 特殊设备文件：/dev/urandom\n* UUID生成命令：uuidgen\n\n随机信息的转换：md5sum\n> 依据输入文本计算出256位(32字符)的MD5编码值\n* echo $RANDOM |md5sum\n* head -1 /dev/urandom|md5sum\n\n### 命令替换\n1. 反撇号`\n* 适用场景：在命令行潜入另一个命令的输出结果；将命令的输出保存到指定变量\n* 优先执行反撇号内的命令，并将执行结果作为输入\n* 举例：rpm -qf `which tr`\n2. $(可执行命令)，优点为==可嵌套使用==，举例：rpm -qf $(which tr)\n\n## 流程控制\n### if语句\n~~~\n//单分支\nif 条件测试\n    then 命令序列\nfi\n\n//双分支\nif 条件测试\n    then 命令序列1\n    else 命令序列2\nfi\n\n//多分支（嵌套）\nif 条件测试1\n    then 命令序列1\nelif 条件测试2 ;then\n    命令序列2\nelse \n    命令序列n\nfi\n~~~\n说明：如果then要跟着条件测试写在一行，则需在then前加封号，如：\n~~~\nif 条件测试 ;then\n    命令序列\nfi\n~~~\n### for循环\n~~~\nfor 变量名 in 值列表\ndo\n    命令序列\ndone\n~~~\n\n### while循环\n~~~\nwhile 条件测试\ndo\n    命令序列\ndone\n~~~\n\n### case分支\n~~~\ncase 变量值  in\n模式1)\n    命令序列1;;\n模式2)\n    命令序列2;;\n    .. ..\n*)\n    默认命令序列\nesac\n~~~\n\n### 中断及退出控制\n类型 | 含义\n---|---\nbreak | 跳出当前所在循环体，执行循环体后的语句块\ncontinue | 跳过循环体内余下的语句，重新判断条件以便执行下一次循环\nexit | 退出脚本，可以指定返回的状态值，默认返回0\n \n## 编写服务脚本\n### shell函数\ntype 名称  //查看名称对应类型\n~~~\n基本格式:\nfunction 函数名(){\n    命令序列\n    .. ..\n}\n或🔥\n函数名(){\n    命令序列\n    .. ..\n}\n\n调用： 函数名\n传参： 函数名  参数1  参数2 .. ..  //传递的值作为函数的位置参数\n~~~\n\n### 系统服务管理\n* 查看服务列表、自启状态\n- -  chkconfig --list [服务名]\n- - chkconfig 服务名  on/off\n* 启动／停止／重启服务\n- - service 服务名 start/stop/restart\n- - /etc/init.d/服务名 start/stop/restart\n* ntsysv:可视化设置自启动状态\n\n1. shell脚本直接交给service控制，则将脚本或者脚本的快捷方式放到/etc/init.d／下即可\n2. shell脚本交给chkconfig工具管理,需设置适用级别、启动／停止顺序、服务说明\n* 添加设置\n~~~\n#!/bin/bash\n#\n# chkconfig:2345 10 95\n# description:服务相关说明\n~~~\n* 添加服务：chkconfig --add 服务名\n\n## 文件的排序集统计\n### ls列表排序\n* -S:按文档大小降序排列\n* -t:按文档的修改时间降序排列\n* -r:反序排列\n\n### uniq去重工具\n~~~\n用法1：uniq 文件\n用法2: 命令|uniq\n~~~\n缺点：==未排序的文本会出现重复现象==，需配合其他方式先排序，再去重\n方法：sort 文件名|uniq -c\n\n### sort工具\n~~~\n用法1:sort 文件\n用法2:命令|sort\n\n常用选项：\n* -u: 去除重复行\n* -n：按数字升序排列\n* -r：反向排序\n* -k：优先对第几列内容排序，即优先对哪个字段排序，只是字段是通过显示顺序编号的\n~~~\n\n## 文本处理的的特殊应用\n### tac、rev反序输出\n* tac：以行为单位反序，与cat命令效果相反\n* rev: 以字符为单位反序，与echo命令效果相反\n\n### tee整合重定向\n举例：uname -r|tee un.txt\n\n### unix2dos与dos2unix转换\nwindows和linux系统文本格式转换\n~~~\n安装：yum -y install unix2dos dos2unix\n基本用法：\n* unix2dos Linux文件\n* dos2unix Windows文件\n~~~\n\n## xargs多参数处理\n背景：ls、mv、rm、cp等命令给出的参数长度不能超过2.5M，基于*匹配、find等方式处理大量文件时容易出错\n\n### 多参数的分散处理\n* 利用find.. .. -exec.. .. 查找处理  //仅适用于处理文件或目录参数，如：find / -exec ls -lh {} \\;\n* xargs工具:根据给定的参数组（以行为单位）分次执行目标命令行\n~~~\n用法1：提供参数的命令 | xargs 目标命令，如：find /|args ls -lh\n用法2: xargs --arg-file=提供参数的文件  目标命令\n选项：\n* -I：定义标记，如：ls txt.log* | xargs -I{} cp {} {}.new\n* -d: 制定分割符，默认按行分割，如：head -1 /etc/passwd |xargs -d: -I{} echo {}\n~~~\n\n## expect预期交互控制\n> 基于TCL编写的自动化交互式程序，可以用在Shell脚本中，为FTP、SSH等交互过程自动输送预先准备的文本或指令，而无需人工干预，出发的依据是预期会出现的特征提示文本\n\n* 安装：yum -y install expect\n1. 手动交互\n2. 自动交互\n~~~\ncat mike-ftp.sh\n--------------------\nspawn ftp 192.168.4.5\nexpect \"):\"\nsend \"mike\\r\"\nexpect \"Password:\"\nsend \"123456\\r\"\nexpect \"ftp>\"\nsend \"put install.log\\r\"\nexpect \"ftp>\"\nsend \"quit\\r\"\n---------------------\nepxect mike-ftp.sh\n~~~\n\n* 调整执行环境：添加Sha-Bang环境声明\n~~~\ncat mike-ftp.sh\n-----------------------\n#!/usr/bin/expect\nspawn ftp 192.168.4.5\nexpect \"):\"\nsend \"mike\\r\"\nexpect \"Password:\"\nsend \"123456\\r\"\nexpect \"ftp>\"\nsend \"put install.log\\r\"\nexpect \"ftp>\"\nsend \"quit\\r\"\n------------------------\nsh mike-ftp.sh\n~~~\n\n* SSH登陆免交互举例\n~~~\n#!/usr/bin/expect\nset host 192.168.4.5\nset user mike\nset password \"1234567\"\nspawn ssh $user@$host\nexpect \"password:\"{send \"$password\\r\"}\nexpect \"\\[$user\\@\"{send \"pwd>/tmp/$user.txt;exit\\r\"}\nexpect eof\n~~~\n\n# 应用技巧\n## 正则表达式\n> 使用“一串符号”来描述有共同属性的数据\n\n### egrep测试工具\n* 用法1:egrep [选项] ‘正则表达式’ 文件\n* 用法2:前置命令|egrep [选项] ‘正则表达式’\n\n选项\n~~~ \n-i：忽略大小写\n-v: 取反\n-c：统计匹配行数\n-q：静默、无任何输出\n-n：显示出所匹配结果所在的行号\n~~~\n\n### 基本元字符\n类型 | 含义 | 示例 | 说明\n---|---|----|------|-------\n^|匹配行首|^abc 或 ^#|以abc开头的行  或  以#开头的行（比如注释行）\n$|匹配行尾|abc$ 或 ^$|以abc结尾的行  或  空行\n.|单个字符|.|除换行符\\n以外的任意单个字符 \n+|最少匹配一次|a+ 或 (abc)+|一个或多个连续的a 或  一个或多个连续的abc\n?|最多匹配一次|a? 或 (abc)?|0个或1个a 或  0或1个abc\n*|匹配任意次数|a* 或 (abc)* 或 .*|0个或多个连续的a 或 0个或多个连续的abc 或 任意长度的任意字符串\n{n}|匹配n次|(ab){3}|匹配ababab\n{n,m}|匹配n～m次|(ab){1,3}|匹配ab、abab、ababab\n{n,}|匹配至少n次|(ab){2,}|匹配2个及以上连续的ab\n[]|匹配范围内的单个字符|[a-z]|匹配任意小写字母\n[]内加^|可取反|[^a-z]|匹配任意非小写字母\n()|组合为整体|(ab)|连续的ab\n||或者|root\\|bin|匹配root、bin\n\\b|单词边界|\\broot\\b|匹配root，不匹配keroot、rooty、brooty等字符串\n\\<|单词的开头|\\<th|匹配以th开头的单词\n\\>|单词的结尾|th\\>|匹配以th结尾的单词\n\n## awk文本过滤\n> awk:模式扫描及处理语言，创始人Aho、Weinberger、Kernighan，基于模式匹配检查输入的文本，逐行处理并print结果，目前最常用的实际是GNU版本的gawk\n\n* 用法1:前置命令|awk [选项] ‘[条件]{编辑指令}’\n* 用法2:awk [选项] ‘[条件]{编辑指令}’ 文件，如：awk -F \":\" '{print $1,$2} /etc/passwd'\n\n条件的表现形式\n* 正则表达式，/正则表达式/ 🔥 ~匹配、!\\~不匹配,如：awk -F: '/^ro/{print}' /etc/passwd\n* 数值／字符串比较\n* 逻辑比较\n* 运算符\n\n选项\n~~~\n-F:指定分隔符，可省略，默认空格或Tab位，如：awk -F: '$1==ENVIRON[\"USER\"]{print $3}' /etc/passwd  //输出当前用户的UID信息\n-f:调用awk脚本进行处理\n~~~\n\nawk内置变量\n变量 | 用途\n---|---\nFS |保存或设置字段分隔符，如 FS=“：”\n$n |指定分隔符的第n个字段，如$1、$3分别表示第1、第3列\n$0 |当前读入的整行文本内容\nNF |记录当前处理的字段个数（列数）\nNR |记录当前已读入行的数量（行数）\nFNR|保存当前处理行在元文本内的序号（行号）\nFILENAME|当前处理的文件名\nENVIRON|调用Shell环境变量，格式：ENVIRON[\"变量名\"]\n\nawk处理的时机：可单独使用，也可以同时一起使用，具体如下：\n* 行前处理,BEGIN{}:读入第一行文本之前执行，一般用来初始化操作\n* 逐行处理,{}：逐行读入文本执行相应的处理，是最常见的编辑指令块\n* 行后处理，END{}：处理完最后一行文本之后执行，一般用来输出处理结果\n~~~\nawk 'BEGIN{print NR}END{print NR}' m.txt\n~~~\n\nawk的流程控制\n* if分支，如：if(条件){编辑指令1}else if(条件){编辑指令12}....else{编辑指令n}\n~~~\nawk -F: 'BEGIN{i=0;j=0}{if($3<500){i++}else{j++}}END{print i,j}'     /etc/passwd\n~~~\n* while循环，如：while(条件){编辑指令}\n* do while循环，如：do {编辑指令}while(条件)\n* for循环,如：for(初值；条件；步长){编辑指令}\n\n关键字 | 含义\n---|---\nbreak|结束当前的循环体\ncontinue|中止本次循环，转入下一次循环\nnext|跳过当前行，读入下一行文本开始处理\nexit|结束文本读入，转入END{}执行，没有则直接退出\n\n## sed文本流处理\n> sed:Stream EDitor，流式编辑器，基于模式匹配过滤及修改文本，逐行处理并将结果输出到屏幕，可实现文本过滤／删除／替换／复制／剪切，以及导入／导出等各种操作\n\n* 用法1:前置命令|sed [选项] ‘编辑指令’，如：se -n /etc/inittab |sed -n '4,7p'\n* 用法2:sed [选项] ‘编辑指令’ 文件\n~~~\n编辑指令由“[定址符]处理动作”组成，[定址符]的格式为“[地址1，[地址2]]”\n~~~\n选项：\n~~~\n-n:屏蔽默认输出\n-i:直接修改文件内容\n-f:使用sed脚本\n-e:可指定多个处理动作\n-r:启用扩展的正则表达式，若与其他选项一起使用，应作为首个选项\n{}:可组合多个命令，以分号分隔\n~~~\n处理动作：替换操作的分隔符“／”可用其他字符，如#、&等以便于修改文件路径\n操作符|用途|指令示例\n---|---|------\np|打印行|2,4p 输出2，3，4行 🔥 2p；4p输出第2行、4行\nd|删除行|2,4d 删除第2，3，4行\ns|字符串替换|s/old/new/ 将每行第1个old替换为new\n|||s/old/new/3 将每行第3个old替换为new\n|||s/old/new/g 将所有的old替换为new\n4,+10p|加10行|输出第4行及其后10行内容\nn|表示下一行|p:n输出奇数行\n||n:p输出偶数行\n$=|输出文件的行数|sed -n '$=' a.txxt\ni|行前插入文本|2iYY 在第2行前添加文本行YY\n|||4，7iYY 在第4-7行每一行钱添加文本行YY\na|行后插入文本|2aYY 在第2行后插入YY\nc|替换当前行|2cYY 将第2行内容修改为YY\nr|读取文件，结合-i选项才会存入，否则只输出|3r b.txt 在第3行下发插入文本b.txt\nw|保存到文件，以覆盖方式|3w b.txt 将第3行保存到b.txt\n\nsed复制剪切\n* 模式空间:存放当前处理的行，将处理结果输出；若当前行不符合处理条件则原样输出；处理完当前行再读入下一行来处理\n* 保存空间:作用类似剪贴板，默认存放一个空行\\n\n选项：\n~~~\n-H：模式空间 追加 到 保持空间 ，即复制\n-h：模式空间 覆盖 到 保持空间 ，即复制\n-G：保持空间 追加 到 模式空间 ，即粘贴\n-g：保持空间 覆盖 到 模式空间 ，即粘贴\n\nsed '1,3H;$G' reg.txt //把第1～3行复制到文件末尾\n~~~\n\n# 实战脚本\n## 基本知识\n1. 查看用户信息：id gsuis\n2. \n\n## awk&sed应用实战\n\n\n\n","source":"_posts/Linux/Shell编程入门.md","raw":"---\ntitle: Shell编程入门\ntags:\n  - Shell编程\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-12-19 15:29:55\ncategories: Linux\npassword:\n---\n\n# 认识Shell环境\n* Shell是工作在Linux内核与用户之间的==解释程序==，相当于操作系统的“外壳”，是向Linux内核传达用户指令的“翻译官”，通常指BASH（/bin/bash）,常见的还有zsh、tcsh，用于和操作系统内核交互，操作系统内核控制底层硬件\n* windows下的Shell为cmd.exe\n* 查看当前的Shell的命令为：echo $SHELL\n* 可以手动选择Shell环境，直接在Shell中输入shell如：tcsh，相当于新建了一个子环境（父--子进程）\n* shell操作有交互式和非交互式两种\n\n交互式 | 非交互式\n------ | ---------\n人工干预、智能化程度低 | 需提前设计、智能化难度大\n逐条解释执行、效率低 | 批量执行、效率高\n | |方便在后台静悄悄地运行\n \n# shell脚本\n* shell脚本指提前写好的可执行代码，用来完成特定任务的文件，特点为：顺序、批处理，解释型程序\n* shell脚本编写步骤：\n \n1. 理清任务| 自然语言：步骤拆分、顺序化整理\n---------|----------\n2. 编写可执行语句 | 脚本语言：各步骤如何实现\n3. 完善脚本 | 界面友好／结构规范／代码优化\n\n* shell脚本一般以.sh结尾，==第一行 #!/bin/bash== 用来申明Shell环境\n* shell脚本的免交互及输出处理\n    - 免交互：通过选项 ==--stdin== 可以从标准输入读取字串；也可以从键盘或由另一个命令给出\n    ~~~ \n    // 修改root密码\n    passwd --stdin root     //从键盘读入\n    echo 1234567 | passwd --stdin root  //由echo命令给出\n    ~~~\n    - 输出处理：\n        -  忽略无关输出:黑洞设备/dev/null\n        ~~~\n        相当于只能写入、不能读出的单向文件；存放到其中的数据都会丢失，用法：可执行语句 &> /dev/null，如：\n        echo 1234567 | passwd --stdin root &> /dev/null\n        ~~~\n        - 记录错误输出：根据需要，将出错信息保存到指定文件\n        ~~~\n        是针对后台脚本的有效排错手段，适用于不便交互但又需要查看报错的情况，用法：可执行语句 2>/路径／文件，如：\n        useradd root 2>/tmp/err.log\n        ~~~\n* 命令的组合运用\n    - 顺序分割--==使用分号==，格式：命令1；命令2；命令3...,依次执行，只有先后，没有逻辑关系\n    - 逻辑“与”分割--==使用&&==，格式：命令1 && 命令2 && 命令3...,逻辑关系为“而且”（and），期望所有命令都能执行成功，一旦出现失败，后续命令不再执行\n    - 逻辑“或”分割--==使用||==，格式：命令1 || 命令2 || 命令3...,逻辑关系为“或者”（or），任何一条成功都符合期望，只在前面的命令失败时，后续命令才执行\n    - 管道--==使用|==，格式：命令1|命令2，后续命令要能正确处理传来的文本，否则无意义，如：\n    ~~~\n    find /etc -type f | wc -l   //计算／etc下文件数量，将结果交给wc统计行数\n    ~~~\n* shell脚本的运行方式\n    - 作为指定shell解释程序的参数\n    ~~~\n    -sh 代码文件路径    ===     bash 代码文件路径\n    -.  代码文件路径    ===     source  代码文件路径\n    ~~~\n    - 作为可独立运行的脚本程序\n    ~~~\n    为shell代码文件添加x权限，指定脚本路径即可运行.如：\n    chmod +x ／root／first.sh；/root/first.sh\n    ~~~\n# 标准输入输出和重定向\n> Unix/Linux基本思想：普通文件、目录、鼠标、键盘...都是以文件形式存在；要访问硬件设备，必须找对应的设备文件\n\nI/O交互设备\n\n类型|设备文件|文件描述号|默认设备|备注\n----|--------|----------|--------|-----\n标准输入|/dev/stdin|0|键盘|从此设备接收用户输入的数据\n标准输出|/dev/stdout|1|显示器|通过此设备向用户报告正常的命令输出结果\n标准错误输出|/dev/stderr|2|显示器|通过此设备报告执行中的错误信息\n\n重定向：重新指定命令执行是I/O设备的方向\n\n根据I／O方向和类型区分\n\n类型|操作符|用途|举例\n----|------|-----|---\n重定向输入|<|将文本输入来源由键盘改为指定的文件|mial -s 'A Test Mail' root@localhost < /root/mail.txt\n重定向输出|>|将命令行的正常输出保存到文件，而非显示器|echo 'nameserver 8.8.8.8' > /etc/resolv.conf\n重定向输出|>>|与“>”类似，但操作是追加而不是覆盖|\n重定向错误|2>|将命令行的错误输出保存到文件，而非显示器|\n重定向错误|2>>|与“2>”类似，但操作是追加而不是覆盖|\n混合重定向|&>|相当于“>”和“2>”\n\n# 脚本逻辑\n## 变量值及范围控制\n1. 引号在赋值中的应用\n* 双引号\n~~~\n- 在双引号内允许$扩展，可调用其他变量的值\n- 出现特殊字符时，可采用\\符号转义\n- 当变量值不包括空格、制表符时，双引号通常被省略，如：A=CentOS7\n~~~\n* 单引号\n~~~\n- 所有字符均视为该字符本身（无特殊含义）\n- 不允许\\转义\n~~~\n2. read读入变量值\n~~~\n* 基本格式\n - read 变量名.. ..\n - read -p \"提示信息\" 变量名 .. ..  //read -p \"svr5 login\" YOUR_NAME\n - 启用read命令的 -s 选项，可关闭输入回显，适合敏感信息，提高安全性，如密码\n~~~\n3. 变量的作用范围\n* 局部变量：只在定义此变量的shell环境有效；自定义变量默认都是局部变量 \n* 全局变量：在当前shell及所有子shell环境下有效；子shell中若赋值同名变量，与父shell中变量无关\n\n 发布全局变量\n ~~~\n export 局部变量名[=变量值] .. ..\n  - 直接定义／赋值指定的变量，作为全局变量发布\n  - 对已有的局部变量，只需发布不需赋值\n ~~~\n\n## 数值运算及处理\n> bash内置机制仅支持整数运算\n### 基本运算类别\n加减乘除求模  +-*／%\n~~~\n1. expr工具：==expr 数值1 运算符 数值2==  \n乘法操作需转义\n2. 使用$[]表达式： ==$[数值1 运算符 数值2]==  \n* 乘法操作无需转义，运算符两侧可以无空格，引用变量可省略$符号，如：echo $[x+100-Y*2/7]\n* 支持混合运算，乘除优先\n* 支持乘方运算,如：echo $[10**3]\n~~~\n自增表达式\n~~~\n1. 加减乘除求模自增，如：i+=2 或 i=i+2 或 $[i+=2]\n2. 如果步长为1，则支持如： --i，++i/i--，i++\n~~~\nlet命令操作变量\n~~~\n操作变量值运算，并保存新结果，适用于不需要输出的情况，如：let  x++\n~~~\n\n### 使用随机整数\n1. 环境变量RANDOM:随机生成0～32767之间的一个整数\n2. 扩大随机数范围：多个随机数相乘\n3. 缩小随机数范围：取余数，如：$[RANDOM%1000]取0～999的整数\n\n### 整数序列\n使用seq命令\n~~~\n使用格式：默认分隔符为\\n\n- seq 末数  ;默认从1开始，步长为1\n- seq 首数 末数\n- seq 首数 步长 末数\n参数选项：\n  -s：定义分隔符，如：seq -s' ' 3,结果“1  2  3”\n  -w：等宽显示,不足前面补0\n~~~\n\n### bc计算器\n> bc运算器支持高精度的数值运算，输入bc进入交互式预算界面，quit退出，设置scale=n可约束小数位，也支持小数值的比较，大多数Linux系统已内置\n\n使用举例：\n1. echo \"scale=4;123.4*2.5\" | bc\n2. echo \"$A>$B\" | bc\n\n## Shell变量\n* 变量：以固定名称存放的可能会变化的值\n* 定义／赋值变量\n~~~\n变量名=变量值\n1. 如果变量名已存在，则相当于赋值\n2. 等号两边不能有空格\n3. 变量区分大小写\n4. 变量名不能以数字开头，不要使用关键字和特殊字符\n~~~\n* 查看／引用变量：$变量名  或  ${变量名}\n* 取消变量：退出shell变量自动失效 或  ==unset 变量名==  方式手动取消\n\n变量的分类\n1. 存储类型：shell不作为高级编程语言，对存储类型的要求比较松散\n2. 使用类型\n\n类型|说明|备注\n----|---|---\n环境变量| 变量名通常大写，由系统维护，用来设置工作环境，其中只有个别变量用户可以直接修改|配置文件：/etc/profile,~/.bash_profile\n位置变量 | 由bash内置，用来存储在执行脚本时提供的命令行参数|$n,从1开始,当n>10，格式为 ==${n}==\n预定义变量|由bash内置，一类有特殊用途的变量，可以直接调用，但不能直接赋值或修改|参见下表与定义变量定义\n自定义变量|用户自主设置、修改及使用|\n\nenv-列出所有环境变量；\nset-列出所有变量\n\n常见环境变量：PWD,PATH,USER,LOGNAME,UID,SHELL,HOME,PS1,PS2...\n\n变量名 | 含义|备注\n---|---|---\n$0 | 当前所在进程或脚本名\n$$ | 当前运行进程PID\n$? | 命令执行后的状态值，0-正常   1或其他-异常\n$# | 已加载位置变量个数|如传入参数个数判断: if[ $# -ne 2 ]\n$* | 所有位置变量的值\n \n## 条件测试\n###  返回状态值：$?\n### 专用测试工具test\n~~~\n格式：\n* test 选项  参数...\n* [ 选项 参数... ]\n~~~\n### 文件状态检测：test的参数则为文件或目录\n测试选项 | 含义 | 举例\n---|---|---\n-e | 检测对象是否存在Exist |[ -e /etc/test ];echo $?\n-d | 检测对象是否为目录Directory\n-f | 检测对象是否为文件File\n-r | 检测对象是否有可读权限Read\n-w | 检测对象是否有可写权限Write\n-x | 检测对象是否有可执行权限eXcute\n\n### 整数值比较\n测试选项 | 含义 | 举例\n---|---|---\n-eq | 等于Equal |[ $(who\\|wc -l) -eq 10 ]//判断登陆用户数等于10\n-ne | 不等于Not Equal\n-ge | 大于或等于 Greater or Equal\n-le | 小于或等于 Lesser or Equal\n-gt | 大于 Greater Than\n-lt | 小于 Lesser Than\n\n### 组合多个条件\n~~~\n格式：\n* test 测试条件1 -a或-o 测试条件2...\n* [[ 测试条件1 &&或|| 测试条件2...]]\n~~~\n\n### 字符串比较\n~~~\n格式：\n* [ 字符串1 选项  字符串2 ]\n* [ 选项 字符串 ]\n~~~\n测试选项 | 含义 | 举例/说明\n---|--- |---\n= | 两字符串相同 | [ $USER = 'root' ] && echo $USER\n!= | 两字符串不同 |\n-z | 字符串值为空 |  Zero\n-n | 字符串值不为空 | Not zero\n\n### 将条件取反\n~~~\n格式：\n[ ! 测试条件 ]\n举例：\n[ ! 100 -gt 200] && echo YES\n~~~\n \n## 字符串处理\n### 截取字符串\n1. 使用expr命令，==expr substr $var1 起始位置 截取长度==\n2. 使用cut命令\n~~~\n* 命令输出|cut -c 起始位置-结束位置，echo $var1|cut -c 5-6\n* 命令输出|cut -d '分隔符' -f 字段编号....,echo \"CentOS6.5\" |cut -d 't' -f2 //OS6.5，相当于java中的split[2]\n~~~\n3. 使用${}\n~~~\n格式：\n* ${var1:起始位置:截取长度}\n* ${var1::截取长度} //默认从头开始\n~~~\n\n### 字符串替换\n使用${}\n~~~\n格式：\n* ${var1/old/new}   //只替换一个\n* ${var1//old/new}  //替换全部 \n~~~\n\n### tr单字替换工具\n~~~\n格式：\n* 命令输出|tr 'abc' 'ABC'  //abc替换为大写ABC\n* 命令输出|tr -d 'abc'     //删除所有的abc\n~~~\n\n### 路径分割\n* dirname \"路径字符串\":取目录位置\n* basename \"路径字符串\":取基本名称\n\n### 使用随机字符串\n* 随机数变量：RANDOM\n* 特殊设备文件：/dev/urandom\n* UUID生成命令：uuidgen\n\n随机信息的转换：md5sum\n> 依据输入文本计算出256位(32字符)的MD5编码值\n* echo $RANDOM |md5sum\n* head -1 /dev/urandom|md5sum\n\n### 命令替换\n1. 反撇号`\n* 适用场景：在命令行潜入另一个命令的输出结果；将命令的输出保存到指定变量\n* 优先执行反撇号内的命令，并将执行结果作为输入\n* 举例：rpm -qf `which tr`\n2. $(可执行命令)，优点为==可嵌套使用==，举例：rpm -qf $(which tr)\n\n## 流程控制\n### if语句\n~~~\n//单分支\nif 条件测试\n    then 命令序列\nfi\n\n//双分支\nif 条件测试\n    then 命令序列1\n    else 命令序列2\nfi\n\n//多分支（嵌套）\nif 条件测试1\n    then 命令序列1\nelif 条件测试2 ;then\n    命令序列2\nelse \n    命令序列n\nfi\n~~~\n说明：如果then要跟着条件测试写在一行，则需在then前加封号，如：\n~~~\nif 条件测试 ;then\n    命令序列\nfi\n~~~\n### for循环\n~~~\nfor 变量名 in 值列表\ndo\n    命令序列\ndone\n~~~\n\n### while循环\n~~~\nwhile 条件测试\ndo\n    命令序列\ndone\n~~~\n\n### case分支\n~~~\ncase 变量值  in\n模式1)\n    命令序列1;;\n模式2)\n    命令序列2;;\n    .. ..\n*)\n    默认命令序列\nesac\n~~~\n\n### 中断及退出控制\n类型 | 含义\n---|---\nbreak | 跳出当前所在循环体，执行循环体后的语句块\ncontinue | 跳过循环体内余下的语句，重新判断条件以便执行下一次循环\nexit | 退出脚本，可以指定返回的状态值，默认返回0\n \n## 编写服务脚本\n### shell函数\ntype 名称  //查看名称对应类型\n~~~\n基本格式:\nfunction 函数名(){\n    命令序列\n    .. ..\n}\n或🔥\n函数名(){\n    命令序列\n    .. ..\n}\n\n调用： 函数名\n传参： 函数名  参数1  参数2 .. ..  //传递的值作为函数的位置参数\n~~~\n\n### 系统服务管理\n* 查看服务列表、自启状态\n- -  chkconfig --list [服务名]\n- - chkconfig 服务名  on/off\n* 启动／停止／重启服务\n- - service 服务名 start/stop/restart\n- - /etc/init.d/服务名 start/stop/restart\n* ntsysv:可视化设置自启动状态\n\n1. shell脚本直接交给service控制，则将脚本或者脚本的快捷方式放到/etc/init.d／下即可\n2. shell脚本交给chkconfig工具管理,需设置适用级别、启动／停止顺序、服务说明\n* 添加设置\n~~~\n#!/bin/bash\n#\n# chkconfig:2345 10 95\n# description:服务相关说明\n~~~\n* 添加服务：chkconfig --add 服务名\n\n## 文件的排序集统计\n### ls列表排序\n* -S:按文档大小降序排列\n* -t:按文档的修改时间降序排列\n* -r:反序排列\n\n### uniq去重工具\n~~~\n用法1：uniq 文件\n用法2: 命令|uniq\n~~~\n缺点：==未排序的文本会出现重复现象==，需配合其他方式先排序，再去重\n方法：sort 文件名|uniq -c\n\n### sort工具\n~~~\n用法1:sort 文件\n用法2:命令|sort\n\n常用选项：\n* -u: 去除重复行\n* -n：按数字升序排列\n* -r：反向排序\n* -k：优先对第几列内容排序，即优先对哪个字段排序，只是字段是通过显示顺序编号的\n~~~\n\n## 文本处理的的特殊应用\n### tac、rev反序输出\n* tac：以行为单位反序，与cat命令效果相反\n* rev: 以字符为单位反序，与echo命令效果相反\n\n### tee整合重定向\n举例：uname -r|tee un.txt\n\n### unix2dos与dos2unix转换\nwindows和linux系统文本格式转换\n~~~\n安装：yum -y install unix2dos dos2unix\n基本用法：\n* unix2dos Linux文件\n* dos2unix Windows文件\n~~~\n\n## xargs多参数处理\n背景：ls、mv、rm、cp等命令给出的参数长度不能超过2.5M，基于*匹配、find等方式处理大量文件时容易出错\n\n### 多参数的分散处理\n* 利用find.. .. -exec.. .. 查找处理  //仅适用于处理文件或目录参数，如：find / -exec ls -lh {} \\;\n* xargs工具:根据给定的参数组（以行为单位）分次执行目标命令行\n~~~\n用法1：提供参数的命令 | xargs 目标命令，如：find /|args ls -lh\n用法2: xargs --arg-file=提供参数的文件  目标命令\n选项：\n* -I：定义标记，如：ls txt.log* | xargs -I{} cp {} {}.new\n* -d: 制定分割符，默认按行分割，如：head -1 /etc/passwd |xargs -d: -I{} echo {}\n~~~\n\n## expect预期交互控制\n> 基于TCL编写的自动化交互式程序，可以用在Shell脚本中，为FTP、SSH等交互过程自动输送预先准备的文本或指令，而无需人工干预，出发的依据是预期会出现的特征提示文本\n\n* 安装：yum -y install expect\n1. 手动交互\n2. 自动交互\n~~~\ncat mike-ftp.sh\n--------------------\nspawn ftp 192.168.4.5\nexpect \"):\"\nsend \"mike\\r\"\nexpect \"Password:\"\nsend \"123456\\r\"\nexpect \"ftp>\"\nsend \"put install.log\\r\"\nexpect \"ftp>\"\nsend \"quit\\r\"\n---------------------\nepxect mike-ftp.sh\n~~~\n\n* 调整执行环境：添加Sha-Bang环境声明\n~~~\ncat mike-ftp.sh\n-----------------------\n#!/usr/bin/expect\nspawn ftp 192.168.4.5\nexpect \"):\"\nsend \"mike\\r\"\nexpect \"Password:\"\nsend \"123456\\r\"\nexpect \"ftp>\"\nsend \"put install.log\\r\"\nexpect \"ftp>\"\nsend \"quit\\r\"\n------------------------\nsh mike-ftp.sh\n~~~\n\n* SSH登陆免交互举例\n~~~\n#!/usr/bin/expect\nset host 192.168.4.5\nset user mike\nset password \"1234567\"\nspawn ssh $user@$host\nexpect \"password:\"{send \"$password\\r\"}\nexpect \"\\[$user\\@\"{send \"pwd>/tmp/$user.txt;exit\\r\"}\nexpect eof\n~~~\n\n# 应用技巧\n## 正则表达式\n> 使用“一串符号”来描述有共同属性的数据\n\n### egrep测试工具\n* 用法1:egrep [选项] ‘正则表达式’ 文件\n* 用法2:前置命令|egrep [选项] ‘正则表达式’\n\n选项\n~~~ \n-i：忽略大小写\n-v: 取反\n-c：统计匹配行数\n-q：静默、无任何输出\n-n：显示出所匹配结果所在的行号\n~~~\n\n### 基本元字符\n类型 | 含义 | 示例 | 说明\n---|---|----|------|-------\n^|匹配行首|^abc 或 ^#|以abc开头的行  或  以#开头的行（比如注释行）\n$|匹配行尾|abc$ 或 ^$|以abc结尾的行  或  空行\n.|单个字符|.|除换行符\\n以外的任意单个字符 \n+|最少匹配一次|a+ 或 (abc)+|一个或多个连续的a 或  一个或多个连续的abc\n?|最多匹配一次|a? 或 (abc)?|0个或1个a 或  0或1个abc\n*|匹配任意次数|a* 或 (abc)* 或 .*|0个或多个连续的a 或 0个或多个连续的abc 或 任意长度的任意字符串\n{n}|匹配n次|(ab){3}|匹配ababab\n{n,m}|匹配n～m次|(ab){1,3}|匹配ab、abab、ababab\n{n,}|匹配至少n次|(ab){2,}|匹配2个及以上连续的ab\n[]|匹配范围内的单个字符|[a-z]|匹配任意小写字母\n[]内加^|可取反|[^a-z]|匹配任意非小写字母\n()|组合为整体|(ab)|连续的ab\n||或者|root\\|bin|匹配root、bin\n\\b|单词边界|\\broot\\b|匹配root，不匹配keroot、rooty、brooty等字符串\n\\<|单词的开头|\\<th|匹配以th开头的单词\n\\>|单词的结尾|th\\>|匹配以th结尾的单词\n\n## awk文本过滤\n> awk:模式扫描及处理语言，创始人Aho、Weinberger、Kernighan，基于模式匹配检查输入的文本，逐行处理并print结果，目前最常用的实际是GNU版本的gawk\n\n* 用法1:前置命令|awk [选项] ‘[条件]{编辑指令}’\n* 用法2:awk [选项] ‘[条件]{编辑指令}’ 文件，如：awk -F \":\" '{print $1,$2} /etc/passwd'\n\n条件的表现形式\n* 正则表达式，/正则表达式/ 🔥 ~匹配、!\\~不匹配,如：awk -F: '/^ro/{print}' /etc/passwd\n* 数值／字符串比较\n* 逻辑比较\n* 运算符\n\n选项\n~~~\n-F:指定分隔符，可省略，默认空格或Tab位，如：awk -F: '$1==ENVIRON[\"USER\"]{print $3}' /etc/passwd  //输出当前用户的UID信息\n-f:调用awk脚本进行处理\n~~~\n\nawk内置变量\n变量 | 用途\n---|---\nFS |保存或设置字段分隔符，如 FS=“：”\n$n |指定分隔符的第n个字段，如$1、$3分别表示第1、第3列\n$0 |当前读入的整行文本内容\nNF |记录当前处理的字段个数（列数）\nNR |记录当前已读入行的数量（行数）\nFNR|保存当前处理行在元文本内的序号（行号）\nFILENAME|当前处理的文件名\nENVIRON|调用Shell环境变量，格式：ENVIRON[\"变量名\"]\n\nawk处理的时机：可单独使用，也可以同时一起使用，具体如下：\n* 行前处理,BEGIN{}:读入第一行文本之前执行，一般用来初始化操作\n* 逐行处理,{}：逐行读入文本执行相应的处理，是最常见的编辑指令块\n* 行后处理，END{}：处理完最后一行文本之后执行，一般用来输出处理结果\n~~~\nawk 'BEGIN{print NR}END{print NR}' m.txt\n~~~\n\nawk的流程控制\n* if分支，如：if(条件){编辑指令1}else if(条件){编辑指令12}....else{编辑指令n}\n~~~\nawk -F: 'BEGIN{i=0;j=0}{if($3<500){i++}else{j++}}END{print i,j}'     /etc/passwd\n~~~\n* while循环，如：while(条件){编辑指令}\n* do while循环，如：do {编辑指令}while(条件)\n* for循环,如：for(初值；条件；步长){编辑指令}\n\n关键字 | 含义\n---|---\nbreak|结束当前的循环体\ncontinue|中止本次循环，转入下一次循环\nnext|跳过当前行，读入下一行文本开始处理\nexit|结束文本读入，转入END{}执行，没有则直接退出\n\n## sed文本流处理\n> sed:Stream EDitor，流式编辑器，基于模式匹配过滤及修改文本，逐行处理并将结果输出到屏幕，可实现文本过滤／删除／替换／复制／剪切，以及导入／导出等各种操作\n\n* 用法1:前置命令|sed [选项] ‘编辑指令’，如：se -n /etc/inittab |sed -n '4,7p'\n* 用法2:sed [选项] ‘编辑指令’ 文件\n~~~\n编辑指令由“[定址符]处理动作”组成，[定址符]的格式为“[地址1，[地址2]]”\n~~~\n选项：\n~~~\n-n:屏蔽默认输出\n-i:直接修改文件内容\n-f:使用sed脚本\n-e:可指定多个处理动作\n-r:启用扩展的正则表达式，若与其他选项一起使用，应作为首个选项\n{}:可组合多个命令，以分号分隔\n~~~\n处理动作：替换操作的分隔符“／”可用其他字符，如#、&等以便于修改文件路径\n操作符|用途|指令示例\n---|---|------\np|打印行|2,4p 输出2，3，4行 🔥 2p；4p输出第2行、4行\nd|删除行|2,4d 删除第2，3，4行\ns|字符串替换|s/old/new/ 将每行第1个old替换为new\n|||s/old/new/3 将每行第3个old替换为new\n|||s/old/new/g 将所有的old替换为new\n4,+10p|加10行|输出第4行及其后10行内容\nn|表示下一行|p:n输出奇数行\n||n:p输出偶数行\n$=|输出文件的行数|sed -n '$=' a.txxt\ni|行前插入文本|2iYY 在第2行前添加文本行YY\n|||4，7iYY 在第4-7行每一行钱添加文本行YY\na|行后插入文本|2aYY 在第2行后插入YY\nc|替换当前行|2cYY 将第2行内容修改为YY\nr|读取文件，结合-i选项才会存入，否则只输出|3r b.txt 在第3行下发插入文本b.txt\nw|保存到文件，以覆盖方式|3w b.txt 将第3行保存到b.txt\n\nsed复制剪切\n* 模式空间:存放当前处理的行，将处理结果输出；若当前行不符合处理条件则原样输出；处理完当前行再读入下一行来处理\n* 保存空间:作用类似剪贴板，默认存放一个空行\\n\n选项：\n~~~\n-H：模式空间 追加 到 保持空间 ，即复制\n-h：模式空间 覆盖 到 保持空间 ，即复制\n-G：保持空间 追加 到 模式空间 ，即粘贴\n-g：保持空间 覆盖 到 模式空间 ，即粘贴\n\nsed '1,3H;$G' reg.txt //把第1～3行复制到文件末尾\n~~~\n\n# 实战脚本\n## 基本知识\n1. 查看用户信息：id gsuis\n2. \n\n## awk&sed应用实战\n\n\n\n","slug":"Linux-Shell编程入门","published":1,"updated":"2019-02-14T08:08:59.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue5600ej5b8hdlhede9x","content":"<h1 id=\"认识shell环境\"><a class=\"markdownIt-Anchor\" href=\"#认识shell环境\"></a> 认识Shell环境</h1>\n<ul>\n<li>Shell是工作在Linux内核与用户之间的==解释程序==，相当于操作系统的“外壳”，是向Linux内核传达用户指令的“翻译官”，通常指BASH（/bin/bash）,常见的还有zsh、tcsh，用于和操作系统内核交互，操作系统内核控制底层硬件</li>\n<li>windows下的Shell为cmd.exe</li>\n<li>查看当前的Shell的命令为：echo $SHELL</li>\n<li>可以手动选择Shell环境，直接在Shell中输入shell如：tcsh，相当于新建了一个子环境（父–子进程）</li>\n<li>shell操作有交互式和非交互式两种</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>交互式</th>\n<th>非交互式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>人工干预、智能化程度低</td>\n<td>需提前设计、智能化难度大</td>\n</tr>\n<tr>\n<td>逐条解释执行、效率低</td>\n<td>批量执行、效率高</td>\n</tr>\n<tr>\n<td></td>\n<td>方便在后台静悄悄地运行</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"shell脚本\"><a class=\"markdownIt-Anchor\" href=\"#shell脚本\"></a> shell脚本</h1>\n<ul>\n<li>shell脚本指提前写好的可执行代码，用来完成特定任务的文件，特点为：顺序、批处理，解释型程序</li>\n<li>shell脚本编写步骤：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1. 理清任务</th>\n<th>自然语言：步骤拆分、顺序化整理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2. 编写可执行语句</td>\n<td>脚本语言：各步骤如何实现</td>\n</tr>\n<tr>\n<td>3. 完善脚本</td>\n<td>界面友好／结构规范／代码优化</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>shell脚本一般以.sh结尾，==第一行 #!/bin/bash== 用来申明Shell环境</p>\n</li>\n<li>\n<p>shell脚本的免交互及输出处理</p>\n<ul>\n<li>免交互：通过选项 ==–stdin== 可以从标准输入读取字串；也可以从键盘或由另一个命令给出</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修改root密码</span><br><span class=\"line\">passwd --stdin root     //从键盘读入</span><br><span class=\"line\">echo 1234567 | passwd --stdin root  //由echo命令给出</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>输出处理：</p>\n<ul>\n<li>忽略无关输出:黑洞设备/dev/null</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相当于只能写入、不能读出的单向文件；存放到其中的数据都会丢失，用法：可执行语句 &amp;&gt; /dev/null，如：</span><br><span class=\"line\">echo 1234567 | passwd --stdin root &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<ul>\n<li>记录错误输出：根据需要，将出错信息保存到指定文件</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是针对后台脚本的有效排错手段，适用于不便交互但又需要查看报错的情况，用法：可执行语句 2&gt;/路径／文件，如：</span><br><span class=\"line\">useradd root 2&gt;/tmp/err.log</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>命令的组合运用</p>\n<ul>\n<li>顺序分割–==使用分号==，格式：命令1；命令2；命令3…,依次执行，只有先后，没有逻辑关系</li>\n<li>逻辑“与”分割–==使用&amp;&amp;==，格式：命令1 &amp;&amp; 命令2 &amp;&amp; 命令3…,逻辑关系为“而且”（and），期望所有命令都能执行成功，一旦出现失败，后续命令不再执行</li>\n<li>逻辑“或”分割–==使用||==，格式：命令1 || 命令2 || 命令3…,逻辑关系为“或者”（or），任何一条成功都符合期望，只在前面的命令失败时，后续命令才执行</li>\n<li>管道–==使用|==，格式：命令1|命令2，后续命令要能正确处理传来的文本，否则无意义，如：</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /etc -type f | wc -l   //计算／etc下文件数量，将结果交给wc统计行数</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>shell脚本的运行方式</p>\n<ul>\n<li>作为指定shell解释程序的参数</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-sh 代码文件路径    ===     bash 代码文件路径</span><br><span class=\"line\">-.  代码文件路径    ===     source  代码文件路径</span><br></pre></td></tr></table></figure>\n<ul>\n<li>作为可独立运行的脚本程序</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为shell代码文件添加x权限，指定脚本路径即可运行.如：</span><br><span class=\"line\">chmod +x ／root／first.sh；/root/first.sh</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"标准输入输出和重定向\"><a class=\"markdownIt-Anchor\" href=\"#标准输入输出和重定向\"></a> 标准输入输出和重定向</h1>\n<blockquote>\n<p>Unix/Linux基本思想：普通文件、目录、鼠标、键盘…都是以文件形式存在；要访问硬件设备，必须找对应的设备文件</p>\n</blockquote>\n<p>I/O交互设备</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>设备文件</th>\n<th>文件描述号</th>\n<th>默认设备</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标准输入</td>\n<td>/dev/stdin</td>\n<td>0</td>\n<td>键盘</td>\n<td>从此设备接收用户输入的数据</td>\n</tr>\n<tr>\n<td>标准输出</td>\n<td>/dev/stdout</td>\n<td>1</td>\n<td>显示器</td>\n<td>通过此设备向用户报告正常的命令输出结果</td>\n</tr>\n<tr>\n<td>标准错误输出</td>\n<td>/dev/stderr</td>\n<td>2</td>\n<td>显示器</td>\n<td>通过此设备报告执行中的错误信息</td>\n</tr>\n</tbody>\n</table>\n<p>重定向：重新指定命令执行是I/O设备的方向</p>\n<p>根据I／O方向和类型区分</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>操作符</th>\n<th>用途</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重定向输入</td>\n<td>&lt;</td>\n<td>将文本输入来源由键盘改为指定的文件</td>\n<td>mial -s ‘A Test Mail’ root@localhost &lt; /root/mail.txt</td>\n</tr>\n<tr>\n<td>重定向输出</td>\n<td>&gt;</td>\n<td>将命令行的正常输出保存到文件，而非显示器</td>\n<td>echo ‘nameserver 8.8.8.8’ &gt; /etc/resolv.conf</td>\n</tr>\n<tr>\n<td>重定向输出</td>\n<td>&gt;&gt;</td>\n<td>与“&gt;”类似，但操作是追加而不是覆盖</td>\n<td></td>\n</tr>\n<tr>\n<td>重定向错误</td>\n<td>2&gt;</td>\n<td>将命令行的错误输出保存到文件，而非显示器</td>\n<td></td>\n</tr>\n<tr>\n<td>重定向错误</td>\n<td>2&gt;&gt;</td>\n<td>与“2&gt;”类似，但操作是追加而不是覆盖</td>\n<td></td>\n</tr>\n<tr>\n<td>混合重定向</td>\n<td>&amp;&gt;</td>\n<td>相当于“&gt;”和“2&gt;”</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"脚本逻辑\"><a class=\"markdownIt-Anchor\" href=\"#脚本逻辑\"></a> 脚本逻辑</h1>\n<h2 id=\"变量值及范围控制\"><a class=\"markdownIt-Anchor\" href=\"#变量值及范围控制\"></a> 变量值及范围控制</h2>\n<ol>\n<li>引号在赋值中的应用</li>\n</ol>\n<ul>\n<li>双引号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 在双引号内允许$扩展，可调用其他变量的值</span><br><span class=\"line\">- 出现特殊字符时，可采用\\符号转义</span><br><span class=\"line\">- 当变量值不包括空格、制表符时，双引号通常被省略，如：A=CentOS7</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单引号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 所有字符均视为该字符本身（无特殊含义）</span><br><span class=\"line\">- 不允许\\转义</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>read读入变量值</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 基本格式</span><br><span class=\"line\"> - read 变量名.. ..</span><br><span class=\"line\"> - read -p &quot;提示信息&quot; 变量名 .. ..  //read -p &quot;svr5 login&quot; YOUR_NAME</span><br><span class=\"line\"> - 启用read命令的 -s 选项，可关闭输入回显，适合敏感信息，提高安全性，如密码</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量的作用范围</li>\n</ol>\n<ul>\n<li>局部变量：只在定义此变量的shell环境有效；自定义变量默认都是局部变量</li>\n<li>全局变量：在当前shell及所有子shell环境下有效；子shell中若赋值同名变量，与父shell中变量无关</li>\n</ul>\n<p>发布全局变量</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export 局部变量名[=变量值] .. ..</span><br><span class=\"line\"> - 直接定义／赋值指定的变量，作为全局变量发布</span><br><span class=\"line\"> - 对已有的局部变量，只需发布不需赋值</span><br></pre></td></tr></table></figure>\n<h2 id=\"数值运算及处理\"><a class=\"markdownIt-Anchor\" href=\"#数值运算及处理\"></a> 数值运算及处理</h2>\n<blockquote>\n<p>bash内置机制仅支持整数运算</p>\n</blockquote>\n<h3 id=\"基本运算类别\"><a class=\"markdownIt-Anchor\" href=\"#基本运算类别\"></a> 基本运算类别</h3>\n<p>加减乘除求模  ±*／%</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. expr工具：==expr 数值1 运算符 数值2==  </span><br><span class=\"line\">乘法操作需转义</span><br><span class=\"line\">2. 使用$[]表达式： ==$[数值1 运算符 数值2]==  </span><br><span class=\"line\">* 乘法操作无需转义，运算符两侧可以无空格，引用变量可省略$符号，如：echo $[x+100-Y*2/7]</span><br><span class=\"line\">* 支持混合运算，乘除优先</span><br><span class=\"line\">* 支持乘方运算,如：echo $[10**3]</span><br></pre></td></tr></table></figure>\n<p>自增表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 加减乘除求模自增，如：i+=2 或 i=i+2 或 $[i+=2]</span><br><span class=\"line\">2. 如果步长为1，则支持如： --i，++i/i--，i++</span><br></pre></td></tr></table></figure>\n<p>let命令操作变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作变量值运算，并保存新结果，适用于不需要输出的情况，如：let  x++</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用随机整数\"><a class=\"markdownIt-Anchor\" href=\"#使用随机整数\"></a> 使用随机整数</h3>\n<ol>\n<li>环境变量RANDOM:随机生成0～32767之间的一个整数</li>\n<li>扩大随机数范围：多个随机数相乘</li>\n<li>缩小随机数范围：取余数，如：$[RANDOM%1000]取0～999的整数</li>\n</ol>\n<h3 id=\"整数序列\"><a class=\"markdownIt-Anchor\" href=\"#整数序列\"></a> 整数序列</h3>\n<p>使用seq命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用格式：默认分隔符为\\n</span><br><span class=\"line\">- seq 末数  ;默认从1开始，步长为1</span><br><span class=\"line\">- seq 首数 末数</span><br><span class=\"line\">- seq 首数 步长 末数</span><br><span class=\"line\">参数选项：</span><br><span class=\"line\">  -s：定义分隔符，如：seq -s&apos; &apos; 3,结果“1  2  3”</span><br><span class=\"line\">  -w：等宽显示,不足前面补0</span><br></pre></td></tr></table></figure>\n<h3 id=\"bc计算器\"><a class=\"markdownIt-Anchor\" href=\"#bc计算器\"></a> bc计算器</h3>\n<blockquote>\n<p>bc运算器支持高精度的数值运算，输入bc进入交互式预算界面，quit退出，设置scale=n可约束小数位，也支持小数值的比较，大多数Linux系统已内置</p>\n</blockquote>\n<p>使用举例：</p>\n<ol>\n<li>echo “scale=4;123.4*2.5” | bc</li>\n<li>echo “<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">A&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>B” | bc</li>\n</ol>\n<h2 id=\"shell变量\"><a class=\"markdownIt-Anchor\" href=\"#shell变量\"></a> Shell变量</h2>\n<ul>\n<li>变量：以固定名称存放的可能会变化的值</li>\n<li>定义／赋值变量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名=变量值</span><br><span class=\"line\">1. 如果变量名已存在，则相当于赋值</span><br><span class=\"line\">2. 等号两边不能有空格</span><br><span class=\"line\">3. 变量区分大小写</span><br><span class=\"line\">4. 变量名不能以数字开头，不要使用关键字和特殊字符</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看／引用变量：$变量名  或  ${变量名}</li>\n<li>取消变量：退出shell变量自动失效 或  ==unset 变量名==  方式手动取消</li>\n</ul>\n<p>变量的分类</p>\n<ol>\n<li>存储类型：shell不作为高级编程语言，对存储类型的要求比较松散</li>\n<li>使用类型</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>环境变量</td>\n<td>变量名通常大写，由系统维护，用来设置工作环境，其中只有个别变量用户可以直接修改</td>\n<td>配置文件：/etc/profile,~/.bash_profile</td>\n</tr>\n<tr>\n<td>位置变量</td>\n<td>由bash内置，用来存储在执行脚本时提供的命令行参数</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">从</mi><mn>1</mn><mi mathvariant=\"normal\">开</mi><mi mathvariant=\"normal\">始</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">当</mi><mi>n</mi><mo>&gt;</mo><mn>10</mn><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">格</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">为</mi><mo>=</mo><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">n,从1开始,当n&gt;10，格式为 ==</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">从</span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">开</span><span class=\"mord cjk_fallback\">始</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">当</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">格</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">为</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>{n}==</td>\n</tr>\n<tr>\n<td>预定义变量</td>\n<td>由bash内置，一类有特殊用途的变量，可以直接调用，但不能直接赋值或修改</td>\n<td>参见下表与定义变量定义</td>\n</tr>\n<tr>\n<td>自定义变量</td>\n<td>用户自主设置、修改及使用</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>env-列出所有环境变量；<br>\nset-列出所有变量</p>\n<p>常见环境变量：PWD,PATH,USER,LOGNAME,UID,SHELL,HOME,PS1,PS2…</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$0</td>\n<td>当前所在进程或脚本名</td>\n<td></td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前运行进程PID</td>\n<td></td>\n</tr>\n<tr>\n<td>$?</td>\n<td>命令执行后的状态值，0-正常   1或其他-异常</td>\n<td></td>\n</tr>\n<tr>\n<td>$#</td>\n<td>已加载位置变量个数</td>\n<td>如传入参数个数判断: if[ $# -ne 2 ]</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>所有位置变量的值</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"条件测试\"><a class=\"markdownIt-Anchor\" href=\"#条件测试\"></a> 条件测试</h2>\n<h3 id=\"返回状态值\"><a class=\"markdownIt-Anchor\" href=\"#返回状态值\"></a> 返回状态值：$?</h3>\n<h3 id=\"专用测试工具test\"><a class=\"markdownIt-Anchor\" href=\"#专用测试工具test\"></a> 专用测试工具test</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* test 选项  参数...</span><br><span class=\"line\">* [ 选项 参数... ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件状态检测test的参数则为文件或目录\"><a class=\"markdownIt-Anchor\" href=\"#文件状态检测test的参数则为文件或目录\"></a> 文件状态检测：test的参数则为文件或目录</h3>\n<table>\n<thead>\n<tr>\n<th>测试选项</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-e</td>\n<td>检测对象是否存在Exist</td>\n<td>[ -e /etc/test ];echo $?</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>检测对象是否为目录Directory</td>\n<td></td>\n</tr>\n<tr>\n<td>-f</td>\n<td>检测对象是否为文件File</td>\n<td></td>\n</tr>\n<tr>\n<td>-r</td>\n<td>检测对象是否有可读权限Read</td>\n<td></td>\n</tr>\n<tr>\n<td>-w</td>\n<td>检测对象是否有可写权限Write</td>\n<td></td>\n</tr>\n<tr>\n<td>-x</td>\n<td>检测对象是否有可执行权限eXcute</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"整数值比较\"><a class=\"markdownIt-Anchor\" href=\"#整数值比较\"></a> 整数值比较</h3>\n<table>\n<thead>\n<tr>\n<th>测试选项</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-eq</td>\n<td>等于Equal</td>\n<td>[ $(who|wc -l) -eq 10 ]//判断登陆用户数等于10</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>不等于Not Equal</td>\n<td></td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>大于或等于 Greater or Equal</td>\n<td></td>\n</tr>\n<tr>\n<td>-le</td>\n<td>小于或等于 Lesser or Equal</td>\n<td></td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>大于 Greater Than</td>\n<td></td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>小于 Lesser Than</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"组合多个条件\"><a class=\"markdownIt-Anchor\" href=\"#组合多个条件\"></a> 组合多个条件</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* test 测试条件1 -a或-o 测试条件2...</span><br><span class=\"line\">* [[ 测试条件1 &amp;&amp;或|| 测试条件2...]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串比较\"><a class=\"markdownIt-Anchor\" href=\"#字符串比较\"></a> 字符串比较</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* [ 字符串1 选项  字符串2 ]</span><br><span class=\"line\">* [ 选项 字符串 ]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>测试选项</th>\n<th>含义</th>\n<th>举例/说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>两字符串相同</td>\n<td>[ $USER = ‘root’ ] &amp;&amp; echo $USER</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>两字符串不同</td>\n<td></td>\n</tr>\n<tr>\n<td>-z</td>\n<td>字符串值为空</td>\n<td>Zero</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>字符串值不为空</td>\n<td>Not zero</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"将条件取反\"><a class=\"markdownIt-Anchor\" href=\"#将条件取反\"></a> 将条件取反</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">[ ! 测试条件 ]</span><br><span class=\"line\">举例：</span><br><span class=\"line\">[ ! 100 -gt 200] &amp;&amp; echo YES</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串处理\"><a class=\"markdownIt-Anchor\" href=\"#字符串处理\"></a> 字符串处理</h2>\n<h3 id=\"截取字符串\"><a class=\"markdownIt-Anchor\" href=\"#截取字符串\"></a> 截取字符串</h3>\n<ol>\n<li>使用expr命令，==expr substr $var1 起始位置 截取长度==</li>\n<li>使用cut命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 命令输出|cut -c 起始位置-结束位置，echo $var1|cut -c 5-6</span><br><span class=\"line\">* 命令输出|cut -d &apos;分隔符&apos; -f 字段编号....,echo &quot;CentOS6.5&quot; |cut -d &apos;t&apos; -f2 //OS6.5，相当于java中的split[2]</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用${}</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* $&#123;var1:起始位置:截取长度&#125;</span><br><span class=\"line\">* $&#123;var1::截取长度&#125; //默认从头开始</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串替换\"><a class=\"markdownIt-Anchor\" href=\"#字符串替换\"></a> 字符串替换</h3>\n<p>使用${}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* $&#123;var1/old/new&#125;   //只替换一个</span><br><span class=\"line\">* $&#123;var1//old/new&#125;  //替换全部</span><br></pre></td></tr></table></figure>\n<h3 id=\"tr单字替换工具\"><a class=\"markdownIt-Anchor\" href=\"#tr单字替换工具\"></a> tr单字替换工具</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* 命令输出|tr &apos;abc&apos; &apos;ABC&apos;  //abc替换为大写ABC</span><br><span class=\"line\">* 命令输出|tr -d &apos;abc&apos;     //删除所有的abc</span><br></pre></td></tr></table></figure>\n<h3 id=\"路径分割\"><a class=\"markdownIt-Anchor\" href=\"#路径分割\"></a> 路径分割</h3>\n<ul>\n<li>dirname “路径字符串”:取目录位置</li>\n<li>basename “路径字符串”:取基本名称</li>\n</ul>\n<h3 id=\"使用随机字符串\"><a class=\"markdownIt-Anchor\" href=\"#使用随机字符串\"></a> 使用随机字符串</h3>\n<ul>\n<li>随机数变量：RANDOM</li>\n<li>特殊设备文件：/dev/urandom</li>\n<li>UUID生成命令：uuidgen</li>\n</ul>\n<p>随机信息的转换：md5sum</p>\n<blockquote>\n<p>依据输入文本计算出256位(32字符)的MD5编码值</p>\n</blockquote>\n<ul>\n<li>echo $RANDOM |md5sum</li>\n<li>head -1 /dev/urandom|md5sum</li>\n</ul>\n<h3 id=\"命令替换\"><a class=\"markdownIt-Anchor\" href=\"#命令替换\"></a> 命令替换</h3>\n<ol>\n<li>反撇号`</li>\n</ol>\n<ul>\n<li>适用场景：在命令行潜入另一个命令的输出结果；将命令的输出保存到指定变量</li>\n<li>优先执行反撇号内的命令，并将执行结果作为输入</li>\n<li>举例：rpm -qf <code>which tr</code></li>\n</ul>\n<ol start=\"2\">\n<li>$(可执行命令)，优点为==可嵌套使用==，举例：rpm -qf $(which tr)</li>\n</ol>\n<h2 id=\"流程控制\"><a class=\"markdownIt-Anchor\" href=\"#流程控制\"></a> 流程控制</h2>\n<h3 id=\"if语句\"><a class=\"markdownIt-Anchor\" href=\"#if语句\"></a> if语句</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//单分支</span><br><span class=\"line\">if 条件测试</span><br><span class=\"line\">    then 命令序列</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">//双分支</span><br><span class=\"line\">if 条件测试</span><br><span class=\"line\">    then 命令序列1</span><br><span class=\"line\">    else 命令序列2</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">//多分支（嵌套）</span><br><span class=\"line\">if 条件测试1</span><br><span class=\"line\">    then 命令序列1</span><br><span class=\"line\">elif 条件测试2 ;then</span><br><span class=\"line\">    命令序列2</span><br><span class=\"line\">else </span><br><span class=\"line\">    命令序列n</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>说明：如果then要跟着条件测试写在一行，则需在then前加封号，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 条件测试 ;then</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h3 id=\"for循环\"><a class=\"markdownIt-Anchor\" href=\"#for循环\"></a> for循环</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for 变量名 in 值列表</span><br><span class=\"line\">do</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"while循环\"><a class=\"markdownIt-Anchor\" href=\"#while循环\"></a> while循环</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while 条件测试</span><br><span class=\"line\">do</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"case分支\"><a class=\"markdownIt-Anchor\" href=\"#case分支\"></a> case分支</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case 变量值  in</span><br><span class=\"line\">模式1)</span><br><span class=\"line\">    命令序列1;;</span><br><span class=\"line\">模式2)</span><br><span class=\"line\">    命令序列2;;</span><br><span class=\"line\">    .. ..</span><br><span class=\"line\">*)</span><br><span class=\"line\">    默认命令序列</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<h3 id=\"中断及退出控制\"><a class=\"markdownIt-Anchor\" href=\"#中断及退出控制\"></a> 中断及退出控制</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>跳出当前所在循环体，执行循环体后的语句块</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>退出脚本，可以指定返回的状态值，默认返回0</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"编写服务脚本\"><a class=\"markdownIt-Anchor\" href=\"#编写服务脚本\"></a> 编写服务脚本</h2>\n<h3 id=\"shell函数\"><a class=\"markdownIt-Anchor\" href=\"#shell函数\"></a> shell函数</h3>\n<p>type 名称  //查看名称对应类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本格式:</span><br><span class=\"line\">function 函数名()&#123;</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">    .. ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或🔥</span><br><span class=\"line\">函数名()&#123;</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">    .. ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">调用： 函数名</span><br><span class=\"line\">传参： 函数名  参数1  参数2 .. ..  //传递的值作为函数的位置参数</span><br></pre></td></tr></table></figure>\n<h3 id=\"系统服务管理\"><a class=\"markdownIt-Anchor\" href=\"#系统服务管理\"></a> 系统服务管理</h3>\n<ul>\n<li>查看服务列表、自启状态</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>chkconfig --list [服务名]</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>chkconfig 服务名  on/off</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>启动／停止／重启服务</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>service 服务名 start/stop/restart</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>/etc/init.d/服务名 start/stop/restart</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>ntsysv:可视化设置自启动状态</li>\n</ul>\n<ol>\n<li>shell脚本直接交给service控制，则将脚本或者脚本的快捷方式放到/etc/init.d／下即可</li>\n<li>shell脚本交给chkconfig工具管理,需设置适用级别、启动／停止顺序、服务说明</li>\n</ol>\n<ul>\n<li>添加设置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#</span><br><span class=\"line\"># chkconfig:2345 10 95</span><br><span class=\"line\"># description:服务相关说明</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加服务：chkconfig --add 服务名</li>\n</ul>\n<h2 id=\"文件的排序集统计\"><a class=\"markdownIt-Anchor\" href=\"#文件的排序集统计\"></a> 文件的排序集统计</h2>\n<h3 id=\"ls列表排序\"><a class=\"markdownIt-Anchor\" href=\"#ls列表排序\"></a> ls列表排序</h3>\n<ul>\n<li>-S:按文档大小降序排列</li>\n<li>-t:按文档的修改时间降序排列</li>\n<li>-r:反序排列</li>\n</ul>\n<h3 id=\"uniq去重工具\"><a class=\"markdownIt-Anchor\" href=\"#uniq去重工具\"></a> uniq去重工具</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法1：uniq 文件</span><br><span class=\"line\">用法2: 命令|uniq</span><br></pre></td></tr></table></figure>\n<p>缺点：==未排序的文本会出现重复现象==，需配合其他方式先排序，再去重<br>\n方法：sort 文件名|uniq -c</p>\n<h3 id=\"sort工具\"><a class=\"markdownIt-Anchor\" href=\"#sort工具\"></a> sort工具</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法1:sort 文件</span><br><span class=\"line\">用法2:命令|sort</span><br><span class=\"line\"></span><br><span class=\"line\">常用选项：</span><br><span class=\"line\">* -u: 去除重复行</span><br><span class=\"line\">* -n：按数字升序排列</span><br><span class=\"line\">* -r：反向排序</span><br><span class=\"line\">* -k：优先对第几列内容排序，即优先对哪个字段排序，只是字段是通过显示顺序编号的</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本处理的的特殊应用\"><a class=\"markdownIt-Anchor\" href=\"#文本处理的的特殊应用\"></a> 文本处理的的特殊应用</h2>\n<h3 id=\"tac-rev反序输出\"><a class=\"markdownIt-Anchor\" href=\"#tac-rev反序输出\"></a> tac、rev反序输出</h3>\n<ul>\n<li>tac：以行为单位反序，与cat命令效果相反</li>\n<li>rev: 以字符为单位反序，与echo命令效果相反</li>\n</ul>\n<h3 id=\"tee整合重定向\"><a class=\"markdownIt-Anchor\" href=\"#tee整合重定向\"></a> tee整合重定向</h3>\n<p>举例：uname -r|tee un.txt</p>\n<h3 id=\"unix2dos与dos2unix转换\"><a class=\"markdownIt-Anchor\" href=\"#unix2dos与dos2unix转换\"></a> unix2dos与dos2unix转换</h3>\n<p>windows和linux系统文本格式转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装：yum -y install unix2dos dos2unix</span><br><span class=\"line\">基本用法：</span><br><span class=\"line\">* unix2dos Linux文件</span><br><span class=\"line\">* dos2unix Windows文件</span><br></pre></td></tr></table></figure>\n<h2 id=\"xargs多参数处理\"><a class=\"markdownIt-Anchor\" href=\"#xargs多参数处理\"></a> xargs多参数处理</h2>\n<p>背景：ls、mv、rm、cp等命令给出的参数长度不能超过2.5M，基于*匹配、find等方式处理大量文件时容易出错</p>\n<h3 id=\"多参数的分散处理\"><a class=\"markdownIt-Anchor\" href=\"#多参数的分散处理\"></a> 多参数的分散处理</h3>\n<ul>\n<li>利用find… … -exec… … 查找处理  //仅适用于处理文件或目录参数，如：find / -exec ls -lh {} ;</li>\n<li>xargs工具:根据给定的参数组（以行为单位）分次执行目标命令行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法1：提供参数的命令 | xargs 目标命令，如：find /|args ls -lh</span><br><span class=\"line\">用法2: xargs --arg-file=提供参数的文件  目标命令</span><br><span class=\"line\">选项：</span><br><span class=\"line\">* -I：定义标记，如：ls txt.log* | xargs -I&#123;&#125; cp &#123;&#125; &#123;&#125;.new</span><br><span class=\"line\">* -d: 制定分割符，默认按行分割，如：head -1 /etc/passwd |xargs -d: -I&#123;&#125; echo &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"expect预期交互控制\"><a class=\"markdownIt-Anchor\" href=\"#expect预期交互控制\"></a> expect预期交互控制</h2>\n<blockquote>\n<p>基于TCL编写的自动化交互式程序，可以用在Shell脚本中，为FTP、SSH等交互过程自动输送预先准备的文本或指令，而无需人工干预，出发的依据是预期会出现的特征提示文本</p>\n</blockquote>\n<ul>\n<li>安装：yum -y install expect</li>\n</ul>\n<ol>\n<li>手动交互</li>\n<li>自动交互</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat mike-ftp.sh</span><br><span class=\"line\">--------------------</span><br><span class=\"line\">spawn ftp 192.168.4.5</span><br><span class=\"line\">expect &quot;):&quot;</span><br><span class=\"line\">send &quot;mike\\r&quot;</span><br><span class=\"line\">expect &quot;Password:&quot;</span><br><span class=\"line\">send &quot;123456\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;put install.log\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;quit\\r&quot;</span><br><span class=\"line\">---------------------</span><br><span class=\"line\">epxect mike-ftp.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>调整执行环境：添加Sha-Bang环境声明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat mike-ftp.sh</span><br><span class=\"line\">-----------------------</span><br><span class=\"line\">#!/usr/bin/expect</span><br><span class=\"line\">spawn ftp 192.168.4.5</span><br><span class=\"line\">expect &quot;):&quot;</span><br><span class=\"line\">send &quot;mike\\r&quot;</span><br><span class=\"line\">expect &quot;Password:&quot;</span><br><span class=\"line\">send &quot;123456\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;put install.log\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;quit\\r&quot;</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">sh mike-ftp.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>SSH登陆免交互举例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/expect</span><br><span class=\"line\">set host 192.168.4.5</span><br><span class=\"line\">set user mike</span><br><span class=\"line\">set password &quot;1234567&quot;</span><br><span class=\"line\">spawn ssh $user@$host</span><br><span class=\"line\">expect &quot;password:&quot;&#123;send &quot;$password\\r&quot;&#125;</span><br><span class=\"line\">expect &quot;\\[$user\\@&quot;&#123;send &quot;pwd&gt;/tmp/$user.txt;exit\\r&quot;&#125;</span><br><span class=\"line\">expect eof</span><br></pre></td></tr></table></figure>\n<h1 id=\"应用技巧\"><a class=\"markdownIt-Anchor\" href=\"#应用技巧\"></a> 应用技巧</h1>\n<h2 id=\"正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#正则表达式\"></a> 正则表达式</h2>\n<blockquote>\n<p>使用“一串符号”来描述有共同属性的数据</p>\n</blockquote>\n<h3 id=\"egrep测试工具\"><a class=\"markdownIt-Anchor\" href=\"#egrep测试工具\"></a> egrep测试工具</h3>\n<ul>\n<li>用法1:egrep [选项] ‘正则表达式’ 文件</li>\n<li>用法2:前置命令|egrep [选项] ‘正则表达式’</li>\n</ul>\n<p>选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i：忽略大小写</span><br><span class=\"line\">-v: 取反</span><br><span class=\"line\">-c：统计匹配行数</span><br><span class=\"line\">-q：静默、无任何输出</span><br><span class=\"line\">-n：显示出所匹配结果所在的行号</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本元字符\"><a class=\"markdownIt-Anchor\" href=\"#基本元字符\"></a> 基本元字符</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>匹配行首</td>\n<td>^abc 或 ^#</td>\n<td>以abc开头的行  或  以#开头的行（比如注释行）</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配行尾</td>\n<td>abc$ 或 ^$</td>\n<td>以abc结尾的行  或  空行</td>\n</tr>\n<tr>\n<td>.</td>\n<td>单个字符</td>\n<td>.</td>\n<td>除换行符\\n以外的任意单个字符</td>\n</tr>\n<tr>\n<td>+</td>\n<td>最少匹配一次</td>\n<td>a+ 或 (abc)+</td>\n<td>一个或多个连续的a 或  一个或多个连续的abc</td>\n</tr>\n<tr>\n<td>?</td>\n<td>最多匹配一次</td>\n<td>a? 或 (abc)?</td>\n<td>0个或1个a 或  0或1个abc</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配任意次数</td>\n<td>a* 或 (abc)* 或 .*</td>\n<td>0个或多个连续的a 或 0个或多个连续的abc 或 任意长度的任意字符串</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配n次</td>\n<td>(ab){3}</td>\n<td>匹配ababab</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配n～m次</td>\n<td>(ab){1,3}</td>\n<td>匹配ab、abab、ababab</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>匹配至少n次</td>\n<td>(ab){2,}</td>\n<td>匹配2个及以上连续的ab</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>匹配范围内的单个字符</td>\n<td>[a-z]</td>\n<td>匹配任意小写字母</td>\n</tr>\n<tr>\n<td>[]内加^</td>\n<td>可取反</td>\n<td>[^a-z]</td>\n<td>匹配任意非小写字母</td>\n</tr>\n<tr>\n<td>()</td>\n<td>组合为整体</td>\n<td>(ab)</td>\n<td>连续的ab</td>\n</tr>\n<tr>\n<td></td>\n<td>或者</td>\n<td>root|bin</td>\n<td>匹配root、bin</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>单词边界</td>\n<td>\\broot\\b</td>\n<td>匹配root，不匹配keroot、rooty、brooty等字符串</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>单词的开头</td>\n<td>&lt;th</td>\n<td>匹配以th开头的单词</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>单词的结尾</td>\n<td>th&gt;</td>\n<td>匹配以th结尾的单词</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"awk文本过滤\"><a class=\"markdownIt-Anchor\" href=\"#awk文本过滤\"></a> awk文本过滤</h2>\n<blockquote>\n<p>awk:模式扫描及处理语言，创始人Aho、Weinberger、Kernighan，基于模式匹配检查输入的文本，逐行处理并print结果，目前最常用的实际是GNU版本的gawk</p>\n</blockquote>\n<ul>\n<li>用法1:前置命令|awk [选项] ‘[条件]{编辑指令}’</li>\n<li>用法2:awk [选项] ‘[条件]{编辑指令}’ 文件，如：awk -F “:” ‘{print $1,$2} /etc/passwd’</li>\n</ul>\n<p>条件的表现形式</p>\n<ul>\n<li>正则表达式，/正则表达式/ 🔥 ~匹配、!~不匹配,如：awk -F: ‘/^ro/{print}’ /etc/passwd</li>\n<li>数值／字符串比较</li>\n<li>逻辑比较</li>\n<li>运算符</li>\n</ul>\n<p>选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F:指定分隔符，可省略，默认空格或Tab位，如：awk -F: &apos;$1==ENVIRON[&quot;USER&quot;]&#123;print $3&#125;&apos; /etc/passwd  //输出当前用户的UID信息</span><br><span class=\"line\">-f:调用awk脚本进行处理</span><br></pre></td></tr></table></figure>\n<p>awk内置变量</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FS</td>\n<td>保存或设置字段分隔符，如 FS=“：”</td>\n</tr>\n<tr>\n<td>$n</td>\n<td>指定分隔符的第n个字段，如$1、$3分别表示第1、第3列</td>\n</tr>\n<tr>\n<td>$0</td>\n<td>当前读入的整行文本内容</td>\n</tr>\n<tr>\n<td>NF</td>\n<td>记录当前处理的字段个数（列数）</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>记录当前已读入行的数量（行数）</td>\n</tr>\n<tr>\n<td>FNR</td>\n<td>保存当前处理行在元文本内的序号（行号）</td>\n</tr>\n<tr>\n<td>FILENAME</td>\n<td>当前处理的文件名</td>\n</tr>\n<tr>\n<td>ENVIRON</td>\n<td>调用Shell环境变量，格式：ENVIRON[“变量名”]</td>\n</tr>\n</tbody>\n</table>\n<p>awk处理的时机：可单独使用，也可以同时一起使用，具体如下：</p>\n<ul>\n<li>行前处理,BEGIN{}:读入第一行文本之前执行，一般用来初始化操作</li>\n<li>逐行处理,{}：逐行读入文本执行相应的处理，是最常见的编辑指令块</li>\n<li>行后处理，END{}：处理完最后一行文本之后执行，一般用来输出处理结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &apos;BEGIN&#123;print NR&#125;END&#123;print NR&#125;&apos; m.txt</span><br></pre></td></tr></table></figure>\n<p>awk的流程控制</p>\n<ul>\n<li>if分支，如：if(条件){编辑指令1}else if(条件){编辑指令12}…else{编辑指令n}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F: &apos;BEGIN&#123;i=0;j=0&#125;&#123;if($3&lt;500)&#123;i++&#125;else&#123;j++&#125;&#125;END&#123;print i,j&#125;&apos;     /etc/passwd</span><br></pre></td></tr></table></figure>\n<ul>\n<li>while循环，如：while(条件){编辑指令}</li>\n<li>do while循环，如：do {编辑指令}while(条件)</li>\n<li>for循环,如：for(初值；条件；步长){编辑指令}</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>结束当前的循环体</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>中止本次循环，转入下一次循环</td>\n</tr>\n<tr>\n<td>next</td>\n<td>跳过当前行，读入下一行文本开始处理</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>结束文本读入，转入END{}执行，没有则直接退出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"sed文本流处理\"><a class=\"markdownIt-Anchor\" href=\"#sed文本流处理\"></a> sed文本流处理</h2>\n<blockquote>\n<p>sed:Stream EDitor，流式编辑器，基于模式匹配过滤及修改文本，逐行处理并将结果输出到屏幕，可实现文本过滤／删除／替换／复制／剪切，以及导入／导出等各种操作</p>\n</blockquote>\n<ul>\n<li>用法1:前置命令|sed [选项] ‘编辑指令’，如：se -n /etc/inittab |sed -n ‘4,7p’</li>\n<li>用法2:sed [选项] ‘编辑指令’ 文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑指令由“[定址符]处理动作”组成，[定址符]的格式为“[地址1，[地址2]]”</span><br></pre></td></tr></table></figure>\n<p>选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-n:屏蔽默认输出</span><br><span class=\"line\">-i:直接修改文件内容</span><br><span class=\"line\">-f:使用sed脚本</span><br><span class=\"line\">-e:可指定多个处理动作</span><br><span class=\"line\">-r:启用扩展的正则表达式，若与其他选项一起使用，应作为首个选项</span><br><span class=\"line\">&#123;&#125;:可组合多个命令，以分号分隔</span><br></pre></td></tr></table></figure>\n<p>处理动作：替换操作的分隔符“／”可用其他字符，如#、&amp;等以便于修改文件路径</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>用途</th>\n<th>指令示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>p</td>\n<td>打印行</td>\n<td>2,4p 输出2，3，4行 🔥 2p；4p输出第2行、4行</td>\n</tr>\n<tr>\n<td>d</td>\n<td>删除行</td>\n<td>2,4d 删除第2，3，4行</td>\n</tr>\n<tr>\n<td>s</td>\n<td>字符串替换</td>\n<td>s/old/new/ 将每行第1个old替换为new</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>s/old/new/3 将每行第3个old替换为new</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>s/old/new/g 将所有的old替换为new</td>\n</tr>\n<tr>\n<td>4,+10p</td>\n<td>加10行</td>\n<td>输出第4行及其后10行内容</td>\n</tr>\n<tr>\n<td>n</td>\n<td>表示下一行</td>\n<td>p:n输出奇数行</td>\n</tr>\n<tr>\n<td></td>\n<td>n:p输出偶数行</td>\n<td></td>\n</tr>\n<tr>\n<td>$=</td>\n<td>输出文件的行数</td>\n<td>sed -n ‘$=’ a.txxt</td>\n</tr>\n<tr>\n<td>i</td>\n<td>行前插入文本</td>\n<td>2iYY 在第2行前添加文本行YY</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>4，7iYY 在第4-7行每一行钱添加文本行YY</td>\n</tr>\n<tr>\n<td>a</td>\n<td>行后插入文本</td>\n<td>2aYY 在第2行后插入YY</td>\n</tr>\n<tr>\n<td>c</td>\n<td>替换当前行</td>\n<td>2cYY 将第2行内容修改为YY</td>\n</tr>\n<tr>\n<td>r</td>\n<td>读取文件，结合-i选项才会存入，否则只输出</td>\n<td>3r b.txt 在第3行下发插入文本b.txt</td>\n</tr>\n<tr>\n<td>w</td>\n<td>保存到文件，以覆盖方式</td>\n<td>3w b.txt 将第3行保存到b.txt</td>\n</tr>\n</tbody>\n</table>\n<p>sed复制剪切</p>\n<ul>\n<li>模式空间:存放当前处理的行，将处理结果输出；若当前行不符合处理条件则原样输出；处理完当前行再读入下一行来处理</li>\n<li>保存空间:作用类似剪贴板，默认存放一个空行\\n<br>\n选项：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-H：模式空间 追加 到 保持空间 ，即复制</span><br><span class=\"line\">-h：模式空间 覆盖 到 保持空间 ，即复制</span><br><span class=\"line\">-G：保持空间 追加 到 模式空间 ，即粘贴</span><br><span class=\"line\">-g：保持空间 覆盖 到 模式空间 ，即粘贴</span><br><span class=\"line\"></span><br><span class=\"line\">sed &apos;1,3H;$G&apos; reg.txt //把第1～3行复制到文件末尾</span><br></pre></td></tr></table></figure>\n<h1 id=\"实战脚本\"><a class=\"markdownIt-Anchor\" href=\"#实战脚本\"></a> 实战脚本</h1>\n<h2 id=\"基本知识\"><a class=\"markdownIt-Anchor\" href=\"#基本知识\"></a> 基本知识</h2>\n<ol>\n<li>查看用户信息：id gsuis</li>\n<li></li>\n</ol>\n<h2 id=\"awksed应用实战\"><a class=\"markdownIt-Anchor\" href=\"#awksed应用实战\"></a> awk&amp;sed应用实战</h2>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"认识shell环境\"><a class=\"markdownIt-Anchor\" href=\"#认识shell环境\"></a> 认识Shell环境</h1>\n<ul>\n<li>Shell是工作在Linux内核与用户之间的==解释程序==，相当于操作系统的“外壳”，是向Linux内核传达用户指令的“翻译官”，通常指BASH（/bin/bash）,常见的还有zsh、tcsh，用于和操作系统内核交互，操作系统内核控制底层硬件</li>\n<li>windows下的Shell为cmd.exe</li>\n<li>查看当前的Shell的命令为：echo $SHELL</li>\n<li>可以手动选择Shell环境，直接在Shell中输入shell如：tcsh，相当于新建了一个子环境（父–子进程）</li>\n<li>shell操作有交互式和非交互式两种</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>交互式</th>\n<th>非交互式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>人工干预、智能化程度低</td>\n<td>需提前设计、智能化难度大</td>\n</tr>\n<tr>\n<td>逐条解释执行、效率低</td>\n<td>批量执行、效率高</td>\n</tr>\n<tr>\n<td></td>\n<td>方便在后台静悄悄地运行</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"shell脚本\"><a class=\"markdownIt-Anchor\" href=\"#shell脚本\"></a> shell脚本</h1>\n<ul>\n<li>shell脚本指提前写好的可执行代码，用来完成特定任务的文件，特点为：顺序、批处理，解释型程序</li>\n<li>shell脚本编写步骤：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1. 理清任务</th>\n<th>自然语言：步骤拆分、顺序化整理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2. 编写可执行语句</td>\n<td>脚本语言：各步骤如何实现</td>\n</tr>\n<tr>\n<td>3. 完善脚本</td>\n<td>界面友好／结构规范／代码优化</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>shell脚本一般以.sh结尾，==第一行 #!/bin/bash== 用来申明Shell环境</p>\n</li>\n<li>\n<p>shell脚本的免交互及输出处理</p>\n<ul>\n<li>免交互：通过选项 ==–stdin== 可以从标准输入读取字串；也可以从键盘或由另一个命令给出</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修改root密码</span><br><span class=\"line\">passwd --stdin root     //从键盘读入</span><br><span class=\"line\">echo 1234567 | passwd --stdin root  //由echo命令给出</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>输出处理：</p>\n<ul>\n<li>忽略无关输出:黑洞设备/dev/null</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相当于只能写入、不能读出的单向文件；存放到其中的数据都会丢失，用法：可执行语句 &amp;&gt; /dev/null，如：</span><br><span class=\"line\">echo 1234567 | passwd --stdin root &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<ul>\n<li>记录错误输出：根据需要，将出错信息保存到指定文件</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是针对后台脚本的有效排错手段，适用于不便交互但又需要查看报错的情况，用法：可执行语句 2&gt;/路径／文件，如：</span><br><span class=\"line\">useradd root 2&gt;/tmp/err.log</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>命令的组合运用</p>\n<ul>\n<li>顺序分割–==使用分号==，格式：命令1；命令2；命令3…,依次执行，只有先后，没有逻辑关系</li>\n<li>逻辑“与”分割–==使用&amp;&amp;==，格式：命令1 &amp;&amp; 命令2 &amp;&amp; 命令3…,逻辑关系为“而且”（and），期望所有命令都能执行成功，一旦出现失败，后续命令不再执行</li>\n<li>逻辑“或”分割–==使用||==，格式：命令1 || 命令2 || 命令3…,逻辑关系为“或者”（or），任何一条成功都符合期望，只在前面的命令失败时，后续命令才执行</li>\n<li>管道–==使用|==，格式：命令1|命令2，后续命令要能正确处理传来的文本，否则无意义，如：</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /etc -type f | wc -l   //计算／etc下文件数量，将结果交给wc统计行数</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>shell脚本的运行方式</p>\n<ul>\n<li>作为指定shell解释程序的参数</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-sh 代码文件路径    ===     bash 代码文件路径</span><br><span class=\"line\">-.  代码文件路径    ===     source  代码文件路径</span><br></pre></td></tr></table></figure>\n<ul>\n<li>作为可独立运行的脚本程序</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为shell代码文件添加x权限，指定脚本路径即可运行.如：</span><br><span class=\"line\">chmod +x ／root／first.sh；/root/first.sh</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"标准输入输出和重定向\"><a class=\"markdownIt-Anchor\" href=\"#标准输入输出和重定向\"></a> 标准输入输出和重定向</h1>\n<blockquote>\n<p>Unix/Linux基本思想：普通文件、目录、鼠标、键盘…都是以文件形式存在；要访问硬件设备，必须找对应的设备文件</p>\n</blockquote>\n<p>I/O交互设备</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>设备文件</th>\n<th>文件描述号</th>\n<th>默认设备</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标准输入</td>\n<td>/dev/stdin</td>\n<td>0</td>\n<td>键盘</td>\n<td>从此设备接收用户输入的数据</td>\n</tr>\n<tr>\n<td>标准输出</td>\n<td>/dev/stdout</td>\n<td>1</td>\n<td>显示器</td>\n<td>通过此设备向用户报告正常的命令输出结果</td>\n</tr>\n<tr>\n<td>标准错误输出</td>\n<td>/dev/stderr</td>\n<td>2</td>\n<td>显示器</td>\n<td>通过此设备报告执行中的错误信息</td>\n</tr>\n</tbody>\n</table>\n<p>重定向：重新指定命令执行是I/O设备的方向</p>\n<p>根据I／O方向和类型区分</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>操作符</th>\n<th>用途</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重定向输入</td>\n<td>&lt;</td>\n<td>将文本输入来源由键盘改为指定的文件</td>\n<td>mial -s ‘A Test Mail’ root@localhost &lt; /root/mail.txt</td>\n</tr>\n<tr>\n<td>重定向输出</td>\n<td>&gt;</td>\n<td>将命令行的正常输出保存到文件，而非显示器</td>\n<td>echo ‘nameserver 8.8.8.8’ &gt; /etc/resolv.conf</td>\n</tr>\n<tr>\n<td>重定向输出</td>\n<td>&gt;&gt;</td>\n<td>与“&gt;”类似，但操作是追加而不是覆盖</td>\n<td></td>\n</tr>\n<tr>\n<td>重定向错误</td>\n<td>2&gt;</td>\n<td>将命令行的错误输出保存到文件，而非显示器</td>\n<td></td>\n</tr>\n<tr>\n<td>重定向错误</td>\n<td>2&gt;&gt;</td>\n<td>与“2&gt;”类似，但操作是追加而不是覆盖</td>\n<td></td>\n</tr>\n<tr>\n<td>混合重定向</td>\n<td>&amp;&gt;</td>\n<td>相当于“&gt;”和“2&gt;”</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"脚本逻辑\"><a class=\"markdownIt-Anchor\" href=\"#脚本逻辑\"></a> 脚本逻辑</h1>\n<h2 id=\"变量值及范围控制\"><a class=\"markdownIt-Anchor\" href=\"#变量值及范围控制\"></a> 变量值及范围控制</h2>\n<ol>\n<li>引号在赋值中的应用</li>\n</ol>\n<ul>\n<li>双引号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 在双引号内允许$扩展，可调用其他变量的值</span><br><span class=\"line\">- 出现特殊字符时，可采用\\符号转义</span><br><span class=\"line\">- 当变量值不包括空格、制表符时，双引号通常被省略，如：A=CentOS7</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单引号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 所有字符均视为该字符本身（无特殊含义）</span><br><span class=\"line\">- 不允许\\转义</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>read读入变量值</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 基本格式</span><br><span class=\"line\"> - read 变量名.. ..</span><br><span class=\"line\"> - read -p &quot;提示信息&quot; 变量名 .. ..  //read -p &quot;svr5 login&quot; YOUR_NAME</span><br><span class=\"line\"> - 启用read命令的 -s 选项，可关闭输入回显，适合敏感信息，提高安全性，如密码</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>变量的作用范围</li>\n</ol>\n<ul>\n<li>局部变量：只在定义此变量的shell环境有效；自定义变量默认都是局部变量</li>\n<li>全局变量：在当前shell及所有子shell环境下有效；子shell中若赋值同名变量，与父shell中变量无关</li>\n</ul>\n<p>发布全局变量</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export 局部变量名[=变量值] .. ..</span><br><span class=\"line\"> - 直接定义／赋值指定的变量，作为全局变量发布</span><br><span class=\"line\"> - 对已有的局部变量，只需发布不需赋值</span><br></pre></td></tr></table></figure>\n<h2 id=\"数值运算及处理\"><a class=\"markdownIt-Anchor\" href=\"#数值运算及处理\"></a> 数值运算及处理</h2>\n<blockquote>\n<p>bash内置机制仅支持整数运算</p>\n</blockquote>\n<h3 id=\"基本运算类别\"><a class=\"markdownIt-Anchor\" href=\"#基本运算类别\"></a> 基本运算类别</h3>\n<p>加减乘除求模  ±*／%</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. expr工具：==expr 数值1 运算符 数值2==  </span><br><span class=\"line\">乘法操作需转义</span><br><span class=\"line\">2. 使用$[]表达式： ==$[数值1 运算符 数值2]==  </span><br><span class=\"line\">* 乘法操作无需转义，运算符两侧可以无空格，引用变量可省略$符号，如：echo $[x+100-Y*2/7]</span><br><span class=\"line\">* 支持混合运算，乘除优先</span><br><span class=\"line\">* 支持乘方运算,如：echo $[10**3]</span><br></pre></td></tr></table></figure>\n<p>自增表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 加减乘除求模自增，如：i+=2 或 i=i+2 或 $[i+=2]</span><br><span class=\"line\">2. 如果步长为1，则支持如： --i，++i/i--，i++</span><br></pre></td></tr></table></figure>\n<p>let命令操作变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作变量值运算，并保存新结果，适用于不需要输出的情况，如：let  x++</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用随机整数\"><a class=\"markdownIt-Anchor\" href=\"#使用随机整数\"></a> 使用随机整数</h3>\n<ol>\n<li>环境变量RANDOM:随机生成0～32767之间的一个整数</li>\n<li>扩大随机数范围：多个随机数相乘</li>\n<li>缩小随机数范围：取余数，如：$[RANDOM%1000]取0～999的整数</li>\n</ol>\n<h3 id=\"整数序列\"><a class=\"markdownIt-Anchor\" href=\"#整数序列\"></a> 整数序列</h3>\n<p>使用seq命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用格式：默认分隔符为\\n</span><br><span class=\"line\">- seq 末数  ;默认从1开始，步长为1</span><br><span class=\"line\">- seq 首数 末数</span><br><span class=\"line\">- seq 首数 步长 末数</span><br><span class=\"line\">参数选项：</span><br><span class=\"line\">  -s：定义分隔符，如：seq -s&apos; &apos; 3,结果“1  2  3”</span><br><span class=\"line\">  -w：等宽显示,不足前面补0</span><br></pre></td></tr></table></figure>\n<h3 id=\"bc计算器\"><a class=\"markdownIt-Anchor\" href=\"#bc计算器\"></a> bc计算器</h3>\n<blockquote>\n<p>bc运算器支持高精度的数值运算，输入bc进入交互式预算界面，quit退出，设置scale=n可约束小数位，也支持小数值的比较，大多数Linux系统已内置</p>\n</blockquote>\n<p>使用举例：</p>\n<ol>\n<li>echo “scale=4;123.4*2.5” | bc</li>\n<li>echo “<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">A&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>B” | bc</li>\n</ol>\n<h2 id=\"shell变量\"><a class=\"markdownIt-Anchor\" href=\"#shell变量\"></a> Shell变量</h2>\n<ul>\n<li>变量：以固定名称存放的可能会变化的值</li>\n<li>定义／赋值变量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名=变量值</span><br><span class=\"line\">1. 如果变量名已存在，则相当于赋值</span><br><span class=\"line\">2. 等号两边不能有空格</span><br><span class=\"line\">3. 变量区分大小写</span><br><span class=\"line\">4. 变量名不能以数字开头，不要使用关键字和特殊字符</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看／引用变量：$变量名  或  ${变量名}</li>\n<li>取消变量：退出shell变量自动失效 或  ==unset 变量名==  方式手动取消</li>\n</ul>\n<p>变量的分类</p>\n<ol>\n<li>存储类型：shell不作为高级编程语言，对存储类型的要求比较松散</li>\n<li>使用类型</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>环境变量</td>\n<td>变量名通常大写，由系统维护，用来设置工作环境，其中只有个别变量用户可以直接修改</td>\n<td>配置文件：/etc/profile,~/.bash_profile</td>\n</tr>\n<tr>\n<td>位置变量</td>\n<td>由bash内置，用来存储在执行脚本时提供的命令行参数</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">从</mi><mn>1</mn><mi mathvariant=\"normal\">开</mi><mi mathvariant=\"normal\">始</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">当</mi><mi>n</mi><mo>&gt;</mo><mn>10</mn><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">格</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">为</mi><mo>=</mo><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">n,从1开始,当n&gt;10，格式为 ==</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">从</span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">开</span><span class=\"mord cjk_fallback\">始</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">当</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">格</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">为</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span></span></span></span>{n}==</td>\n</tr>\n<tr>\n<td>预定义变量</td>\n<td>由bash内置，一类有特殊用途的变量，可以直接调用，但不能直接赋值或修改</td>\n<td>参见下表与定义变量定义</td>\n</tr>\n<tr>\n<td>自定义变量</td>\n<td>用户自主设置、修改及使用</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>env-列出所有环境变量；<br>\nset-列出所有变量</p>\n<p>常见环境变量：PWD,PATH,USER,LOGNAME,UID,SHELL,HOME,PS1,PS2…</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$0</td>\n<td>当前所在进程或脚本名</td>\n<td></td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前运行进程PID</td>\n<td></td>\n</tr>\n<tr>\n<td>$?</td>\n<td>命令执行后的状态值，0-正常   1或其他-异常</td>\n<td></td>\n</tr>\n<tr>\n<td>$#</td>\n<td>已加载位置变量个数</td>\n<td>如传入参数个数判断: if[ $# -ne 2 ]</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>所有位置变量的值</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"条件测试\"><a class=\"markdownIt-Anchor\" href=\"#条件测试\"></a> 条件测试</h2>\n<h3 id=\"返回状态值\"><a class=\"markdownIt-Anchor\" href=\"#返回状态值\"></a> 返回状态值：$?</h3>\n<h3 id=\"专用测试工具test\"><a class=\"markdownIt-Anchor\" href=\"#专用测试工具test\"></a> 专用测试工具test</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* test 选项  参数...</span><br><span class=\"line\">* [ 选项 参数... ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件状态检测test的参数则为文件或目录\"><a class=\"markdownIt-Anchor\" href=\"#文件状态检测test的参数则为文件或目录\"></a> 文件状态检测：test的参数则为文件或目录</h3>\n<table>\n<thead>\n<tr>\n<th>测试选项</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-e</td>\n<td>检测对象是否存在Exist</td>\n<td>[ -e /etc/test ];echo $?</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>检测对象是否为目录Directory</td>\n<td></td>\n</tr>\n<tr>\n<td>-f</td>\n<td>检测对象是否为文件File</td>\n<td></td>\n</tr>\n<tr>\n<td>-r</td>\n<td>检测对象是否有可读权限Read</td>\n<td></td>\n</tr>\n<tr>\n<td>-w</td>\n<td>检测对象是否有可写权限Write</td>\n<td></td>\n</tr>\n<tr>\n<td>-x</td>\n<td>检测对象是否有可执行权限eXcute</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"整数值比较\"><a class=\"markdownIt-Anchor\" href=\"#整数值比较\"></a> 整数值比较</h3>\n<table>\n<thead>\n<tr>\n<th>测试选项</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-eq</td>\n<td>等于Equal</td>\n<td>[ $(who|wc -l) -eq 10 ]//判断登陆用户数等于10</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>不等于Not Equal</td>\n<td></td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>大于或等于 Greater or Equal</td>\n<td></td>\n</tr>\n<tr>\n<td>-le</td>\n<td>小于或等于 Lesser or Equal</td>\n<td></td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>大于 Greater Than</td>\n<td></td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>小于 Lesser Than</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"组合多个条件\"><a class=\"markdownIt-Anchor\" href=\"#组合多个条件\"></a> 组合多个条件</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* test 测试条件1 -a或-o 测试条件2...</span><br><span class=\"line\">* [[ 测试条件1 &amp;&amp;或|| 测试条件2...]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串比较\"><a class=\"markdownIt-Anchor\" href=\"#字符串比较\"></a> 字符串比较</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* [ 字符串1 选项  字符串2 ]</span><br><span class=\"line\">* [ 选项 字符串 ]</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>测试选项</th>\n<th>含义</th>\n<th>举例/说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>两字符串相同</td>\n<td>[ $USER = ‘root’ ] &amp;&amp; echo $USER</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>两字符串不同</td>\n<td></td>\n</tr>\n<tr>\n<td>-z</td>\n<td>字符串值为空</td>\n<td>Zero</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>字符串值不为空</td>\n<td>Not zero</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"将条件取反\"><a class=\"markdownIt-Anchor\" href=\"#将条件取反\"></a> 将条件取反</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">[ ! 测试条件 ]</span><br><span class=\"line\">举例：</span><br><span class=\"line\">[ ! 100 -gt 200] &amp;&amp; echo YES</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串处理\"><a class=\"markdownIt-Anchor\" href=\"#字符串处理\"></a> 字符串处理</h2>\n<h3 id=\"截取字符串\"><a class=\"markdownIt-Anchor\" href=\"#截取字符串\"></a> 截取字符串</h3>\n<ol>\n<li>使用expr命令，==expr substr $var1 起始位置 截取长度==</li>\n<li>使用cut命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 命令输出|cut -c 起始位置-结束位置，echo $var1|cut -c 5-6</span><br><span class=\"line\">* 命令输出|cut -d &apos;分隔符&apos; -f 字段编号....,echo &quot;CentOS6.5&quot; |cut -d &apos;t&apos; -f2 //OS6.5，相当于java中的split[2]</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用${}</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* $&#123;var1:起始位置:截取长度&#125;</span><br><span class=\"line\">* $&#123;var1::截取长度&#125; //默认从头开始</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串替换\"><a class=\"markdownIt-Anchor\" href=\"#字符串替换\"></a> 字符串替换</h3>\n<p>使用${}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* $&#123;var1/old/new&#125;   //只替换一个</span><br><span class=\"line\">* $&#123;var1//old/new&#125;  //替换全部</span><br></pre></td></tr></table></figure>\n<h3 id=\"tr单字替换工具\"><a class=\"markdownIt-Anchor\" href=\"#tr单字替换工具\"></a> tr单字替换工具</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式：</span><br><span class=\"line\">* 命令输出|tr &apos;abc&apos; &apos;ABC&apos;  //abc替换为大写ABC</span><br><span class=\"line\">* 命令输出|tr -d &apos;abc&apos;     //删除所有的abc</span><br></pre></td></tr></table></figure>\n<h3 id=\"路径分割\"><a class=\"markdownIt-Anchor\" href=\"#路径分割\"></a> 路径分割</h3>\n<ul>\n<li>dirname “路径字符串”:取目录位置</li>\n<li>basename “路径字符串”:取基本名称</li>\n</ul>\n<h3 id=\"使用随机字符串\"><a class=\"markdownIt-Anchor\" href=\"#使用随机字符串\"></a> 使用随机字符串</h3>\n<ul>\n<li>随机数变量：RANDOM</li>\n<li>特殊设备文件：/dev/urandom</li>\n<li>UUID生成命令：uuidgen</li>\n</ul>\n<p>随机信息的转换：md5sum</p>\n<blockquote>\n<p>依据输入文本计算出256位(32字符)的MD5编码值</p>\n</blockquote>\n<ul>\n<li>echo $RANDOM |md5sum</li>\n<li>head -1 /dev/urandom|md5sum</li>\n</ul>\n<h3 id=\"命令替换\"><a class=\"markdownIt-Anchor\" href=\"#命令替换\"></a> 命令替换</h3>\n<ol>\n<li>反撇号`</li>\n</ol>\n<ul>\n<li>适用场景：在命令行潜入另一个命令的输出结果；将命令的输出保存到指定变量</li>\n<li>优先执行反撇号内的命令，并将执行结果作为输入</li>\n<li>举例：rpm -qf <code>which tr</code></li>\n</ul>\n<ol start=\"2\">\n<li>$(可执行命令)，优点为==可嵌套使用==，举例：rpm -qf $(which tr)</li>\n</ol>\n<h2 id=\"流程控制\"><a class=\"markdownIt-Anchor\" href=\"#流程控制\"></a> 流程控制</h2>\n<h3 id=\"if语句\"><a class=\"markdownIt-Anchor\" href=\"#if语句\"></a> if语句</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//单分支</span><br><span class=\"line\">if 条件测试</span><br><span class=\"line\">    then 命令序列</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">//双分支</span><br><span class=\"line\">if 条件测试</span><br><span class=\"line\">    then 命令序列1</span><br><span class=\"line\">    else 命令序列2</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">//多分支（嵌套）</span><br><span class=\"line\">if 条件测试1</span><br><span class=\"line\">    then 命令序列1</span><br><span class=\"line\">elif 条件测试2 ;then</span><br><span class=\"line\">    命令序列2</span><br><span class=\"line\">else </span><br><span class=\"line\">    命令序列n</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>说明：如果then要跟着条件测试写在一行，则需在then前加封号，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 条件测试 ;then</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h3 id=\"for循环\"><a class=\"markdownIt-Anchor\" href=\"#for循环\"></a> for循环</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for 变量名 in 值列表</span><br><span class=\"line\">do</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"while循环\"><a class=\"markdownIt-Anchor\" href=\"#while循环\"></a> while循环</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while 条件测试</span><br><span class=\"line\">do</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"case分支\"><a class=\"markdownIt-Anchor\" href=\"#case分支\"></a> case分支</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case 变量值  in</span><br><span class=\"line\">模式1)</span><br><span class=\"line\">    命令序列1;;</span><br><span class=\"line\">模式2)</span><br><span class=\"line\">    命令序列2;;</span><br><span class=\"line\">    .. ..</span><br><span class=\"line\">*)</span><br><span class=\"line\">    默认命令序列</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<h3 id=\"中断及退出控制\"><a class=\"markdownIt-Anchor\" href=\"#中断及退出控制\"></a> 中断及退出控制</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>跳出当前所在循环体，执行循环体后的语句块</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>跳过循环体内余下的语句，重新判断条件以便执行下一次循环</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>退出脚本，可以指定返回的状态值，默认返回0</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"编写服务脚本\"><a class=\"markdownIt-Anchor\" href=\"#编写服务脚本\"></a> 编写服务脚本</h2>\n<h3 id=\"shell函数\"><a class=\"markdownIt-Anchor\" href=\"#shell函数\"></a> shell函数</h3>\n<p>type 名称  //查看名称对应类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本格式:</span><br><span class=\"line\">function 函数名()&#123;</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">    .. ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或🔥</span><br><span class=\"line\">函数名()&#123;</span><br><span class=\"line\">    命令序列</span><br><span class=\"line\">    .. ..</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">调用： 函数名</span><br><span class=\"line\">传参： 函数名  参数1  参数2 .. ..  //传递的值作为函数的位置参数</span><br></pre></td></tr></table></figure>\n<h3 id=\"系统服务管理\"><a class=\"markdownIt-Anchor\" href=\"#系统服务管理\"></a> 系统服务管理</h3>\n<ul>\n<li>查看服务列表、自启状态</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>chkconfig --list [服务名]</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>chkconfig 服务名  on/off</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>启动／停止／重启服务</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>service 服务名 start/stop/restart</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>/etc/init.d/服务名 start/stop/restart</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>ntsysv:可视化设置自启动状态</li>\n</ul>\n<ol>\n<li>shell脚本直接交给service控制，则将脚本或者脚本的快捷方式放到/etc/init.d／下即可</li>\n<li>shell脚本交给chkconfig工具管理,需设置适用级别、启动／停止顺序、服务说明</li>\n</ol>\n<ul>\n<li>添加设置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#</span><br><span class=\"line\"># chkconfig:2345 10 95</span><br><span class=\"line\"># description:服务相关说明</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加服务：chkconfig --add 服务名</li>\n</ul>\n<h2 id=\"文件的排序集统计\"><a class=\"markdownIt-Anchor\" href=\"#文件的排序集统计\"></a> 文件的排序集统计</h2>\n<h3 id=\"ls列表排序\"><a class=\"markdownIt-Anchor\" href=\"#ls列表排序\"></a> ls列表排序</h3>\n<ul>\n<li>-S:按文档大小降序排列</li>\n<li>-t:按文档的修改时间降序排列</li>\n<li>-r:反序排列</li>\n</ul>\n<h3 id=\"uniq去重工具\"><a class=\"markdownIt-Anchor\" href=\"#uniq去重工具\"></a> uniq去重工具</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法1：uniq 文件</span><br><span class=\"line\">用法2: 命令|uniq</span><br></pre></td></tr></table></figure>\n<p>缺点：==未排序的文本会出现重复现象==，需配合其他方式先排序，再去重<br>\n方法：sort 文件名|uniq -c</p>\n<h3 id=\"sort工具\"><a class=\"markdownIt-Anchor\" href=\"#sort工具\"></a> sort工具</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法1:sort 文件</span><br><span class=\"line\">用法2:命令|sort</span><br><span class=\"line\"></span><br><span class=\"line\">常用选项：</span><br><span class=\"line\">* -u: 去除重复行</span><br><span class=\"line\">* -n：按数字升序排列</span><br><span class=\"line\">* -r：反向排序</span><br><span class=\"line\">* -k：优先对第几列内容排序，即优先对哪个字段排序，只是字段是通过显示顺序编号的</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本处理的的特殊应用\"><a class=\"markdownIt-Anchor\" href=\"#文本处理的的特殊应用\"></a> 文本处理的的特殊应用</h2>\n<h3 id=\"tac-rev反序输出\"><a class=\"markdownIt-Anchor\" href=\"#tac-rev反序输出\"></a> tac、rev反序输出</h3>\n<ul>\n<li>tac：以行为单位反序，与cat命令效果相反</li>\n<li>rev: 以字符为单位反序，与echo命令效果相反</li>\n</ul>\n<h3 id=\"tee整合重定向\"><a class=\"markdownIt-Anchor\" href=\"#tee整合重定向\"></a> tee整合重定向</h3>\n<p>举例：uname -r|tee un.txt</p>\n<h3 id=\"unix2dos与dos2unix转换\"><a class=\"markdownIt-Anchor\" href=\"#unix2dos与dos2unix转换\"></a> unix2dos与dos2unix转换</h3>\n<p>windows和linux系统文本格式转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装：yum -y install unix2dos dos2unix</span><br><span class=\"line\">基本用法：</span><br><span class=\"line\">* unix2dos Linux文件</span><br><span class=\"line\">* dos2unix Windows文件</span><br></pre></td></tr></table></figure>\n<h2 id=\"xargs多参数处理\"><a class=\"markdownIt-Anchor\" href=\"#xargs多参数处理\"></a> xargs多参数处理</h2>\n<p>背景：ls、mv、rm、cp等命令给出的参数长度不能超过2.5M，基于*匹配、find等方式处理大量文件时容易出错</p>\n<h3 id=\"多参数的分散处理\"><a class=\"markdownIt-Anchor\" href=\"#多参数的分散处理\"></a> 多参数的分散处理</h3>\n<ul>\n<li>利用find… … -exec… … 查找处理  //仅适用于处理文件或目录参数，如：find / -exec ls -lh {} ;</li>\n<li>xargs工具:根据给定的参数组（以行为单位）分次执行目标命令行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法1：提供参数的命令 | xargs 目标命令，如：find /|args ls -lh</span><br><span class=\"line\">用法2: xargs --arg-file=提供参数的文件  目标命令</span><br><span class=\"line\">选项：</span><br><span class=\"line\">* -I：定义标记，如：ls txt.log* | xargs -I&#123;&#125; cp &#123;&#125; &#123;&#125;.new</span><br><span class=\"line\">* -d: 制定分割符，默认按行分割，如：head -1 /etc/passwd |xargs -d: -I&#123;&#125; echo &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"expect预期交互控制\"><a class=\"markdownIt-Anchor\" href=\"#expect预期交互控制\"></a> expect预期交互控制</h2>\n<blockquote>\n<p>基于TCL编写的自动化交互式程序，可以用在Shell脚本中，为FTP、SSH等交互过程自动输送预先准备的文本或指令，而无需人工干预，出发的依据是预期会出现的特征提示文本</p>\n</blockquote>\n<ul>\n<li>安装：yum -y install expect</li>\n</ul>\n<ol>\n<li>手动交互</li>\n<li>自动交互</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat mike-ftp.sh</span><br><span class=\"line\">--------------------</span><br><span class=\"line\">spawn ftp 192.168.4.5</span><br><span class=\"line\">expect &quot;):&quot;</span><br><span class=\"line\">send &quot;mike\\r&quot;</span><br><span class=\"line\">expect &quot;Password:&quot;</span><br><span class=\"line\">send &quot;123456\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;put install.log\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;quit\\r&quot;</span><br><span class=\"line\">---------------------</span><br><span class=\"line\">epxect mike-ftp.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>调整执行环境：添加Sha-Bang环境声明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat mike-ftp.sh</span><br><span class=\"line\">-----------------------</span><br><span class=\"line\">#!/usr/bin/expect</span><br><span class=\"line\">spawn ftp 192.168.4.5</span><br><span class=\"line\">expect &quot;):&quot;</span><br><span class=\"line\">send &quot;mike\\r&quot;</span><br><span class=\"line\">expect &quot;Password:&quot;</span><br><span class=\"line\">send &quot;123456\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;put install.log\\r&quot;</span><br><span class=\"line\">expect &quot;ftp&gt;&quot;</span><br><span class=\"line\">send &quot;quit\\r&quot;</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">sh mike-ftp.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>SSH登陆免交互举例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/expect</span><br><span class=\"line\">set host 192.168.4.5</span><br><span class=\"line\">set user mike</span><br><span class=\"line\">set password &quot;1234567&quot;</span><br><span class=\"line\">spawn ssh $user@$host</span><br><span class=\"line\">expect &quot;password:&quot;&#123;send &quot;$password\\r&quot;&#125;</span><br><span class=\"line\">expect &quot;\\[$user\\@&quot;&#123;send &quot;pwd&gt;/tmp/$user.txt;exit\\r&quot;&#125;</span><br><span class=\"line\">expect eof</span><br></pre></td></tr></table></figure>\n<h1 id=\"应用技巧\"><a class=\"markdownIt-Anchor\" href=\"#应用技巧\"></a> 应用技巧</h1>\n<h2 id=\"正则表达式\"><a class=\"markdownIt-Anchor\" href=\"#正则表达式\"></a> 正则表达式</h2>\n<blockquote>\n<p>使用“一串符号”来描述有共同属性的数据</p>\n</blockquote>\n<h3 id=\"egrep测试工具\"><a class=\"markdownIt-Anchor\" href=\"#egrep测试工具\"></a> egrep测试工具</h3>\n<ul>\n<li>用法1:egrep [选项] ‘正则表达式’ 文件</li>\n<li>用法2:前置命令|egrep [选项] ‘正则表达式’</li>\n</ul>\n<p>选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i：忽略大小写</span><br><span class=\"line\">-v: 取反</span><br><span class=\"line\">-c：统计匹配行数</span><br><span class=\"line\">-q：静默、无任何输出</span><br><span class=\"line\">-n：显示出所匹配结果所在的行号</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本元字符\"><a class=\"markdownIt-Anchor\" href=\"#基本元字符\"></a> 基本元字符</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>匹配行首</td>\n<td>^abc 或 ^#</td>\n<td>以abc开头的行  或  以#开头的行（比如注释行）</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配行尾</td>\n<td>abc$ 或 ^$</td>\n<td>以abc结尾的行  或  空行</td>\n</tr>\n<tr>\n<td>.</td>\n<td>单个字符</td>\n<td>.</td>\n<td>除换行符\\n以外的任意单个字符</td>\n</tr>\n<tr>\n<td>+</td>\n<td>最少匹配一次</td>\n<td>a+ 或 (abc)+</td>\n<td>一个或多个连续的a 或  一个或多个连续的abc</td>\n</tr>\n<tr>\n<td>?</td>\n<td>最多匹配一次</td>\n<td>a? 或 (abc)?</td>\n<td>0个或1个a 或  0或1个abc</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配任意次数</td>\n<td>a* 或 (abc)* 或 .*</td>\n<td>0个或多个连续的a 或 0个或多个连续的abc 或 任意长度的任意字符串</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配n次</td>\n<td>(ab){3}</td>\n<td>匹配ababab</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配n～m次</td>\n<td>(ab){1,3}</td>\n<td>匹配ab、abab、ababab</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>匹配至少n次</td>\n<td>(ab){2,}</td>\n<td>匹配2个及以上连续的ab</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>匹配范围内的单个字符</td>\n<td>[a-z]</td>\n<td>匹配任意小写字母</td>\n</tr>\n<tr>\n<td>[]内加^</td>\n<td>可取反</td>\n<td>[^a-z]</td>\n<td>匹配任意非小写字母</td>\n</tr>\n<tr>\n<td>()</td>\n<td>组合为整体</td>\n<td>(ab)</td>\n<td>连续的ab</td>\n</tr>\n<tr>\n<td></td>\n<td>或者</td>\n<td>root|bin</td>\n<td>匹配root、bin</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>单词边界</td>\n<td>\\broot\\b</td>\n<td>匹配root，不匹配keroot、rooty、brooty等字符串</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>单词的开头</td>\n<td>&lt;th</td>\n<td>匹配以th开头的单词</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>单词的结尾</td>\n<td>th&gt;</td>\n<td>匹配以th结尾的单词</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"awk文本过滤\"><a class=\"markdownIt-Anchor\" href=\"#awk文本过滤\"></a> awk文本过滤</h2>\n<blockquote>\n<p>awk:模式扫描及处理语言，创始人Aho、Weinberger、Kernighan，基于模式匹配检查输入的文本，逐行处理并print结果，目前最常用的实际是GNU版本的gawk</p>\n</blockquote>\n<ul>\n<li>用法1:前置命令|awk [选项] ‘[条件]{编辑指令}’</li>\n<li>用法2:awk [选项] ‘[条件]{编辑指令}’ 文件，如：awk -F “:” ‘{print $1,$2} /etc/passwd’</li>\n</ul>\n<p>条件的表现形式</p>\n<ul>\n<li>正则表达式，/正则表达式/ 🔥 ~匹配、!~不匹配,如：awk -F: ‘/^ro/{print}’ /etc/passwd</li>\n<li>数值／字符串比较</li>\n<li>逻辑比较</li>\n<li>运算符</li>\n</ul>\n<p>选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F:指定分隔符，可省略，默认空格或Tab位，如：awk -F: &apos;$1==ENVIRON[&quot;USER&quot;]&#123;print $3&#125;&apos; /etc/passwd  //输出当前用户的UID信息</span><br><span class=\"line\">-f:调用awk脚本进行处理</span><br></pre></td></tr></table></figure>\n<p>awk内置变量</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FS</td>\n<td>保存或设置字段分隔符，如 FS=“：”</td>\n</tr>\n<tr>\n<td>$n</td>\n<td>指定分隔符的第n个字段，如$1、$3分别表示第1、第3列</td>\n</tr>\n<tr>\n<td>$0</td>\n<td>当前读入的整行文本内容</td>\n</tr>\n<tr>\n<td>NF</td>\n<td>记录当前处理的字段个数（列数）</td>\n</tr>\n<tr>\n<td>NR</td>\n<td>记录当前已读入行的数量（行数）</td>\n</tr>\n<tr>\n<td>FNR</td>\n<td>保存当前处理行在元文本内的序号（行号）</td>\n</tr>\n<tr>\n<td>FILENAME</td>\n<td>当前处理的文件名</td>\n</tr>\n<tr>\n<td>ENVIRON</td>\n<td>调用Shell环境变量，格式：ENVIRON[“变量名”]</td>\n</tr>\n</tbody>\n</table>\n<p>awk处理的时机：可单独使用，也可以同时一起使用，具体如下：</p>\n<ul>\n<li>行前处理,BEGIN{}:读入第一行文本之前执行，一般用来初始化操作</li>\n<li>逐行处理,{}：逐行读入文本执行相应的处理，是最常见的编辑指令块</li>\n<li>行后处理，END{}：处理完最后一行文本之后执行，一般用来输出处理结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk &apos;BEGIN&#123;print NR&#125;END&#123;print NR&#125;&apos; m.txt</span><br></pre></td></tr></table></figure>\n<p>awk的流程控制</p>\n<ul>\n<li>if分支，如：if(条件){编辑指令1}else if(条件){编辑指令12}…else{编辑指令n}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F: &apos;BEGIN&#123;i=0;j=0&#125;&#123;if($3&lt;500)&#123;i++&#125;else&#123;j++&#125;&#125;END&#123;print i,j&#125;&apos;     /etc/passwd</span><br></pre></td></tr></table></figure>\n<ul>\n<li>while循环，如：while(条件){编辑指令}</li>\n<li>do while循环，如：do {编辑指令}while(条件)</li>\n<li>for循环,如：for(初值；条件；步长){编辑指令}</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>结束当前的循环体</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>中止本次循环，转入下一次循环</td>\n</tr>\n<tr>\n<td>next</td>\n<td>跳过当前行，读入下一行文本开始处理</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>结束文本读入，转入END{}执行，没有则直接退出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"sed文本流处理\"><a class=\"markdownIt-Anchor\" href=\"#sed文本流处理\"></a> sed文本流处理</h2>\n<blockquote>\n<p>sed:Stream EDitor，流式编辑器，基于模式匹配过滤及修改文本，逐行处理并将结果输出到屏幕，可实现文本过滤／删除／替换／复制／剪切，以及导入／导出等各种操作</p>\n</blockquote>\n<ul>\n<li>用法1:前置命令|sed [选项] ‘编辑指令’，如：se -n /etc/inittab |sed -n ‘4,7p’</li>\n<li>用法2:sed [选项] ‘编辑指令’ 文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑指令由“[定址符]处理动作”组成，[定址符]的格式为“[地址1，[地址2]]”</span><br></pre></td></tr></table></figure>\n<p>选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-n:屏蔽默认输出</span><br><span class=\"line\">-i:直接修改文件内容</span><br><span class=\"line\">-f:使用sed脚本</span><br><span class=\"line\">-e:可指定多个处理动作</span><br><span class=\"line\">-r:启用扩展的正则表达式，若与其他选项一起使用，应作为首个选项</span><br><span class=\"line\">&#123;&#125;:可组合多个命令，以分号分隔</span><br></pre></td></tr></table></figure>\n<p>处理动作：替换操作的分隔符“／”可用其他字符，如#、&amp;等以便于修改文件路径</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>用途</th>\n<th>指令示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>p</td>\n<td>打印行</td>\n<td>2,4p 输出2，3，4行 🔥 2p；4p输出第2行、4行</td>\n</tr>\n<tr>\n<td>d</td>\n<td>删除行</td>\n<td>2,4d 删除第2，3，4行</td>\n</tr>\n<tr>\n<td>s</td>\n<td>字符串替换</td>\n<td>s/old/new/ 将每行第1个old替换为new</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>s/old/new/3 将每行第3个old替换为new</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>s/old/new/g 将所有的old替换为new</td>\n</tr>\n<tr>\n<td>4,+10p</td>\n<td>加10行</td>\n<td>输出第4行及其后10行内容</td>\n</tr>\n<tr>\n<td>n</td>\n<td>表示下一行</td>\n<td>p:n输出奇数行</td>\n</tr>\n<tr>\n<td></td>\n<td>n:p输出偶数行</td>\n<td></td>\n</tr>\n<tr>\n<td>$=</td>\n<td>输出文件的行数</td>\n<td>sed -n ‘$=’ a.txxt</td>\n</tr>\n<tr>\n<td>i</td>\n<td>行前插入文本</td>\n<td>2iYY 在第2行前添加文本行YY</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>4，7iYY 在第4-7行每一行钱添加文本行YY</td>\n</tr>\n<tr>\n<td>a</td>\n<td>行后插入文本</td>\n<td>2aYY 在第2行后插入YY</td>\n</tr>\n<tr>\n<td>c</td>\n<td>替换当前行</td>\n<td>2cYY 将第2行内容修改为YY</td>\n</tr>\n<tr>\n<td>r</td>\n<td>读取文件，结合-i选项才会存入，否则只输出</td>\n<td>3r b.txt 在第3行下发插入文本b.txt</td>\n</tr>\n<tr>\n<td>w</td>\n<td>保存到文件，以覆盖方式</td>\n<td>3w b.txt 将第3行保存到b.txt</td>\n</tr>\n</tbody>\n</table>\n<p>sed复制剪切</p>\n<ul>\n<li>模式空间:存放当前处理的行，将处理结果输出；若当前行不符合处理条件则原样输出；处理完当前行再读入下一行来处理</li>\n<li>保存空间:作用类似剪贴板，默认存放一个空行\\n<br>\n选项：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-H：模式空间 追加 到 保持空间 ，即复制</span><br><span class=\"line\">-h：模式空间 覆盖 到 保持空间 ，即复制</span><br><span class=\"line\">-G：保持空间 追加 到 模式空间 ，即粘贴</span><br><span class=\"line\">-g：保持空间 覆盖 到 模式空间 ，即粘贴</span><br><span class=\"line\"></span><br><span class=\"line\">sed &apos;1,3H;$G&apos; reg.txt //把第1～3行复制到文件末尾</span><br></pre></td></tr></table></figure>\n<h1 id=\"实战脚本\"><a class=\"markdownIt-Anchor\" href=\"#实战脚本\"></a> 实战脚本</h1>\n<h2 id=\"基本知识\"><a class=\"markdownIt-Anchor\" href=\"#基本知识\"></a> 基本知识</h2>\n<ol>\n<li>查看用户信息：id gsuis</li>\n<li></li>\n</ol>\n<h2 id=\"awksed应用实战\"><a class=\"markdownIt-Anchor\" href=\"#awksed应用实战\"></a> awk&amp;sed应用实战</h2>\n"},{"title":"MongoDB","copyright":true,"comments":1,"toc":true,"password":null,"_content":"\n\nhttps://www.jikexueyuan.com/course/mongoDB/\n\nNoSQL数据库：NoSQL(NoSQL = Not Only SQL )，意即\"不仅仅是SQL\"，指的是非关系型的数据库\n\nmongodb官网：https://www.mongodb.com/\nhttps://docs.mongodb.com/manual/\n\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n\nhttp://www.runoob.com/mongodb/mongodb-tutorial.html\n\nNoSQL保证数据的最终一致性，数据由更新延迟\n\nCAP理论\n\n适用场景：数据缓存；json格式数据存储；高伸缩性场景；\nMongoDB更多适合大数据量、高并发、弱事务的互联网应用，其内置的水平扩展机制提供了从几百万到十亿级别的数据处理能力，可很好的满足Web2.0和移动互联网应用的s数据存储要求。\n\nMongoDB由C++编写，支持32位（2G限制）和64位应用，是一个基于分布式文件存储的开源数据库系统。\n\nMongoDB3.0特性：\n1. 加入WiredTiger存储引擎:\n  开源的存储引擎；为现代硬件设计：多核CPU，充分利用内存／芯片级缓存；RAM/SSD/HDD；为大数据设计：高性能，低延迟，高并发稳定性\n2. MMAPv1:内存映射存储引擎，为默认引擎 ，提供了Collection锁；无缝迁移MMAP\n3. 可插拔引擎API\n4. 基于Web的可视化管理工具：Ops Manager\n\nMongoDB数据模型\n文档：本质上是一种类JSON的BSON格式的数据，可以理解为在JSON基础上添加了一些新的数据类型，包括Date，正则表达式等。\nBSON官网：http://bsonspec.org/\nBSON是由一组组键值对组成，具有轻量性、可靠性和高效性3个特征。可遍历性是MongoDB将BSON作为数据存储的重要原因\n使用文档时需要注意以下事项：\nMongoDB中写操作的原子性限制在文档级别；\n单个文档占用的存储空间不能超过16MB；\nMongoDB会尽量保持文档被插入时键值对的顺序；\n关于文档命名需要注意的事项：\n_id是系统保留的关键字，他是默认的主键，该值在集合中必须唯一，且不可更改；\n键不能包含空字符或\\0，这个字符用于表示键的结尾；\n不能以$开头且不能包含点号.\n键是区分大小写的且不能重复\n\n集合：把一组相关的文档放到一起组成了集合，MongoDB的集合是模式自由的，一个集合里面的文档可以是各式各样的 \nMogoDB提供了一些特殊的集合：capped collection、system.indexes、system.namespaces等\n集合命名需注意：\n集合名不能是空字符串；\n集合名不能包含空字符串或\\0，该字符表示集合名的结尾\n集合名不能以\"system.\"开头，此前缀是系统本身保留的\n集合名不能包含$字符，但是可以包含点号.\n\n数据库：多个文档组成集合，多个集合组成数据库。一个MongoDB实例可承载多个数据库，每个数据库有独立的权限，在磁盘上，不同的数据库也可放置到不通目录\n数据库命名规则：\n不能是空字符串；不能以$开头；不能包含空字符串和点号.;数据库名称区分大小写；建议数据库名全部使用小写；数据库名最长64字节；不要与系统保留数据库名相同\n\n命名空间：把数据库名添加到集合名前面，中间用点号连接，得到集合的完全限定，就是命名空间\n因为点号可以出现在集合名字中，如：jike.blog.posts 和 jike.blog.authors，可以将posts和authors看作是blog集合的子集合，blog集合甚至可以不存在 \n使用子集合的方式，可以是我们更好的组织数据，使数据结构更加清晰明了\n\nMongoDB数据类型\n基本数据类型\nnull：表示空值或者不存在的字段\n布尔：true／false\n数据类型：32-int,64-int,64-double,注意：JavaScript只支持64位浮点数\n字符串类型：使用UTF-8对字符串进行编码\n二进制数据：可以保存由任意字节组成的字符串，如：图片、视频等\n正则表达式类型：主要用于查询，使用正则表达式作为限定条件\nDate类型：是一个64位整数，它代表距Unix epoch：1970-1-1的毫秒数，MongoDB在存储时间是现转换为UTC时间，北京时间=UTC+8小时，MongoDB Shell会根据本地时间 设置显示日期时间\nTimestap：32bit Unix epoch + 32bit自增序数，只供MongoDB数据库服务内部使用，用于记录操作的详细时间\nObjectId：由24个16精制字符组成，每个字节存储两位16精制数字，总共需12字节存储空间=4字节时间戳+3字节机器标识+2字节pid+3字节计数器，ObjectId(),getTimestamp(),valueOf()\n数组：使用方括号来表示的一组值，数组中可以包含不通数据类型的元素，针对数组，MongoDB提供了许多操作符，如：$pop,$push,$pull,$slice,$addToSet等；MongoDB可自动为数组元素建立MultiKey索引\n内嵌文档：文档可以作为键的值，这样的文档成为内嵌文档。内嵌文档可以使数据不用保存成扁平结果的键值对，从而使数据组织形式更加自然。\n\n内嵌文档模式VS引用文档模式\n子文档比较小或变化不频繁，则使用内嵌文档模式，否则使用引用文档模式\n\nMongoDB自动将_id字段设置为主键\n\nMongoDB Shell：是MongoDB自带的JavaScript Shell，随MongoDB一起发布 =JavaScript V8解释器+MongoDB客户端\n\nhelp查看帮助\n执行脚本\n    直接执行：mongo [--quiet] script.js\n    交互执行：load(\"script.js\")\n执行命令行程序：run(\"ls\")\n.mongorc.js文件，默认会加载\n编辑复合变量EDITOR：在.bashrc中添加后source生效\n~~~\n#EDITOR\nEDITOR=/usr/bin/vim\n~~~\n即可使用editor编辑文档\n\n\n\nhttp://www.runoob.com/mongodb/mongodb-intro.html\nMongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。\nGridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。\nMongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。\n\nMongoDB数据库安装：\n1. 下载安装文件解压缩并添加bin目录到环境变量\n2. 创建一个data目录，然后在data目录里创建db目录、logs目录\n3. 启动服务端 \n4. 启动客户端：mongo\n5. windows下可以将MongoDB做成系统服务\n\n\nmac\n临时添加环境变量：export PATH=/usr/local/mongodb/bin:$PATH\n编辑~/.bash_profile,添加：export PATH=$PATH:/usr/local/mongodb4/bin/:$PATH 即可永久添加环境变量\n\n连接MongoDB数据库：./mongo + 服务器IP:端口号/数据库名\n关闭MongoDB服务在 ./mongo 进入控制台后，输入 use admin,然后输入 db.shutdownServer()\n\nMongodb可以通过命令行方式和配置文件的方式来启动：\n这两种方式都是在前台启动Mongodb进程，如果Session窗口关闭，Mongodb进程也随之停止。\n不过Mongodb同时还提供了一种后台Daemon方式启动，只需要加上一个\"--fork\"参数即可，用到了\"--fork\"参数就必须启用\"--logpath\"参数\n通过命令行： ./bin/mongod --dbpath=/data/db --fork --logpath=/data/logs/mongodb.log\n配置文件方式：./bin/mongod -f mongodb.conf  或 ./bin/mongod --config mongodb.conf  //-f 后面写要使用的配置文件\n            ./bin/mongod --shutdown -f mongod.conf\n~~~\nport=27017\ndbpath=/usr/local/mongodb/data/\nlogpath=/usr/local/mongodb/log/mongodb.log  \nfork = true\n~~~\n\n命令行操作：\nuse mytetDB  //数据库如果不存在则创建\nsave时如果给定了_ObjectId则更新创建整条记录；如果要更新部分字段则使用update方法使用$set\ndb.dropDatabase()\ndb//显示当前数据库\nshow dbs\nshow collections\n\n有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。\nadmin： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\nlocal: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\nconfig: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n\nMongoDB GridFS文件系统\n分布式文件系统：将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点通过网络进行通信和数据传输\n\n当存储文档大于16M时，可以考虑使用GridFS\nGridFS：是MongoDB制定的如何在数据库中存储大文件的规范，MongoDB并没有实现GridFS，而是交由客户端驱动程序实现\nGridFS使用两个集合（collection）存储文件。一个集合是chunks, 用于存储文件内容的二进制数据；一个集合是files，用于存储文件的元数据。\n使用fs.files存储文件的元数据，包含字段如下： \n使用fs.chunks存储以255K进行分割的文件块，包含字段如下：\nGridFS适用于如下场景：\n存储用户产生的文件且文件数量比较大；需要文件的自动备份和分布式存储；需要访问文件的部分内容；存储16MB以上的文件\nmongofiles是MongoDB安装包中提供的一个工具，专门用来存取文件，包括查询所有文件、查看文件、上传一个文件、获取一个文件、按照_id来获取文件、按文件名删除文件、按_id删除文件。\nmongofiles --help其实有四个主要命令，分别为：\nput —存储命令\nget —获取命令 \nlist —列表命令\ndelete —删除命令 \n\nMongoDB聚合管道：聚合操作主要用户批量数据处理，往往将记录按条件分组，然后在每组上分别进行一系列操作，如：求和、求最大小值等\n聚合操作能够对记录进行复杂处理，主要为数理统计和数据挖掘。\nMongoDB提供了3种聚合操作方式：\n聚合管道（Aggregation Pipeline）:MongoDB Shell使用db.collection.aggregate([{...}])来构建和使用聚合管道\n    $project:用于修改文档的结构，可以重命名、增加或删除文档字段\n    $match:用于过滤文档，在$match中不能使用$where,尽量出现在管道的前面，方便借助索引加快查询\n    $group:将集合中的文档进行分组，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理\n    $sort:将集合中的文档进行排序，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理\n    $skip:跳过指定数量的文档\n    $unwind:将文档按照数组字段拆分成多条文档，每条文档包含数组的一个元素\n    $geoNear:按照由近到远顺序输出接近某一地理位置的文档\n    $out:将聚合结果存储到集合中，参数为集合名称\n    。。。\n    聚合管道表达式：阶段操作符可以看作是\"键\"，所对应的\"值\"称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。\n    聚合管道使用优化：\n    1将$match、$sort放到管道开始阶段，有利于利用索引提高文档处理效率\n    2提交过滤可减少流经后续阶段的文档数量\n    聚合管道的限制：\n    1返回文档结果不能超过16M，可通过返回一个游标或存储到集合中跳过此限制\n单目的聚合操作\n    count\n    distinct\n    group\nMapReduce编程模型\n\n\nmongoimport可以导入集合\n\nMongoDB数据更新\n文档插入和删除：insert、update、delete\nBulk函数：Bulk可将多个数据更新操作放到一个待执行的列表中批量来执行，顺序执行的Bulk（按添加顺序执行，一个有问题则退出）和并执行的Bulk（随机方式并行）\n1初始化Bulk：\n并行：db.集合名.initializeUnorderedBulkOp()\n顺序：db.集合名.initializeOrderedBulkOp()\n2 bulk.inset({...})\n3 bulk.execute()\n\nMMAPv1的内存分配策略：如果一个更新操作超过了文档在磁盘上预分配的空间，MongoDB会重新在磁盘上为其分配一块更大的连续空间。使用\"2的N次方\"的方式分配内存，如：32，64，128，256...2M，4M...\n优点：1有利用内存的重用，降低系统碎片的数量；2减少数据移动频率，提高系统数据写效率\n\n文档修改\nWriteResult = db.集合名.update(query,obj,upsert,multi)\nquery:查询条件，相当于where\nobj：更改的内容，相当于SQL中的set语句\nupsert：当query的文档不存在时是否插入一条新文档\nmulti：当query返回多个文档时是否一次更新满足条件的所有文档，默认只更新一条\n\n内嵌文档的修改：\n1. 修改整个内嵌文档：{$set:{field1:新内嵌文档}}\n2. 修改内嵌文档的某个字段：{$某个修改操作符:{field1.field2:value}}\n\n数组元素：MongoDB提供了大量的特定操作符，使得数组既可以作为栈、队列等有序对象使用，也可当作集合等无序对象来使用\n\nMongoDB的写安全机制\n写过程：使用update、save等操作数据集合中数据时，只是修改了数据再内存中的映像，数据更新并没有同步地保存到磁盘上，而且更新内存中数据之前，更新操作会被记录到journal日志文件中，\n每隔100ms将内存journal中的日志写到磁盘journal日志文件中 ，每隔60s将内存中修改的数据写会到磁盘上\n写入安全级别：写入安全Write Concern是一种客户端设置的，用于控制写入安全级别的机制，通过写入安全机制可提高数据的可靠性。\n分为四个级别，分别是：\n非确认式写入Unacknowledged：写操作不会返回结果，所以无法知道是否写入成功；但速度快、效率高、无阻塞\n确认式写入Acknowledged：写操作必须得到MongoDB服务器的写入确认，如果失败，会返回异常 \n日志写入Journaled：写操作要等到操作记录存储到Journal日志文件后才返回结果\n复制集确认写入Replica Acknowledged：写操作不仅要得到主节点的写入确认，还要得到从节点的写入确认，可以设置写入节点的个数（包含主节点）\n\njournal日志相当于oracle中的redo日志文件，用户故障恢复和持久。Journal默认100ms刷新一次，所以最多丢失100ms数据 \n文件位于journal目录中，只能以追加方式添加数据，文件名以\"j._\"开头，超过1G会自动创建新的；数据库正常关闭时，数据库服务会自动清空journal目录下所有文件\n\n设置写安全操作级别，其实就是在写操作的性能和可靠性间取一个权衡；使用的写操作级别越高，时间越长，可靠性越高 \n\n使用writeConcern函数作为更新函数的一个参数来设置写安全级别,如：db.集合名称.insert({name:\"joe\"},{writeConcern:{j:true}}),writeConcern函数参数如下：\nw选项，可选择0，1，2等整数值及\"majority\"，0-非确认式写入 1-确认式写入（未启用复制集）／主节点确认式写入（启用了复制集），>1只能用于复制集，2-数据至少写到1个从节点后返回，majority 只能用于复制集，表示更新操作用到大多数从节点\nj选项，设置为true来使用journaled日志安全级别\nwtimeout选项，用于设置超时单位为毫秒\n以上选项可组合使用\n\n数据MongoDB数据查询\nCursor = db.集合名称.find(query,fields,limit,skip)\nquery:查询条件，相当于where\nfields:用于字段映射，语法格式：{field:0}（0表示返回结果不包含此字段）或{field:1}（1表示返回结果不包含此字段），默认包含_id字段,相当于select中后面需要的字段\nlimit：限制查询结果集的数量，指定查询返回结果的数量上限，也可通过limit()实现\nskip:跳过一定数据量的结果，设置第一条返回文档的偏移量，也可通过skip()实现\nfind查询只能正对一个集合；返回的集合默认是无序的\n\ndb.集合名称.findOne()只返回第一条数据\n\n查询操作符\n比较查询操作符\n逻辑查询操作符\n元素查询操作符\n$where查询操作符：可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在js表达式和函数中，可使用this或obj来引用当前操作的文档，当js表达式或函数返回true时，才会返回当前文档\n\n内嵌文档与数组查询\n内嵌文档查询\n1查询整个内嵌文档：当内嵌文档的键值对数量和键值对顺序都相同时，才会匹配\n2查询文档的某个字段：需要使用.号操作符，如:db.user.find({\"address.city\":\"BeiJing\"})\n数组查询\n1查询整个数组：当数组元素内容和数组元素顺序都相同时，才会匹配\n2查询数组中的元素（普通元素）：\nA与位置无关，查询数组中含有某个值的文档，如：db.user.find({score:80})\nB与位置有关，按照指定的数组索引查询数组元素的值，如：db.user.find({'scores.2':80})\n3查询数组中的数组元素是文档时，查询数组元素有两种情况\nA与位置无关，查询数组中满足条件的子文档元素，如：db.user.find('scores.成绩'：95)\nB与位置有关，按照指定的数组索引查询数组子文档，如： db.user.find('scores.2.成绩'：95)\n\nMongoDB查询结果返回过程：find函数查询结果是以多条文档的形式分批来返回查询结果的，返回的文档会缓存到内存中，Cursor在一批数据回来之后遍历，下一批没来时会自动发起下一批请求，然后继续遍历\n\nMongoDB游标：用来遍历结果集中的数据。\n游标的生命周期：创建、使用、销毁\n游标可能会返回那些由于体积变大而被移动到集合末尾的文档而重复返回，可通过对查询快照的方式解决此问题，语法为：db.collection.find().snapshot().\n使用快照之后，查询就会在_id索引上来遍历执行，这样就可以保证每个文档只被返回一次，从而保证获取结果的一致性。\n\n模糊查询：查询条件可以使用正则表达式实现模糊查询，支持正则表达式操作符和正则表达式对象两种。\n正则表达式操作符：$regex\n\n\nfindAndModify函数使用执行分为find和update两步，但可以保证操作的原子性\n\nMongoDB是为分布式存储而设计，_id主键默认使用ObjectId类型的值，比自增方式更适合分布式环境，所以MongoDB默认不支持字段自增长功能\n\nMongoDB索引：数据库索引是对数据表中一列或多列的值进行排序的一种数据结构，使用索引可快速访问数据表中的特定信息。MogonDB索引不仅提高文档查询速度，还有利于排序时节省内存资源。\nMongoDB所有的索引信息被保存在system.indexes集合中，且默认总为_id创建单字段升序具有唯一属性的索引，可通过db.system.indexes.find()查看所有索引\nMongoDB可在单个字段上建立索引，字段可以是普通字段、整个文档以及子文档的某个字段\n对于复合索引，MongoDB支持前缀匹配\n为确保查询只使用复合索引，可以使用映射来指定不要返回_id字段（除非它是复合索引的一部分）\n多键索引：是对数组类型建立的索引，实际上是对数组的每个元素建立索引，而不是数组本身建立索引；当数组元素是文档时，可为文档的某个字段建立多键索引\n哈希索引：只支持等值查询，不支持范围查询，主要用于分片的集合上，可以作为片键来使用，能将数据比较均匀的分散存储在各个分片上，如：db.集合名.createIndex({name:\"hashed\"})\n\nMongoDB索引的属性\n唯一索引:可以确保集合的每一个文档的索引字段都有唯一的值，不会出现重复值，如：db.集合名.createIndex({name:1},{unique:true})，在非空集合创建唯一索引可能会因为已有重复值而失败，可添加dropBups:true删除重复文档\n稀疏索引：只会为索引字段存在的文档建立索引，即使索引字段的值为null，但不会为索引字段不存在的文档建立索引\nTTL(Time To Live)索引：为文档设置一个超时时间，当达到预设置的时间后，该文档会被数据库自动删除，但删除可能有延迟。这种类型的索引对缓存问题非常有用。只能建立在单独非_id字段\n创建了TTL索引后，MongoDB会有一个后台线程来管理文档；在复制集上建立的TTL索引，TTL后台线程只会运行在主节点上\n\nMongoDB索引的管理\n索引的默认命名规则：keyname1_dir1_keyname2_dir2...，其中keynameX是索引字段的名称，dirX是索引方向，1升序-1降序，也可自定义命名\n创建索引：db.集合名.createIndex(keys,options),返回值为一个文档类型。索引一旦创建就不能修改，创建后可通过db.集合名.getIndexes()查看集合所拥有的索引，创建索引有两种方式：\n1foreground:阻塞所有对数据库的读写请求，直到索引创建完成，为默认方式\n2background：创建索引时，如果有新的数据库请求，创建过程会暂停\n删除索引：db.集合.dropIndex(index)\n查询优化器：用来优化查询过程，通过比较返回100条文档速度得到最佳查询计划\nexplain函数：能够提供大量与查询有关的信息，可以很好的评估索引性能，帮助优化索引的使用策略。db.集合.find().explain(mode),支持3种模式：\n1queryPlanner：查询计划，默认\n2executionStatus：查询性能统计\n3allPlansExecution：所有计划统计信息（最优与被拒绝的计划）\nexplain返回结果使用由多个阶段（Stage）组成的树形结构来表示查询计划，查询计划自下而上执行，树的叶节点用来访问文档或索引，内部节点处理下层节点返回文档或索引，根节点输出查询结果\nhint函数：强制MongoDB使用特定索引\n\nMongoDB特殊索引\n地理空间索引：对地理位置数据建立索引，MongoDB支持两种2dsphere球面索引和平面2d索引\n2dSphere球面索引\n2d平面索引\n\n全文索引：又称为倒排索引，用于在大量文本中对每一个词组建立索引，指出该词在整段文本中出现的位置和次数，此技术主要用于搜索引擎和站内搜索等。\n一个集合只能有一个全文索引\n\n\njava对mongodb的使用\n集群搭建：mongodb分布式集群搭建手记\n\n\n学习：http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html\n\n\n分析没有默认的，因为你还没给root设置密码，第一个 user 是在 admin 组 ，所以他可以给 root 设置密码 , so\nsudo passwd root\n\n\nLanguage Support\n\n\nhttp://blog.csdn.net/sinat_35418761/article/details/53241481\n\n\nhttp://www.2cto.com/database/201504/395442.html\nhttp://www.myexception.cn/operating-system/1685604.html\n\n\nhttps://my.oschina.net/chinacaptain/blog/465723\n\n\n\nhttp://api.mongodb.com/java/current/\n\n\n\nMongoDB是什么\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\n他的特点:高性能、易部署、易使用，存储数据非常方便。\n\n\nBson：Binary Serialized Document Format，是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型\n\n\n\n","source":"_posts/数据库/2018-12-10-MongoDB.md","raw":"---\ntitle: MongoDB\ntags:\n  - MongoDB \ncopyright: true\ncomments: true\ntoc: true\ncategories: 数据库\npassword:\n---\n\n\nhttps://www.jikexueyuan.com/course/mongoDB/\n\nNoSQL数据库：NoSQL(NoSQL = Not Only SQL )，意即\"不仅仅是SQL\"，指的是非关系型的数据库\n\nmongodb官网：https://www.mongodb.com/\nhttps://docs.mongodb.com/manual/\n\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n\nhttp://www.runoob.com/mongodb/mongodb-tutorial.html\n\nNoSQL保证数据的最终一致性，数据由更新延迟\n\nCAP理论\n\n适用场景：数据缓存；json格式数据存储；高伸缩性场景；\nMongoDB更多适合大数据量、高并发、弱事务的互联网应用，其内置的水平扩展机制提供了从几百万到十亿级别的数据处理能力，可很好的满足Web2.0和移动互联网应用的s数据存储要求。\n\nMongoDB由C++编写，支持32位（2G限制）和64位应用，是一个基于分布式文件存储的开源数据库系统。\n\nMongoDB3.0特性：\n1. 加入WiredTiger存储引擎:\n  开源的存储引擎；为现代硬件设计：多核CPU，充分利用内存／芯片级缓存；RAM/SSD/HDD；为大数据设计：高性能，低延迟，高并发稳定性\n2. MMAPv1:内存映射存储引擎，为默认引擎 ，提供了Collection锁；无缝迁移MMAP\n3. 可插拔引擎API\n4. 基于Web的可视化管理工具：Ops Manager\n\nMongoDB数据模型\n文档：本质上是一种类JSON的BSON格式的数据，可以理解为在JSON基础上添加了一些新的数据类型，包括Date，正则表达式等。\nBSON官网：http://bsonspec.org/\nBSON是由一组组键值对组成，具有轻量性、可靠性和高效性3个特征。可遍历性是MongoDB将BSON作为数据存储的重要原因\n使用文档时需要注意以下事项：\nMongoDB中写操作的原子性限制在文档级别；\n单个文档占用的存储空间不能超过16MB；\nMongoDB会尽量保持文档被插入时键值对的顺序；\n关于文档命名需要注意的事项：\n_id是系统保留的关键字，他是默认的主键，该值在集合中必须唯一，且不可更改；\n键不能包含空字符或\\0，这个字符用于表示键的结尾；\n不能以$开头且不能包含点号.\n键是区分大小写的且不能重复\n\n集合：把一组相关的文档放到一起组成了集合，MongoDB的集合是模式自由的，一个集合里面的文档可以是各式各样的 \nMogoDB提供了一些特殊的集合：capped collection、system.indexes、system.namespaces等\n集合命名需注意：\n集合名不能是空字符串；\n集合名不能包含空字符串或\\0，该字符表示集合名的结尾\n集合名不能以\"system.\"开头，此前缀是系统本身保留的\n集合名不能包含$字符，但是可以包含点号.\n\n数据库：多个文档组成集合，多个集合组成数据库。一个MongoDB实例可承载多个数据库，每个数据库有独立的权限，在磁盘上，不同的数据库也可放置到不通目录\n数据库命名规则：\n不能是空字符串；不能以$开头；不能包含空字符串和点号.;数据库名称区分大小写；建议数据库名全部使用小写；数据库名最长64字节；不要与系统保留数据库名相同\n\n命名空间：把数据库名添加到集合名前面，中间用点号连接，得到集合的完全限定，就是命名空间\n因为点号可以出现在集合名字中，如：jike.blog.posts 和 jike.blog.authors，可以将posts和authors看作是blog集合的子集合，blog集合甚至可以不存在 \n使用子集合的方式，可以是我们更好的组织数据，使数据结构更加清晰明了\n\nMongoDB数据类型\n基本数据类型\nnull：表示空值或者不存在的字段\n布尔：true／false\n数据类型：32-int,64-int,64-double,注意：JavaScript只支持64位浮点数\n字符串类型：使用UTF-8对字符串进行编码\n二进制数据：可以保存由任意字节组成的字符串，如：图片、视频等\n正则表达式类型：主要用于查询，使用正则表达式作为限定条件\nDate类型：是一个64位整数，它代表距Unix epoch：1970-1-1的毫秒数，MongoDB在存储时间是现转换为UTC时间，北京时间=UTC+8小时，MongoDB Shell会根据本地时间 设置显示日期时间\nTimestap：32bit Unix epoch + 32bit自增序数，只供MongoDB数据库服务内部使用，用于记录操作的详细时间\nObjectId：由24个16精制字符组成，每个字节存储两位16精制数字，总共需12字节存储空间=4字节时间戳+3字节机器标识+2字节pid+3字节计数器，ObjectId(),getTimestamp(),valueOf()\n数组：使用方括号来表示的一组值，数组中可以包含不通数据类型的元素，针对数组，MongoDB提供了许多操作符，如：$pop,$push,$pull,$slice,$addToSet等；MongoDB可自动为数组元素建立MultiKey索引\n内嵌文档：文档可以作为键的值，这样的文档成为内嵌文档。内嵌文档可以使数据不用保存成扁平结果的键值对，从而使数据组织形式更加自然。\n\n内嵌文档模式VS引用文档模式\n子文档比较小或变化不频繁，则使用内嵌文档模式，否则使用引用文档模式\n\nMongoDB自动将_id字段设置为主键\n\nMongoDB Shell：是MongoDB自带的JavaScript Shell，随MongoDB一起发布 =JavaScript V8解释器+MongoDB客户端\n\nhelp查看帮助\n执行脚本\n    直接执行：mongo [--quiet] script.js\n    交互执行：load(\"script.js\")\n执行命令行程序：run(\"ls\")\n.mongorc.js文件，默认会加载\n编辑复合变量EDITOR：在.bashrc中添加后source生效\n~~~\n#EDITOR\nEDITOR=/usr/bin/vim\n~~~\n即可使用editor编辑文档\n\n\n\nhttp://www.runoob.com/mongodb/mongodb-intro.html\nMongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。\nGridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。\nMongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。\n\nMongoDB数据库安装：\n1. 下载安装文件解压缩并添加bin目录到环境变量\n2. 创建一个data目录，然后在data目录里创建db目录、logs目录\n3. 启动服务端 \n4. 启动客户端：mongo\n5. windows下可以将MongoDB做成系统服务\n\n\nmac\n临时添加环境变量：export PATH=/usr/local/mongodb/bin:$PATH\n编辑~/.bash_profile,添加：export PATH=$PATH:/usr/local/mongodb4/bin/:$PATH 即可永久添加环境变量\n\n连接MongoDB数据库：./mongo + 服务器IP:端口号/数据库名\n关闭MongoDB服务在 ./mongo 进入控制台后，输入 use admin,然后输入 db.shutdownServer()\n\nMongodb可以通过命令行方式和配置文件的方式来启动：\n这两种方式都是在前台启动Mongodb进程，如果Session窗口关闭，Mongodb进程也随之停止。\n不过Mongodb同时还提供了一种后台Daemon方式启动，只需要加上一个\"--fork\"参数即可，用到了\"--fork\"参数就必须启用\"--logpath\"参数\n通过命令行： ./bin/mongod --dbpath=/data/db --fork --logpath=/data/logs/mongodb.log\n配置文件方式：./bin/mongod -f mongodb.conf  或 ./bin/mongod --config mongodb.conf  //-f 后面写要使用的配置文件\n            ./bin/mongod --shutdown -f mongod.conf\n~~~\nport=27017\ndbpath=/usr/local/mongodb/data/\nlogpath=/usr/local/mongodb/log/mongodb.log  \nfork = true\n~~~\n\n命令行操作：\nuse mytetDB  //数据库如果不存在则创建\nsave时如果给定了_ObjectId则更新创建整条记录；如果要更新部分字段则使用update方法使用$set\ndb.dropDatabase()\ndb//显示当前数据库\nshow dbs\nshow collections\n\n有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。\nadmin： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\nlocal: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\nconfig: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n\nMongoDB GridFS文件系统\n分布式文件系统：将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点通过网络进行通信和数据传输\n\n当存储文档大于16M时，可以考虑使用GridFS\nGridFS：是MongoDB制定的如何在数据库中存储大文件的规范，MongoDB并没有实现GridFS，而是交由客户端驱动程序实现\nGridFS使用两个集合（collection）存储文件。一个集合是chunks, 用于存储文件内容的二进制数据；一个集合是files，用于存储文件的元数据。\n使用fs.files存储文件的元数据，包含字段如下： \n使用fs.chunks存储以255K进行分割的文件块，包含字段如下：\nGridFS适用于如下场景：\n存储用户产生的文件且文件数量比较大；需要文件的自动备份和分布式存储；需要访问文件的部分内容；存储16MB以上的文件\nmongofiles是MongoDB安装包中提供的一个工具，专门用来存取文件，包括查询所有文件、查看文件、上传一个文件、获取一个文件、按照_id来获取文件、按文件名删除文件、按_id删除文件。\nmongofiles --help其实有四个主要命令，分别为：\nput —存储命令\nget —获取命令 \nlist —列表命令\ndelete —删除命令 \n\nMongoDB聚合管道：聚合操作主要用户批量数据处理，往往将记录按条件分组，然后在每组上分别进行一系列操作，如：求和、求最大小值等\n聚合操作能够对记录进行复杂处理，主要为数理统计和数据挖掘。\nMongoDB提供了3种聚合操作方式：\n聚合管道（Aggregation Pipeline）:MongoDB Shell使用db.collection.aggregate([{...}])来构建和使用聚合管道\n    $project:用于修改文档的结构，可以重命名、增加或删除文档字段\n    $match:用于过滤文档，在$match中不能使用$where,尽量出现在管道的前面，方便借助索引加快查询\n    $group:将集合中的文档进行分组，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理\n    $sort:将集合中的文档进行排序，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理\n    $skip:跳过指定数量的文档\n    $unwind:将文档按照数组字段拆分成多条文档，每条文档包含数组的一个元素\n    $geoNear:按照由近到远顺序输出接近某一地理位置的文档\n    $out:将聚合结果存储到集合中，参数为集合名称\n    。。。\n    聚合管道表达式：阶段操作符可以看作是\"键\"，所对应的\"值\"称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。\n    聚合管道使用优化：\n    1将$match、$sort放到管道开始阶段，有利于利用索引提高文档处理效率\n    2提交过滤可减少流经后续阶段的文档数量\n    聚合管道的限制：\n    1返回文档结果不能超过16M，可通过返回一个游标或存储到集合中跳过此限制\n单目的聚合操作\n    count\n    distinct\n    group\nMapReduce编程模型\n\n\nmongoimport可以导入集合\n\nMongoDB数据更新\n文档插入和删除：insert、update、delete\nBulk函数：Bulk可将多个数据更新操作放到一个待执行的列表中批量来执行，顺序执行的Bulk（按添加顺序执行，一个有问题则退出）和并执行的Bulk（随机方式并行）\n1初始化Bulk：\n并行：db.集合名.initializeUnorderedBulkOp()\n顺序：db.集合名.initializeOrderedBulkOp()\n2 bulk.inset({...})\n3 bulk.execute()\n\nMMAPv1的内存分配策略：如果一个更新操作超过了文档在磁盘上预分配的空间，MongoDB会重新在磁盘上为其分配一块更大的连续空间。使用\"2的N次方\"的方式分配内存，如：32，64，128，256...2M，4M...\n优点：1有利用内存的重用，降低系统碎片的数量；2减少数据移动频率，提高系统数据写效率\n\n文档修改\nWriteResult = db.集合名.update(query,obj,upsert,multi)\nquery:查询条件，相当于where\nobj：更改的内容，相当于SQL中的set语句\nupsert：当query的文档不存在时是否插入一条新文档\nmulti：当query返回多个文档时是否一次更新满足条件的所有文档，默认只更新一条\n\n内嵌文档的修改：\n1. 修改整个内嵌文档：{$set:{field1:新内嵌文档}}\n2. 修改内嵌文档的某个字段：{$某个修改操作符:{field1.field2:value}}\n\n数组元素：MongoDB提供了大量的特定操作符，使得数组既可以作为栈、队列等有序对象使用，也可当作集合等无序对象来使用\n\nMongoDB的写安全机制\n写过程：使用update、save等操作数据集合中数据时，只是修改了数据再内存中的映像，数据更新并没有同步地保存到磁盘上，而且更新内存中数据之前，更新操作会被记录到journal日志文件中，\n每隔100ms将内存journal中的日志写到磁盘journal日志文件中 ，每隔60s将内存中修改的数据写会到磁盘上\n写入安全级别：写入安全Write Concern是一种客户端设置的，用于控制写入安全级别的机制，通过写入安全机制可提高数据的可靠性。\n分为四个级别，分别是：\n非确认式写入Unacknowledged：写操作不会返回结果，所以无法知道是否写入成功；但速度快、效率高、无阻塞\n确认式写入Acknowledged：写操作必须得到MongoDB服务器的写入确认，如果失败，会返回异常 \n日志写入Journaled：写操作要等到操作记录存储到Journal日志文件后才返回结果\n复制集确认写入Replica Acknowledged：写操作不仅要得到主节点的写入确认，还要得到从节点的写入确认，可以设置写入节点的个数（包含主节点）\n\njournal日志相当于oracle中的redo日志文件，用户故障恢复和持久。Journal默认100ms刷新一次，所以最多丢失100ms数据 \n文件位于journal目录中，只能以追加方式添加数据，文件名以\"j._\"开头，超过1G会自动创建新的；数据库正常关闭时，数据库服务会自动清空journal目录下所有文件\n\n设置写安全操作级别，其实就是在写操作的性能和可靠性间取一个权衡；使用的写操作级别越高，时间越长，可靠性越高 \n\n使用writeConcern函数作为更新函数的一个参数来设置写安全级别,如：db.集合名称.insert({name:\"joe\"},{writeConcern:{j:true}}),writeConcern函数参数如下：\nw选项，可选择0，1，2等整数值及\"majority\"，0-非确认式写入 1-确认式写入（未启用复制集）／主节点确认式写入（启用了复制集），>1只能用于复制集，2-数据至少写到1个从节点后返回，majority 只能用于复制集，表示更新操作用到大多数从节点\nj选项，设置为true来使用journaled日志安全级别\nwtimeout选项，用于设置超时单位为毫秒\n以上选项可组合使用\n\n数据MongoDB数据查询\nCursor = db.集合名称.find(query,fields,limit,skip)\nquery:查询条件，相当于where\nfields:用于字段映射，语法格式：{field:0}（0表示返回结果不包含此字段）或{field:1}（1表示返回结果不包含此字段），默认包含_id字段,相当于select中后面需要的字段\nlimit：限制查询结果集的数量，指定查询返回结果的数量上限，也可通过limit()实现\nskip:跳过一定数据量的结果，设置第一条返回文档的偏移量，也可通过skip()实现\nfind查询只能正对一个集合；返回的集合默认是无序的\n\ndb.集合名称.findOne()只返回第一条数据\n\n查询操作符\n比较查询操作符\n逻辑查询操作符\n元素查询操作符\n$where查询操作符：可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在js表达式和函数中，可使用this或obj来引用当前操作的文档，当js表达式或函数返回true时，才会返回当前文档\n\n内嵌文档与数组查询\n内嵌文档查询\n1查询整个内嵌文档：当内嵌文档的键值对数量和键值对顺序都相同时，才会匹配\n2查询文档的某个字段：需要使用.号操作符，如:db.user.find({\"address.city\":\"BeiJing\"})\n数组查询\n1查询整个数组：当数组元素内容和数组元素顺序都相同时，才会匹配\n2查询数组中的元素（普通元素）：\nA与位置无关，查询数组中含有某个值的文档，如：db.user.find({score:80})\nB与位置有关，按照指定的数组索引查询数组元素的值，如：db.user.find({'scores.2':80})\n3查询数组中的数组元素是文档时，查询数组元素有两种情况\nA与位置无关，查询数组中满足条件的子文档元素，如：db.user.find('scores.成绩'：95)\nB与位置有关，按照指定的数组索引查询数组子文档，如： db.user.find('scores.2.成绩'：95)\n\nMongoDB查询结果返回过程：find函数查询结果是以多条文档的形式分批来返回查询结果的，返回的文档会缓存到内存中，Cursor在一批数据回来之后遍历，下一批没来时会自动发起下一批请求，然后继续遍历\n\nMongoDB游标：用来遍历结果集中的数据。\n游标的生命周期：创建、使用、销毁\n游标可能会返回那些由于体积变大而被移动到集合末尾的文档而重复返回，可通过对查询快照的方式解决此问题，语法为：db.collection.find().snapshot().\n使用快照之后，查询就会在_id索引上来遍历执行，这样就可以保证每个文档只被返回一次，从而保证获取结果的一致性。\n\n模糊查询：查询条件可以使用正则表达式实现模糊查询，支持正则表达式操作符和正则表达式对象两种。\n正则表达式操作符：$regex\n\n\nfindAndModify函数使用执行分为find和update两步，但可以保证操作的原子性\n\nMongoDB是为分布式存储而设计，_id主键默认使用ObjectId类型的值，比自增方式更适合分布式环境，所以MongoDB默认不支持字段自增长功能\n\nMongoDB索引：数据库索引是对数据表中一列或多列的值进行排序的一种数据结构，使用索引可快速访问数据表中的特定信息。MogonDB索引不仅提高文档查询速度，还有利于排序时节省内存资源。\nMongoDB所有的索引信息被保存在system.indexes集合中，且默认总为_id创建单字段升序具有唯一属性的索引，可通过db.system.indexes.find()查看所有索引\nMongoDB可在单个字段上建立索引，字段可以是普通字段、整个文档以及子文档的某个字段\n对于复合索引，MongoDB支持前缀匹配\n为确保查询只使用复合索引，可以使用映射来指定不要返回_id字段（除非它是复合索引的一部分）\n多键索引：是对数组类型建立的索引，实际上是对数组的每个元素建立索引，而不是数组本身建立索引；当数组元素是文档时，可为文档的某个字段建立多键索引\n哈希索引：只支持等值查询，不支持范围查询，主要用于分片的集合上，可以作为片键来使用，能将数据比较均匀的分散存储在各个分片上，如：db.集合名.createIndex({name:\"hashed\"})\n\nMongoDB索引的属性\n唯一索引:可以确保集合的每一个文档的索引字段都有唯一的值，不会出现重复值，如：db.集合名.createIndex({name:1},{unique:true})，在非空集合创建唯一索引可能会因为已有重复值而失败，可添加dropBups:true删除重复文档\n稀疏索引：只会为索引字段存在的文档建立索引，即使索引字段的值为null，但不会为索引字段不存在的文档建立索引\nTTL(Time To Live)索引：为文档设置一个超时时间，当达到预设置的时间后，该文档会被数据库自动删除，但删除可能有延迟。这种类型的索引对缓存问题非常有用。只能建立在单独非_id字段\n创建了TTL索引后，MongoDB会有一个后台线程来管理文档；在复制集上建立的TTL索引，TTL后台线程只会运行在主节点上\n\nMongoDB索引的管理\n索引的默认命名规则：keyname1_dir1_keyname2_dir2...，其中keynameX是索引字段的名称，dirX是索引方向，1升序-1降序，也可自定义命名\n创建索引：db.集合名.createIndex(keys,options),返回值为一个文档类型。索引一旦创建就不能修改，创建后可通过db.集合名.getIndexes()查看集合所拥有的索引，创建索引有两种方式：\n1foreground:阻塞所有对数据库的读写请求，直到索引创建完成，为默认方式\n2background：创建索引时，如果有新的数据库请求，创建过程会暂停\n删除索引：db.集合.dropIndex(index)\n查询优化器：用来优化查询过程，通过比较返回100条文档速度得到最佳查询计划\nexplain函数：能够提供大量与查询有关的信息，可以很好的评估索引性能，帮助优化索引的使用策略。db.集合.find().explain(mode),支持3种模式：\n1queryPlanner：查询计划，默认\n2executionStatus：查询性能统计\n3allPlansExecution：所有计划统计信息（最优与被拒绝的计划）\nexplain返回结果使用由多个阶段（Stage）组成的树形结构来表示查询计划，查询计划自下而上执行，树的叶节点用来访问文档或索引，内部节点处理下层节点返回文档或索引，根节点输出查询结果\nhint函数：强制MongoDB使用特定索引\n\nMongoDB特殊索引\n地理空间索引：对地理位置数据建立索引，MongoDB支持两种2dsphere球面索引和平面2d索引\n2dSphere球面索引\n2d平面索引\n\n全文索引：又称为倒排索引，用于在大量文本中对每一个词组建立索引，指出该词在整段文本中出现的位置和次数，此技术主要用于搜索引擎和站内搜索等。\n一个集合只能有一个全文索引\n\n\njava对mongodb的使用\n集群搭建：mongodb分布式集群搭建手记\n\n\n学习：http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html\n\n\n分析没有默认的，因为你还没给root设置密码，第一个 user 是在 admin 组 ，所以他可以给 root 设置密码 , so\nsudo passwd root\n\n\nLanguage Support\n\n\nhttp://blog.csdn.net/sinat_35418761/article/details/53241481\n\n\nhttp://www.2cto.com/database/201504/395442.html\nhttp://www.myexception.cn/operating-system/1685604.html\n\n\nhttps://my.oschina.net/chinacaptain/blog/465723\n\n\n\nhttp://api.mongodb.com/java/current/\n\n\n\nMongoDB是什么\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\n他的特点:高性能、易部署、易使用，存储数据非常方便。\n\n\nBson：Binary Serialized Document Format，是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型\n\n\n\n","slug":"数据库-2018-12-10-MongoDB","published":1,"date":"2019-02-14T08:22:58.000Z","updated":"2019-02-14T08:22:58.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue5700ek5b8hyz3hjmdx","content":"<p><a href=\"https://www.jikexueyuan.com/course/mongoDB/\" target=\"_blank\" rel=\"noopener\">https://www.jikexueyuan.com/course/mongoDB/</a></p>\n<p>NoSQL数据库：NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;，指的是非关系型的数据库</p>\n<p>mongodb官网：<a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/</a><br>\n<a href=\"https://docs.mongodb.com/manual/\" target=\"_blank\" rel=\"noopener\">https://docs.mongodb.com/manual/</a></p>\n<p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>\n<p><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/mongodb/mongodb-tutorial.html</a></p>\n<p>NoSQL保证数据的最终一致性，数据由更新延迟</p>\n<p>CAP理论</p>\n<p>适用场景：数据缓存；json格式数据存储；高伸缩性场景；<br>\nMongoDB更多适合大数据量、高并发、弱事务的互联网应用，其内置的水平扩展机制提供了从几百万到十亿级别的数据处理能力，可很好的满足Web2.0和移动互联网应用的s数据存储要求。</p>\n<p>MongoDB由C++编写，支持32位（2G限制）和64位应用，是一个基于分布式文件存储的开源数据库系统。</p>\n<p>MongoDB3.0特性：</p>\n<ol>\n<li>加入WiredTiger存储引擎:<br>\n开源的存储引擎；为现代硬件设计：多核CPU，充分利用内存／芯片级缓存；RAM/SSD/HDD；为大数据设计：高性能，低延迟，高并发稳定性</li>\n<li>MMAPv1:内存映射存储引擎，为默认引擎 ，提供了Collection锁；无缝迁移MMAP</li>\n<li>可插拔引擎API</li>\n<li>基于Web的可视化管理工具：Ops Manager</li>\n</ol>\n<p>MongoDB数据模型<br>\n文档：本质上是一种类JSON的BSON格式的数据，可以理解为在JSON基础上添加了一些新的数据类型，包括Date，正则表达式等。<br>\nBSON官网：<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\">http://bsonspec.org/</a><br>\nBSON是由一组组键值对组成，具有轻量性、可靠性和高效性3个特征。可遍历性是MongoDB将BSON作为数据存储的重要原因<br>\n使用文档时需要注意以下事项：<br>\nMongoDB中写操作的原子性限制在文档级别；<br>\n单个文档占用的存储空间不能超过16MB；<br>\nMongoDB会尽量保持文档被插入时键值对的顺序；<br>\n关于文档命名需要注意的事项：<br>\n_id是系统保留的关键字，他是默认的主键，该值在集合中必须唯一，且不可更改；<br>\n键不能包含空字符或\\0，这个字符用于表示键的结尾；<br>\n不能以$开头且不能包含点号.<br>\n键是区分大小写的且不能重复</p>\n<p>集合：把一组相关的文档放到一起组成了集合，MongoDB的集合是模式自由的，一个集合里面的文档可以是各式各样的<br>\nMogoDB提供了一些特殊的集合：capped collection、system.indexes、system.namespaces等<br>\n集合命名需注意：<br>\n集合名不能是空字符串；<br>\n集合名不能包含空字符串或\\0，该字符表示集合名的结尾<br>\n集合名不能以&quot;system.&quot;开头，此前缀是系统本身保留的<br>\n集合名不能包含$字符，但是可以包含点号.</p>\n<p>数据库：多个文档组成集合，多个集合组成数据库。一个MongoDB实例可承载多个数据库，每个数据库有独立的权限，在磁盘上，不同的数据库也可放置到不通目录<br>\n数据库命名规则：<br>\n不能是空字符串；不能以$开头；不能包含空字符串和点号.;数据库名称区分大小写；建议数据库名全部使用小写；数据库名最长64字节；不要与系统保留数据库名相同</p>\n<p>命名空间：把数据库名添加到集合名前面，中间用点号连接，得到集合的完全限定，就是命名空间<br>\n因为点号可以出现在集合名字中，如：jike.blog.posts 和 jike.blog.authors，可以将posts和authors看作是blog集合的子集合，blog集合甚至可以不存在<br>\n使用子集合的方式，可以是我们更好的组织数据，使数据结构更加清晰明了</p>\n<p>MongoDB数据类型<br>\n基本数据类型<br>\nnull：表示空值或者不存在的字段<br>\n布尔：true／false<br>\n数据类型：32-int,64-int,64-double,注意：JavaScript只支持64位浮点数<br>\n字符串类型：使用UTF-8对字符串进行编码<br>\n二进制数据：可以保存由任意字节组成的字符串，如：图片、视频等<br>\n正则表达式类型：主要用于查询，使用正则表达式作为限定条件<br>\nDate类型：是一个64位整数，它代表距Unix epoch：1970-1-1的毫秒数，MongoDB在存储时间是现转换为UTC时间，北京时间=UTC+8小时，MongoDB Shell会根据本地时间 设置显示日期时间<br>\nTimestap：32bit Unix epoch + 32bit自增序数，只供MongoDB数据库服务内部使用，用于记录操作的详细时间<br>\nObjectId：由24个16精制字符组成，每个字节存储两位16精制数字，总共需12字节存储空间=4字节时间戳+3字节机器标识+2字节pid+3字节计数器，ObjectId(),getTimestamp(),valueOf()<br>\n数组：使用方括号来表示的一组值，数组中可以包含不通数据类型的元素，针对数组，MongoDB提供了许多操作符，如：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">pop,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">p</span><span class=\"mpunct\">,</span></span></span></span>push,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>l</mi><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">pull,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span></span></span></span>slice,$addToSet等；MongoDB可自动为数组元素建立MultiKey索引<br>\n内嵌文档：文档可以作为键的值，这样的文档成为内嵌文档。内嵌文档可以使数据不用保存成扁平结果的键值对，从而使数据组织形式更加自然。</p>\n<p>内嵌文档模式VS引用文档模式<br>\n子文档比较小或变化不频繁，则使用内嵌文档模式，否则使用引用文档模式</p>\n<p>MongoDB自动将_id字段设置为主键</p>\n<p>MongoDB Shell：是MongoDB自带的JavaScript Shell，随MongoDB一起发布 =JavaScript V8解释器+MongoDB客户端</p>\n<p>help查看帮助<br>\n执行脚本<br>\n直接执行：mongo [–quiet] script.js<br>\n交互执行：load(“script.js”)<br>\n执行命令行程序：run(“ls”)<br>\n.mongorc.js文件，默认会加载<br>\n编辑复合变量EDITOR：在.bashrc中添加后source生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EDITOR</span><br><span class=\"line\">EDITOR=/usr/bin/vim</span><br></pre></td></tr></table></figure>\n<p>即可使用editor编辑文档</p>\n<p><a href=\"http://www.runoob.com/mongodb/mongodb-intro.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/mongodb/mongodb-intro.html</a><br>\nMongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。<br>\nGridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。<br>\nMongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</p>\n<p>MongoDB数据库安装：</p>\n<ol>\n<li>下载安装文件解压缩并添加bin目录到环境变量</li>\n<li>创建一个data目录，然后在data目录里创建db目录、logs目录</li>\n<li>启动服务端</li>\n<li>启动客户端：mongo</li>\n<li>windows下可以将MongoDB做成系统服务</li>\n</ol>\n<p>mac<br>\n临时添加环境变量：export PATH=/usr/local/mongodb/bin:<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mi mathvariant=\"normal\">编</mi><mi mathvariant=\"normal\">辑</mi><mtext> </mtext><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mi>p</mi></msub><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">添</mi><mi mathvariant=\"normal\">加</mi><mi mathvariant=\"normal\">：</mi><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">PATH\n编辑~/.bash_profile,添加：export PATH=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord cjk_fallback\">编</span><span class=\"mord cjk_fallback\">辑</span><span class=\"mspace nobreak\"> </span><span class=\"mord\">/</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">b</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">s</span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">添</span><span class=\"mord cjk_fallback\">加</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span>PATH:/usr/local/mongodb4/bin/:$PATH 即可永久添加环境变量</p>\n<p>连接MongoDB数据库：./mongo + 服务器IP:端口号/数据库名<br>\n关闭MongoDB服务在 ./mongo 进入控制台后，输入 use admin,然后输入 db.shutdownServer()</p>\n<p>Mongodb可以通过命令行方式和配置文件的方式来启动：<br>\n这两种方式都是在前台启动Mongodb进程，如果Session窗口关闭，Mongodb进程也随之停止。<br>\n不过Mongodb同时还提供了一种后台Daemon方式启动，只需要加上一个&quot;–fork&quot;参数即可，用到了&quot;–fork&quot;参数就必须启用&quot;–logpath&quot;参数<br>\n通过命令行： ./bin/mongod --dbpath=/data/db --fork --logpath=/data/logs/mongodb.log<br>\n配置文件方式：./bin/mongod -f mongodb.conf  或 ./bin/mongod --config mongodb.conf  //-f 后面写要使用的配置文件<br>\n./bin/mongod --shutdown -f mongod.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port=27017</span><br><span class=\"line\">dbpath=/usr/local/mongodb/data/</span><br><span class=\"line\">logpath=/usr/local/mongodb/log/mongodb.log  </span><br><span class=\"line\">fork = true</span><br></pre></td></tr></table></figure>\n<p>命令行操作：<br>\nuse mytetDB  //数据库如果不存在则创建<br>\nsave时如果给定了_ObjectId则更新创建整条记录；如果要更新部分字段则使用update方法使用$set<br>\ndb.dropDatabase()<br>\ndb//显示当前数据库<br>\nshow dbs<br>\nshow collections</p>\n<p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。<br>\nadmin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。<br>\nlocal: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合<br>\nconfig: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p>\n<p>MongoDB GridFS文件系统<br>\n分布式文件系统：将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点通过网络进行通信和数据传输</p>\n<p>当存储文档大于16M时，可以考虑使用GridFS<br>\nGridFS：是MongoDB制定的如何在数据库中存储大文件的规范，MongoDB并没有实现GridFS，而是交由客户端驱动程序实现<br>\nGridFS使用两个集合（collection）存储文件。一个集合是chunks, 用于存储文件内容的二进制数据；一个集合是files，用于存储文件的元数据。<br>\n使用fs.files存储文件的元数据，包含字段如下：<br>\n使用fs.chunks存储以255K进行分割的文件块，包含字段如下：<br>\nGridFS适用于如下场景：<br>\n存储用户产生的文件且文件数量比较大；需要文件的自动备份和分布式存储；需要访问文件的部分内容；存储16MB以上的文件<br>\nmongofiles是MongoDB安装包中提供的一个工具，专门用来存取文件，包括查询所有文件、查看文件、上传一个文件、获取一个文件、按照_id来获取文件、按文件名删除文件、按_id删除文件。<br>\nmongofiles --help其实有四个主要命令，分别为：<br>\nput —存储命令<br>\nget —获取命令<br>\nlist —列表命令<br>\ndelete —删除命令</p>\n<p>MongoDB聚合管道：聚合操作主要用户批量数据处理，往往将记录按条件分组，然后在每组上分别进行一系列操作，如：求和、求最大小值等<br>\n聚合操作能够对记录进行复杂处理，主要为数理统计和数据挖掘。<br>\nMongoDB提供了3种聚合操作方式：<br>\n聚合管道（Aggregation Pipeline）:MongoDB Shell使用db.collection.aggregate([{…}])来构建和使用聚合管道<br>\n$project:用于修改文档的结构，可以重命名、增加或删除文档字段<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>:</mo><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">于</mi><mi mathvariant=\"normal\">过</mi><mi mathvariant=\"normal\">滤</mi><mi mathvariant=\"normal\">文</mi><mi mathvariant=\"normal\">档</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">在</mi></mrow><annotation encoding=\"application/x-tex\">match:用于过滤文档，在</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">于</span><span class=\"mord cjk_fallback\">过</span><span class=\"mord cjk_fallback\">滤</span><span class=\"mord cjk_fallback\">文</span><span class=\"mord cjk_fallback\">档</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">在</span></span></span></span>match中不能使用$where,尽量出现在管道的前面，方便借助索引加快查询<br>\n$group:将集合中的文档进行分组，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理<br>\n$sort:将集合中的文档进行排序，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理<br>\n$skip:跳过指定数量的文档<br>\n$unwind:将文档按照数组字段拆分成多条文档，每条文档包含数组的一个元素<br>\n$geoNear:按照由近到远顺序输出接近某一地理位置的文档<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mo>:</mo><mi mathvariant=\"normal\">将</mi><mi mathvariant=\"normal\">聚</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">结</mi><mi mathvariant=\"normal\">果</mi><mi mathvariant=\"normal\">存</mi><mi mathvariant=\"normal\">储</mi><mi mathvariant=\"normal\">到</mi><mi mathvariant=\"normal\">集</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">参</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">为</mi><mi mathvariant=\"normal\">集</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">称</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">聚</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">：</mi><mi mathvariant=\"normal\">阶</mi><mi mathvariant=\"normal\">段</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">符</mi><mi mathvariant=\"normal\">可</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">看</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">键</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">所</mi><mi mathvariant=\"normal\">对</mi><mi mathvariant=\"normal\">应</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">值</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">称</mi><mi mathvariant=\"normal\">为</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">可</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">看</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">符</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">一</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">文</mi><mi mathvariant=\"normal\">档</mi><mi mathvariant=\"normal\">结</mi><mi mathvariant=\"normal\">构</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">由</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">段</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">、</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">段</mi><mi mathvariant=\"normal\">值</mi><mi mathvariant=\"normal\">和</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">符</mi><mi mathvariant=\"normal\">组</mi><mi mathvariant=\"normal\">成</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">聚</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">使</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">优</mi><mi mathvariant=\"normal\">化</mi><mi mathvariant=\"normal\">：</mi><mn>1</mn><mi mathvariant=\"normal\">将</mi></mrow><annotation encoding=\"application/x-tex\">out:将聚合结果存储到集合中，参数为集合名称\n    。。。\n    聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。\n    聚合管道使用优化：\n    1将</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">将</span><span class=\"mord cjk_fallback\">聚</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">结</span><span class=\"mord cjk_fallback\">果</span><span class=\"mord cjk_fallback\">存</span><span class=\"mord cjk_fallback\">储</span><span class=\"mord cjk_fallback\">到</span><span class=\"mord cjk_fallback\">集</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord cjk_fallback\">集</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">称</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">聚</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">阶</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">可</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">看</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">键</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">对</span><span class=\"mord cjk_fallback\">应</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">值</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">称</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">可</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">看</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">文</span><span class=\"mord cjk_fallback\">档</span><span class=\"mord cjk_fallback\">结</span><span class=\"mord cjk_fallback\">构</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">由</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">、</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">值</span><span class=\"mord cjk_fallback\">和</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">成</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">聚</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">使</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">优</span><span class=\"mord cjk_fallback\">化</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">将</span></span></span></span>match、$sort放到管道开始阶段，有利于利用索引提高文档处理效率<br>\n2提交过滤可减少流经后续阶段的文档数量<br>\n聚合管道的限制：<br>\n1返回文档结果不能超过16M，可通过返回一个游标或存储到集合中跳过此限制<br>\n单目的聚合操作<br>\ncount<br>\ndistinct<br>\ngroup<br>\nMapReduce编程模型</p>\n<p>mongoimport可以导入集合</p>\n<p>MongoDB数据更新<br>\n文档插入和删除：insert、update、delete<br>\nBulk函数：Bulk可将多个数据更新操作放到一个待执行的列表中批量来执行，顺序执行的Bulk（按添加顺序执行，一个有问题则退出）和并执行的Bulk（随机方式并行）<br>\n1初始化Bulk：<br>\n并行：db.集合名.initializeUnorderedBulkOp()<br>\n顺序：db.集合名.initializeOrderedBulkOp()<br>\n2 bulk.inset({…})<br>\n3 bulk.execute()</p>\n<p>MMAPv1的内存分配策略：如果一个更新操作超过了文档在磁盘上预分配的空间，MongoDB会重新在磁盘上为其分配一块更大的连续空间。使用&quot;2的N次方&quot;的方式分配内存，如：32，64，128，256…2M，4M…<br>\n优点：1有利用内存的重用，降低系统碎片的数量；2减少数据移动频率，提高系统数据写效率</p>\n<p>文档修改<br>\nWriteResult = db.集合名.update(query,obj,upsert,multi)<br>\nquery:查询条件，相当于where<br>\nobj：更改的内容，相当于SQL中的set语句<br>\nupsert：当query的文档不存在时是否插入一条新文档<br>\nmulti：当query返回多个文档时是否一次更新满足条件的所有文档，默认只更新一条</p>\n<p>内嵌文档的修改：</p>\n<ol>\n<li>修改整个内嵌文档：{$set:{field1:新内嵌文档}}</li>\n<li>修改内嵌文档的某个字段：{$某个修改操作符:{field1.field2:value}}</li>\n</ol>\n<p>数组元素：MongoDB提供了大量的特定操作符，使得数组既可以作为栈、队列等有序对象使用，也可当作集合等无序对象来使用</p>\n<p>MongoDB的写安全机制<br>\n写过程：使用update、save等操作数据集合中数据时，只是修改了数据再内存中的映像，数据更新并没有同步地保存到磁盘上，而且更新内存中数据之前，更新操作会被记录到journal日志文件中，<br>\n每隔100ms将内存journal中的日志写到磁盘journal日志文件中 ，每隔60s将内存中修改的数据写会到磁盘上<br>\n写入安全级别：写入安全Write Concern是一种客户端设置的，用于控制写入安全级别的机制，通过写入安全机制可提高数据的可靠性。<br>\n分为四个级别，分别是：<br>\n非确认式写入Unacknowledged：写操作不会返回结果，所以无法知道是否写入成功；但速度快、效率高、无阻塞<br>\n确认式写入Acknowledged：写操作必须得到MongoDB服务器的写入确认，如果失败，会返回异常<br>\n日志写入Journaled：写操作要等到操作记录存储到Journal日志文件后才返回结果<br>\n复制集确认写入Replica Acknowledged：写操作不仅要得到主节点的写入确认，还要得到从节点的写入确认，可以设置写入节点的个数（包含主节点）</p>\n<p>journal日志相当于oracle中的redo日志文件，用户故障恢复和持久。Journal默认100ms刷新一次，所以最多丢失100ms数据<br>\n文件位于journal目录中，只能以追加方式添加数据，文件名以&quot;j._&quot;开头，超过1G会自动创建新的；数据库正常关闭时，数据库服务会自动清空journal目录下所有文件</p>\n<p>设置写安全操作级别，其实就是在写操作的性能和可靠性间取一个权衡；使用的写操作级别越高，时间越长，可靠性越高</p>\n<p>使用writeConcern函数作为更新函数的一个参数来设置写安全级别,如：db.集合名称.insert({name:“joe”},{writeConcern:{j:true}}),writeConcern函数参数如下：<br>\nw选项，可选择0，1，2等整数值及&quot;majority&quot;，0-非确认式写入 1-确认式写入（未启用复制集）／主节点确认式写入（启用了复制集），&gt;1只能用于复制集，2-数据至少写到1个从节点后返回，majority 只能用于复制集，表示更新操作用到大多数从节点<br>\nj选项，设置为true来使用journaled日志安全级别<br>\nwtimeout选项，用于设置超时单位为毫秒<br>\n以上选项可组合使用</p>\n<p>数据MongoDB数据查询<br>\nCursor = db.集合名称.find(query,fields,limit,skip)<br>\nquery:查询条件，相当于where<br>\nfields:用于字段映射，语法格式：{field:0}（0表示返回结果不包含此字段）或{field:1}（1表示返回结果不包含此字段），默认包含_id字段,相当于select中后面需要的字段<br>\nlimit：限制查询结果集的数量，指定查询返回结果的数量上限，也可通过limit()实现<br>\nskip:跳过一定数据量的结果，设置第一条返回文档的偏移量，也可通过skip()实现<br>\nfind查询只能正对一个集合；返回的集合默认是无序的</p>\n<p>db.集合名称.findOne()只返回第一条数据</p>\n<p>查询操作符<br>\n比较查询操作符<br>\n逻辑查询操作符<br>\n元素查询操作符<br>\n$where查询操作符：可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在js表达式和函数中，可使用this或obj来引用当前操作的文档，当js表达式或函数返回true时，才会返回当前文档</p>\n<p>内嵌文档与数组查询<br>\n内嵌文档查询<br>\n1查询整个内嵌文档：当内嵌文档的键值对数量和键值对顺序都相同时，才会匹配<br>\n2查询文档的某个字段：需要使用.号操作符，如:db.user.find({“address.city”:“BeiJing”})<br>\n数组查询<br>\n1查询整个数组：当数组元素内容和数组元素顺序都相同时，才会匹配<br>\n2查询数组中的元素（普通元素）：<br>\nA与位置无关，查询数组中含有某个值的文档，如：db.user.find({score:80})<br>\nB与位置有关，按照指定的数组索引查询数组元素的值，如：db.user.find({‘scores.2’:80})<br>\n3查询数组中的数组元素是文档时，查询数组元素有两种情况<br>\nA与位置无关，查询数组中满足条件的子文档元素，如：db.user.find(‘scores.成绩’：95)<br>\nB与位置有关，按照指定的数组索引查询数组子文档，如： db.user.find(‘scores.2.成绩’：95)</p>\n<p>MongoDB查询结果返回过程：find函数查询结果是以多条文档的形式分批来返回查询结果的，返回的文档会缓存到内存中，Cursor在一批数据回来之后遍历，下一批没来时会自动发起下一批请求，然后继续遍历</p>\n<p>MongoDB游标：用来遍历结果集中的数据。<br>\n游标的生命周期：创建、使用、销毁<br>\n游标可能会返回那些由于体积变大而被移动到集合末尾的文档而重复返回，可通过对查询快照的方式解决此问题，语法为：db.collection.find().snapshot().<br>\n使用快照之后，查询就会在_id索引上来遍历执行，这样就可以保证每个文档只被返回一次，从而保证获取结果的一致性。</p>\n<p>模糊查询：查询条件可以使用正则表达式实现模糊查询，支持正则表达式操作符和正则表达式对象两种。<br>\n正则表达式操作符：$regex</p>\n<p>findAndModify函数使用执行分为find和update两步，但可以保证操作的原子性</p>\n<p>MongoDB是为分布式存储而设计，_id主键默认使用ObjectId类型的值，比自增方式更适合分布式环境，所以MongoDB默认不支持字段自增长功能</p>\n<p>MongoDB索引：数据库索引是对数据表中一列或多列的值进行排序的一种数据结构，使用索引可快速访问数据表中的特定信息。MogonDB索引不仅提高文档查询速度，还有利于排序时节省内存资源。<br>\nMongoDB所有的索引信息被保存在system.indexes集合中，且默认总为_id创建单字段升序具有唯一属性的索引，可通过db.system.indexes.find()查看所有索引<br>\nMongoDB可在单个字段上建立索引，字段可以是普通字段、整个文档以及子文档的某个字段<br>\n对于复合索引，MongoDB支持前缀匹配<br>\n为确保查询只使用复合索引，可以使用映射来指定不要返回_id字段（除非它是复合索引的一部分）<br>\n多键索引：是对数组类型建立的索引，实际上是对数组的每个元素建立索引，而不是数组本身建立索引；当数组元素是文档时，可为文档的某个字段建立多键索引<br>\n哈希索引：只支持等值查询，不支持范围查询，主要用于分片的集合上，可以作为片键来使用，能将数据比较均匀的分散存储在各个分片上，如：db.集合名.createIndex({name:“hashed”})</p>\n<p>MongoDB索引的属性<br>\n唯一索引:可以确保集合的每一个文档的索引字段都有唯一的值，不会出现重复值，如：db.集合名.createIndex({name:1},{unique:true})，在非空集合创建唯一索引可能会因为已有重复值而失败，可添加dropBups:true删除重复文档<br>\n稀疏索引：只会为索引字段存在的文档建立索引，即使索引字段的值为null，但不会为索引字段不存在的文档建立索引<br>\nTTL(Time To Live)索引：为文档设置一个超时时间，当达到预设置的时间后，该文档会被数据库自动删除，但删除可能有延迟。这种类型的索引对缓存问题非常有用。只能建立在单独非_id字段<br>\n创建了TTL索引后，MongoDB会有一个后台线程来管理文档；在复制集上建立的TTL索引，TTL后台线程只会运行在主节点上</p>\n<p>MongoDB索引的管理<br>\n索引的默认命名规则：keyname1_dir1_keyname2_dir2…，其中keynameX是索引字段的名称，dirX是索引方向，1升序-1降序，也可自定义命名<br>\n创建索引：db.集合名.createIndex(keys,options),返回值为一个文档类型。索引一旦创建就不能修改，创建后可通过db.集合名.getIndexes()查看集合所拥有的索引，创建索引有两种方式：<br>\n1foreground:阻塞所有对数据库的读写请求，直到索引创建完成，为默认方式<br>\n2background：创建索引时，如果有新的数据库请求，创建过程会暂停<br>\n删除索引：db.集合.dropIndex(index)<br>\n查询优化器：用来优化查询过程，通过比较返回100条文档速度得到最佳查询计划<br>\nexplain函数：能够提供大量与查询有关的信息，可以很好的评估索引性能，帮助优化索引的使用策略。db.集合.find().explain(mode),支持3种模式：<br>\n1queryPlanner：查询计划，默认<br>\n2executionStatus：查询性能统计<br>\n3allPlansExecution：所有计划统计信息（最优与被拒绝的计划）<br>\nexplain返回结果使用由多个阶段（Stage）组成的树形结构来表示查询计划，查询计划自下而上执行，树的叶节点用来访问文档或索引，内部节点处理下层节点返回文档或索引，根节点输出查询结果<br>\nhint函数：强制MongoDB使用特定索引</p>\n<p>MongoDB特殊索引<br>\n地理空间索引：对地理位置数据建立索引，MongoDB支持两种2dsphere球面索引和平面2d索引<br>\n2dSphere球面索引<br>\n2d平面索引</p>\n<p>全文索引：又称为倒排索引，用于在大量文本中对每一个词组建立索引，指出该词在整段文本中出现的位置和次数，此技术主要用于搜索引擎和站内搜索等。<br>\n一个集合只能有一个全文索引</p>\n<p>java对mongodb的使用<br>\n集群搭建：mongodb分布式集群搭建手记</p>\n<p>学习：<a href=\"http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html</a></p>\n<p>分析没有默认的，因为你还没给root设置密码，第一个 user 是在 admin 组 ，所以他可以给 root 设置密码 , so<br>\nsudo passwd root</p>\n<p>Language Support</p>\n<p><a href=\"http://blog.csdn.net/sinat_35418761/article/details/53241481\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/sinat_35418761/article/details/53241481</a></p>\n<p><a href=\"http://www.2cto.com/database/201504/395442.html\" target=\"_blank\" rel=\"noopener\">http://www.2cto.com/database/201504/395442.html</a><br>\n<a href=\"http://www.myexception.cn/operating-system/1685604.html\" target=\"_blank\" rel=\"noopener\">http://www.myexception.cn/operating-system/1685604.html</a></p>\n<p><a href=\"https://my.oschina.net/chinacaptain/blog/465723\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/chinacaptain/blog/465723</a></p>\n<p><a href=\"http://api.mongodb.com/java/current/\" target=\"_blank\" rel=\"noopener\">http://api.mongodb.com/java/current/</a></p>\n<p>MongoDB是什么<br>\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>\n他的特点:高性能、易部署、易使用，存储数据非常方便。</p>\n<p>Bson：Binary Serialized Document Format，是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.jikexueyuan.com/course/mongoDB/\" target=\"_blank\" rel=\"noopener\">https://www.jikexueyuan.com/course/mongoDB/</a></p>\n<p>NoSQL数据库：NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;，指的是非关系型的数据库</p>\n<p>mongodb官网：<a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/</a><br>\n<a href=\"https://docs.mongodb.com/manual/\" target=\"_blank\" rel=\"noopener\">https://docs.mongodb.com/manual/</a></p>\n<p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>\n<p><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/mongodb/mongodb-tutorial.html</a></p>\n<p>NoSQL保证数据的最终一致性，数据由更新延迟</p>\n<p>CAP理论</p>\n<p>适用场景：数据缓存；json格式数据存储；高伸缩性场景；<br>\nMongoDB更多适合大数据量、高并发、弱事务的互联网应用，其内置的水平扩展机制提供了从几百万到十亿级别的数据处理能力，可很好的满足Web2.0和移动互联网应用的s数据存储要求。</p>\n<p>MongoDB由C++编写，支持32位（2G限制）和64位应用，是一个基于分布式文件存储的开源数据库系统。</p>\n<p>MongoDB3.0特性：</p>\n<ol>\n<li>加入WiredTiger存储引擎:<br>\n开源的存储引擎；为现代硬件设计：多核CPU，充分利用内存／芯片级缓存；RAM/SSD/HDD；为大数据设计：高性能，低延迟，高并发稳定性</li>\n<li>MMAPv1:内存映射存储引擎，为默认引擎 ，提供了Collection锁；无缝迁移MMAP</li>\n<li>可插拔引擎API</li>\n<li>基于Web的可视化管理工具：Ops Manager</li>\n</ol>\n<p>MongoDB数据模型<br>\n文档：本质上是一种类JSON的BSON格式的数据，可以理解为在JSON基础上添加了一些新的数据类型，包括Date，正则表达式等。<br>\nBSON官网：<a href=\"http://bsonspec.org/\" target=\"_blank\" rel=\"noopener\">http://bsonspec.org/</a><br>\nBSON是由一组组键值对组成，具有轻量性、可靠性和高效性3个特征。可遍历性是MongoDB将BSON作为数据存储的重要原因<br>\n使用文档时需要注意以下事项：<br>\nMongoDB中写操作的原子性限制在文档级别；<br>\n单个文档占用的存储空间不能超过16MB；<br>\nMongoDB会尽量保持文档被插入时键值对的顺序；<br>\n关于文档命名需要注意的事项：<br>\n_id是系统保留的关键字，他是默认的主键，该值在集合中必须唯一，且不可更改；<br>\n键不能包含空字符或\\0，这个字符用于表示键的结尾；<br>\n不能以$开头且不能包含点号.<br>\n键是区分大小写的且不能重复</p>\n<p>集合：把一组相关的文档放到一起组成了集合，MongoDB的集合是模式自由的，一个集合里面的文档可以是各式各样的<br>\nMogoDB提供了一些特殊的集合：capped collection、system.indexes、system.namespaces等<br>\n集合命名需注意：<br>\n集合名不能是空字符串；<br>\n集合名不能包含空字符串或\\0，该字符表示集合名的结尾<br>\n集合名不能以&quot;system.&quot;开头，此前缀是系统本身保留的<br>\n集合名不能包含$字符，但是可以包含点号.</p>\n<p>数据库：多个文档组成集合，多个集合组成数据库。一个MongoDB实例可承载多个数据库，每个数据库有独立的权限，在磁盘上，不同的数据库也可放置到不通目录<br>\n数据库命名规则：<br>\n不能是空字符串；不能以$开头；不能包含空字符串和点号.;数据库名称区分大小写；建议数据库名全部使用小写；数据库名最长64字节；不要与系统保留数据库名相同</p>\n<p>命名空间：把数据库名添加到集合名前面，中间用点号连接，得到集合的完全限定，就是命名空间<br>\n因为点号可以出现在集合名字中，如：jike.blog.posts 和 jike.blog.authors，可以将posts和authors看作是blog集合的子集合，blog集合甚至可以不存在<br>\n使用子集合的方式，可以是我们更好的组织数据，使数据结构更加清晰明了</p>\n<p>MongoDB数据类型<br>\n基本数据类型<br>\nnull：表示空值或者不存在的字段<br>\n布尔：true／false<br>\n数据类型：32-int,64-int,64-double,注意：JavaScript只支持64位浮点数<br>\n字符串类型：使用UTF-8对字符串进行编码<br>\n二进制数据：可以保存由任意字节组成的字符串，如：图片、视频等<br>\n正则表达式类型：主要用于查询，使用正则表达式作为限定条件<br>\nDate类型：是一个64位整数，它代表距Unix epoch：1970-1-1的毫秒数，MongoDB在存储时间是现转换为UTC时间，北京时间=UTC+8小时，MongoDB Shell会根据本地时间 设置显示日期时间<br>\nTimestap：32bit Unix epoch + 32bit自增序数，只供MongoDB数据库服务内部使用，用于记录操作的详细时间<br>\nObjectId：由24个16精制字符组成，每个字节存储两位16精制数字，总共需12字节存储空间=4字节时间戳+3字节机器标识+2字节pid+3字节计数器，ObjectId(),getTimestamp(),valueOf()<br>\n数组：使用方括号来表示的一组值，数组中可以包含不通数据类型的元素，针对数组，MongoDB提供了许多操作符，如：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">pop,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">p</span><span class=\"mpunct\">,</span></span></span></span>push,<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>l</mi><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">pull,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span></span></span></span>slice,$addToSet等；MongoDB可自动为数组元素建立MultiKey索引<br>\n内嵌文档：文档可以作为键的值，这样的文档成为内嵌文档。内嵌文档可以使数据不用保存成扁平结果的键值对，从而使数据组织形式更加自然。</p>\n<p>内嵌文档模式VS引用文档模式<br>\n子文档比较小或变化不频繁，则使用内嵌文档模式，否则使用引用文档模式</p>\n<p>MongoDB自动将_id字段设置为主键</p>\n<p>MongoDB Shell：是MongoDB自带的JavaScript Shell，随MongoDB一起发布 =JavaScript V8解释器+MongoDB客户端</p>\n<p>help查看帮助<br>\n执行脚本<br>\n直接执行：mongo [–quiet] script.js<br>\n交互执行：load(“script.js”)<br>\n执行命令行程序：run(“ls”)<br>\n.mongorc.js文件，默认会加载<br>\n编辑复合变量EDITOR：在.bashrc中添加后source生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EDITOR</span><br><span class=\"line\">EDITOR=/usr/bin/vim</span><br></pre></td></tr></table></figure>\n<p>即可使用editor编辑文档</p>\n<p><a href=\"http://www.runoob.com/mongodb/mongodb-intro.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/mongodb/mongodb-intro.html</a><br>\nMongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。<br>\nGridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。<br>\nMongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</p>\n<p>MongoDB数据库安装：</p>\n<ol>\n<li>下载安装文件解压缩并添加bin目录到环境变量</li>\n<li>创建一个data目录，然后在data目录里创建db目录、logs目录</li>\n<li>启动服务端</li>\n<li>启动客户端：mongo</li>\n<li>windows下可以将MongoDB做成系统服务</li>\n</ol>\n<p>mac<br>\n临时添加环境变量：export PATH=/usr/local/mongodb/bin:<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mi mathvariant=\"normal\">编</mi><mi mathvariant=\"normal\">辑</mi><mtext> </mtext><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>h</mi><mi>p</mi></msub><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">添</mi><mi mathvariant=\"normal\">加</mi><mi mathvariant=\"normal\">：</mi><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">PATH\n编辑~/.bash_profile,添加：export PATH=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord cjk_fallback\">编</span><span class=\"mord cjk_fallback\">辑</span><span class=\"mspace nobreak\"> </span><span class=\"mord\">/</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">b</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">s</span><span class=\"mord\"><span class=\"mord mathdefault\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">添</span><span class=\"mord cjk_fallback\">加</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span></span></span>PATH:/usr/local/mongodb4/bin/:$PATH 即可永久添加环境变量</p>\n<p>连接MongoDB数据库：./mongo + 服务器IP:端口号/数据库名<br>\n关闭MongoDB服务在 ./mongo 进入控制台后，输入 use admin,然后输入 db.shutdownServer()</p>\n<p>Mongodb可以通过命令行方式和配置文件的方式来启动：<br>\n这两种方式都是在前台启动Mongodb进程，如果Session窗口关闭，Mongodb进程也随之停止。<br>\n不过Mongodb同时还提供了一种后台Daemon方式启动，只需要加上一个&quot;–fork&quot;参数即可，用到了&quot;–fork&quot;参数就必须启用&quot;–logpath&quot;参数<br>\n通过命令行： ./bin/mongod --dbpath=/data/db --fork --logpath=/data/logs/mongodb.log<br>\n配置文件方式：./bin/mongod -f mongodb.conf  或 ./bin/mongod --config mongodb.conf  //-f 后面写要使用的配置文件<br>\n./bin/mongod --shutdown -f mongod.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port=27017</span><br><span class=\"line\">dbpath=/usr/local/mongodb/data/</span><br><span class=\"line\">logpath=/usr/local/mongodb/log/mongodb.log  </span><br><span class=\"line\">fork = true</span><br></pre></td></tr></table></figure>\n<p>命令行操作：<br>\nuse mytetDB  //数据库如果不存在则创建<br>\nsave时如果给定了_ObjectId则更新创建整条记录；如果要更新部分字段则使用update方法使用$set<br>\ndb.dropDatabase()<br>\ndb//显示当前数据库<br>\nshow dbs<br>\nshow collections</p>\n<p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。<br>\nadmin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。<br>\nlocal: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合<br>\nconfig: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p>\n<p>MongoDB GridFS文件系统<br>\n分布式文件系统：将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点通过网络进行通信和数据传输</p>\n<p>当存储文档大于16M时，可以考虑使用GridFS<br>\nGridFS：是MongoDB制定的如何在数据库中存储大文件的规范，MongoDB并没有实现GridFS，而是交由客户端驱动程序实现<br>\nGridFS使用两个集合（collection）存储文件。一个集合是chunks, 用于存储文件内容的二进制数据；一个集合是files，用于存储文件的元数据。<br>\n使用fs.files存储文件的元数据，包含字段如下：<br>\n使用fs.chunks存储以255K进行分割的文件块，包含字段如下：<br>\nGridFS适用于如下场景：<br>\n存储用户产生的文件且文件数量比较大；需要文件的自动备份和分布式存储；需要访问文件的部分内容；存储16MB以上的文件<br>\nmongofiles是MongoDB安装包中提供的一个工具，专门用来存取文件，包括查询所有文件、查看文件、上传一个文件、获取一个文件、按照_id来获取文件、按文件名删除文件、按_id删除文件。<br>\nmongofiles --help其实有四个主要命令，分别为：<br>\nput —存储命令<br>\nget —获取命令<br>\nlist —列表命令<br>\ndelete —删除命令</p>\n<p>MongoDB聚合管道：聚合操作主要用户批量数据处理，往往将记录按条件分组，然后在每组上分别进行一系列操作，如：求和、求最大小值等<br>\n聚合操作能够对记录进行复杂处理，主要为数理统计和数据挖掘。<br>\nMongoDB提供了3种聚合操作方式：<br>\n聚合管道（Aggregation Pipeline）:MongoDB Shell使用db.collection.aggregate([{…}])来构建和使用聚合管道<br>\n$project:用于修改文档的结构，可以重命名、增加或删除文档字段<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>:</mo><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">于</mi><mi mathvariant=\"normal\">过</mi><mi mathvariant=\"normal\">滤</mi><mi mathvariant=\"normal\">文</mi><mi mathvariant=\"normal\">档</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">在</mi></mrow><annotation encoding=\"application/x-tex\">match:用于过滤文档，在</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">于</span><span class=\"mord cjk_fallback\">过</span><span class=\"mord cjk_fallback\">滤</span><span class=\"mord cjk_fallback\">文</span><span class=\"mord cjk_fallback\">档</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">在</span></span></span></span>match中不能使用$where,尽量出现在管道的前面，方便借助索引加快查询<br>\n$group:将集合中的文档进行分组，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理<br>\n$sort:将集合中的文档进行排序，此分组在内存中进行，最大100M，可通过allowDiskUse启用磁盘交换处理<br>\n$skip:跳过指定数量的文档<br>\n$unwind:将文档按照数组字段拆分成多条文档，每条文档包含数组的一个元素<br>\n$geoNear:按照由近到远顺序输出接近某一地理位置的文档<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mo>:</mo><mi mathvariant=\"normal\">将</mi><mi mathvariant=\"normal\">聚</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">结</mi><mi mathvariant=\"normal\">果</mi><mi mathvariant=\"normal\">存</mi><mi mathvariant=\"normal\">储</mi><mi mathvariant=\"normal\">到</mi><mi mathvariant=\"normal\">集</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">参</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">为</mi><mi mathvariant=\"normal\">集</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">称</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">聚</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">：</mi><mi mathvariant=\"normal\">阶</mi><mi mathvariant=\"normal\">段</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">符</mi><mi mathvariant=\"normal\">可</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">看</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">键</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">所</mi><mi mathvariant=\"normal\">对</mi><mi mathvariant=\"normal\">应</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">值</mi><mi mathvariant=\"normal\">&quot;</mi><mi mathvariant=\"normal\">称</mi><mi mathvariant=\"normal\">为</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">可</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">看</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">符</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">一</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">文</mi><mi mathvariant=\"normal\">档</mi><mi mathvariant=\"normal\">结</mi><mi mathvariant=\"normal\">构</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">由</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">段</mi><mi mathvariant=\"normal\">名</mi><mi mathvariant=\"normal\">、</mi><mi mathvariant=\"normal\">字</mi><mi mathvariant=\"normal\">段</mi><mi mathvariant=\"normal\">值</mi><mi mathvariant=\"normal\">和</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">达</mi><mi mathvariant=\"normal\">式</mi><mi mathvariant=\"normal\">操</mi><mi mathvariant=\"normal\">作</mi><mi mathvariant=\"normal\">符</mi><mi mathvariant=\"normal\">组</mi><mi mathvariant=\"normal\">成</mi><mi mathvariant=\"normal\">。</mi><mi mathvariant=\"normal\">聚</mi><mi mathvariant=\"normal\">合</mi><mi mathvariant=\"normal\">管</mi><mi mathvariant=\"normal\">道</mi><mi mathvariant=\"normal\">使</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">优</mi><mi mathvariant=\"normal\">化</mi><mi mathvariant=\"normal\">：</mi><mn>1</mn><mi mathvariant=\"normal\">将</mi></mrow><annotation encoding=\"application/x-tex\">out:将聚合结果存储到集合中，参数为集合名称\n    。。。\n    聚合管道表达式：阶段操作符可以看作是&quot;键&quot;，所对应的&quot;值&quot;称为管道表达式，管道表达式可以看作是管道操作符的操作数，管道表达式是一个文档结构，由字段名、字段值和表达式操作符组成。\n    聚合管道使用优化：\n    1将</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">将</span><span class=\"mord cjk_fallback\">聚</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">结</span><span class=\"mord cjk_fallback\">果</span><span class=\"mord cjk_fallback\">存</span><span class=\"mord cjk_fallback\">储</span><span class=\"mord cjk_fallback\">到</span><span class=\"mord cjk_fallback\">集</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord cjk_fallback\">集</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">称</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">聚</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">阶</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">可</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">看</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">键</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">对</span><span class=\"mord cjk_fallback\">应</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">值</span><span class=\"mord\">&quot;</span><span class=\"mord cjk_fallback\">称</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">可</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">看</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">文</span><span class=\"mord cjk_fallback\">档</span><span class=\"mord cjk_fallback\">结</span><span class=\"mord cjk_fallback\">构</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">由</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">名</span><span class=\"mord cjk_fallback\">、</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">值</span><span class=\"mord cjk_fallback\">和</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">达</span><span class=\"mord cjk_fallback\">式</span><span class=\"mord cjk_fallback\">操</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">成</span><span class=\"mord cjk_fallback\">。</span><span class=\"mord cjk_fallback\">聚</span><span class=\"mord cjk_fallback\">合</span><span class=\"mord cjk_fallback\">管</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">使</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">优</span><span class=\"mord cjk_fallback\">化</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">将</span></span></span></span>match、$sort放到管道开始阶段，有利于利用索引提高文档处理效率<br>\n2提交过滤可减少流经后续阶段的文档数量<br>\n聚合管道的限制：<br>\n1返回文档结果不能超过16M，可通过返回一个游标或存储到集合中跳过此限制<br>\n单目的聚合操作<br>\ncount<br>\ndistinct<br>\ngroup<br>\nMapReduce编程模型</p>\n<p>mongoimport可以导入集合</p>\n<p>MongoDB数据更新<br>\n文档插入和删除：insert、update、delete<br>\nBulk函数：Bulk可将多个数据更新操作放到一个待执行的列表中批量来执行，顺序执行的Bulk（按添加顺序执行，一个有问题则退出）和并执行的Bulk（随机方式并行）<br>\n1初始化Bulk：<br>\n并行：db.集合名.initializeUnorderedBulkOp()<br>\n顺序：db.集合名.initializeOrderedBulkOp()<br>\n2 bulk.inset({…})<br>\n3 bulk.execute()</p>\n<p>MMAPv1的内存分配策略：如果一个更新操作超过了文档在磁盘上预分配的空间，MongoDB会重新在磁盘上为其分配一块更大的连续空间。使用&quot;2的N次方&quot;的方式分配内存，如：32，64，128，256…2M，4M…<br>\n优点：1有利用内存的重用，降低系统碎片的数量；2减少数据移动频率，提高系统数据写效率</p>\n<p>文档修改<br>\nWriteResult = db.集合名.update(query,obj,upsert,multi)<br>\nquery:查询条件，相当于where<br>\nobj：更改的内容，相当于SQL中的set语句<br>\nupsert：当query的文档不存在时是否插入一条新文档<br>\nmulti：当query返回多个文档时是否一次更新满足条件的所有文档，默认只更新一条</p>\n<p>内嵌文档的修改：</p>\n<ol>\n<li>修改整个内嵌文档：{$set:{field1:新内嵌文档}}</li>\n<li>修改内嵌文档的某个字段：{$某个修改操作符:{field1.field2:value}}</li>\n</ol>\n<p>数组元素：MongoDB提供了大量的特定操作符，使得数组既可以作为栈、队列等有序对象使用，也可当作集合等无序对象来使用</p>\n<p>MongoDB的写安全机制<br>\n写过程：使用update、save等操作数据集合中数据时，只是修改了数据再内存中的映像，数据更新并没有同步地保存到磁盘上，而且更新内存中数据之前，更新操作会被记录到journal日志文件中，<br>\n每隔100ms将内存journal中的日志写到磁盘journal日志文件中 ，每隔60s将内存中修改的数据写会到磁盘上<br>\n写入安全级别：写入安全Write Concern是一种客户端设置的，用于控制写入安全级别的机制，通过写入安全机制可提高数据的可靠性。<br>\n分为四个级别，分别是：<br>\n非确认式写入Unacknowledged：写操作不会返回结果，所以无法知道是否写入成功；但速度快、效率高、无阻塞<br>\n确认式写入Acknowledged：写操作必须得到MongoDB服务器的写入确认，如果失败，会返回异常<br>\n日志写入Journaled：写操作要等到操作记录存储到Journal日志文件后才返回结果<br>\n复制集确认写入Replica Acknowledged：写操作不仅要得到主节点的写入确认，还要得到从节点的写入确认，可以设置写入节点的个数（包含主节点）</p>\n<p>journal日志相当于oracle中的redo日志文件，用户故障恢复和持久。Journal默认100ms刷新一次，所以最多丢失100ms数据<br>\n文件位于journal目录中，只能以追加方式添加数据，文件名以&quot;j._&quot;开头，超过1G会自动创建新的；数据库正常关闭时，数据库服务会自动清空journal目录下所有文件</p>\n<p>设置写安全操作级别，其实就是在写操作的性能和可靠性间取一个权衡；使用的写操作级别越高，时间越长，可靠性越高</p>\n<p>使用writeConcern函数作为更新函数的一个参数来设置写安全级别,如：db.集合名称.insert({name:“joe”},{writeConcern:{j:true}}),writeConcern函数参数如下：<br>\nw选项，可选择0，1，2等整数值及&quot;majority&quot;，0-非确认式写入 1-确认式写入（未启用复制集）／主节点确认式写入（启用了复制集），&gt;1只能用于复制集，2-数据至少写到1个从节点后返回，majority 只能用于复制集，表示更新操作用到大多数从节点<br>\nj选项，设置为true来使用journaled日志安全级别<br>\nwtimeout选项，用于设置超时单位为毫秒<br>\n以上选项可组合使用</p>\n<p>数据MongoDB数据查询<br>\nCursor = db.集合名称.find(query,fields,limit,skip)<br>\nquery:查询条件，相当于where<br>\nfields:用于字段映射，语法格式：{field:0}（0表示返回结果不包含此字段）或{field:1}（1表示返回结果不包含此字段），默认包含_id字段,相当于select中后面需要的字段<br>\nlimit：限制查询结果集的数量，指定查询返回结果的数量上限，也可通过limit()实现<br>\nskip:跳过一定数据量的结果，设置第一条返回文档的偏移量，也可通过skip()实现<br>\nfind查询只能正对一个集合；返回的集合默认是无序的</p>\n<p>db.集合名称.findOne()只返回第一条数据</p>\n<p>查询操作符<br>\n比较查询操作符<br>\n逻辑查询操作符<br>\n元素查询操作符<br>\n$where查询操作符：可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在js表达式和函数中，可使用this或obj来引用当前操作的文档，当js表达式或函数返回true时，才会返回当前文档</p>\n<p>内嵌文档与数组查询<br>\n内嵌文档查询<br>\n1查询整个内嵌文档：当内嵌文档的键值对数量和键值对顺序都相同时，才会匹配<br>\n2查询文档的某个字段：需要使用.号操作符，如:db.user.find({“address.city”:“BeiJing”})<br>\n数组查询<br>\n1查询整个数组：当数组元素内容和数组元素顺序都相同时，才会匹配<br>\n2查询数组中的元素（普通元素）：<br>\nA与位置无关，查询数组中含有某个值的文档，如：db.user.find({score:80})<br>\nB与位置有关，按照指定的数组索引查询数组元素的值，如：db.user.find({‘scores.2’:80})<br>\n3查询数组中的数组元素是文档时，查询数组元素有两种情况<br>\nA与位置无关，查询数组中满足条件的子文档元素，如：db.user.find(‘scores.成绩’：95)<br>\nB与位置有关，按照指定的数组索引查询数组子文档，如： db.user.find(‘scores.2.成绩’：95)</p>\n<p>MongoDB查询结果返回过程：find函数查询结果是以多条文档的形式分批来返回查询结果的，返回的文档会缓存到内存中，Cursor在一批数据回来之后遍历，下一批没来时会自动发起下一批请求，然后继续遍历</p>\n<p>MongoDB游标：用来遍历结果集中的数据。<br>\n游标的生命周期：创建、使用、销毁<br>\n游标可能会返回那些由于体积变大而被移动到集合末尾的文档而重复返回，可通过对查询快照的方式解决此问题，语法为：db.collection.find().snapshot().<br>\n使用快照之后，查询就会在_id索引上来遍历执行，这样就可以保证每个文档只被返回一次，从而保证获取结果的一致性。</p>\n<p>模糊查询：查询条件可以使用正则表达式实现模糊查询，支持正则表达式操作符和正则表达式对象两种。<br>\n正则表达式操作符：$regex</p>\n<p>findAndModify函数使用执行分为find和update两步，但可以保证操作的原子性</p>\n<p>MongoDB是为分布式存储而设计，_id主键默认使用ObjectId类型的值，比自增方式更适合分布式环境，所以MongoDB默认不支持字段自增长功能</p>\n<p>MongoDB索引：数据库索引是对数据表中一列或多列的值进行排序的一种数据结构，使用索引可快速访问数据表中的特定信息。MogonDB索引不仅提高文档查询速度，还有利于排序时节省内存资源。<br>\nMongoDB所有的索引信息被保存在system.indexes集合中，且默认总为_id创建单字段升序具有唯一属性的索引，可通过db.system.indexes.find()查看所有索引<br>\nMongoDB可在单个字段上建立索引，字段可以是普通字段、整个文档以及子文档的某个字段<br>\n对于复合索引，MongoDB支持前缀匹配<br>\n为确保查询只使用复合索引，可以使用映射来指定不要返回_id字段（除非它是复合索引的一部分）<br>\n多键索引：是对数组类型建立的索引，实际上是对数组的每个元素建立索引，而不是数组本身建立索引；当数组元素是文档时，可为文档的某个字段建立多键索引<br>\n哈希索引：只支持等值查询，不支持范围查询，主要用于分片的集合上，可以作为片键来使用，能将数据比较均匀的分散存储在各个分片上，如：db.集合名.createIndex({name:“hashed”})</p>\n<p>MongoDB索引的属性<br>\n唯一索引:可以确保集合的每一个文档的索引字段都有唯一的值，不会出现重复值，如：db.集合名.createIndex({name:1},{unique:true})，在非空集合创建唯一索引可能会因为已有重复值而失败，可添加dropBups:true删除重复文档<br>\n稀疏索引：只会为索引字段存在的文档建立索引，即使索引字段的值为null，但不会为索引字段不存在的文档建立索引<br>\nTTL(Time To Live)索引：为文档设置一个超时时间，当达到预设置的时间后，该文档会被数据库自动删除，但删除可能有延迟。这种类型的索引对缓存问题非常有用。只能建立在单独非_id字段<br>\n创建了TTL索引后，MongoDB会有一个后台线程来管理文档；在复制集上建立的TTL索引，TTL后台线程只会运行在主节点上</p>\n<p>MongoDB索引的管理<br>\n索引的默认命名规则：keyname1_dir1_keyname2_dir2…，其中keynameX是索引字段的名称，dirX是索引方向，1升序-1降序，也可自定义命名<br>\n创建索引：db.集合名.createIndex(keys,options),返回值为一个文档类型。索引一旦创建就不能修改，创建后可通过db.集合名.getIndexes()查看集合所拥有的索引，创建索引有两种方式：<br>\n1foreground:阻塞所有对数据库的读写请求，直到索引创建完成，为默认方式<br>\n2background：创建索引时，如果有新的数据库请求，创建过程会暂停<br>\n删除索引：db.集合.dropIndex(index)<br>\n查询优化器：用来优化查询过程，通过比较返回100条文档速度得到最佳查询计划<br>\nexplain函数：能够提供大量与查询有关的信息，可以很好的评估索引性能，帮助优化索引的使用策略。db.集合.find().explain(mode),支持3种模式：<br>\n1queryPlanner：查询计划，默认<br>\n2executionStatus：查询性能统计<br>\n3allPlansExecution：所有计划统计信息（最优与被拒绝的计划）<br>\nexplain返回结果使用由多个阶段（Stage）组成的树形结构来表示查询计划，查询计划自下而上执行，树的叶节点用来访问文档或索引，内部节点处理下层节点返回文档或索引，根节点输出查询结果<br>\nhint函数：强制MongoDB使用特定索引</p>\n<p>MongoDB特殊索引<br>\n地理空间索引：对地理位置数据建立索引，MongoDB支持两种2dsphere球面索引和平面2d索引<br>\n2dSphere球面索引<br>\n2d平面索引</p>\n<p>全文索引：又称为倒排索引，用于在大量文本中对每一个词组建立索引，指出该词在整段文本中出现的位置和次数，此技术主要用于搜索引擎和站内搜索等。<br>\n一个集合只能有一个全文索引</p>\n<p>java对mongodb的使用<br>\n集群搭建：mongodb分布式集群搭建手记</p>\n<p>学习：<a href=\"http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html</a></p>\n<p>分析没有默认的，因为你还没给root设置密码，第一个 user 是在 admin 组 ，所以他可以给 root 设置密码 , so<br>\nsudo passwd root</p>\n<p>Language Support</p>\n<p><a href=\"http://blog.csdn.net/sinat_35418761/article/details/53241481\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/sinat_35418761/article/details/53241481</a></p>\n<p><a href=\"http://www.2cto.com/database/201504/395442.html\" target=\"_blank\" rel=\"noopener\">http://www.2cto.com/database/201504/395442.html</a><br>\n<a href=\"http://www.myexception.cn/operating-system/1685604.html\" target=\"_blank\" rel=\"noopener\">http://www.myexception.cn/operating-system/1685604.html</a></p>\n<p><a href=\"https://my.oschina.net/chinacaptain/blog/465723\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/chinacaptain/blog/465723</a></p>\n<p><a href=\"http://api.mongodb.com/java/current/\" target=\"_blank\" rel=\"noopener\">http://api.mongodb.com/java/current/</a></p>\n<p>MongoDB是什么<br>\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>\n他的特点:高性能、易部署、易使用，存储数据非常方便。</p>\n<p>Bson：Binary Serialized Document Format，是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型</p>\n"},{"title":"docker","copyright":true,"comments":1,"toc":true,"date":"2018-10-18T01:38:59.000Z","password":null,"_content":"阿里云服务器购买\nhttp://www.runoob.com/docker/docker-tutorial.html\n\n\n官网：https://www.docker.com/\n中文社区：http://www.docker.org.cn/\n\nhttp://www.cnblogs.com/SzeCheng/p/6822905.html\n\nDocker是基于CS架构，系统有两个程序：docker服务端和docker客户端，是一种Linux容器管理技术 \n其中docker服务端是一个服务进程，管理着所有的容器。\ndocker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。\n大部分情况下，docker服务端和客户端运行在一台机器上。\n\nDocker为容器引入了镜像，使得容器可以从预先定义好的模版（images）创建出来，并且这个模版还是分层的\nDocker容器通过镜像启动，是镜像的启动和执行阶段，采用写时复制（copy on write）\n\nDocker容器的能力\n1文件系统隔离：每个容器都有自己的root文件系统\n2进程隔离：每个容器都运行在自己的进程环境中\n3网络隔离：容器间的虚拟网络接口和IP地址都是分开的\n4资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器\n\ndocker Client客户端————>向docker服务器进程发起请求，如:创建、停止、销毁容器等操作\ndocker Server服务器进程—–>处理所有docker的请求，管理所有容器\ndocker Registry镜像仓库——>镜像存放的中央仓库，可看作是存放二进制的软件配置管理（scm）\n\nhttps://www.cnblogs.com/atuotuo/p/6668233.html\n\n安装：下载安装完成之后docker version查看\n\nKitematic，\n\n\nVagrant+virtualbox\nhttps://www.vagrantup.com/\nhttps://www.virtualbox.org/\nhttps://app.vagrantup.com/boxes/search\n\nmkdir centos7\nls\nvagrant init centos/7\nvagrant up\nvagrant ssh\nsudo yum update\nexit\nvagrant status\nvagrant halt\nvagrant destroy\n\nDocker Machine\ndocker-machine ls\ndocker-machine ssh demo\n\n远程登录管理deocker和本地管理远程docker\nhttps://labs.play-with-docker.com/\n\n\ndocker提供了一个开发，打包，运行app的平台，把app和底层infratructure隔离开来\n\ndocker底层技术支持,依赖于Linux内核特性Namespaces和Cgroups\nNamespaces：做隔离pid，net，ipc，mnt，uts\nControl Groups：做资源限制\nUnion file Systems：Container和image的分层\n\nnamespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid\ncgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory\nunionfs，典型：aufs/overlayfs，分层镜像实现的基础\n\ndocker image：是容器的基石，本身为层叠的只读文件系统，\ndocker通过联合加载技术一次加载多个文件系统，从外部看，只能看到一个文件系统，包含所有文件系统的文件和目录。bootfs-rootfs(如：ubuntu)-apache。。。，rootfs称为基础镜像\n文件和meta data的集合（root filesystem）\n分层的，并且每一层都可以添加改变删除文件，成为一个新的image\n不同的image可以共享x相同的layer\nimage本身是read-only的\nsudo docker image ls\ndocker history [imageID]\n\nimage的获取\n1. 通过Dockerfile\n2. 从Registry获取，如：docker pull ubuntu:14.04，https://hub.docker.com/\n3. 命令行的格式为：docker search 镜像名字\n\nDIY一个Base Image\n\nContainer\ndocker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。\n\n通过Image创建\n在Image Layer之上建立一个container layer（可读写）\n类比面向对象：类和实例\nImage负责app的存储和分发，Container负责运行app\ncontainer id只要能够区分出来就行，不用全部输入\ndocker container ls //运行的\ndocker container ls -a  //所有的，包括退出的和正在运行的\n\ndocker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。\n\ndocker run [name]   //运行container\ndocker run -it [name]   //交互式运行container\n\n命令简写\ndocker container ls -a  == docker ps -a\ndocker container rm [conatinerID] == docker rm [conatinerID]\ndocker image ls == docker images\ndocker image rm [imageID] == docker rmi [imageID]\n\ndocker container ls -aq //列出所有conatinerID\n\n构建自己的docker镜像\ndocker commit [containerName] [dockerhubID/imageNewName]\n\n通过Dockerfile创建\n1. 新建空文件夹\n2. 创建Dockerfile文件 \n~~~\nFROM [BaseImageName]    //如果没有则值为scratch\nRUN yum install -y vim\n~~~\n3. docker build -t [dockerhubID/imageNewName] .   //.表示当前目录中查找Dockerfile\n4. docker image ls查看\n\nDockerfile语法梳理及最佳实践\n1. FROM:尽量使用官方的iamge作为base image\n2. LABEL:Metadata不可少，让大家了解到image的信息，相当于image的注释\n3. RUN:为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行\n4. WORKDIR:设定当前工作目录，如果没有则会自动创建目录；用WORKDIR，不要用RUN cd，尽量使用绝对目录\n5. ADD和COPY：把本地文件（构建目录中的相对地址 ）添加到image里面，同时ADD添加的文件如果是压缩文件的话，会自动解压缩，大部分情况COPY优于ADD，添加远程文件／目录请使用crul或wget；目标路径需指定docker中的绝对路径\n6. ENV：设置环境变量，尽量使用ENV增加可维护性\n \n\nhttps://github.com/docker-library/\n\nMAINTAINER：指定容器的相关维护信息，维护人、邮箱等\nRUN：执行命令并创建新的Image Layer，是在容器构建时执行\nCMD：设置容器启动后默认执行的命令和参数，是在容器运行时运行的.如果docker run指定了其他命令，CMD命令被忽略；如果定义了多个CMD，只会执行最后一个；也可以只提供参数，作为ENTRYPOINT的默认参数\nENTRYPOINT：设置容器启动时运行的命令，让容器以应用程序或者服务的形式执行；不会被忽略，一定会执行；最佳实践是写一个shell脚本作为entrypoint\nEXPOSE：指定运行该镜像的容器使用的端口，但此端口并未自动打开，在使用的时候需要映射／设置端口 \nVOLUME：用来向基于镜像创建的容器，一个卷是可以存在于一个或多个容器的特定目录，这个目录可以绕过联合文件系统提供共享数据、数据持久化功能\nWORKDIR：用于在容器内部设置工作目录，一般使用绝对路径，如果使用相对路径，路径会一致传递下去\nUSER：用来指定镜像被什么用户去运行，如果不设置，默认为root用户\nONBUILD：用来为镜像添加触发器，当一个镜像被其他镜像作为基础镜像执行时，此触发器会被执行\n\n使用中间层镜像进行调试，查找错误\ndocker build命令只删除了中间层常见的容器，但是没有删除中间层创建的镜像\n\n构建缓存：构建过程中会产生缓存，下次构建直接使用缓存镜像，如果不想使用构建缓存，则可通过：docker build --no-cache,或者通过dockerfile文件的ENV REFRESH_DATE修改日期，则本条语句后就不使用缓存了\n\ndocker history 镜像，用来查看镜像的构建过程\n~~~\nCOPY docker-entrypoint.sh /usr/local/bin/\nENTRYPOINT [\"docker-entrypoint.sh \"]\n~~~\nshell格式和EXEC格式 \n~~~ shell格式  \nRUN apt-get install -y vim\nCMD echo \"Hello Docker\"\nENTRYPOINT echo \"Hello Docker\"\n~~~\n\n~~~ exec格式\nRUN [\"apt-get\",\"install\",\"-y\",\"vim\"]\nCMD [\"/bin/echo\", \"Hello Docker\"]\nENTRYPOINT [\"/bin/echo\", \"Hello Docker\"]\n~~~\n\n登录dockerhub\ndocker login:  用户名（非邮箱）／密码\n1. 本地push上去，其他人就可以pull\n2. 关联github，github管理Dockerfile，有修改后自动build。Create-Create Automated build\n3. 通过docker的registry本地自己搭建。https://hub.docker.com/_/registry/,后期学习\n\n\nDockerfile实战\nDockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。\n不论是开发还是运维，学会编写Dockerfile几乎是必备的\n\n容器的操作\n//对容器执行命令\ndocker exec  \ndocker exec -it [containerID] /bin/bash\ndocker inspect [imageName] //查看\ndocker logs [containerID]\n\n\n前3章\n\n\nDocker常见命令\n容器相关操作\ndocker create # 创建一个容器但是不启动它\ndocker run # 创建并启动一个容器\ndocker stop # 停止容器运行，发送信号SIGTERM\ndocker start # 启动一个停止状态的容器\ndocker restart # 重启一个容器\ndocker rm # 删除一个容器\ndocker kill # 发送信号给容器，默认SIGKILL\ndocker attach # 连接(进入)到一个正在运行的容器\ndocker wait # 阻塞到一个容器，直到容器停止运行\n获取容器相关信息\ndocker ps # 显示状态为运行（Up）的容器\ndocker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)\ndocker inspect # 深入容器内部获取容器所有信息\ndocker logs # 查看容器的日志(stdout/stderr)\ndocker events # 得到docker服务器的实时的事件\ndocker port # 显示容器的端口映射\ndocker top # 显示容器的进程信息\ndocker diff # 显示容器文件系统的前后变化\n导出容器\ndocker cp # 从容器里向外拷贝文件或目录\ndocker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息\n执行\ndocker exec # 在容器里执行一个命令，可以执行bash进入交互式\n镜像操作\ndocker images # 显示本地所有的镜像列表\ndocker import # 从一个tar包创建一个镜像，往往和export结合使用\ndocker build # 使用Dockerfile创建镜像（推荐）\ndocker commit # 从容器创建镜像\ndocker rmi # 删除一个镜像\ndocker load # 从一个tar包创建一个镜像，和save配合使用\ndocker save # 将一个镜像保存为一个tar包，带layers和tag信息\ndocker history # 显示生成一个镜像的历史命令\ndocker tag # 为镜像起一个别名\n镜像仓库(registry)操作\ndocker login # 登录到一个registry\ndocker search # 从registry仓库搜索镜像\ndocker pull # 从仓库下载镜像到本地\ndocker push # 将一个镜像push到registry仓库中  \n\n\ndocker system df    //查看镜像、容器、数据卷所占用的空间\ndocker commit -m \"ubuntu with vim\" -a \"sgy\" aa97ba3292ce sgy/ubuntu:vim\n\n\n前后端分离部署及运维\n高性能高负载高可用\n\nhttps://www.renren.io  renren-fast\n\nSwagger:\nJWT:\n\n\nhttps://www.ghostcloud.cn/\n\n\n服务器虚拟化 （vsphere  cas  ZStack不通厂家命名）：裸机虚拟化、半裸机虚拟化\n网络虚拟化 SDN\n存储虚拟化 VSAN   服务器做raid保证系统安全，然后做存储虚拟化\n\nMac 上的 Docker 背后应该是一个 Linux 虚机，和 Windows 版本的 Docker 是一样的原理\n\n容器一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。\n\n容器不适合构建那种发布周期以周或月为单位的大型单一架构企业软件，容器适合采用微服务的方式，以及探索诸如持续部署这样的技术，使得我们能安全地在一天内多次更新生产环境。\n\nhttps://blog.csdn.net/xdy3008/article/details/74531125\n\nhttps://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004 \n\n\n想看到docker容器的ip地址，只需要安装net-tools就可以了：yum install net-tools -y\n\n\n\n\n\n如果你仅仅是想管理虚拟机，那么你应该使用vagrant。如果你想快速开发和部署应用，那么应该使用docker。\nvagrant是一款管理虚拟机的工具，而docker是一款通过将应用打包到轻量级容器，而实现构建和部署的工具。两者适用范围不同。一个容器就是一个包含了应用执行所依赖的数据(包括lib，配置文件等等)。它可以保证应用在一个可重复的环境中随时执行。\n\n\n\n数据卷：是经过特殊设计的目录，可以绕过联合文件系统ufs，为一个或多个容其提供访问。让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。\nDocker允许你定义应用部分和数据部分，并提供工具让你将他们分开。容器是短暂和一次性的。\ndocker run -v ~/container_data:/data:ro -it centos,映射本地~/container_data到容器/data下,且/data的权限为ro只读，登录进去后ls查看，发现会有data目录\n\n数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器。\ndocker run --volumes-from 数据卷容器名称\n即使删除了数据卷容器，挂载了数据卷容器的容器，仍然可以访问数据卷容器的目录，数据卷容器起的作用仅仅是将挂载配置传递到待挂载容器\n\nDocker数据卷的备份与还原：通过挂载目录压缩后放到挂载目录\n\nDocker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。\n\ndocker容器的网络连接\ndocker0：是Linux的虚拟网桥（网桥是数据链路层的一种设备），Linux的虚拟网桥可以设置IP地址，相当于拥有一个隐藏的虚拟网卡\ndocker0地址划分：IP127.17.42.1,掩码255.255.0.0,总共提供了65534个地址\n网桥操作需安装bridge-utils工具，安装之后brctl show查看网桥信息，可以添加网桥或者配置网桥信息\ndocker容器的IP地址在重启容器之后会变化，是不可靠的\n\n容器互联：在同一宿主机下，docker容器是通过虚拟网桥互相连接的，默认在同一宿主机下docker允许所有容器互联。让容器之间可以相互连接主要借用了一个link的功能。 在使用纯Docker时，被连接的容器必须在同一个Docker宿主机中。不同宿主机之间的容器如果想要连接，则需要借助Swarm或Kubernetes等编排工具。\n--link:链接容器，docker run -it --name cct3 --link=cct1:webtest bitchofgod/testnet （webtest为cct1的别名），然后在cct3中ping webtest即可互联\nDocker在父容器中的以下两个地方写入了连接信息：\n/etc/hosts文件中，--link在此文件中写入了映射信息，当docker重新启动的时候，docker会自动维护此文件中的映射 \n包含连接信息的环境变量中 \n如果拒绝所有容器互联，则修改docker配置，在/ect/default/docker文件中添加DOCKER_OPTS=\" --icc=false\"后重启docker服务即可\n如果需要特定容器互联，则通过--link、--icc=false、--iptables=true来实现\n\ndocker容器与外部网络的连接\nipforward\niptables\n\nCtrl+p，Ctrl+q退出交互界面\ndocker attach containerName重新打开交互界面\n\nCaaS(Container as a Service):镜像容器托管\n从Docker到Caas\n容器集群管理工具\n容器调度\n配置管理\n服务发现 \n日志／监控／报警\n\nLaaS（基础设施） 出租计算、存储、网络、DNS等基础IT服务\nPaaS（基础设施+系统平台—应用服务器应用框架 编程语言） 提供应用运行和开发环境 提供应用开发组件（邮件、消息、计费、支付）\nSaaS （基础设施+系统平台+软件应用）互联网Web2.0应用 企业应用（ERP/CRM等）\n\n\n通俗点讲\nSaaS：软件即服务，简单来说就是把企业想要的功能开发好成应用软件，然后直接卖给用户使用。通俗点讲就是去饭店吃饭一样，什么都是店家的。\nPaaS：平台即服务，简单来说就是云计算平台提供硬件、编程语言、开发库等帮助用户更好更快的开发软件。通俗来说就是点外卖，使用时店家的，但是餐桌是自己的。\nIaaS：基础设施即服务，简单来说就是云服务商提供企业所需要的服务器、存储、网络给企业用。通俗来说就是买菜买面，回家自己做饭。\n\n\nhttps://blog.csdn.net/weixin_38003389/article/details/84025762\n\nDocker Machine：目的是简化 Docker 的安装和远程管理,是官方提供的一个工具。 \n先创建Docker Machine机器\n\nDocker Compose：Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。\nDocker Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）\nCompose 中有两个重要的概念：\n项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。\n服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例\n运行 compose 项目：docker-compose up\n\nDocker Compose命令集\n管理镜像：build/pull\n管理服务：up/start/stop/kill/rm/scale\n服务状态：ps/logs/port\n一次性服务：run\n\nDocker Swarm:Docker集群管理工具，支持标准的Docker API,其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。\nSwarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。\n\nDocker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。\n\n三大主流调度框架：Swarm、Kubernetes和Mesos\n\nKubernetes：交互工具kubectl\npods：创建、调度及管理的最小单元，共存的一组容器的集合，同一pods中的容器共享pid、网络、ipc及utf命名空间和共享存储卷","source":"_posts/容器技术/2018-10-18-docker.md","raw":"---\ntitle: docker\ntags:\n  - docker\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-18 09:38:59\ncategories: docker\npassword:\n---\n阿里云服务器购买\nhttp://www.runoob.com/docker/docker-tutorial.html\n\n\n官网：https://www.docker.com/\n中文社区：http://www.docker.org.cn/\n\nhttp://www.cnblogs.com/SzeCheng/p/6822905.html\n\nDocker是基于CS架构，系统有两个程序：docker服务端和docker客户端，是一种Linux容器管理技术 \n其中docker服务端是一个服务进程，管理着所有的容器。\ndocker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。\n大部分情况下，docker服务端和客户端运行在一台机器上。\n\nDocker为容器引入了镜像，使得容器可以从预先定义好的模版（images）创建出来，并且这个模版还是分层的\nDocker容器通过镜像启动，是镜像的启动和执行阶段，采用写时复制（copy on write）\n\nDocker容器的能力\n1文件系统隔离：每个容器都有自己的root文件系统\n2进程隔离：每个容器都运行在自己的进程环境中\n3网络隔离：容器间的虚拟网络接口和IP地址都是分开的\n4资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器\n\ndocker Client客户端————>向docker服务器进程发起请求，如:创建、停止、销毁容器等操作\ndocker Server服务器进程—–>处理所有docker的请求，管理所有容器\ndocker Registry镜像仓库——>镜像存放的中央仓库，可看作是存放二进制的软件配置管理（scm）\n\nhttps://www.cnblogs.com/atuotuo/p/6668233.html\n\n安装：下载安装完成之后docker version查看\n\nKitematic，\n\n\nVagrant+virtualbox\nhttps://www.vagrantup.com/\nhttps://www.virtualbox.org/\nhttps://app.vagrantup.com/boxes/search\n\nmkdir centos7\nls\nvagrant init centos/7\nvagrant up\nvagrant ssh\nsudo yum update\nexit\nvagrant status\nvagrant halt\nvagrant destroy\n\nDocker Machine\ndocker-machine ls\ndocker-machine ssh demo\n\n远程登录管理deocker和本地管理远程docker\nhttps://labs.play-with-docker.com/\n\n\ndocker提供了一个开发，打包，运行app的平台，把app和底层infratructure隔离开来\n\ndocker底层技术支持,依赖于Linux内核特性Namespaces和Cgroups\nNamespaces：做隔离pid，net，ipc，mnt，uts\nControl Groups：做资源限制\nUnion file Systems：Container和image的分层\n\nnamespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid\ncgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory\nunionfs，典型：aufs/overlayfs，分层镜像实现的基础\n\ndocker image：是容器的基石，本身为层叠的只读文件系统，\ndocker通过联合加载技术一次加载多个文件系统，从外部看，只能看到一个文件系统，包含所有文件系统的文件和目录。bootfs-rootfs(如：ubuntu)-apache。。。，rootfs称为基础镜像\n文件和meta data的集合（root filesystem）\n分层的，并且每一层都可以添加改变删除文件，成为一个新的image\n不同的image可以共享x相同的layer\nimage本身是read-only的\nsudo docker image ls\ndocker history [imageID]\n\nimage的获取\n1. 通过Dockerfile\n2. 从Registry获取，如：docker pull ubuntu:14.04，https://hub.docker.com/\n3. 命令行的格式为：docker search 镜像名字\n\nDIY一个Base Image\n\nContainer\ndocker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。\n\n通过Image创建\n在Image Layer之上建立一个container layer（可读写）\n类比面向对象：类和实例\nImage负责app的存储和分发，Container负责运行app\ncontainer id只要能够区分出来就行，不用全部输入\ndocker container ls //运行的\ndocker container ls -a  //所有的，包括退出的和正在运行的\n\ndocker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。\n\ndocker run [name]   //运行container\ndocker run -it [name]   //交互式运行container\n\n命令简写\ndocker container ls -a  == docker ps -a\ndocker container rm [conatinerID] == docker rm [conatinerID]\ndocker image ls == docker images\ndocker image rm [imageID] == docker rmi [imageID]\n\ndocker container ls -aq //列出所有conatinerID\n\n构建自己的docker镜像\ndocker commit [containerName] [dockerhubID/imageNewName]\n\n通过Dockerfile创建\n1. 新建空文件夹\n2. 创建Dockerfile文件 \n~~~\nFROM [BaseImageName]    //如果没有则值为scratch\nRUN yum install -y vim\n~~~\n3. docker build -t [dockerhubID/imageNewName] .   //.表示当前目录中查找Dockerfile\n4. docker image ls查看\n\nDockerfile语法梳理及最佳实践\n1. FROM:尽量使用官方的iamge作为base image\n2. LABEL:Metadata不可少，让大家了解到image的信息，相当于image的注释\n3. RUN:为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行\n4. WORKDIR:设定当前工作目录，如果没有则会自动创建目录；用WORKDIR，不要用RUN cd，尽量使用绝对目录\n5. ADD和COPY：把本地文件（构建目录中的相对地址 ）添加到image里面，同时ADD添加的文件如果是压缩文件的话，会自动解压缩，大部分情况COPY优于ADD，添加远程文件／目录请使用crul或wget；目标路径需指定docker中的绝对路径\n6. ENV：设置环境变量，尽量使用ENV增加可维护性\n \n\nhttps://github.com/docker-library/\n\nMAINTAINER：指定容器的相关维护信息，维护人、邮箱等\nRUN：执行命令并创建新的Image Layer，是在容器构建时执行\nCMD：设置容器启动后默认执行的命令和参数，是在容器运行时运行的.如果docker run指定了其他命令，CMD命令被忽略；如果定义了多个CMD，只会执行最后一个；也可以只提供参数，作为ENTRYPOINT的默认参数\nENTRYPOINT：设置容器启动时运行的命令，让容器以应用程序或者服务的形式执行；不会被忽略，一定会执行；最佳实践是写一个shell脚本作为entrypoint\nEXPOSE：指定运行该镜像的容器使用的端口，但此端口并未自动打开，在使用的时候需要映射／设置端口 \nVOLUME：用来向基于镜像创建的容器，一个卷是可以存在于一个或多个容器的特定目录，这个目录可以绕过联合文件系统提供共享数据、数据持久化功能\nWORKDIR：用于在容器内部设置工作目录，一般使用绝对路径，如果使用相对路径，路径会一致传递下去\nUSER：用来指定镜像被什么用户去运行，如果不设置，默认为root用户\nONBUILD：用来为镜像添加触发器，当一个镜像被其他镜像作为基础镜像执行时，此触发器会被执行\n\n使用中间层镜像进行调试，查找错误\ndocker build命令只删除了中间层常见的容器，但是没有删除中间层创建的镜像\n\n构建缓存：构建过程中会产生缓存，下次构建直接使用缓存镜像，如果不想使用构建缓存，则可通过：docker build --no-cache,或者通过dockerfile文件的ENV REFRESH_DATE修改日期，则本条语句后就不使用缓存了\n\ndocker history 镜像，用来查看镜像的构建过程\n~~~\nCOPY docker-entrypoint.sh /usr/local/bin/\nENTRYPOINT [\"docker-entrypoint.sh \"]\n~~~\nshell格式和EXEC格式 \n~~~ shell格式  \nRUN apt-get install -y vim\nCMD echo \"Hello Docker\"\nENTRYPOINT echo \"Hello Docker\"\n~~~\n\n~~~ exec格式\nRUN [\"apt-get\",\"install\",\"-y\",\"vim\"]\nCMD [\"/bin/echo\", \"Hello Docker\"]\nENTRYPOINT [\"/bin/echo\", \"Hello Docker\"]\n~~~\n\n登录dockerhub\ndocker login:  用户名（非邮箱）／密码\n1. 本地push上去，其他人就可以pull\n2. 关联github，github管理Dockerfile，有修改后自动build。Create-Create Automated build\n3. 通过docker的registry本地自己搭建。https://hub.docker.com/_/registry/,后期学习\n\n\nDockerfile实战\nDockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。\n不论是开发还是运维，学会编写Dockerfile几乎是必备的\n\n容器的操作\n//对容器执行命令\ndocker exec  \ndocker exec -it [containerID] /bin/bash\ndocker inspect [imageName] //查看\ndocker logs [containerID]\n\n\n前3章\n\n\nDocker常见命令\n容器相关操作\ndocker create # 创建一个容器但是不启动它\ndocker run # 创建并启动一个容器\ndocker stop # 停止容器运行，发送信号SIGTERM\ndocker start # 启动一个停止状态的容器\ndocker restart # 重启一个容器\ndocker rm # 删除一个容器\ndocker kill # 发送信号给容器，默认SIGKILL\ndocker attach # 连接(进入)到一个正在运行的容器\ndocker wait # 阻塞到一个容器，直到容器停止运行\n获取容器相关信息\ndocker ps # 显示状态为运行（Up）的容器\ndocker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)\ndocker inspect # 深入容器内部获取容器所有信息\ndocker logs # 查看容器的日志(stdout/stderr)\ndocker events # 得到docker服务器的实时的事件\ndocker port # 显示容器的端口映射\ndocker top # 显示容器的进程信息\ndocker diff # 显示容器文件系统的前后变化\n导出容器\ndocker cp # 从容器里向外拷贝文件或目录\ndocker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息\n执行\ndocker exec # 在容器里执行一个命令，可以执行bash进入交互式\n镜像操作\ndocker images # 显示本地所有的镜像列表\ndocker import # 从一个tar包创建一个镜像，往往和export结合使用\ndocker build # 使用Dockerfile创建镜像（推荐）\ndocker commit # 从容器创建镜像\ndocker rmi # 删除一个镜像\ndocker load # 从一个tar包创建一个镜像，和save配合使用\ndocker save # 将一个镜像保存为一个tar包，带layers和tag信息\ndocker history # 显示生成一个镜像的历史命令\ndocker tag # 为镜像起一个别名\n镜像仓库(registry)操作\ndocker login # 登录到一个registry\ndocker search # 从registry仓库搜索镜像\ndocker pull # 从仓库下载镜像到本地\ndocker push # 将一个镜像push到registry仓库中  \n\n\ndocker system df    //查看镜像、容器、数据卷所占用的空间\ndocker commit -m \"ubuntu with vim\" -a \"sgy\" aa97ba3292ce sgy/ubuntu:vim\n\n\n前后端分离部署及运维\n高性能高负载高可用\n\nhttps://www.renren.io  renren-fast\n\nSwagger:\nJWT:\n\n\nhttps://www.ghostcloud.cn/\n\n\n服务器虚拟化 （vsphere  cas  ZStack不通厂家命名）：裸机虚拟化、半裸机虚拟化\n网络虚拟化 SDN\n存储虚拟化 VSAN   服务器做raid保证系统安全，然后做存储虚拟化\n\nMac 上的 Docker 背后应该是一个 Linux 虚机，和 Windows 版本的 Docker 是一样的原理\n\n容器一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。\n\n容器不适合构建那种发布周期以周或月为单位的大型单一架构企业软件，容器适合采用微服务的方式，以及探索诸如持续部署这样的技术，使得我们能安全地在一天内多次更新生产环境。\n\nhttps://blog.csdn.net/xdy3008/article/details/74531125\n\nhttps://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004 \n\n\n想看到docker容器的ip地址，只需要安装net-tools就可以了：yum install net-tools -y\n\n\n\n\n\n如果你仅仅是想管理虚拟机，那么你应该使用vagrant。如果你想快速开发和部署应用，那么应该使用docker。\nvagrant是一款管理虚拟机的工具，而docker是一款通过将应用打包到轻量级容器，而实现构建和部署的工具。两者适用范围不同。一个容器就是一个包含了应用执行所依赖的数据(包括lib，配置文件等等)。它可以保证应用在一个可重复的环境中随时执行。\n\n\n\n数据卷：是经过特殊设计的目录，可以绕过联合文件系统ufs，为一个或多个容其提供访问。让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。\nDocker允许你定义应用部分和数据部分，并提供工具让你将他们分开。容器是短暂和一次性的。\ndocker run -v ~/container_data:/data:ro -it centos,映射本地~/container_data到容器/data下,且/data的权限为ro只读，登录进去后ls查看，发现会有data目录\n\n数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器。\ndocker run --volumes-from 数据卷容器名称\n即使删除了数据卷容器，挂载了数据卷容器的容器，仍然可以访问数据卷容器的目录，数据卷容器起的作用仅仅是将挂载配置传递到待挂载容器\n\nDocker数据卷的备份与还原：通过挂载目录压缩后放到挂载目录\n\nDocker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。\n\ndocker容器的网络连接\ndocker0：是Linux的虚拟网桥（网桥是数据链路层的一种设备），Linux的虚拟网桥可以设置IP地址，相当于拥有一个隐藏的虚拟网卡\ndocker0地址划分：IP127.17.42.1,掩码255.255.0.0,总共提供了65534个地址\n网桥操作需安装bridge-utils工具，安装之后brctl show查看网桥信息，可以添加网桥或者配置网桥信息\ndocker容器的IP地址在重启容器之后会变化，是不可靠的\n\n容器互联：在同一宿主机下，docker容器是通过虚拟网桥互相连接的，默认在同一宿主机下docker允许所有容器互联。让容器之间可以相互连接主要借用了一个link的功能。 在使用纯Docker时，被连接的容器必须在同一个Docker宿主机中。不同宿主机之间的容器如果想要连接，则需要借助Swarm或Kubernetes等编排工具。\n--link:链接容器，docker run -it --name cct3 --link=cct1:webtest bitchofgod/testnet （webtest为cct1的别名），然后在cct3中ping webtest即可互联\nDocker在父容器中的以下两个地方写入了连接信息：\n/etc/hosts文件中，--link在此文件中写入了映射信息，当docker重新启动的时候，docker会自动维护此文件中的映射 \n包含连接信息的环境变量中 \n如果拒绝所有容器互联，则修改docker配置，在/ect/default/docker文件中添加DOCKER_OPTS=\" --icc=false\"后重启docker服务即可\n如果需要特定容器互联，则通过--link、--icc=false、--iptables=true来实现\n\ndocker容器与外部网络的连接\nipforward\niptables\n\nCtrl+p，Ctrl+q退出交互界面\ndocker attach containerName重新打开交互界面\n\nCaaS(Container as a Service):镜像容器托管\n从Docker到Caas\n容器集群管理工具\n容器调度\n配置管理\n服务发现 \n日志／监控／报警\n\nLaaS（基础设施） 出租计算、存储、网络、DNS等基础IT服务\nPaaS（基础设施+系统平台—应用服务器应用框架 编程语言） 提供应用运行和开发环境 提供应用开发组件（邮件、消息、计费、支付）\nSaaS （基础设施+系统平台+软件应用）互联网Web2.0应用 企业应用（ERP/CRM等）\n\n\n通俗点讲\nSaaS：软件即服务，简单来说就是把企业想要的功能开发好成应用软件，然后直接卖给用户使用。通俗点讲就是去饭店吃饭一样，什么都是店家的。\nPaaS：平台即服务，简单来说就是云计算平台提供硬件、编程语言、开发库等帮助用户更好更快的开发软件。通俗来说就是点外卖，使用时店家的，但是餐桌是自己的。\nIaaS：基础设施即服务，简单来说就是云服务商提供企业所需要的服务器、存储、网络给企业用。通俗来说就是买菜买面，回家自己做饭。\n\n\nhttps://blog.csdn.net/weixin_38003389/article/details/84025762\n\nDocker Machine：目的是简化 Docker 的安装和远程管理,是官方提供的一个工具。 \n先创建Docker Machine机器\n\nDocker Compose：Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。\nDocker Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）\nCompose 中有两个重要的概念：\n项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。\n服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例\n运行 compose 项目：docker-compose up\n\nDocker Compose命令集\n管理镜像：build/pull\n管理服务：up/start/stop/kill/rm/scale\n服务状态：ps/logs/port\n一次性服务：run\n\nDocker Swarm:Docker集群管理工具，支持标准的Docker API,其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。\nSwarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。\n\nDocker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。\n\n三大主流调度框架：Swarm、Kubernetes和Mesos\n\nKubernetes：交互工具kubectl\npods：创建、调度及管理的最小单元，共存的一组容器的集合，同一pods中的容器共享pid、网络、ipc及utf命名空间和共享存储卷","slug":"容器技术-2018-10-18-docker","published":1,"updated":"2019-01-10T16:04:42.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue5800em5b8h152wxm7w","content":"<p>阿里云服务器购买<br>\n<a href=\"http://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-tutorial.html</a></p>\n<p>官网：<a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\">https://www.docker.com/</a><br>\n中文社区：<a href=\"http://www.docker.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.docker.org.cn/</a></p>\n<p><a href=\"http://www.cnblogs.com/SzeCheng/p/6822905.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/SzeCheng/p/6822905.html</a></p>\n<p>Docker是基于CS架构，系统有两个程序：docker服务端和docker客户端，是一种Linux容器管理技术<br>\n其中docker服务端是一个服务进程，管理着所有的容器。<br>\ndocker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。<br>\n大部分情况下，docker服务端和客户端运行在一台机器上。</p>\n<p>Docker为容器引入了镜像，使得容器可以从预先定义好的模版（images）创建出来，并且这个模版还是分层的<br>\nDocker容器通过镜像启动，是镜像的启动和执行阶段，采用写时复制（copy on write）</p>\n<p>Docker容器的能力<br>\n1文件系统隔离：每个容器都有自己的root文件系统<br>\n2进程隔离：每个容器都运行在自己的进程环境中<br>\n3网络隔离：容器间的虚拟网络接口和IP地址都是分开的<br>\n4资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器</p>\n<p>docker Client客户端————&gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作<br>\ndocker Server服务器进程—–&gt;处理所有docker的请求，管理所有容器<br>\ndocker Registry镜像仓库——&gt;镜像存放的中央仓库，可看作是存放二进制的软件配置管理（scm）</p>\n<p><a href=\"https://www.cnblogs.com/atuotuo/p/6668233.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/atuotuo/p/6668233.html</a></p>\n<p>安装：下载安装完成之后docker version查看</p>\n<p>Kitematic，</p>\n<p>Vagrant+virtualbox<br>\n<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a><br>\n<a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/</a><br>\n<a href=\"https://app.vagrantup.com/boxes/search\" target=\"_blank\" rel=\"noopener\">https://app.vagrantup.com/boxes/search</a></p>\n<p>mkdir centos7<br>\nls<br>\nvagrant init centos/7<br>\nvagrant up<br>\nvagrant ssh<br>\nsudo yum update<br>\nexit<br>\nvagrant status<br>\nvagrant halt<br>\nvagrant destroy</p>\n<p>Docker Machine<br>\ndocker-machine ls<br>\ndocker-machine ssh demo</p>\n<p>远程登录管理deocker和本地管理远程docker<br>\n<a href=\"https://labs.play-with-docker.com/\" target=\"_blank\" rel=\"noopener\">https://labs.play-with-docker.com/</a></p>\n<p>docker提供了一个开发，打包，运行app的平台，把app和底层infratructure隔离开来</p>\n<p>docker底层技术支持,依赖于Linux内核特性Namespaces和Cgroups<br>\nNamespaces：做隔离pid，net，ipc，mnt，uts<br>\nControl Groups：做资源限制<br>\nUnion file Systems：Container和image的分层</p>\n<p>namespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid<br>\ncgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory<br>\nunionfs，典型：aufs/overlayfs，分层镜像实现的基础</p>\n<p>docker image：是容器的基石，本身为层叠的只读文件系统，<br>\ndocker通过联合加载技术一次加载多个文件系统，从外部看，只能看到一个文件系统，包含所有文件系统的文件和目录。bootfs-rootfs(如：ubuntu)-apache。。。，rootfs称为基础镜像<br>\n文件和meta data的集合（root filesystem）<br>\n分层的，并且每一层都可以添加改变删除文件，成为一个新的image<br>\n不同的image可以共享x相同的layer<br>\nimage本身是read-only的<br>\nsudo docker image ls<br>\ndocker history [imageID]</p>\n<p>image的获取</p>\n<ol>\n<li>通过Dockerfile</li>\n<li>从Registry获取，如：docker pull ubuntu:14.04，<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/</a></li>\n<li>命令行的格式为：docker search 镜像名字</li>\n</ol>\n<p>DIY一个Base Image</p>\n<p>Container<br>\ndocker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>\n<p>通过Image创建<br>\n在Image Layer之上建立一个container layer（可读写）<br>\n类比面向对象：类和实例<br>\nImage负责app的存储和分发，Container负责运行app<br>\ncontainer id只要能够区分出来就行，不用全部输入<br>\ndocker container ls //运行的<br>\ndocker container ls -a  //所有的，包括退出的和正在运行的</p>\n<p>docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。</p>\n<p>docker run [name]   //运行container<br>\ndocker run -it [name]   //交互式运行container</p>\n<p>命令简写<br>\ndocker container ls -a  == docker ps -a<br>\ndocker container rm [conatinerID] == docker rm [conatinerID]<br>\ndocker image ls == docker images<br>\ndocker image rm [imageID] == docker rmi [imageID]</p>\n<p>docker container ls -aq //列出所有conatinerID</p>\n<p>构建自己的docker镜像<br>\ndocker commit [containerName] [dockerhubID/imageNewName]</p>\n<p>通过Dockerfile创建</p>\n<ol>\n<li>新建空文件夹</li>\n<li>创建Dockerfile文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM [BaseImageName]    //如果没有则值为scratch</span><br><span class=\"line\">RUN yum install -y vim</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>docker build -t [dockerhubID/imageNewName] .   //.表示当前目录中查找Dockerfile</li>\n<li>docker image ls查看</li>\n</ol>\n<p>Dockerfile语法梳理及最佳实践</p>\n<ol>\n<li>FROM:尽量使用官方的iamge作为base image</li>\n<li>LABEL:Metadata不可少，让大家了解到image的信息，相当于image的注释</li>\n<li>RUN:为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行</li>\n<li>WORKDIR:设定当前工作目录，如果没有则会自动创建目录；用WORKDIR，不要用RUN cd，尽量使用绝对目录</li>\n<li>ADD和COPY：把本地文件（构建目录中的相对地址 ）添加到image里面，同时ADD添加的文件如果是压缩文件的话，会自动解压缩，大部分情况COPY优于ADD，添加远程文件／目录请使用crul或wget；目标路径需指定docker中的绝对路径</li>\n<li>ENV：设置环境变量，尽量使用ENV增加可维护性</li>\n</ol>\n<p><a href=\"https://github.com/docker-library/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker-library/</a></p>\n<p>MAINTAINER：指定容器的相关维护信息，维护人、邮箱等<br>\nRUN：执行命令并创建新的Image Layer，是在容器构建时执行<br>\nCMD：设置容器启动后默认执行的命令和参数，是在容器运行时运行的.如果docker run指定了其他命令，CMD命令被忽略；如果定义了多个CMD，只会执行最后一个；也可以只提供参数，作为ENTRYPOINT的默认参数<br>\nENTRYPOINT：设置容器启动时运行的命令，让容器以应用程序或者服务的形式执行；不会被忽略，一定会执行；最佳实践是写一个shell脚本作为entrypoint<br>\nEXPOSE：指定运行该镜像的容器使用的端口，但此端口并未自动打开，在使用的时候需要映射／设置端口<br>\nVOLUME：用来向基于镜像创建的容器，一个卷是可以存在于一个或多个容器的特定目录，这个目录可以绕过联合文件系统提供共享数据、数据持久化功能<br>\nWORKDIR：用于在容器内部设置工作目录，一般使用绝对路径，如果使用相对路径，路径会一致传递下去<br>\nUSER：用来指定镜像被什么用户去运行，如果不设置，默认为root用户<br>\nONBUILD：用来为镜像添加触发器，当一个镜像被其他镜像作为基础镜像执行时，此触发器会被执行</p>\n<p>使用中间层镜像进行调试，查找错误<br>\ndocker build命令只删除了中间层常见的容器，但是没有删除中间层创建的镜像</p>\n<p>构建缓存：构建过程中会产生缓存，下次构建直接使用缓存镜像，如果不想使用构建缓存，则可通过：docker build --no-cache,或者通过dockerfile文件的ENV REFRESH_DATE修改日期，则本条语句后就不使用缓存了</p>\n<p>docker history 镜像，用来查看镜像的构建过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY docker-entrypoint.sh /usr/local/bin/</span><br><span class=\"line\">ENTRYPOINT [&quot;docker-entrypoint.sh &quot;]</span><br></pre></td></tr></table></figure>\n<p>shell格式和EXEC格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN apt-get install -y vim</span><br><span class=\"line\">CMD echo &quot;Hello Docker&quot;</span><br><span class=\"line\">ENTRYPOINT echo &quot;Hello Docker&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]</span><br><span class=\"line\">CMD [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;]</span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;]</span><br></pre></td></tr></table></figure>\n<p>登录dockerhub<br>\ndocker login:  用户名（非邮箱）／密码</p>\n<ol>\n<li>本地push上去，其他人就可以pull</li>\n<li>关联github，github管理Dockerfile，有修改后自动build。Create-Create Automated build</li>\n<li>通过docker的registry本地自己搭建。<a href=\"https://hub.docker.com/_/registry/,%E5%90%8E%E6%9C%9F%E5%AD%A6%E4%B9%A0\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/registry/,后期学习</a></li>\n</ol>\n<p>Dockerfile实战<br>\nDockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。<br>\n不论是开发还是运维，学会编写Dockerfile几乎是必备的</p>\n<p>容器的操作<br>\n//对容器执行命令<br>\ndocker exec<br>\ndocker exec -it [containerID] /bin/bash<br>\ndocker inspect [imageName] //查看<br>\ndocker logs [containerID]</p>\n<p>前3章</p>\n<p>Docker常见命令<br>\n容器相关操作<br>\ndocker create # 创建一个容器但是不启动它<br>\ndocker run # 创建并启动一个容器<br>\ndocker stop # 停止容器运行，发送信号SIGTERM<br>\ndocker start # 启动一个停止状态的容器<br>\ndocker restart # 重启一个容器<br>\ndocker rm # 删除一个容器<br>\ndocker kill # 发送信号给容器，默认SIGKILL<br>\ndocker attach # 连接(进入)到一个正在运行的容器<br>\ndocker wait # 阻塞到一个容器，直到容器停止运行<br>\n获取容器相关信息<br>\ndocker ps # 显示状态为运行（Up）的容器<br>\ndocker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)<br>\ndocker inspect # 深入容器内部获取容器所有信息<br>\ndocker logs # 查看容器的日志(stdout/stderr)<br>\ndocker events # 得到docker服务器的实时的事件<br>\ndocker port # 显示容器的端口映射<br>\ndocker top # 显示容器的进程信息<br>\ndocker diff # 显示容器文件系统的前后变化<br>\n导出容器<br>\ndocker cp # 从容器里向外拷贝文件或目录<br>\ndocker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息<br>\n执行<br>\ndocker exec # 在容器里执行一个命令，可以执行bash进入交互式<br>\n镜像操作<br>\ndocker images # 显示本地所有的镜像列表<br>\ndocker import # 从一个tar包创建一个镜像，往往和export结合使用<br>\ndocker build # 使用Dockerfile创建镜像（推荐）<br>\ndocker commit # 从容器创建镜像<br>\ndocker rmi # 删除一个镜像<br>\ndocker load # 从一个tar包创建一个镜像，和save配合使用<br>\ndocker save # 将一个镜像保存为一个tar包，带layers和tag信息<br>\ndocker history # 显示生成一个镜像的历史命令<br>\ndocker tag # 为镜像起一个别名<br>\n镜像仓库(registry)操作<br>\ndocker login # 登录到一个registry<br>\ndocker search # 从registry仓库搜索镜像<br>\ndocker pull # 从仓库下载镜像到本地<br>\ndocker push # 将一个镜像push到registry仓库中</p>\n<p>docker system df    //查看镜像、容器、数据卷所占用的空间<br>\ndocker commit -m “ubuntu with vim” -a “sgy” aa97ba3292ce sgy/ubuntu:vim</p>\n<p>前后端分离部署及运维<br>\n高性能高负载高可用</p>\n<p><a href=\"https://www.renren.io\" target=\"_blank\" rel=\"noopener\">https://www.renren.io</a>  renren-fast</p>\n<p>Swagger:<br>\nJWT:</p>\n<p><a href=\"https://www.ghostcloud.cn/\" target=\"_blank\" rel=\"noopener\">https://www.ghostcloud.cn/</a></p>\n<p>服务器虚拟化 （vsphere  cas  ZStack不通厂家命名）：裸机虚拟化、半裸机虚拟化<br>\n网络虚拟化 SDN<br>\n存储虚拟化 VSAN   服务器做raid保证系统安全，然后做存储虚拟化</p>\n<p>Mac 上的 Docker 背后应该是一个 Linux 虚机，和 Windows 版本的 Docker 是一样的原理</p>\n<p>容器一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。</p>\n<p>容器不适合构建那种发布周期以周或月为单位的大型单一架构企业软件，容器适合采用微服务的方式，以及探索诸如持续部署这样的技术，使得我们能安全地在一天内多次更新生产环境。</p>\n<p><a href=\"https://blog.csdn.net/xdy3008/article/details/74531125\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xdy3008/article/details/74531125</a></p>\n<p><a href=\"https://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004\" target=\"_blank\" rel=\"noopener\">https://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004</a></p>\n<p>想看到docker容器的ip地址，只需要安装net-tools就可以了：yum install net-tools -y</p>\n<p>如果你仅仅是想管理虚拟机，那么你应该使用vagrant。如果你想快速开发和部署应用，那么应该使用docker。<br>\nvagrant是一款管理虚拟机的工具，而docker是一款通过将应用打包到轻量级容器，而实现构建和部署的工具。两者适用范围不同。一个容器就是一个包含了应用执行所依赖的数据(包括lib，配置文件等等)。它可以保证应用在一个可重复的环境中随时执行。</p>\n<p>数据卷：是经过特殊设计的目录，可以绕过联合文件系统ufs，为一个或多个容其提供访问。让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。<br>\nDocker允许你定义应用部分和数据部分，并提供工具让你将他们分开。容器是短暂和一次性的。<br>\ndocker run -v ~/container_data:/data:ro -it centos,映射本地~/container_data到容器/data下,且/data的权限为ro只读，登录进去后ls查看，发现会有data目录</p>\n<p>数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器。<br>\ndocker run --volumes-from 数据卷容器名称<br>\n即使删除了数据卷容器，挂载了数据卷容器的容器，仍然可以访问数据卷容器的目录，数据卷容器起的作用仅仅是将挂载配置传递到待挂载容器</p>\n<p>Docker数据卷的备份与还原：通过挂载目录压缩后放到挂载目录</p>\n<p>Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。</p>\n<p>docker容器的网络连接<br>\ndocker0：是Linux的虚拟网桥（网桥是数据链路层的一种设备），Linux的虚拟网桥可以设置IP地址，相当于拥有一个隐藏的虚拟网卡<br>\ndocker0地址划分：IP127.17.42.1,掩码255.255.0.0,总共提供了65534个地址<br>\n网桥操作需安装bridge-utils工具，安装之后brctl show查看网桥信息，可以添加网桥或者配置网桥信息<br>\ndocker容器的IP地址在重启容器之后会变化，是不可靠的</p>\n<p>容器互联：在同一宿主机下，docker容器是通过虚拟网桥互相连接的，默认在同一宿主机下docker允许所有容器互联。让容器之间可以相互连接主要借用了一个link的功能。 在使用纯Docker时，被连接的容器必须在同一个Docker宿主机中。不同宿主机之间的容器如果想要连接，则需要借助Swarm或Kubernetes等编排工具。<br>\n–link:链接容器，docker run -it --name cct3 --link=cct1:webtest bitchofgod/testnet （webtest为cct1的别名），然后在cct3中ping webtest即可互联<br>\nDocker在父容器中的以下两个地方写入了连接信息：<br>\n/etc/hosts文件中，–link在此文件中写入了映射信息，当docker重新启动的时候，docker会自动维护此文件中的映射<br>\n包含连接信息的环境变量中<br>\n如果拒绝所有容器互联，则修改docker配置，在/ect/default/docker文件中添加DOCKER_OPTS=&quot; --icc=false&quot;后重启docker服务即可<br>\n如果需要特定容器互联，则通过–link、–icc=false、–iptables=true来实现</p>\n<p>docker容器与外部网络的连接<br>\nipforward<br>\niptables</p>\n<p>Ctrl+p，Ctrl+q退出交互界面<br>\ndocker attach containerName重新打开交互界面</p>\n<p>CaaS(Container as a Service):镜像容器托管<br>\n从Docker到Caas<br>\n容器集群管理工具<br>\n容器调度<br>\n配置管理<br>\n服务发现<br>\n日志／监控／报警</p>\n<p>LaaS（基础设施） 出租计算、存储、网络、DNS等基础IT服务<br>\nPaaS（基础设施+系统平台—应用服务器应用框架 编程语言） 提供应用运行和开发环境 提供应用开发组件（邮件、消息、计费、支付）<br>\nSaaS （基础设施+系统平台+软件应用）互联网Web2.0应用 企业应用（ERP/CRM等）</p>\n<p>通俗点讲<br>\nSaaS：软件即服务，简单来说就是把企业想要的功能开发好成应用软件，然后直接卖给用户使用。通俗点讲就是去饭店吃饭一样，什么都是店家的。<br>\nPaaS：平台即服务，简单来说就是云计算平台提供硬件、编程语言、开发库等帮助用户更好更快的开发软件。通俗来说就是点外卖，使用时店家的，但是餐桌是自己的。<br>\nIaaS：基础设施即服务，简单来说就是云服务商提供企业所需要的服务器、存储、网络给企业用。通俗来说就是买菜买面，回家自己做饭。</p>\n<p><a href=\"https://blog.csdn.net/weixin_38003389/article/details/84025762\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_38003389/article/details/84025762</a></p>\n<p>Docker Machine：目的是简化 Docker 的安装和远程管理,是官方提供的一个工具。<br>\n先创建Docker Machine机器</p>\n<p>Docker Compose：Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。<br>\nDocker Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）<br>\nCompose 中有两个重要的概念：<br>\n项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。<br>\n服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例<br>\n运行 compose 项目：docker-compose up</p>\n<p>Docker Compose命令集<br>\n管理镜像：build/pull<br>\n管理服务：up/start/stop/kill/rm/scale<br>\n服务状态：ps/logs/port<br>\n一次性服务：run</p>\n<p>Docker Swarm:Docker集群管理工具，支持标准的Docker API,其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。<br>\nSwarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。</p>\n<p>Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p>\n<p>三大主流调度框架：Swarm、Kubernetes和Mesos</p>\n<p>Kubernetes：交互工具kubectl<br>\npods：创建、调度及管理的最小单元，共存的一组容器的集合，同一pods中的容器共享pid、网络、ipc及utf命名空间和共享存储卷</p>\n","site":{"data":{}},"excerpt":"","more":"<p>阿里云服务器购买<br>\n<a href=\"http://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-tutorial.html</a></p>\n<p>官网：<a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\">https://www.docker.com/</a><br>\n中文社区：<a href=\"http://www.docker.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.docker.org.cn/</a></p>\n<p><a href=\"http://www.cnblogs.com/SzeCheng/p/6822905.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/SzeCheng/p/6822905.html</a></p>\n<p>Docker是基于CS架构，系统有两个程序：docker服务端和docker客户端，是一种Linux容器管理技术<br>\n其中docker服务端是一个服务进程，管理着所有的容器。<br>\ndocker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。<br>\n大部分情况下，docker服务端和客户端运行在一台机器上。</p>\n<p>Docker为容器引入了镜像，使得容器可以从预先定义好的模版（images）创建出来，并且这个模版还是分层的<br>\nDocker容器通过镜像启动，是镜像的启动和执行阶段，采用写时复制（copy on write）</p>\n<p>Docker容器的能力<br>\n1文件系统隔离：每个容器都有自己的root文件系统<br>\n2进程隔离：每个容器都运行在自己的进程环境中<br>\n3网络隔离：容器间的虚拟网络接口和IP地址都是分开的<br>\n4资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器</p>\n<p>docker Client客户端————&gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作<br>\ndocker Server服务器进程—–&gt;处理所有docker的请求，管理所有容器<br>\ndocker Registry镜像仓库——&gt;镜像存放的中央仓库，可看作是存放二进制的软件配置管理（scm）</p>\n<p><a href=\"https://www.cnblogs.com/atuotuo/p/6668233.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/atuotuo/p/6668233.html</a></p>\n<p>安装：下载安装完成之后docker version查看</p>\n<p>Kitematic，</p>\n<p>Vagrant+virtualbox<br>\n<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a><br>\n<a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/</a><br>\n<a href=\"https://app.vagrantup.com/boxes/search\" target=\"_blank\" rel=\"noopener\">https://app.vagrantup.com/boxes/search</a></p>\n<p>mkdir centos7<br>\nls<br>\nvagrant init centos/7<br>\nvagrant up<br>\nvagrant ssh<br>\nsudo yum update<br>\nexit<br>\nvagrant status<br>\nvagrant halt<br>\nvagrant destroy</p>\n<p>Docker Machine<br>\ndocker-machine ls<br>\ndocker-machine ssh demo</p>\n<p>远程登录管理deocker和本地管理远程docker<br>\n<a href=\"https://labs.play-with-docker.com/\" target=\"_blank\" rel=\"noopener\">https://labs.play-with-docker.com/</a></p>\n<p>docker提供了一个开发，打包，运行app的平台，把app和底层infratructure隔离开来</p>\n<p>docker底层技术支持,依赖于Linux内核特性Namespaces和Cgroups<br>\nNamespaces：做隔离pid，net，ipc，mnt，uts<br>\nControl Groups：做资源限制<br>\nUnion file Systems：Container和image的分层</p>\n<p>namespace，容器隔离的基础，保证A容器看不到B容器. 6个名空间：User,Mnt,Network,UTS,IPC,Pid<br>\ncgroups，容器资源统计和隔离。主要用到的cgroups子系统：cpu,blkio,device,freezer,memory<br>\nunionfs，典型：aufs/overlayfs，分层镜像实现的基础</p>\n<p>docker image：是容器的基石，本身为层叠的只读文件系统，<br>\ndocker通过联合加载技术一次加载多个文件系统，从外部看，只能看到一个文件系统，包含所有文件系统的文件和目录。bootfs-rootfs(如：ubuntu)-apache。。。，rootfs称为基础镜像<br>\n文件和meta data的集合（root filesystem）<br>\n分层的，并且每一层都可以添加改变删除文件，成为一个新的image<br>\n不同的image可以共享x相同的layer<br>\nimage本身是read-only的<br>\nsudo docker image ls<br>\ndocker history [imageID]</p>\n<p>image的获取</p>\n<ol>\n<li>通过Dockerfile</li>\n<li>从Registry获取，如：docker pull ubuntu:14.04，<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/</a></li>\n<li>命令行的格式为：docker search 镜像名字</li>\n</ol>\n<p>DIY一个Base Image</p>\n<p>Container<br>\ndocker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>\n<p>通过Image创建<br>\n在Image Layer之上建立一个container layer（可读写）<br>\n类比面向对象：类和实例<br>\nImage负责app的存储和分发，Container负责运行app<br>\ncontainer id只要能够区分出来就行，不用全部输入<br>\ndocker container ls //运行的<br>\ndocker container ls -a  //所有的，包括退出的和正在运行的</p>\n<p>docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。</p>\n<p>docker run [name]   //运行container<br>\ndocker run -it [name]   //交互式运行container</p>\n<p>命令简写<br>\ndocker container ls -a  == docker ps -a<br>\ndocker container rm [conatinerID] == docker rm [conatinerID]<br>\ndocker image ls == docker images<br>\ndocker image rm [imageID] == docker rmi [imageID]</p>\n<p>docker container ls -aq //列出所有conatinerID</p>\n<p>构建自己的docker镜像<br>\ndocker commit [containerName] [dockerhubID/imageNewName]</p>\n<p>通过Dockerfile创建</p>\n<ol>\n<li>新建空文件夹</li>\n<li>创建Dockerfile文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM [BaseImageName]    //如果没有则值为scratch</span><br><span class=\"line\">RUN yum install -y vim</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>docker build -t [dockerhubID/imageNewName] .   //.表示当前目录中查找Dockerfile</li>\n<li>docker image ls查看</li>\n</ol>\n<p>Dockerfile语法梳理及最佳实践</p>\n<ol>\n<li>FROM:尽量使用官方的iamge作为base image</li>\n<li>LABEL:Metadata不可少，让大家了解到image的信息，相当于image的注释</li>\n<li>RUN:为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行</li>\n<li>WORKDIR:设定当前工作目录，如果没有则会自动创建目录；用WORKDIR，不要用RUN cd，尽量使用绝对目录</li>\n<li>ADD和COPY：把本地文件（构建目录中的相对地址 ）添加到image里面，同时ADD添加的文件如果是压缩文件的话，会自动解压缩，大部分情况COPY优于ADD，添加远程文件／目录请使用crul或wget；目标路径需指定docker中的绝对路径</li>\n<li>ENV：设置环境变量，尽量使用ENV增加可维护性</li>\n</ol>\n<p><a href=\"https://github.com/docker-library/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker-library/</a></p>\n<p>MAINTAINER：指定容器的相关维护信息，维护人、邮箱等<br>\nRUN：执行命令并创建新的Image Layer，是在容器构建时执行<br>\nCMD：设置容器启动后默认执行的命令和参数，是在容器运行时运行的.如果docker run指定了其他命令，CMD命令被忽略；如果定义了多个CMD，只会执行最后一个；也可以只提供参数，作为ENTRYPOINT的默认参数<br>\nENTRYPOINT：设置容器启动时运行的命令，让容器以应用程序或者服务的形式执行；不会被忽略，一定会执行；最佳实践是写一个shell脚本作为entrypoint<br>\nEXPOSE：指定运行该镜像的容器使用的端口，但此端口并未自动打开，在使用的时候需要映射／设置端口<br>\nVOLUME：用来向基于镜像创建的容器，一个卷是可以存在于一个或多个容器的特定目录，这个目录可以绕过联合文件系统提供共享数据、数据持久化功能<br>\nWORKDIR：用于在容器内部设置工作目录，一般使用绝对路径，如果使用相对路径，路径会一致传递下去<br>\nUSER：用来指定镜像被什么用户去运行，如果不设置，默认为root用户<br>\nONBUILD：用来为镜像添加触发器，当一个镜像被其他镜像作为基础镜像执行时，此触发器会被执行</p>\n<p>使用中间层镜像进行调试，查找错误<br>\ndocker build命令只删除了中间层常见的容器，但是没有删除中间层创建的镜像</p>\n<p>构建缓存：构建过程中会产生缓存，下次构建直接使用缓存镜像，如果不想使用构建缓存，则可通过：docker build --no-cache,或者通过dockerfile文件的ENV REFRESH_DATE修改日期，则本条语句后就不使用缓存了</p>\n<p>docker history 镜像，用来查看镜像的构建过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY docker-entrypoint.sh /usr/local/bin/</span><br><span class=\"line\">ENTRYPOINT [&quot;docker-entrypoint.sh &quot;]</span><br></pre></td></tr></table></figure>\n<p>shell格式和EXEC格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN apt-get install -y vim</span><br><span class=\"line\">CMD echo &quot;Hello Docker&quot;</span><br><span class=\"line\">ENTRYPOINT echo &quot;Hello Docker&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]</span><br><span class=\"line\">CMD [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;]</span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello Docker&quot;]</span><br></pre></td></tr></table></figure>\n<p>登录dockerhub<br>\ndocker login:  用户名（非邮箱）／密码</p>\n<ol>\n<li>本地push上去，其他人就可以pull</li>\n<li>关联github，github管理Dockerfile，有修改后自动build。Create-Create Automated build</li>\n<li>通过docker的registry本地自己搭建。<a href=\"https://hub.docker.com/_/registry/,%E5%90%8E%E6%9C%9F%E5%AD%A6%E4%B9%A0\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/registry/,后期学习</a></li>\n</ol>\n<p>Dockerfile实战<br>\nDockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。<br>\n不论是开发还是运维，学会编写Dockerfile几乎是必备的</p>\n<p>容器的操作<br>\n//对容器执行命令<br>\ndocker exec<br>\ndocker exec -it [containerID] /bin/bash<br>\ndocker inspect [imageName] //查看<br>\ndocker logs [containerID]</p>\n<p>前3章</p>\n<p>Docker常见命令<br>\n容器相关操作<br>\ndocker create # 创建一个容器但是不启动它<br>\ndocker run # 创建并启动一个容器<br>\ndocker stop # 停止容器运行，发送信号SIGTERM<br>\ndocker start # 启动一个停止状态的容器<br>\ndocker restart # 重启一个容器<br>\ndocker rm # 删除一个容器<br>\ndocker kill # 发送信号给容器，默认SIGKILL<br>\ndocker attach # 连接(进入)到一个正在运行的容器<br>\ndocker wait # 阻塞到一个容器，直到容器停止运行<br>\n获取容器相关信息<br>\ndocker ps # 显示状态为运行（Up）的容器<br>\ndocker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)<br>\ndocker inspect # 深入容器内部获取容器所有信息<br>\ndocker logs # 查看容器的日志(stdout/stderr)<br>\ndocker events # 得到docker服务器的实时的事件<br>\ndocker port # 显示容器的端口映射<br>\ndocker top # 显示容器的进程信息<br>\ndocker diff # 显示容器文件系统的前后变化<br>\n导出容器<br>\ndocker cp # 从容器里向外拷贝文件或目录<br>\ndocker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息<br>\n执行<br>\ndocker exec # 在容器里执行一个命令，可以执行bash进入交互式<br>\n镜像操作<br>\ndocker images # 显示本地所有的镜像列表<br>\ndocker import # 从一个tar包创建一个镜像，往往和export结合使用<br>\ndocker build # 使用Dockerfile创建镜像（推荐）<br>\ndocker commit # 从容器创建镜像<br>\ndocker rmi # 删除一个镜像<br>\ndocker load # 从一个tar包创建一个镜像，和save配合使用<br>\ndocker save # 将一个镜像保存为一个tar包，带layers和tag信息<br>\ndocker history # 显示生成一个镜像的历史命令<br>\ndocker tag # 为镜像起一个别名<br>\n镜像仓库(registry)操作<br>\ndocker login # 登录到一个registry<br>\ndocker search # 从registry仓库搜索镜像<br>\ndocker pull # 从仓库下载镜像到本地<br>\ndocker push # 将一个镜像push到registry仓库中</p>\n<p>docker system df    //查看镜像、容器、数据卷所占用的空间<br>\ndocker commit -m “ubuntu with vim” -a “sgy” aa97ba3292ce sgy/ubuntu:vim</p>\n<p>前后端分离部署及运维<br>\n高性能高负载高可用</p>\n<p><a href=\"https://www.renren.io\" target=\"_blank\" rel=\"noopener\">https://www.renren.io</a>  renren-fast</p>\n<p>Swagger:<br>\nJWT:</p>\n<p><a href=\"https://www.ghostcloud.cn/\" target=\"_blank\" rel=\"noopener\">https://www.ghostcloud.cn/</a></p>\n<p>服务器虚拟化 （vsphere  cas  ZStack不通厂家命名）：裸机虚拟化、半裸机虚拟化<br>\n网络虚拟化 SDN<br>\n存储虚拟化 VSAN   服务器做raid保证系统安全，然后做存储虚拟化</p>\n<p>Mac 上的 Docker 背后应该是一个 Linux 虚机，和 Windows 版本的 Docker 是一样的原理</p>\n<p>容器一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。</p>\n<p>容器不适合构建那种发布周期以周或月为单位的大型单一架构企业软件，容器适合采用微服务的方式，以及探索诸如持续部署这样的技术，使得我们能安全地在一天内多次更新生产环境。</p>\n<p><a href=\"https://blog.csdn.net/xdy3008/article/details/74531125\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xdy3008/article/details/74531125</a></p>\n<p><a href=\"https://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004\" target=\"_blank\" rel=\"noopener\">https://www.missshi.cn/api/view/blog/5a6327c00a745f6335000004</a></p>\n<p>想看到docker容器的ip地址，只需要安装net-tools就可以了：yum install net-tools -y</p>\n<p>如果你仅仅是想管理虚拟机，那么你应该使用vagrant。如果你想快速开发和部署应用，那么应该使用docker。<br>\nvagrant是一款管理虚拟机的工具，而docker是一款通过将应用打包到轻量级容器，而实现构建和部署的工具。两者适用范围不同。一个容器就是一个包含了应用执行所依赖的数据(包括lib，配置文件等等)。它可以保证应用在一个可重复的环境中随时执行。</p>\n<p>数据卷：是经过特殊设计的目录，可以绕过联合文件系统ufs，为一个或多个容其提供访问。让你可以不受容器生命周期影响进行数据持久化。它们表现为容器内的空间，但实际保存在容器之外，从而允许你在不影响数据的情况下销毁、重建、修改、丢弃容器。<br>\nDocker允许你定义应用部分和数据部分，并提供工具让你将他们分开。容器是短暂和一次性的。<br>\ndocker run -v ~/container_data:/data:ro -it centos,映射本地~/container_data到容器/data下,且/data的权限为ro只读，登录进去后ls查看，发现会有data目录</p>\n<p>数据卷容器：命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器。<br>\ndocker run --volumes-from 数据卷容器名称<br>\n即使删除了数据卷容器，挂载了数据卷容器的容器，仍然可以访问数据卷容器的目录，数据卷容器起的作用仅仅是将挂载配置传递到待挂载容器</p>\n<p>Docker数据卷的备份与还原：通过挂载目录压缩后放到挂载目录</p>\n<p>Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。</p>\n<p>docker容器的网络连接<br>\ndocker0：是Linux的虚拟网桥（网桥是数据链路层的一种设备），Linux的虚拟网桥可以设置IP地址，相当于拥有一个隐藏的虚拟网卡<br>\ndocker0地址划分：IP127.17.42.1,掩码255.255.0.0,总共提供了65534个地址<br>\n网桥操作需安装bridge-utils工具，安装之后brctl show查看网桥信息，可以添加网桥或者配置网桥信息<br>\ndocker容器的IP地址在重启容器之后会变化，是不可靠的</p>\n<p>容器互联：在同一宿主机下，docker容器是通过虚拟网桥互相连接的，默认在同一宿主机下docker允许所有容器互联。让容器之间可以相互连接主要借用了一个link的功能。 在使用纯Docker时，被连接的容器必须在同一个Docker宿主机中。不同宿主机之间的容器如果想要连接，则需要借助Swarm或Kubernetes等编排工具。<br>\n–link:链接容器，docker run -it --name cct3 --link=cct1:webtest bitchofgod/testnet （webtest为cct1的别名），然后在cct3中ping webtest即可互联<br>\nDocker在父容器中的以下两个地方写入了连接信息：<br>\n/etc/hosts文件中，–link在此文件中写入了映射信息，当docker重新启动的时候，docker会自动维护此文件中的映射<br>\n包含连接信息的环境变量中<br>\n如果拒绝所有容器互联，则修改docker配置，在/ect/default/docker文件中添加DOCKER_OPTS=&quot; --icc=false&quot;后重启docker服务即可<br>\n如果需要特定容器互联，则通过–link、–icc=false、–iptables=true来实现</p>\n<p>docker容器与外部网络的连接<br>\nipforward<br>\niptables</p>\n<p>Ctrl+p，Ctrl+q退出交互界面<br>\ndocker attach containerName重新打开交互界面</p>\n<p>CaaS(Container as a Service):镜像容器托管<br>\n从Docker到Caas<br>\n容器集群管理工具<br>\n容器调度<br>\n配置管理<br>\n服务发现<br>\n日志／监控／报警</p>\n<p>LaaS（基础设施） 出租计算、存储、网络、DNS等基础IT服务<br>\nPaaS（基础设施+系统平台—应用服务器应用框架 编程语言） 提供应用运行和开发环境 提供应用开发组件（邮件、消息、计费、支付）<br>\nSaaS （基础设施+系统平台+软件应用）互联网Web2.0应用 企业应用（ERP/CRM等）</p>\n<p>通俗点讲<br>\nSaaS：软件即服务，简单来说就是把企业想要的功能开发好成应用软件，然后直接卖给用户使用。通俗点讲就是去饭店吃饭一样，什么都是店家的。<br>\nPaaS：平台即服务，简单来说就是云计算平台提供硬件、编程语言、开发库等帮助用户更好更快的开发软件。通俗来说就是点外卖，使用时店家的，但是餐桌是自己的。<br>\nIaaS：基础设施即服务，简单来说就是云服务商提供企业所需要的服务器、存储、网络给企业用。通俗来说就是买菜买面，回家自己做饭。</p>\n<p><a href=\"https://blog.csdn.net/weixin_38003389/article/details/84025762\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_38003389/article/details/84025762</a></p>\n<p>Docker Machine：目的是简化 Docker 的安装和远程管理,是官方提供的一个工具。<br>\n先创建Docker Machine机器</p>\n<p>Docker Compose：Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。<br>\nDocker Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）<br>\nCompose 中有两个重要的概念：<br>\n项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。<br>\n服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例<br>\n运行 compose 项目：docker-compose up</p>\n<p>Docker Compose命令集<br>\n管理镜像：build/pull<br>\n管理服务：up/start/stop/kill/rm/scale<br>\n服务状态：ps/logs/port<br>\n一次性服务：run</p>\n<p>Docker Swarm:Docker集群管理工具，支持标准的Docker API,其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。<br>\nSwarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。</p>\n<p>Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p>\n<p>三大主流调度框架：Swarm、Kubernetes和Mesos</p>\n<p>Kubernetes：交互工具kubectl<br>\npods：创建、调度及管理的最小单元，共存的一组容器的集合，同一pods中的容器共享pid、网络、ipc及utf命名空间和共享存储卷</p>\n"},{"title":"Gradle3.0自动化项目构建技术","copyright":true,"comments":1,"toc":true,"date":"2018-10-02T14:10:23.000Z","password":null,"_content":"\n# Groovy快速入门\n\n领域特定语言DSL（Domain  Specific Language）：其核心思想为\"求专不求全，解决特定问题\"，\n\nGroovy： http://www.groovy-lang.org/\nGroovy：是一种基于JVM的敏捷开发语言，结合了Python、Ruby等脚本语言的许多强大特性，可以与Java完美结合，使用Java的所有库；\n1. 语法上支持动态类型，闭包等新一代语言特性\n2. 无缝继承所有Java的库（可以完全用Java写，但是不推荐）\n3. 即支持面向对象编程，也支持面向过程编程\n\n优势：一种更加敏捷的编程语言；入门非常容易，但是功能非常强大；既可以作为编程语言也可以作为脚本语言；熟练掌握Java的人会非常容易掌握Groovy\n\nGroovy开发环境搭建：\n> java平台上有各种语言的翻版，例如kotlin对c#,scala对haskell,Clojure对lisp，groovy对ruby\n\n## macOS/Linux\n1. 安装配置好JDK\n2. 下载Groovy SDK并解压到合适未知\n3. 配置bin目录到~/.bash_profile中，如添加如下内容到~/.bash_profile\n~~~\nexport PATH=$PATH:/usr/groovy-2.5.5/bin\n~~~\n4. groovy -version\n\n## InteliJ IDEA配置\n1. 确保已安装Groovy插件\n2. 配置Groovy SDK未知\n![image](/pub-images/Intelij%20Groovy.png)\n3. 编写Groovy版本HelloWorld，注意查看编译后文件\n~~~\n//Java版本\nclass Test {\n    public static void main(String[] args){\n        System.out.println(\"Hello world\");\n    }\n}\n~~~\n\n~~~\n//Groovy版本\nprint \"Hello world\"\n~~~\n\n\n# Groovy基础语法\n1. 变量\n* 变量的类型：基本类型+对象类型，Groovy中没有基本类型，所有的基本类型都会被编译器包装成对象类型，如：int->Integer\n* 变量的定义：强类型定义方式+弱类型def定义方式，Groovy中如果变量的值可以推断除其类型，则可通过def声明为弱类型，区别于java中的强类型定义方式，如：int i=1；\n* 推荐在自有使用模块使用def方式定义，如果有其他模块或其他类使用推荐强类型定义方式\n2. 字符串：String + GString\nString的使用和Java中一致，GString定义方式如下：\n* def name = 'Hello name' //不支持可扩展字符串\n* def doubleName = \"Hello doubleName\" //可扩展字符串，如：def doubleName = \"Hello doubleName and ${name}\",结果为： Hello doubleName and Hello name，此时doubleName是org.codehaus.groovy.runtime.GStringImpl的子类\n* def thupleName  = '''Hello thupleName'''  //支持多行方式\n\n无可扩展字符串时以上3种方式的String都是java.lang.String的子类，编码过程中String和GString是可以通用的，更多从方便使用角度考虑即可\n\nGroovy字符串方法介绍\n* java中String原有的方法\n* DefalutGroovyMethods\n* StringGroovyMethods：普通类型的参数+闭包类型的参数 \n~~~\ndef str = \"Groovy\"，str2 = \"Hello\",str3= \"Hello minus\"\n//字符串填充:center(),paddingLeft(),paddingRight()\nprintln str.center(8,'a')       //aGroovya\n//字符串比较：类似于数字比较；compareTo()\nprintln str > str2  //false\n//获取字符串索引:类似于数组下标；charAt()\nprintln str[0..1]   //Gr\n//减法运算:类似于数字减法；minus()\nprintln str3.minus(str2)    // minus\n//其他方法自己摸索\n~~~\n逻辑控制：单步顺序执行|if／else|switch-case|while|for，基本和Java操作一致，针对Groovy扩展介绍如下：\n~~~\n//switch-case\ndef x=1.23,result\nswitch(x){  //switch(x.class)\n    case \"name\":\n        result = \"name\"\n        break\n    case Integer:\n        result = \"Integer\"\n        break\n    case BigDecimal:\n        result = \"BigDecimal\"\n        break\n    case [1,2,3]:       //列表\n        result = \"list\"\n        break\n    case 1..10:         //范围\n        result = \"range\"    \n    default:\n        result=\"defalut\"\n}\nprintln result  //BigDecimal\n~~~\nfor循环控制\n~~~\n//对范围的for循环\ndef sum =0\nfor(i in 0..9){\n    sum += i\n}\nprintln sum //45\n//对list的for循环\nfor(i in [1,2,3,4,5]){\n    sum += i\n}\n//对map的for循环\nfor(i in [\"lili\":1,\"lucy\":2]){\n    println i.key + \":\" +i.value\n}\n~~~\n3. 闭包\n* 闭包就是一个代码块，所以需要通过{}括起来，def clouser = { println \"Hello Groovy!\"};clouser.call();clouser();  //推荐call()方式调用来区分是闭包\n* def clouser = {String name -> println \"Hello Groovy ${name}!\"};clouser.call(\"a\");clouser(\"b\");\n* 隐式参数it：def clouser = {println \"Hello Groovy ${it}!\"};clouser.call(\"a\");clouser(\"b\");\n* 闭包返回值：总是有返回值的，当闭包体没有明确返回值的时候，返回结果就是null\n* 如果最后一个参数是闭包，闭包可以写在外面   \n\n闭包的使用\n* 与基本类型的结合使用 \n~~~\nint fab1(int number){\n    int result = 1\n    1.upto(number,{num -> result *= num  })\n    return  result\n}\n\nint fab2(int number){\n    int result = 1\n    number.downto(1) {\n        num -> result *= num\n    }\n    return  result\n}\n\nint cal(int number){\n    int result = 0\n    number.times {\n        num -> result += num\n    }\n    return result\n}     \n~~~\n* 与String结合使用\n~~~\ndef str = \"the 2 and 3 is 5\"\nstr.each {String tmp -> print tmp.multiply(2)}  //tthhee  22  aanndd  33  iiss  55\nprintln str.find {String tmp -> tmp.isNumber()} //2\nprintln str.any {String tmp -> tmp.isNumber()}  //true\nprintln str.every {String tmp -> tmp.isNumber()} //false\ndef list = str.collect {it.toUpperCase()};println list.toListString()   //[T, H, E,  , 2,  , A, N, D,  , 3,  , I, S,  , 5]\n~~~\n* 与数据结构结合使用\n* 与文件等结合使用\n* 闭包进阶：闭包关键字（this，owner，delegate）+闭包委托策略\n~~~\ndef scriptClosure = {\n    println \"scriptClosure this:\"+this          //代表闭包定义处的类\n    println \"scriptClosure owner:\"+owner        //代表闭包定义处的类或对象\n    println \"scriptClosure delegate:\"+delegate  //代表任意对象，默认值为owner\n}\nscriptClosure.call()\n\n//scriptClosure this:Test@3c130745\n//scriptClosure owner:Test@3c130745\n//scriptClosure delegate:Test@3c130745\n\nclass Person{\n    def static classClosure = {\n        println \"classClosure this:\"+this\n        println \"classClosure owner:\"+owner\n        println \"classClosure delegate:\"+delegate\n    }\n\n    def static say(){\n        def methodClosure = {\n            println \"methodClosure this:\"+this\n            println \"methodClosure owner:\"+owner\n            println \"methodClosure delegate:\"+delegate\n        }\n        methodClosure.call()\n    }\n}\n\n//静态方法调用\nPerson.classClosure()\nPerson.say()\n//全部指向Person类,闭包指向离他最近的封闭类\n//classClosure this:class Person\n//classClosure owner:class Person\n//classClosure delegate:class Person\n//methodClosure this:class Person\n//methodClosure owner:class Person\n//methodClosure delegate:class Person\n\n//修改Person类中方法，取消static限定符调用\nPerson p = new Person()\np.classClosure()\np.say()\n//全部指向Person类对象，闭包指向离他最近的封闭类对象\nclassClosure this:Person@a9cd3b1\nclassClosure owner:Person@a9cd3b1\nclassClosure delegate:Person@a9cd3b1\nmethodClosure this:Person@a9cd3b1\nmethodClosure owner:Person@a9cd3b1\nmethodClosure delegate:Person@a9cd3b1\n\n//嵌套闭包\ndef outerClosure = {\n    def innerClosure = {\n        println \"innerClosure this:\"+this\n        println \"innerClosure owner:\"+owner\n        println \"innerClosure delegate:\"+delegate\n    }\n    innerClosure.call()\n}\nouterClosure.call()\n\n//innerClosure this:Test@3c130745\n//innerClosure owner:Test$_run_closure7@9353778 //指向outerClosure\n//innerClosure delegate:Test$_run_closure7@9353778\n~~~\n总结：this、owner、delegate的值在大多数情况都是一样的，在嵌套闭包中this的值和owner、delegate的值不一致，只有在给delegate赋值后owner和delegate的值才不一致\n\n闭包的委托策略\n~~~\nclass Student{\n    String name\n    def sayName = { \"My name is ${name}\"}\n    String toString(){\n        sayName.call()\n    }\n}\n\nclass Teacher{\n    String name\n}\n\ndef stu = new Student(name: \"XingFeng\")\nprintln stu.toString()\n\ndef tea = new Teacher(name: \"Lily\")\nstu.sayName.delegate = tea\nprintln stu.toString()\nstu.sayName.resolveStrategy = Closure.DELEGATE_FIRST    //先从delegate中查找name属性，没有了再从owner中查找\nprintln stu.toString()\n\n//My name is XingFeng\n//My name is XingFeng\n//My name is Lily\n~~~\n4. 数据结构\n列表的定义：def list = [1,2,3,4] 此为一个ArrayList；\n数组的定义：def list = [1,2,3,4] as int[]; int[] arr=[1,2,3]\n列表的排序：def list = [1,12,3,444]; Collections.sort(list);list.sort()\n\nmap的定义：def colors=[\"red\":1,\"blue\":2];def colors=[red:1,blue:2]\n索引map：println colors.red;println colors[\"red\"];\n添加map：colors.yellow=3 //Groovy中map可以添加不同类型的数据：colors.complex =[a:1,b:2]\n遍历map： list.each{def tmp,int index -> ...}  list.eachWithIndex{ key,value,index -> ...}\n查找map： any  find  findAll every\n分组map： groupBy{}\n排序map：sort\n\n范围Range：定义 def range = 1..10;println range[0];range.contains(10);println range.from;println range.to\nRange继承自java.util.List\n~~~\nswitch(number){\n    case 0..<60\n        ...\n}\n~~~\n5. 面向对象\n类、接口等的定义和使用\n* Groovy中默认类、方法等都是public类型\n* Groovy中无论是直接调用属性还是通过get／set方法其实质都是通过getter／setter方法调用的属性，getter／setter方法默认自动继承\n* 接口实现需实现接口的所有方法；trait中可以有默认方法实现，没有实现的方法需添加abstract关键字，实现时只需实现abstract的方法即可\n\n> 元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射\n\n> 元编程通常有两种方式起作用。一种方式是通过应用程序接口（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。\n\n![image](/pub-images/Groovy元编程.png)\n~~~\nclass Baby {\n    def invokeMethod(String name,Object args){\n        return \"the method is ${name},the args is ${args}\"\n    }\n\n    def methodMissing(String name,Object args){\n        return \"the method  ${name} is missing}\"\n    }\n}\n\ndef baby = new Baby()\nprintln baby.cry() \n~~~\n结合上图理解：Java中对象方法的调用没有上图否流程分支，在Groovy中对象方法调用有否分支调用，上例中通过注释invokeMethod、methodMissing方法查看运行效果，通过以下代码可动态添加对象属性和方法：\n~~~\nBaby.metaClass.sex = \"male\"\nBaby.metaClass.play = { ... }\nBaby.metaClass.static.play = { ... }    //静态方法\n~~~\n通过ExpandoMetaClass.enableGlobally()设置让动态添加方法全局启用\n\n6. Json操作\n* 对象转换成JSON字符串：JsonOutput.toJson()\n* Json格式化打印：JsonOutput.prettyPrint(jsonObject)\n* Json字符串转对象：def jsonSlurper = new JsonSlurper();jsonSlurper.parse()\n\n7. xml操作\n* Java对xml的处理：DOM文档驱动处理方式+SAX事件驱动处理方式\n* Groovy解析xml数据：def xmlSlurper = new XmlSlurper();def response = xmlSlurper.parse(xml); ／／response对象可以逐级访问节点，节点的属性添加@符号，如：response.books.@id，也可以通过闭包过滤信息\n* Groovy深度遍历xml：可以通过逐级遍历解析后的response数据，也可通过response.depFirst().find{ ...}遍历或 response.'**'.find{ ...}遍历（'**'代表深度遍历）\n* Groovy深度遍历xml：response.books.children().find{...}或response.books.'*'.find{...}（'*'代表深度遍历）\n* Groovy创建xml数据：\n~~~\n'''\n<langs type='current' count='3'>\n    <language flavor='static' version='1.5' />\n    <language flavor='public' version='2.5' />\n</langs>\n'''\n\ndef sw = new StringWriter()\ndef xmlBuilder = new MarkupBuilder(sw)\nxmlBuilder.langs(type:'current',count:3){\n    language(flavor:'static',version:'1.5')\n    language(flavor:'public',version:'2.5')\n}\nprintln sw\n\ndef langs = new Langs()\nxmlBuilder.langs(type:langs.type,count:langs.count){\n     langs.languages.each {\n         language(flavor:it.flavor,version:it.version)\n     }\n}\nprintln sw\n~~~\n\n8. 文件操作\n* Java文件处理：节点流（InputStream、OutputStream及其子类）+处理流（Reader、Writer及其子类），所有Java对文件的操作Groovy都支持\n* 遍历文件内容：def file = new File(\"Test.iml\");file.eachLine { println it } 或 def text = file.getText() 或 def text = file.readLines() ...\n\n# gradle\nGradle是一款最新的，功能强大的构建工具，使用程序代替传统的xml配置，项目构建更加灵活，有丰富的第三方库\n\ngradle组成：groovy核心语法+build script block+gradle api\n\n## gradle生命周期\n执行./gradlew clean 观察执行过程，其生命周期包括：初始化、配置、执行\n![image](/pub-images/gradle生命周期.png)\n\n## gradle生命周期的监听\n在项目的build.gradle中添加如下\n~~~\n//在配置阶段开始之前的回调\nthis.beforeEvaluate {}\n\n//配置阶段完成以后的回调\nthis.afterEvaluate {}\n\n//gradle生命周期执行完以后的回调\nthis.gradle.buildFinished {}\n~~~\n\n# Gradle Project\n./gradlew projects //查看工程Project数量，学会区分Project与module及根Project与子Project，每个Project必须有一个build.gradle文件\n\nProject API组成：\n1. Project相关API：如何管理父Project及如何操作子Project\n* this.getAllProjects()，this.getSubProjects(),this.getParent()，在gradl文件中，对应allprojects、project、subprojects进行操作\n\n./gradlew projects可实现显示所有项目，自我实现如下：\n~~~\ndef getProjects(){\n    println \"------------------------\"\n    this.getAllprojects().eachWithIndex{ Project project, int index ->\n        if(index == 0){\n            println \"Root project:${project.name}\"\n        }else{\n            println \"+--- project:${project.name}\"\n        }\n    }\n}\n\nthis.getProjects()\n\n//------------------------\n//Root project:MyApplication\n//+--- project:app\n~~~\n2. task相关API\n\n3. 属性相关API\n* 父Project的属性在子项目中会被继承，可直接使用\n* 可以在项目中通过common.gradle文件来定义扩展属性ext，然后在根Project中通过apply from:this.file('common.gradle')引入后，按rootProject.ext.定义属性的方式使用\n* 在gradle.properties中定义key-value属性，如：isLoadTest=false，然后在settings.gradle中就可以编码控制是否加载Test项目\n~~~\nif(hasProperty('isLoadTest')? isLoadTest.toBoolean() : false){\n    include ':Test'\n}\n~~~\n自定义属性的两种方式：ext方式+gradle.properties中定义\n4. file相关API\n* 路径获取API：getRootdir()、getBuildDir()、getProjectDir()\n* 文件操作相关API：都是基于根工程操作的，不支持跨工程操作\n~~~\n//文件／文件夹拷贝\ncopy {\n   from file('test.txt')\n   into getRootProject().getBuildDir()\n}\n//文件树遍历\nfileTree('build/'){\n    FileTree fileTree -> fileTree.visit{ FileTreeElement element -> ... }\n}\n~~~\n5. gradle生命周期API\n\n6. 其他API\n* 依赖相关API\n~~~\nbuildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.2.1' \n    }\n}\n//等价于以下操作：\nbuildscript { ScriptHandler scriptHandler ->\n    scriptHandler.repositories {  RepositoryHandler repositoryHandler ->\n        repositoryHandler.google()\n        repositoryHandler.jcenter()\n    }\n    scriptHandler.dependencies {\n        classpath 'com.android.tools.build:gradle:3.2.1'\n    }\n}\n~~~\n依赖传递：A模块依赖B模块，B模块依赖C模块，如果A模块也需要C模块功能，不需依赖使用，防止B修改后去掉C依赖而导致错误，可在A中引入C模块，通过exclude排除依赖，transitive禁止依赖传递\n\n占位编译provided：A.类库只在编译阶段起作用 B.父项目已引入类库，子项目直接使用父项目类库，但为了子项目编译通过使用占位编译\n\n* 外部命令执行\n~~~\ntask abc() {\n    doLast{\n        def command = 'ls'\n        exec{\n            try{\n                executable 'bash'\n                args '-c',command\n                println 'command is execute success.'\n            }catch(GradleException ex){\n                println \"Excepiotn....\"\n            }\n        }\n    }\n}\n~~~\n执行：./gradlew abc\n\n# Task\n1. Task定义及配置\n直接通过task函数去创建\n~~~\ntask(\"abcd\") {\n    doLast{\n        def command = 'ls -al'\n        exec{\n            try{\n                executable 'bash'\n                args '-c',command\n                println 'command is execute success.'\n            }catch(GradleException ex){\n                println \"Excepiotn....\"\n            }\n        }\n    }\n}\n~~~\n通过TaskContainer创建\n~~~\nthis.tasks.create(\"aa\"){\n    println 'Hello task'\n}\n~~~\nTask创建之后可在开发工具的gradle插件重查找到task，如果没有设置group，则默认在other分组中，更多配置可通过task源码查看\n2. Task执行详解\ndoFirst/doLast执行阶段执行，否则在配置阶段执行\n~~~\ntask aa{\n    doFirst{\n        println 'Hello  2'\n    }\n}\ntask.doFirst{\n    println 'Hello  1'\n}\n\n//Hello  1\n//Hello  2\n~~~\n\n编写一个统计build时长的task\napp.gradle中编写：\n~~~\ndef startBuilderTime,endBuilderTime\nthis.afterEvaluate { Project project ->\n    def preBuildTask = this.tasks.getByName(\"preBuild\")\n    preBuildTask.doFirst {\n        startBuilderTime = System.currentTimeMillis()\n        println '------开始计时...'\n    }\n    def buildTask = this.tasks.getByName(\"build\")\n    buildTask.doLast {\n        endBuilderTime = System.currentTimeMillis()\n        println '------计时结束,耗时：'+(endBuilderTime - startBuilderTime)\n    }\n}\n~~~\n./gradlew build执行查看结果\n3. Task的依赖及执行顺序\n* dependsOn强依赖方式\n~~~\ntask t1() { doLast{println 'task t1'} }\ntask t2() << { println 'task t2' }      //此处\"<<\"等同于doLast\ntask t3(dependsOn:[t1,t2]) { doLast{println 'task t3'} }\ntask t4() { dependsOn this.tasks.findAll { task -> return task.name.equals(\"t2\")};doLast{println 'task t4'} }\n\n//./gradlew t3: (t1和t2执行顺序是随机的)\n//task t1\n//task t2\n//task t3\n\n//./gradlew t4\n//task t2\n//task t4\n~~~\n* 通过Task输入输出指定\nTaskInputs:参数为任意对象及文件、文件夹；TaskOutputs:只输出文件\n\n~~~\next{\n    println '------配置中...'\n    versionCode = 100\n    versionName = \"V2.0.0\"\n    versionInfo = \"第一个版本\"\n    destFile = file(\"release.xml\")\n    if(destFile != null && !destFile.exists()){\n        destFile.createNewFile()\n    }\n}\n\nclass VersionMsg{\n    Integer versionCode\n    String versionName\n    String versionInfo\n}\n\ntask writerTask{\n    //为task指定输入\n    inputs.property(\"versionCode\",this.versionCode)\n    inputs.property(\"versionName\",this.versionName)\n    inputs.property(\"versionInfo\",this.versionInfo)\n    //为task指定输出\n    outputs.file destFile\n\n    doLast{\n        def data = inputs.getProperties()\n        File file = outputs.getFiles().getSingleFile()\n        def versionMsg = new VersionMsg(data)\n        def sw = new StringWriter()\n        def xmlBuilder = new groovy.xml.MarkupBuilder(sw)\n        if(file.text != null && file.text.size() <=0){\n            xmlBuilder.releases{\n                release{\n                    versionCode(versionMsg.versionCode)\n                    versionName(versionMsg.versionName)\n                    versionInfo(versionMsg.versionInfo)\n                }\n            }\n            file.withWriter { writer ->\n                writer.append(sw.toString())\n            }\n        }else{\n            def lines = file.readLines()\n            def lengths = lines.size() - 1\n            file.withWriter { writer ->\n                lines.eachWithIndex{ String line, int index ->\n                    if(index != lengths){\n                        writer.append(line +\"\\r\\n\")\n                    }else if(index == lengths){\n                        writer.append(\"\\r\\n\" + sw.toString()+\"\\r\\n\")\n                        writer.append(lines.get(lengths))\n                    }\n                }\n            }\n\n        }\n    }\n}\n\ntask readTask{\n    inputs.file destFile\n    doLast{\n        def file = inputs.files.singleFile\n        println file.text\n    }\n}\n\ntask taskTest{\n    dependsOn readTask,writerTask\n    doLast{\n        println \"输入输出任务结束\"\n    }\n}\n~~~\ndestFile作为writerTask输出结果输入到readTask\n* 通过API指定执行顺序：mustRunAfter／shouldRunAfter\n~~~\ntask t1() { doLast{println 'task t1'} }\ntask t2() { mustRunAfter t1 doLast {println 'task t2'} }\n~~~\n通过./gradlew t2 t1查看执行结果\n4. Task类型\n详见官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete\n5. 构建到生命周期\n~~~\nthis.project.afterEvaluate {project ->\n    println \"开始挂接...\"\n    def buildTask = project.tasks.getByName(\"build\")\n    if(buildTask == null) throw GradleException(\"build Task not found\")\n    buildTask.doLast {\n        writerTask.execute()\n    }\n}\n~~~\n\n# Gradle其他模块\n1. Settings类：对应Settings.gradle\n~~~\nif(hasProperty('isLoadTest')? isLoadTest.toBoolean() : false){\n    include ':Test'\n}\n~~~\n2. SourceSet类:AndroidSourceSet/JavaSourceSet,决定了代码、资源、第三方库要存放的位置\n~~~\n//修改.so等jnilibs的存放位置\nandroid{\n    sourceSets {\n        main{\n            jniLibs.srcDirs = ['libs']\n            res.srcDirs = ['src/main/res','src/main/res-ad']    //对res文件夹内容进行分类，但是只能在Project视图查看到效果\n        }\n    }\n}\n~~~\n3. Gradle的Plugin\n* Gradle没有提供创建自定义Gradle插件工程的模板，需要开发者手动创建Gradle插件工程\n* 使用Groovy开发，其Gradle插件工程必须遵循如下的目录结构：\n groovy代码必须位于xxxProject/src/main/groovy/目录下\n提供插件属性声明文件，该文件必须位于xxxProject/src/main/resources/META-INF/gradle-plugins/xxx.properties\n\n\n4. android插件对gradle的扩展\nandroid具体能配置那些属性，可查看源码通过BaseExtension查看\n\ngradle插件： https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html\n\nvarints变体\n\n\n\n\n\n\n","source":"_posts/移动开发/Gradle3.0自动化项目构建技术.md","raw":"---\ntitle: Gradle3.0自动化项目构建技术\ntags: \n  - andrioid\n  - Gradle \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-02 22:10:23\ncategories: Java\npassword:\n---\n\n# Groovy快速入门\n\n领域特定语言DSL（Domain  Specific Language）：其核心思想为\"求专不求全，解决特定问题\"，\n\nGroovy： http://www.groovy-lang.org/\nGroovy：是一种基于JVM的敏捷开发语言，结合了Python、Ruby等脚本语言的许多强大特性，可以与Java完美结合，使用Java的所有库；\n1. 语法上支持动态类型，闭包等新一代语言特性\n2. 无缝继承所有Java的库（可以完全用Java写，但是不推荐）\n3. 即支持面向对象编程，也支持面向过程编程\n\n优势：一种更加敏捷的编程语言；入门非常容易，但是功能非常强大；既可以作为编程语言也可以作为脚本语言；熟练掌握Java的人会非常容易掌握Groovy\n\nGroovy开发环境搭建：\n> java平台上有各种语言的翻版，例如kotlin对c#,scala对haskell,Clojure对lisp，groovy对ruby\n\n## macOS/Linux\n1. 安装配置好JDK\n2. 下载Groovy SDK并解压到合适未知\n3. 配置bin目录到~/.bash_profile中，如添加如下内容到~/.bash_profile\n~~~\nexport PATH=$PATH:/usr/groovy-2.5.5/bin\n~~~\n4. groovy -version\n\n## InteliJ IDEA配置\n1. 确保已安装Groovy插件\n2. 配置Groovy SDK未知\n![image](/pub-images/Intelij%20Groovy.png)\n3. 编写Groovy版本HelloWorld，注意查看编译后文件\n~~~\n//Java版本\nclass Test {\n    public static void main(String[] args){\n        System.out.println(\"Hello world\");\n    }\n}\n~~~\n\n~~~\n//Groovy版本\nprint \"Hello world\"\n~~~\n\n\n# Groovy基础语法\n1. 变量\n* 变量的类型：基本类型+对象类型，Groovy中没有基本类型，所有的基本类型都会被编译器包装成对象类型，如：int->Integer\n* 变量的定义：强类型定义方式+弱类型def定义方式，Groovy中如果变量的值可以推断除其类型，则可通过def声明为弱类型，区别于java中的强类型定义方式，如：int i=1；\n* 推荐在自有使用模块使用def方式定义，如果有其他模块或其他类使用推荐强类型定义方式\n2. 字符串：String + GString\nString的使用和Java中一致，GString定义方式如下：\n* def name = 'Hello name' //不支持可扩展字符串\n* def doubleName = \"Hello doubleName\" //可扩展字符串，如：def doubleName = \"Hello doubleName and ${name}\",结果为： Hello doubleName and Hello name，此时doubleName是org.codehaus.groovy.runtime.GStringImpl的子类\n* def thupleName  = '''Hello thupleName'''  //支持多行方式\n\n无可扩展字符串时以上3种方式的String都是java.lang.String的子类，编码过程中String和GString是可以通用的，更多从方便使用角度考虑即可\n\nGroovy字符串方法介绍\n* java中String原有的方法\n* DefalutGroovyMethods\n* StringGroovyMethods：普通类型的参数+闭包类型的参数 \n~~~\ndef str = \"Groovy\"，str2 = \"Hello\",str3= \"Hello minus\"\n//字符串填充:center(),paddingLeft(),paddingRight()\nprintln str.center(8,'a')       //aGroovya\n//字符串比较：类似于数字比较；compareTo()\nprintln str > str2  //false\n//获取字符串索引:类似于数组下标；charAt()\nprintln str[0..1]   //Gr\n//减法运算:类似于数字减法；minus()\nprintln str3.minus(str2)    // minus\n//其他方法自己摸索\n~~~\n逻辑控制：单步顺序执行|if／else|switch-case|while|for，基本和Java操作一致，针对Groovy扩展介绍如下：\n~~~\n//switch-case\ndef x=1.23,result\nswitch(x){  //switch(x.class)\n    case \"name\":\n        result = \"name\"\n        break\n    case Integer:\n        result = \"Integer\"\n        break\n    case BigDecimal:\n        result = \"BigDecimal\"\n        break\n    case [1,2,3]:       //列表\n        result = \"list\"\n        break\n    case 1..10:         //范围\n        result = \"range\"    \n    default:\n        result=\"defalut\"\n}\nprintln result  //BigDecimal\n~~~\nfor循环控制\n~~~\n//对范围的for循环\ndef sum =0\nfor(i in 0..9){\n    sum += i\n}\nprintln sum //45\n//对list的for循环\nfor(i in [1,2,3,4,5]){\n    sum += i\n}\n//对map的for循环\nfor(i in [\"lili\":1,\"lucy\":2]){\n    println i.key + \":\" +i.value\n}\n~~~\n3. 闭包\n* 闭包就是一个代码块，所以需要通过{}括起来，def clouser = { println \"Hello Groovy!\"};clouser.call();clouser();  //推荐call()方式调用来区分是闭包\n* def clouser = {String name -> println \"Hello Groovy ${name}!\"};clouser.call(\"a\");clouser(\"b\");\n* 隐式参数it：def clouser = {println \"Hello Groovy ${it}!\"};clouser.call(\"a\");clouser(\"b\");\n* 闭包返回值：总是有返回值的，当闭包体没有明确返回值的时候，返回结果就是null\n* 如果最后一个参数是闭包，闭包可以写在外面   \n\n闭包的使用\n* 与基本类型的结合使用 \n~~~\nint fab1(int number){\n    int result = 1\n    1.upto(number,{num -> result *= num  })\n    return  result\n}\n\nint fab2(int number){\n    int result = 1\n    number.downto(1) {\n        num -> result *= num\n    }\n    return  result\n}\n\nint cal(int number){\n    int result = 0\n    number.times {\n        num -> result += num\n    }\n    return result\n}     \n~~~\n* 与String结合使用\n~~~\ndef str = \"the 2 and 3 is 5\"\nstr.each {String tmp -> print tmp.multiply(2)}  //tthhee  22  aanndd  33  iiss  55\nprintln str.find {String tmp -> tmp.isNumber()} //2\nprintln str.any {String tmp -> tmp.isNumber()}  //true\nprintln str.every {String tmp -> tmp.isNumber()} //false\ndef list = str.collect {it.toUpperCase()};println list.toListString()   //[T, H, E,  , 2,  , A, N, D,  , 3,  , I, S,  , 5]\n~~~\n* 与数据结构结合使用\n* 与文件等结合使用\n* 闭包进阶：闭包关键字（this，owner，delegate）+闭包委托策略\n~~~\ndef scriptClosure = {\n    println \"scriptClosure this:\"+this          //代表闭包定义处的类\n    println \"scriptClosure owner:\"+owner        //代表闭包定义处的类或对象\n    println \"scriptClosure delegate:\"+delegate  //代表任意对象，默认值为owner\n}\nscriptClosure.call()\n\n//scriptClosure this:Test@3c130745\n//scriptClosure owner:Test@3c130745\n//scriptClosure delegate:Test@3c130745\n\nclass Person{\n    def static classClosure = {\n        println \"classClosure this:\"+this\n        println \"classClosure owner:\"+owner\n        println \"classClosure delegate:\"+delegate\n    }\n\n    def static say(){\n        def methodClosure = {\n            println \"methodClosure this:\"+this\n            println \"methodClosure owner:\"+owner\n            println \"methodClosure delegate:\"+delegate\n        }\n        methodClosure.call()\n    }\n}\n\n//静态方法调用\nPerson.classClosure()\nPerson.say()\n//全部指向Person类,闭包指向离他最近的封闭类\n//classClosure this:class Person\n//classClosure owner:class Person\n//classClosure delegate:class Person\n//methodClosure this:class Person\n//methodClosure owner:class Person\n//methodClosure delegate:class Person\n\n//修改Person类中方法，取消static限定符调用\nPerson p = new Person()\np.classClosure()\np.say()\n//全部指向Person类对象，闭包指向离他最近的封闭类对象\nclassClosure this:Person@a9cd3b1\nclassClosure owner:Person@a9cd3b1\nclassClosure delegate:Person@a9cd3b1\nmethodClosure this:Person@a9cd3b1\nmethodClosure owner:Person@a9cd3b1\nmethodClosure delegate:Person@a9cd3b1\n\n//嵌套闭包\ndef outerClosure = {\n    def innerClosure = {\n        println \"innerClosure this:\"+this\n        println \"innerClosure owner:\"+owner\n        println \"innerClosure delegate:\"+delegate\n    }\n    innerClosure.call()\n}\nouterClosure.call()\n\n//innerClosure this:Test@3c130745\n//innerClosure owner:Test$_run_closure7@9353778 //指向outerClosure\n//innerClosure delegate:Test$_run_closure7@9353778\n~~~\n总结：this、owner、delegate的值在大多数情况都是一样的，在嵌套闭包中this的值和owner、delegate的值不一致，只有在给delegate赋值后owner和delegate的值才不一致\n\n闭包的委托策略\n~~~\nclass Student{\n    String name\n    def sayName = { \"My name is ${name}\"}\n    String toString(){\n        sayName.call()\n    }\n}\n\nclass Teacher{\n    String name\n}\n\ndef stu = new Student(name: \"XingFeng\")\nprintln stu.toString()\n\ndef tea = new Teacher(name: \"Lily\")\nstu.sayName.delegate = tea\nprintln stu.toString()\nstu.sayName.resolveStrategy = Closure.DELEGATE_FIRST    //先从delegate中查找name属性，没有了再从owner中查找\nprintln stu.toString()\n\n//My name is XingFeng\n//My name is XingFeng\n//My name is Lily\n~~~\n4. 数据结构\n列表的定义：def list = [1,2,3,4] 此为一个ArrayList；\n数组的定义：def list = [1,2,3,4] as int[]; int[] arr=[1,2,3]\n列表的排序：def list = [1,12,3,444]; Collections.sort(list);list.sort()\n\nmap的定义：def colors=[\"red\":1,\"blue\":2];def colors=[red:1,blue:2]\n索引map：println colors.red;println colors[\"red\"];\n添加map：colors.yellow=3 //Groovy中map可以添加不同类型的数据：colors.complex =[a:1,b:2]\n遍历map： list.each{def tmp,int index -> ...}  list.eachWithIndex{ key,value,index -> ...}\n查找map： any  find  findAll every\n分组map： groupBy{}\n排序map：sort\n\n范围Range：定义 def range = 1..10;println range[0];range.contains(10);println range.from;println range.to\nRange继承自java.util.List\n~~~\nswitch(number){\n    case 0..<60\n        ...\n}\n~~~\n5. 面向对象\n类、接口等的定义和使用\n* Groovy中默认类、方法等都是public类型\n* Groovy中无论是直接调用属性还是通过get／set方法其实质都是通过getter／setter方法调用的属性，getter／setter方法默认自动继承\n* 接口实现需实现接口的所有方法；trait中可以有默认方法实现，没有实现的方法需添加abstract关键字，实现时只需实现abstract的方法即可\n\n> 元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射\n\n> 元编程通常有两种方式起作用。一种方式是通过应用程序接口（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。\n\n![image](/pub-images/Groovy元编程.png)\n~~~\nclass Baby {\n    def invokeMethod(String name,Object args){\n        return \"the method is ${name},the args is ${args}\"\n    }\n\n    def methodMissing(String name,Object args){\n        return \"the method  ${name} is missing}\"\n    }\n}\n\ndef baby = new Baby()\nprintln baby.cry() \n~~~\n结合上图理解：Java中对象方法的调用没有上图否流程分支，在Groovy中对象方法调用有否分支调用，上例中通过注释invokeMethod、methodMissing方法查看运行效果，通过以下代码可动态添加对象属性和方法：\n~~~\nBaby.metaClass.sex = \"male\"\nBaby.metaClass.play = { ... }\nBaby.metaClass.static.play = { ... }    //静态方法\n~~~\n通过ExpandoMetaClass.enableGlobally()设置让动态添加方法全局启用\n\n6. Json操作\n* 对象转换成JSON字符串：JsonOutput.toJson()\n* Json格式化打印：JsonOutput.prettyPrint(jsonObject)\n* Json字符串转对象：def jsonSlurper = new JsonSlurper();jsonSlurper.parse()\n\n7. xml操作\n* Java对xml的处理：DOM文档驱动处理方式+SAX事件驱动处理方式\n* Groovy解析xml数据：def xmlSlurper = new XmlSlurper();def response = xmlSlurper.parse(xml); ／／response对象可以逐级访问节点，节点的属性添加@符号，如：response.books.@id，也可以通过闭包过滤信息\n* Groovy深度遍历xml：可以通过逐级遍历解析后的response数据，也可通过response.depFirst().find{ ...}遍历或 response.'**'.find{ ...}遍历（'**'代表深度遍历）\n* Groovy深度遍历xml：response.books.children().find{...}或response.books.'*'.find{...}（'*'代表深度遍历）\n* Groovy创建xml数据：\n~~~\n'''\n<langs type='current' count='3'>\n    <language flavor='static' version='1.5' />\n    <language flavor='public' version='2.5' />\n</langs>\n'''\n\ndef sw = new StringWriter()\ndef xmlBuilder = new MarkupBuilder(sw)\nxmlBuilder.langs(type:'current',count:3){\n    language(flavor:'static',version:'1.5')\n    language(flavor:'public',version:'2.5')\n}\nprintln sw\n\ndef langs = new Langs()\nxmlBuilder.langs(type:langs.type,count:langs.count){\n     langs.languages.each {\n         language(flavor:it.flavor,version:it.version)\n     }\n}\nprintln sw\n~~~\n\n8. 文件操作\n* Java文件处理：节点流（InputStream、OutputStream及其子类）+处理流（Reader、Writer及其子类），所有Java对文件的操作Groovy都支持\n* 遍历文件内容：def file = new File(\"Test.iml\");file.eachLine { println it } 或 def text = file.getText() 或 def text = file.readLines() ...\n\n# gradle\nGradle是一款最新的，功能强大的构建工具，使用程序代替传统的xml配置，项目构建更加灵活，有丰富的第三方库\n\ngradle组成：groovy核心语法+build script block+gradle api\n\n## gradle生命周期\n执行./gradlew clean 观察执行过程，其生命周期包括：初始化、配置、执行\n![image](/pub-images/gradle生命周期.png)\n\n## gradle生命周期的监听\n在项目的build.gradle中添加如下\n~~~\n//在配置阶段开始之前的回调\nthis.beforeEvaluate {}\n\n//配置阶段完成以后的回调\nthis.afterEvaluate {}\n\n//gradle生命周期执行完以后的回调\nthis.gradle.buildFinished {}\n~~~\n\n# Gradle Project\n./gradlew projects //查看工程Project数量，学会区分Project与module及根Project与子Project，每个Project必须有一个build.gradle文件\n\nProject API组成：\n1. Project相关API：如何管理父Project及如何操作子Project\n* this.getAllProjects()，this.getSubProjects(),this.getParent()，在gradl文件中，对应allprojects、project、subprojects进行操作\n\n./gradlew projects可实现显示所有项目，自我实现如下：\n~~~\ndef getProjects(){\n    println \"------------------------\"\n    this.getAllprojects().eachWithIndex{ Project project, int index ->\n        if(index == 0){\n            println \"Root project:${project.name}\"\n        }else{\n            println \"+--- project:${project.name}\"\n        }\n    }\n}\n\nthis.getProjects()\n\n//------------------------\n//Root project:MyApplication\n//+--- project:app\n~~~\n2. task相关API\n\n3. 属性相关API\n* 父Project的属性在子项目中会被继承，可直接使用\n* 可以在项目中通过common.gradle文件来定义扩展属性ext，然后在根Project中通过apply from:this.file('common.gradle')引入后，按rootProject.ext.定义属性的方式使用\n* 在gradle.properties中定义key-value属性，如：isLoadTest=false，然后在settings.gradle中就可以编码控制是否加载Test项目\n~~~\nif(hasProperty('isLoadTest')? isLoadTest.toBoolean() : false){\n    include ':Test'\n}\n~~~\n自定义属性的两种方式：ext方式+gradle.properties中定义\n4. file相关API\n* 路径获取API：getRootdir()、getBuildDir()、getProjectDir()\n* 文件操作相关API：都是基于根工程操作的，不支持跨工程操作\n~~~\n//文件／文件夹拷贝\ncopy {\n   from file('test.txt')\n   into getRootProject().getBuildDir()\n}\n//文件树遍历\nfileTree('build/'){\n    FileTree fileTree -> fileTree.visit{ FileTreeElement element -> ... }\n}\n~~~\n5. gradle生命周期API\n\n6. 其他API\n* 依赖相关API\n~~~\nbuildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.2.1' \n    }\n}\n//等价于以下操作：\nbuildscript { ScriptHandler scriptHandler ->\n    scriptHandler.repositories {  RepositoryHandler repositoryHandler ->\n        repositoryHandler.google()\n        repositoryHandler.jcenter()\n    }\n    scriptHandler.dependencies {\n        classpath 'com.android.tools.build:gradle:3.2.1'\n    }\n}\n~~~\n依赖传递：A模块依赖B模块，B模块依赖C模块，如果A模块也需要C模块功能，不需依赖使用，防止B修改后去掉C依赖而导致错误，可在A中引入C模块，通过exclude排除依赖，transitive禁止依赖传递\n\n占位编译provided：A.类库只在编译阶段起作用 B.父项目已引入类库，子项目直接使用父项目类库，但为了子项目编译通过使用占位编译\n\n* 外部命令执行\n~~~\ntask abc() {\n    doLast{\n        def command = 'ls'\n        exec{\n            try{\n                executable 'bash'\n                args '-c',command\n                println 'command is execute success.'\n            }catch(GradleException ex){\n                println \"Excepiotn....\"\n            }\n        }\n    }\n}\n~~~\n执行：./gradlew abc\n\n# Task\n1. Task定义及配置\n直接通过task函数去创建\n~~~\ntask(\"abcd\") {\n    doLast{\n        def command = 'ls -al'\n        exec{\n            try{\n                executable 'bash'\n                args '-c',command\n                println 'command is execute success.'\n            }catch(GradleException ex){\n                println \"Excepiotn....\"\n            }\n        }\n    }\n}\n~~~\n通过TaskContainer创建\n~~~\nthis.tasks.create(\"aa\"){\n    println 'Hello task'\n}\n~~~\nTask创建之后可在开发工具的gradle插件重查找到task，如果没有设置group，则默认在other分组中，更多配置可通过task源码查看\n2. Task执行详解\ndoFirst/doLast执行阶段执行，否则在配置阶段执行\n~~~\ntask aa{\n    doFirst{\n        println 'Hello  2'\n    }\n}\ntask.doFirst{\n    println 'Hello  1'\n}\n\n//Hello  1\n//Hello  2\n~~~\n\n编写一个统计build时长的task\napp.gradle中编写：\n~~~\ndef startBuilderTime,endBuilderTime\nthis.afterEvaluate { Project project ->\n    def preBuildTask = this.tasks.getByName(\"preBuild\")\n    preBuildTask.doFirst {\n        startBuilderTime = System.currentTimeMillis()\n        println '------开始计时...'\n    }\n    def buildTask = this.tasks.getByName(\"build\")\n    buildTask.doLast {\n        endBuilderTime = System.currentTimeMillis()\n        println '------计时结束,耗时：'+(endBuilderTime - startBuilderTime)\n    }\n}\n~~~\n./gradlew build执行查看结果\n3. Task的依赖及执行顺序\n* dependsOn强依赖方式\n~~~\ntask t1() { doLast{println 'task t1'} }\ntask t2() << { println 'task t2' }      //此处\"<<\"等同于doLast\ntask t3(dependsOn:[t1,t2]) { doLast{println 'task t3'} }\ntask t4() { dependsOn this.tasks.findAll { task -> return task.name.equals(\"t2\")};doLast{println 'task t4'} }\n\n//./gradlew t3: (t1和t2执行顺序是随机的)\n//task t1\n//task t2\n//task t3\n\n//./gradlew t4\n//task t2\n//task t4\n~~~\n* 通过Task输入输出指定\nTaskInputs:参数为任意对象及文件、文件夹；TaskOutputs:只输出文件\n\n~~~\next{\n    println '------配置中...'\n    versionCode = 100\n    versionName = \"V2.0.0\"\n    versionInfo = \"第一个版本\"\n    destFile = file(\"release.xml\")\n    if(destFile != null && !destFile.exists()){\n        destFile.createNewFile()\n    }\n}\n\nclass VersionMsg{\n    Integer versionCode\n    String versionName\n    String versionInfo\n}\n\ntask writerTask{\n    //为task指定输入\n    inputs.property(\"versionCode\",this.versionCode)\n    inputs.property(\"versionName\",this.versionName)\n    inputs.property(\"versionInfo\",this.versionInfo)\n    //为task指定输出\n    outputs.file destFile\n\n    doLast{\n        def data = inputs.getProperties()\n        File file = outputs.getFiles().getSingleFile()\n        def versionMsg = new VersionMsg(data)\n        def sw = new StringWriter()\n        def xmlBuilder = new groovy.xml.MarkupBuilder(sw)\n        if(file.text != null && file.text.size() <=0){\n            xmlBuilder.releases{\n                release{\n                    versionCode(versionMsg.versionCode)\n                    versionName(versionMsg.versionName)\n                    versionInfo(versionMsg.versionInfo)\n                }\n            }\n            file.withWriter { writer ->\n                writer.append(sw.toString())\n            }\n        }else{\n            def lines = file.readLines()\n            def lengths = lines.size() - 1\n            file.withWriter { writer ->\n                lines.eachWithIndex{ String line, int index ->\n                    if(index != lengths){\n                        writer.append(line +\"\\r\\n\")\n                    }else if(index == lengths){\n                        writer.append(\"\\r\\n\" + sw.toString()+\"\\r\\n\")\n                        writer.append(lines.get(lengths))\n                    }\n                }\n            }\n\n        }\n    }\n}\n\ntask readTask{\n    inputs.file destFile\n    doLast{\n        def file = inputs.files.singleFile\n        println file.text\n    }\n}\n\ntask taskTest{\n    dependsOn readTask,writerTask\n    doLast{\n        println \"输入输出任务结束\"\n    }\n}\n~~~\ndestFile作为writerTask输出结果输入到readTask\n* 通过API指定执行顺序：mustRunAfter／shouldRunAfter\n~~~\ntask t1() { doLast{println 'task t1'} }\ntask t2() { mustRunAfter t1 doLast {println 'task t2'} }\n~~~\n通过./gradlew t2 t1查看执行结果\n4. Task类型\n详见官方文档：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete\n5. 构建到生命周期\n~~~\nthis.project.afterEvaluate {project ->\n    println \"开始挂接...\"\n    def buildTask = project.tasks.getByName(\"build\")\n    if(buildTask == null) throw GradleException(\"build Task not found\")\n    buildTask.doLast {\n        writerTask.execute()\n    }\n}\n~~~\n\n# Gradle其他模块\n1. Settings类：对应Settings.gradle\n~~~\nif(hasProperty('isLoadTest')? isLoadTest.toBoolean() : false){\n    include ':Test'\n}\n~~~\n2. SourceSet类:AndroidSourceSet/JavaSourceSet,决定了代码、资源、第三方库要存放的位置\n~~~\n//修改.so等jnilibs的存放位置\nandroid{\n    sourceSets {\n        main{\n            jniLibs.srcDirs = ['libs']\n            res.srcDirs = ['src/main/res','src/main/res-ad']    //对res文件夹内容进行分类，但是只能在Project视图查看到效果\n        }\n    }\n}\n~~~\n3. Gradle的Plugin\n* Gradle没有提供创建自定义Gradle插件工程的模板，需要开发者手动创建Gradle插件工程\n* 使用Groovy开发，其Gradle插件工程必须遵循如下的目录结构：\n groovy代码必须位于xxxProject/src/main/groovy/目录下\n提供插件属性声明文件，该文件必须位于xxxProject/src/main/resources/META-INF/gradle-plugins/xxx.properties\n\n\n4. android插件对gradle的扩展\nandroid具体能配置那些属性，可查看源码通过BaseExtension查看\n\ngradle插件： https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html\n\nvarints变体\n\n\n\n\n\n\n","slug":"移动开发-Gradle3-0自动化项目构建技术","published":1,"updated":"2019-02-14T02:28:44.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue5a00eo5b8h3mfdhj8z","content":"<h1 id=\"groovy快速入门\"><a class=\"markdownIt-Anchor\" href=\"#groovy快速入门\"></a> Groovy快速入门</h1>\n<p>领域特定语言DSL（Domain  Specific Language）：其核心思想为&quot;求专不求全，解决特定问题&quot;，</p>\n<p>Groovy： <a href=\"http://www.groovy-lang.org/\" target=\"_blank\" rel=\"noopener\">http://www.groovy-lang.org/</a><br>\nGroovy：是一种基于JVM的敏捷开发语言，结合了Python、Ruby等脚本语言的许多强大特性，可以与Java完美结合，使用Java的所有库；</p>\n<ol>\n<li>语法上支持动态类型，闭包等新一代语言特性</li>\n<li>无缝继承所有Java的库（可以完全用Java写，但是不推荐）</li>\n<li>即支持面向对象编程，也支持面向过程编程</li>\n</ol>\n<p>优势：一种更加敏捷的编程语言；入门非常容易，但是功能非常强大；既可以作为编程语言也可以作为脚本语言；熟练掌握Java的人会非常容易掌握Groovy</p>\n<p>Groovy开发环境搭建：</p>\n<blockquote>\n<p>java平台上有各种语言的翻版，例如kotlin对c#,scala对haskell,Clojure对lisp，groovy对ruby</p>\n</blockquote>\n<h2 id=\"macoslinux\"><a class=\"markdownIt-Anchor\" href=\"#macoslinux\"></a> macOS/Linux</h2>\n<ol>\n<li>安装配置好JDK</li>\n<li>下载Groovy SDK并解压到合适未知</li>\n<li>配置bin目录到<sub>/.bash_profile中，如添加如下内容到</sub>/.bash_profile</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:/usr/groovy-2.5.5/bin</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>groovy -version</li>\n</ol>\n<h2 id=\"intelij-idea配置\"><a class=\"markdownIt-Anchor\" href=\"#intelij-idea配置\"></a> InteliJ IDEA配置</h2>\n<ol>\n<li>确保已安装Groovy插件</li>\n<li>配置Groovy SDK未知<br>\n<img src=\"/pub-images/Intelij%20Groovy.png\" alt=\"image\"></li>\n<li>编写Groovy版本HelloWorld，注意查看编译后文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Java版本</span><br><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">        System.out.println(&quot;Hello world&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Groovy版本</span><br><span class=\"line\">print &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"groovy基础语法\"><a class=\"markdownIt-Anchor\" href=\"#groovy基础语法\"></a> Groovy基础语法</h1>\n<ol>\n<li>变量</li>\n</ol>\n<ul>\n<li>变量的类型：基本类型+对象类型，Groovy中没有基本类型，所有的基本类型都会被编译器包装成对象类型，如：int-&gt;Integer</li>\n<li>变量的定义：强类型定义方式+弱类型def定义方式，Groovy中如果变量的值可以推断除其类型，则可通过def声明为弱类型，区别于java中的强类型定义方式，如：int i=1；</li>\n<li>推荐在自有使用模块使用def方式定义，如果有其他模块或其他类使用推荐强类型定义方式</li>\n</ul>\n<ol start=\"2\">\n<li>字符串：String + GString<br>\nString的使用和Java中一致，GString定义方式如下：</li>\n</ol>\n<ul>\n<li>def name = ‘Hello name’ //不支持可扩展字符串</li>\n<li>def doubleName = “Hello doubleName” //可扩展字符串，如：def doubleName = “Hello doubleName and ${name}”,结果为： Hello doubleName and Hello name，此时doubleName是org.codehaus.groovy.runtime.GStringImpl的子类</li>\n<li>def thupleName  = ‘’‘Hello thupleName’’’  //支持多行方式</li>\n</ul>\n<p>无可扩展字符串时以上3种方式的String都是java.lang.String的子类，编码过程中String和GString是可以通用的，更多从方便使用角度考虑即可</p>\n<p>Groovy字符串方法介绍</p>\n<ul>\n<li>java中String原有的方法</li>\n<li>DefalutGroovyMethods</li>\n<li>StringGroovyMethods：普通类型的参数+闭包类型的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def str = &quot;Groovy&quot;，str2 = &quot;Hello&quot;,str3= &quot;Hello minus&quot;</span><br><span class=\"line\">//字符串填充:center(),paddingLeft(),paddingRight()</span><br><span class=\"line\">println str.center(8,&apos;a&apos;)       //aGroovya</span><br><span class=\"line\">//字符串比较：类似于数字比较；compareTo()</span><br><span class=\"line\">println str &gt; str2  //false</span><br><span class=\"line\">//获取字符串索引:类似于数组下标；charAt()</span><br><span class=\"line\">println str[0..1]   //Gr</span><br><span class=\"line\">//减法运算:类似于数字减法；minus()</span><br><span class=\"line\">println str3.minus(str2)    // minus</span><br><span class=\"line\">//其他方法自己摸索</span><br></pre></td></tr></table></figure>\n<p>逻辑控制：单步顺序执行|if／else|switch-case|while|for，基本和Java操作一致，针对Groovy扩展介绍如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//switch-case</span><br><span class=\"line\">def x=1.23,result</span><br><span class=\"line\">switch(x)&#123;  //switch(x.class)</span><br><span class=\"line\">    case &quot;name&quot;:</span><br><span class=\"line\">        result = &quot;name&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case Integer:</span><br><span class=\"line\">        result = &quot;Integer&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case BigDecimal:</span><br><span class=\"line\">        result = &quot;BigDecimal&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case [1,2,3]:       //列表</span><br><span class=\"line\">        result = &quot;list&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case 1..10:         //范围</span><br><span class=\"line\">        result = &quot;range&quot;    </span><br><span class=\"line\">    default:</span><br><span class=\"line\">        result=&quot;defalut&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println result  //BigDecimal</span><br></pre></td></tr></table></figure>\n<p>for循环控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//对范围的for循环</span><br><span class=\"line\">def sum =0</span><br><span class=\"line\">for(i in 0..9)&#123;</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println sum //45</span><br><span class=\"line\">//对list的for循环</span><br><span class=\"line\">for(i in [1,2,3,4,5])&#123;</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//对map的for循环</span><br><span class=\"line\">for(i in [&quot;lili&quot;:1,&quot;lucy&quot;:2])&#123;</span><br><span class=\"line\">    println i.key + &quot;:&quot; +i.value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>闭包</li>\n</ol>\n<ul>\n<li>闭包就是一个代码块，所以需要通过{}括起来，def clouser = { println “Hello Groovy!”};clouser.call();clouser();  //推荐call()方式调用来区分是闭包</li>\n<li>def clouser = {String name -&gt; println “Hello Groovy ${name}!”};clouser.call(“a”);clouser(“b”);</li>\n<li>隐式参数it：def clouser = {println “Hello Groovy ${it}!”};clouser.call(“a”);clouser(“b”);</li>\n<li>闭包返回值：总是有返回值的，当闭包体没有明确返回值的时候，返回结果就是null</li>\n<li>如果最后一个参数是闭包，闭包可以写在外面</li>\n</ul>\n<p>闭包的使用</p>\n<ul>\n<li>与基本类型的结合使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int fab1(int number)&#123;</span><br><span class=\"line\">    int result = 1</span><br><span class=\"line\">    1.upto(number,&#123;num -&gt; result *= num  &#125;)</span><br><span class=\"line\">    return  result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int fab2(int number)&#123;</span><br><span class=\"line\">    int result = 1</span><br><span class=\"line\">    number.downto(1) &#123;</span><br><span class=\"line\">        num -&gt; result *= num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return  result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int cal(int number)&#123;</span><br><span class=\"line\">    int result = 0</span><br><span class=\"line\">    number.times &#123;</span><br><span class=\"line\">        num -&gt; result += num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>与String结合使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def str = &quot;the 2 and 3 is 5&quot;</span><br><span class=\"line\">str.each &#123;String tmp -&gt; print tmp.multiply(2)&#125;  //tthhee  22  aanndd  33  iiss  55</span><br><span class=\"line\">println str.find &#123;String tmp -&gt; tmp.isNumber()&#125; //2</span><br><span class=\"line\">println str.any &#123;String tmp -&gt; tmp.isNumber()&#125;  //true</span><br><span class=\"line\">println str.every &#123;String tmp -&gt; tmp.isNumber()&#125; //false</span><br><span class=\"line\">def list = str.collect &#123;it.toUpperCase()&#125;;println list.toListString()   //[T, H, E,  , 2,  , A, N, D,  , 3,  , I, S,  , 5]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>与数据结构结合使用</li>\n<li>与文件等结合使用</li>\n<li>闭包进阶：闭包关键字（this，owner，delegate）+闭包委托策略</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def scriptClosure = &#123;</span><br><span class=\"line\">    println &quot;scriptClosure this:&quot;+this          //代表闭包定义处的类</span><br><span class=\"line\">    println &quot;scriptClosure owner:&quot;+owner        //代表闭包定义处的类或对象</span><br><span class=\"line\">    println &quot;scriptClosure delegate:&quot;+delegate  //代表任意对象，默认值为owner</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">scriptClosure.call()</span><br><span class=\"line\"></span><br><span class=\"line\">//scriptClosure this:Test@3c130745</span><br><span class=\"line\">//scriptClosure owner:Test@3c130745</span><br><span class=\"line\">//scriptClosure delegate:Test@3c130745</span><br><span class=\"line\"></span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    def static classClosure = &#123;</span><br><span class=\"line\">        println &quot;classClosure this:&quot;+this</span><br><span class=\"line\">        println &quot;classClosure owner:&quot;+owner</span><br><span class=\"line\">        println &quot;classClosure delegate:&quot;+delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    def static say()&#123;</span><br><span class=\"line\">        def methodClosure = &#123;</span><br><span class=\"line\">            println &quot;methodClosure this:&quot;+this</span><br><span class=\"line\">            println &quot;methodClosure owner:&quot;+owner</span><br><span class=\"line\">            println &quot;methodClosure delegate:&quot;+delegate</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        methodClosure.call()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//静态方法调用</span><br><span class=\"line\">Person.classClosure()</span><br><span class=\"line\">Person.say()</span><br><span class=\"line\">//全部指向Person类,闭包指向离他最近的封闭类</span><br><span class=\"line\">//classClosure this:class Person</span><br><span class=\"line\">//classClosure owner:class Person</span><br><span class=\"line\">//classClosure delegate:class Person</span><br><span class=\"line\">//methodClosure this:class Person</span><br><span class=\"line\">//methodClosure owner:class Person</span><br><span class=\"line\">//methodClosure delegate:class Person</span><br><span class=\"line\"></span><br><span class=\"line\">//修改Person类中方法，取消static限定符调用</span><br><span class=\"line\">Person p = new Person()</span><br><span class=\"line\">p.classClosure()</span><br><span class=\"line\">p.say()</span><br><span class=\"line\">//全部指向Person类对象，闭包指向离他最近的封闭类对象</span><br><span class=\"line\">classClosure this:Person@a9cd3b1</span><br><span class=\"line\">classClosure owner:Person@a9cd3b1</span><br><span class=\"line\">classClosure delegate:Person@a9cd3b1</span><br><span class=\"line\">methodClosure this:Person@a9cd3b1</span><br><span class=\"line\">methodClosure owner:Person@a9cd3b1</span><br><span class=\"line\">methodClosure delegate:Person@a9cd3b1</span><br><span class=\"line\"></span><br><span class=\"line\">//嵌套闭包</span><br><span class=\"line\">def outerClosure = &#123;</span><br><span class=\"line\">    def innerClosure = &#123;</span><br><span class=\"line\">        println &quot;innerClosure this:&quot;+this</span><br><span class=\"line\">        println &quot;innerClosure owner:&quot;+owner</span><br><span class=\"line\">        println &quot;innerClosure delegate:&quot;+delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    innerClosure.call()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outerClosure.call()</span><br><span class=\"line\"></span><br><span class=\"line\">//innerClosure this:Test@3c130745</span><br><span class=\"line\">//innerClosure owner:Test$_run_closure7@9353778 //指向outerClosure</span><br><span class=\"line\">//innerClosure delegate:Test$_run_closure7@9353778</span><br></pre></td></tr></table></figure>\n<p>总结：this、owner、delegate的值在大多数情况都是一样的，在嵌套闭包中this的值和owner、delegate的值不一致，只有在给delegate赋值后owner和delegate的值才不一致</p>\n<p>闭包的委托策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student&#123;</span><br><span class=\"line\">    String name</span><br><span class=\"line\">    def sayName = &#123; &quot;My name is $&#123;name&#125;&quot;&#125;</span><br><span class=\"line\">    String toString()&#123;</span><br><span class=\"line\">        sayName.call()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">    String name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def stu = new Student(name: &quot;XingFeng&quot;)</span><br><span class=\"line\">println stu.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">def tea = new Teacher(name: &quot;Lily&quot;)</span><br><span class=\"line\">stu.sayName.delegate = tea</span><br><span class=\"line\">println stu.toString()</span><br><span class=\"line\">stu.sayName.resolveStrategy = Closure.DELEGATE_FIRST    //先从delegate中查找name属性，没有了再从owner中查找</span><br><span class=\"line\">println stu.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">//My name is XingFeng</span><br><span class=\"line\">//My name is XingFeng</span><br><span class=\"line\">//My name is Lily</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>数据结构<br>\n列表的定义：def list = [1,2,3,4] 此为一个ArrayList；<br>\n数组的定义：def list = [1,2,3,4] as int[]; int[] arr=[1,2,3]<br>\n列表的排序：def list = [1,12,3,444]; Collections.sort(list);list.sort()</li>\n</ol>\n<p>map的定义：def colors=[“red”:1,“blue”:2];def colors=[red:1,blue:2]<br>\n索引map：println colors.red;println colors[“red”];<br>\n添加map：colors.yellow=3 //Groovy中map可以添加不同类型的数据：colors.complex =[a:1,b:2]<br>\n遍历map： list.each{def tmp,int index -&gt; …}  list.eachWithIndex{ key,value,index -&gt; …}<br>\n查找map： any  find  findAll every<br>\n分组map： groupBy{}<br>\n排序map：sort</p>\n<p>范围Range：定义 def range = 1…10;println range[0];range.contains(10);println range.from;println <a href=\"http://range.to\" target=\"_blank\" rel=\"noopener\">range.to</a><br>\nRange继承自java.util.List</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(number)&#123;</span><br><span class=\"line\">    case 0..&lt;60</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>面向对象<br>\n类、接口等的定义和使用</li>\n</ol>\n<ul>\n<li>Groovy中默认类、方法等都是public类型</li>\n<li>Groovy中无论是直接调用属性还是通过get／set方法其实质都是通过getter／setter方法调用的属性，getter／setter方法默认自动继承</li>\n<li>接口实现需实现接口的所有方法；trait中可以有默认方法实现，没有实现的方法需添加abstract关键字，实现时只需实现abstract的方法即可</li>\n</ul>\n<blockquote>\n<p>元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射</p>\n</blockquote>\n<blockquote>\n<p>元编程通常有两种方式起作用。一种方式是通过应用程序接口（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。</p>\n</blockquote>\n<p><img src=\"/pub-images/Groovy%E5%85%83%E7%BC%96%E7%A8%8B.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Baby &#123;</span><br><span class=\"line\">    def invokeMethod(String name,Object args)&#123;</span><br><span class=\"line\">        return &quot;the method is $&#123;name&#125;,the args is $&#123;args&#125;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    def methodMissing(String name,Object args)&#123;</span><br><span class=\"line\">        return &quot;the method  $&#123;name&#125; is missing&#125;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def baby = new Baby()</span><br><span class=\"line\">println baby.cry()</span><br></pre></td></tr></table></figure>\n<p>结合上图理解：Java中对象方法的调用没有上图否流程分支，在Groovy中对象方法调用有否分支调用，上例中通过注释invokeMethod、methodMissing方法查看运行效果，通过以下代码可动态添加对象属性和方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Baby.metaClass.sex = &quot;male&quot;</span><br><span class=\"line\">Baby.metaClass.play = &#123; ... &#125;</span><br><span class=\"line\">Baby.metaClass.static.play = &#123; ... &#125;    //静态方法</span><br></pre></td></tr></table></figure>\n<p>通过ExpandoMetaClass.enableGlobally()设置让动态添加方法全局启用</p>\n<ol start=\"6\">\n<li>Json操作</li>\n</ol>\n<ul>\n<li>对象转换成JSON字符串：JsonOutput.toJson()</li>\n<li>Json格式化打印：JsonOutput.prettyPrint(jsonObject)</li>\n<li>Json字符串转对象：def jsonSlurper = new JsonSlurper();jsonSlurper.parse()</li>\n</ul>\n<ol start=\"7\">\n<li>xml操作</li>\n</ol>\n<ul>\n<li>Java对xml的处理：DOM文档驱动处理方式+SAX事件驱动处理方式</li>\n<li>Groovy解析xml数据：def xmlSlurper = new XmlSlurper();def response = xmlSlurper.parse(xml); ／／response对象可以逐级访问节点，节点的属性添加@符号，如：response.books.@id，也可以通过闭包过滤信息</li>\n<li>Groovy深度遍历xml：可以通过逐级遍历解析后的response数据，也可通过response.depFirst().find{ …}遍历或 response.’<strong>’.find{ …}遍历（’</strong>'代表深度遍历）</li>\n<li>Groovy深度遍历xml：response.books.children().find{…}或response.books.’<em>’.find{…}（’</em>'代表深度遍历）</li>\n<li>Groovy创建xml数据：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">&lt;langs type=&apos;current&apos; count=&apos;3&apos;&gt;</span><br><span class=\"line\">    &lt;language flavor=&apos;static&apos; version=&apos;1.5&apos; /&gt;</span><br><span class=\"line\">    &lt;language flavor=&apos;public&apos; version=&apos;2.5&apos; /&gt;</span><br><span class=\"line\">&lt;/langs&gt;</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">def sw = new StringWriter()</span><br><span class=\"line\">def xmlBuilder = new MarkupBuilder(sw)</span><br><span class=\"line\">xmlBuilder.langs(type:&apos;current&apos;,count:3)&#123;</span><br><span class=\"line\">    language(flavor:&apos;static&apos;,version:&apos;1.5&apos;)</span><br><span class=\"line\">    language(flavor:&apos;public&apos;,version:&apos;2.5&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println sw</span><br><span class=\"line\"></span><br><span class=\"line\">def langs = new Langs()</span><br><span class=\"line\">xmlBuilder.langs(type:langs.type,count:langs.count)&#123;</span><br><span class=\"line\">     langs.languages.each &#123;</span><br><span class=\"line\">         language(flavor:it.flavor,version:it.version)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println sw</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>文件操作</li>\n</ol>\n<ul>\n<li>Java文件处理：节点流（InputStream、OutputStream及其子类）+处理流（Reader、Writer及其子类），所有Java对文件的操作Groovy都支持</li>\n<li>遍历文件内容：def file = new File(“Test.iml”);file.eachLine { println it } 或 def text = file.getText() 或 def text = file.readLines() …</li>\n</ul>\n<h1 id=\"gradle\"><a class=\"markdownIt-Anchor\" href=\"#gradle\"></a> gradle</h1>\n<p>Gradle是一款最新的，功能强大的构建工具，使用程序代替传统的xml配置，项目构建更加灵活，有丰富的第三方库</p>\n<p>gradle组成：groovy核心语法+build script block+gradle api</p>\n<h2 id=\"gradle生命周期\"><a class=\"markdownIt-Anchor\" href=\"#gradle生命周期\"></a> gradle生命周期</h2>\n<p>执行./gradlew clean 观察执行过程，其生命周期包括：初始化、配置、执行<br>\n<img src=\"/pub-images/gradle%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"image\"></p>\n<h2 id=\"gradle生命周期的监听\"><a class=\"markdownIt-Anchor\" href=\"#gradle生命周期的监听\"></a> gradle生命周期的监听</h2>\n<p>在项目的build.gradle中添加如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在配置阶段开始之前的回调</span><br><span class=\"line\">this.beforeEvaluate &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//配置阶段完成以后的回调</span><br><span class=\"line\">this.afterEvaluate &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//gradle生命周期执行完以后的回调</span><br><span class=\"line\">this.gradle.buildFinished &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"gradle-project\"><a class=\"markdownIt-Anchor\" href=\"#gradle-project\"></a> Gradle Project</h1>\n<p>./gradlew projects //查看工程Project数量，学会区分Project与module及根Project与子Project，每个Project必须有一个build.gradle文件</p>\n<p>Project API组成：</p>\n<ol>\n<li>Project相关API：如何管理父Project及如何操作子Project</li>\n</ol>\n<ul>\n<li>this.getAllProjects()，this.getSubProjects(),this.getParent()，在gradl文件中，对应allprojects、project、subprojects进行操作</li>\n</ul>\n<p>./gradlew projects可实现显示所有项目，自我实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def getProjects()&#123;</span><br><span class=\"line\">    println &quot;------------------------&quot;</span><br><span class=\"line\">    this.getAllprojects().eachWithIndex&#123; Project project, int index -&gt;</span><br><span class=\"line\">        if(index == 0)&#123;</span><br><span class=\"line\">            println &quot;Root project:$&#123;project.name&#125;&quot;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            println &quot;+--- project:$&#123;project.name&#125;&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">this.getProjects()</span><br><span class=\"line\"></span><br><span class=\"line\">//------------------------</span><br><span class=\"line\">//Root project:MyApplication</span><br><span class=\"line\">//+--- project:app</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>task相关API</p>\n</li>\n<li>\n<p>属性相关API</p>\n</li>\n</ol>\n<ul>\n<li>父Project的属性在子项目中会被继承，可直接使用</li>\n<li>可以在项目中通过common.gradle文件来定义扩展属性ext，然后在根Project中通过apply from:this.file(‘common.gradle’)引入后，按rootProject.ext.定义属性的方式使用</li>\n<li>在gradle.properties中定义key-value属性，如：isLoadTest=false，然后在settings.gradle中就可以编码控制是否加载Test项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123;</span><br><span class=\"line\">    include &apos;:Test&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义属性的两种方式：ext方式+gradle.properties中定义<br>\n4. file相关API</p>\n<ul>\n<li>路径获取API：getRootdir()、getBuildDir()、getProjectDir()</li>\n<li>文件操作相关API：都是基于根工程操作的，不支持跨工程操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//文件／文件夹拷贝</span><br><span class=\"line\">copy &#123;</span><br><span class=\"line\">   from file(&apos;test.txt&apos;)</span><br><span class=\"line\">   into getRootProject().getBuildDir()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//文件树遍历</span><br><span class=\"line\">fileTree(&apos;build/&apos;)&#123;</span><br><span class=\"line\">    FileTree fileTree -&gt; fileTree.visit&#123; FileTreeElement element -&gt; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>gradle生命周期API</p>\n</li>\n<li>\n<p>其他API</p>\n</li>\n</ol>\n<ul>\n<li>依赖相关API</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:3.2.1&apos; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等价于以下操作：</span><br><span class=\"line\">buildscript &#123; ScriptHandler scriptHandler -&gt;</span><br><span class=\"line\">    scriptHandler.repositories &#123;  RepositoryHandler repositoryHandler -&gt;</span><br><span class=\"line\">        repositoryHandler.google()</span><br><span class=\"line\">        repositoryHandler.jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scriptHandler.dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:3.2.1&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依赖传递：A模块依赖B模块，B模块依赖C模块，如果A模块也需要C模块功能，不需依赖使用，防止B修改后去掉C依赖而导致错误，可在A中引入C模块，通过exclude排除依赖，transitive禁止依赖传递</p>\n<p>占位编译provided：A.类库只在编译阶段起作用 B.父项目已引入类库，子项目直接使用父项目类库，但为了子项目编译通过使用占位编译</p>\n<ul>\n<li>外部命令执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task abc() &#123;</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def command = &apos;ls&apos;</span><br><span class=\"line\">        exec&#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                executable &apos;bash&apos;</span><br><span class=\"line\">                args &apos;-c&apos;,command</span><br><span class=\"line\">                println &apos;command is execute success.&apos;</span><br><span class=\"line\">            &#125;catch(GradleException ex)&#123;</span><br><span class=\"line\">                println &quot;Excepiotn....&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行：./gradlew abc</p>\n<h1 id=\"task\"><a class=\"markdownIt-Anchor\" href=\"#task\"></a> Task</h1>\n<ol>\n<li>Task定义及配置<br>\n直接通过task函数去创建</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task(&quot;abcd&quot;) &#123;</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def command = &apos;ls -al&apos;</span><br><span class=\"line\">        exec&#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                executable &apos;bash&apos;</span><br><span class=\"line\">                args &apos;-c&apos;,command</span><br><span class=\"line\">                println &apos;command is execute success.&apos;</span><br><span class=\"line\">            &#125;catch(GradleException ex)&#123;</span><br><span class=\"line\">                println &quot;Excepiotn....&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过TaskContainer创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.tasks.create(&quot;aa&quot;)&#123;</span><br><span class=\"line\">    println &apos;Hello task&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Task创建之后可在开发工具的gradle插件重查找到task，如果没有设置group，则默认在other分组中，更多配置可通过task源码查看<br>\n2. Task执行详解<br>\ndoFirst/doLast执行阶段执行，否则在配置阶段执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task aa&#123;</span><br><span class=\"line\">    doFirst&#123;</span><br><span class=\"line\">        println &apos;Hello  2&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task.doFirst&#123;</span><br><span class=\"line\">    println &apos;Hello  1&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Hello  1</span><br><span class=\"line\">//Hello  2</span><br></pre></td></tr></table></figure>\n<p>编写一个统计build时长的task<br>\napp.gradle中编写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def startBuilderTime,endBuilderTime</span><br><span class=\"line\">this.afterEvaluate &#123; Project project -&gt;</span><br><span class=\"line\">    def preBuildTask = this.tasks.getByName(&quot;preBuild&quot;)</span><br><span class=\"line\">    preBuildTask.doFirst &#123;</span><br><span class=\"line\">        startBuilderTime = System.currentTimeMillis()</span><br><span class=\"line\">        println &apos;------开始计时...&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    def buildTask = this.tasks.getByName(&quot;build&quot;)</span><br><span class=\"line\">    buildTask.doLast &#123;</span><br><span class=\"line\">        endBuilderTime = System.currentTimeMillis()</span><br><span class=\"line\">        println &apos;------计时结束,耗时：&apos;+(endBuilderTime - startBuilderTime)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>./gradlew build执行查看结果<br>\n3. Task的依赖及执行顺序</p>\n<ul>\n<li>dependsOn强依赖方式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;</span><br><span class=\"line\">task t2() &lt;&lt; &#123; println &apos;task t2&apos; &#125;      //此处&quot;&lt;&lt;&quot;等同于doLast</span><br><span class=\"line\">task t3(dependsOn:[t1,t2]) &#123; doLast&#123;println &apos;task t3&apos;&#125; &#125;</span><br><span class=\"line\">task t4() &#123; dependsOn this.tasks.findAll &#123; task -&gt; return task.name.equals(&quot;t2&quot;)&#125;;doLast&#123;println &apos;task t4&apos;&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//./gradlew t3: (t1和t2执行顺序是随机的)</span><br><span class=\"line\">//task t1</span><br><span class=\"line\">//task t2</span><br><span class=\"line\">//task t3</span><br><span class=\"line\"></span><br><span class=\"line\">//./gradlew t4</span><br><span class=\"line\">//task t2</span><br><span class=\"line\">//task t4</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过Task输入输出指定<br>\nTaskInputs:参数为任意对象及文件、文件夹；TaskOutputs:只输出文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext&#123;</span><br><span class=\"line\">    println &apos;------配置中...&apos;</span><br><span class=\"line\">    versionCode = 100</span><br><span class=\"line\">    versionName = &quot;V2.0.0&quot;</span><br><span class=\"line\">    versionInfo = &quot;第一个版本&quot;</span><br><span class=\"line\">    destFile = file(&quot;release.xml&quot;)</span><br><span class=\"line\">    if(destFile != null &amp;&amp; !destFile.exists())&#123;</span><br><span class=\"line\">        destFile.createNewFile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class VersionMsg&#123;</span><br><span class=\"line\">    Integer versionCode</span><br><span class=\"line\">    String versionName</span><br><span class=\"line\">    String versionInfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task writerTask&#123;</span><br><span class=\"line\">    //为task指定输入</span><br><span class=\"line\">    inputs.property(&quot;versionCode&quot;,this.versionCode)</span><br><span class=\"line\">    inputs.property(&quot;versionName&quot;,this.versionName)</span><br><span class=\"line\">    inputs.property(&quot;versionInfo&quot;,this.versionInfo)</span><br><span class=\"line\">    //为task指定输出</span><br><span class=\"line\">    outputs.file destFile</span><br><span class=\"line\"></span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def data = inputs.getProperties()</span><br><span class=\"line\">        File file = outputs.getFiles().getSingleFile()</span><br><span class=\"line\">        def versionMsg = new VersionMsg(data)</span><br><span class=\"line\">        def sw = new StringWriter()</span><br><span class=\"line\">        def xmlBuilder = new groovy.xml.MarkupBuilder(sw)</span><br><span class=\"line\">        if(file.text != null &amp;&amp; file.text.size() &lt;=0)&#123;</span><br><span class=\"line\">            xmlBuilder.releases&#123;</span><br><span class=\"line\">                release&#123;</span><br><span class=\"line\">                    versionCode(versionMsg.versionCode)</span><br><span class=\"line\">                    versionName(versionMsg.versionName)</span><br><span class=\"line\">                    versionInfo(versionMsg.versionInfo)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            file.withWriter &#123; writer -&gt;</span><br><span class=\"line\">                writer.append(sw.toString())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            def lines = file.readLines()</span><br><span class=\"line\">            def lengths = lines.size() - 1</span><br><span class=\"line\">            file.withWriter &#123; writer -&gt;</span><br><span class=\"line\">                lines.eachWithIndex&#123; String line, int index -&gt;</span><br><span class=\"line\">                    if(index != lengths)&#123;</span><br><span class=\"line\">                        writer.append(line +&quot;\\r\\n&quot;)</span><br><span class=\"line\">                    &#125;else if(index == lengths)&#123;</span><br><span class=\"line\">                        writer.append(&quot;\\r\\n&quot; + sw.toString()+&quot;\\r\\n&quot;)</span><br><span class=\"line\">                        writer.append(lines.get(lengths))</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task readTask&#123;</span><br><span class=\"line\">    inputs.file destFile</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def file = inputs.files.singleFile</span><br><span class=\"line\">        println file.text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task taskTest&#123;</span><br><span class=\"line\">    dependsOn readTask,writerTask</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        println &quot;输入输出任务结束&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>destFile作为writerTask输出结果输入到readTask</p>\n<ul>\n<li>通过API指定执行顺序：mustRunAfter／shouldRunAfter</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;</span><br><span class=\"line\">task t2() &#123; mustRunAfter t1 doLast &#123;println &apos;task t2&apos;&#125; &#125;</span><br></pre></td></tr></table></figure>\n<p>通过./gradlew t2 t1查看执行结果<br>\n4. Task类型<br>\n详见官方文档：<a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete\" target=\"_blank\" rel=\"noopener\">https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete</a><br>\n5. 构建到生命周期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.project.afterEvaluate &#123;project -&gt;</span><br><span class=\"line\">    println &quot;开始挂接...&quot;</span><br><span class=\"line\">    def buildTask = project.tasks.getByName(&quot;build&quot;)</span><br><span class=\"line\">    if(buildTask == null) throw GradleException(&quot;build Task not found&quot;)</span><br><span class=\"line\">    buildTask.doLast &#123;</span><br><span class=\"line\">        writerTask.execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"gradle其他模块\"><a class=\"markdownIt-Anchor\" href=\"#gradle其他模块\"></a> Gradle其他模块</h1>\n<ol>\n<li>Settings类：对应Settings.gradle</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123;</span><br><span class=\"line\">    include &apos;:Test&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>SourceSet类:AndroidSourceSet/JavaSourceSet,决定了代码、资源、第三方库要存放的位置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//修改.so等jnilibs的存放位置</span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        main&#123;</span><br><span class=\"line\">            jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class=\"line\">            res.srcDirs = [&apos;src/main/res&apos;,&apos;src/main/res-ad&apos;]    //对res文件夹内容进行分类，但是只能在Project视图查看到效果</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Gradle的Plugin</li>\n</ol>\n<ul>\n<li>Gradle没有提供创建自定义Gradle插件工程的模板，需要开发者手动创建Gradle插件工程</li>\n<li>使用Groovy开发，其Gradle插件工程必须遵循如下的目录结构：<br>\ngroovy代码必须位于xxxProject/src/main/groovy/目录下<br>\n提供插件属性声明文件，该文件必须位于xxxProject/src/main/resources/META-INF/gradle-plugins/xxx.properties</li>\n</ul>\n<ol start=\"4\">\n<li>android插件对gradle的扩展<br>\nandroid具体能配置那些属性，可查看源码通过BaseExtension查看</li>\n</ol>\n<p>gradle插件： <a href=\"https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html\" target=\"_blank\" rel=\"noopener\">https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html</a></p>\n<p>varints变体</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"groovy快速入门\"><a class=\"markdownIt-Anchor\" href=\"#groovy快速入门\"></a> Groovy快速入门</h1>\n<p>领域特定语言DSL（Domain  Specific Language）：其核心思想为&quot;求专不求全，解决特定问题&quot;，</p>\n<p>Groovy： <a href=\"http://www.groovy-lang.org/\" target=\"_blank\" rel=\"noopener\">http://www.groovy-lang.org/</a><br>\nGroovy：是一种基于JVM的敏捷开发语言，结合了Python、Ruby等脚本语言的许多强大特性，可以与Java完美结合，使用Java的所有库；</p>\n<ol>\n<li>语法上支持动态类型，闭包等新一代语言特性</li>\n<li>无缝继承所有Java的库（可以完全用Java写，但是不推荐）</li>\n<li>即支持面向对象编程，也支持面向过程编程</li>\n</ol>\n<p>优势：一种更加敏捷的编程语言；入门非常容易，但是功能非常强大；既可以作为编程语言也可以作为脚本语言；熟练掌握Java的人会非常容易掌握Groovy</p>\n<p>Groovy开发环境搭建：</p>\n<blockquote>\n<p>java平台上有各种语言的翻版，例如kotlin对c#,scala对haskell,Clojure对lisp，groovy对ruby</p>\n</blockquote>\n<h2 id=\"macoslinux\"><a class=\"markdownIt-Anchor\" href=\"#macoslinux\"></a> macOS/Linux</h2>\n<ol>\n<li>安装配置好JDK</li>\n<li>下载Groovy SDK并解压到合适未知</li>\n<li>配置bin目录到<sub>/.bash_profile中，如添加如下内容到</sub>/.bash_profile</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:/usr/groovy-2.5.5/bin</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>groovy -version</li>\n</ol>\n<h2 id=\"intelij-idea配置\"><a class=\"markdownIt-Anchor\" href=\"#intelij-idea配置\"></a> InteliJ IDEA配置</h2>\n<ol>\n<li>确保已安装Groovy插件</li>\n<li>配置Groovy SDK未知<br>\n<img src=\"/pub-images/Intelij%20Groovy.png\" alt=\"image\"></li>\n<li>编写Groovy版本HelloWorld，注意查看编译后文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Java版本</span><br><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">        System.out.println(&quot;Hello world&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Groovy版本</span><br><span class=\"line\">print &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"groovy基础语法\"><a class=\"markdownIt-Anchor\" href=\"#groovy基础语法\"></a> Groovy基础语法</h1>\n<ol>\n<li>变量</li>\n</ol>\n<ul>\n<li>变量的类型：基本类型+对象类型，Groovy中没有基本类型，所有的基本类型都会被编译器包装成对象类型，如：int-&gt;Integer</li>\n<li>变量的定义：强类型定义方式+弱类型def定义方式，Groovy中如果变量的值可以推断除其类型，则可通过def声明为弱类型，区别于java中的强类型定义方式，如：int i=1；</li>\n<li>推荐在自有使用模块使用def方式定义，如果有其他模块或其他类使用推荐强类型定义方式</li>\n</ul>\n<ol start=\"2\">\n<li>字符串：String + GString<br>\nString的使用和Java中一致，GString定义方式如下：</li>\n</ol>\n<ul>\n<li>def name = ‘Hello name’ //不支持可扩展字符串</li>\n<li>def doubleName = “Hello doubleName” //可扩展字符串，如：def doubleName = “Hello doubleName and ${name}”,结果为： Hello doubleName and Hello name，此时doubleName是org.codehaus.groovy.runtime.GStringImpl的子类</li>\n<li>def thupleName  = ‘’‘Hello thupleName’’’  //支持多行方式</li>\n</ul>\n<p>无可扩展字符串时以上3种方式的String都是java.lang.String的子类，编码过程中String和GString是可以通用的，更多从方便使用角度考虑即可</p>\n<p>Groovy字符串方法介绍</p>\n<ul>\n<li>java中String原有的方法</li>\n<li>DefalutGroovyMethods</li>\n<li>StringGroovyMethods：普通类型的参数+闭包类型的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def str = &quot;Groovy&quot;，str2 = &quot;Hello&quot;,str3= &quot;Hello minus&quot;</span><br><span class=\"line\">//字符串填充:center(),paddingLeft(),paddingRight()</span><br><span class=\"line\">println str.center(8,&apos;a&apos;)       //aGroovya</span><br><span class=\"line\">//字符串比较：类似于数字比较；compareTo()</span><br><span class=\"line\">println str &gt; str2  //false</span><br><span class=\"line\">//获取字符串索引:类似于数组下标；charAt()</span><br><span class=\"line\">println str[0..1]   //Gr</span><br><span class=\"line\">//减法运算:类似于数字减法；minus()</span><br><span class=\"line\">println str3.minus(str2)    // minus</span><br><span class=\"line\">//其他方法自己摸索</span><br></pre></td></tr></table></figure>\n<p>逻辑控制：单步顺序执行|if／else|switch-case|while|for，基本和Java操作一致，针对Groovy扩展介绍如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//switch-case</span><br><span class=\"line\">def x=1.23,result</span><br><span class=\"line\">switch(x)&#123;  //switch(x.class)</span><br><span class=\"line\">    case &quot;name&quot;:</span><br><span class=\"line\">        result = &quot;name&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case Integer:</span><br><span class=\"line\">        result = &quot;Integer&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case BigDecimal:</span><br><span class=\"line\">        result = &quot;BigDecimal&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case [1,2,3]:       //列表</span><br><span class=\"line\">        result = &quot;list&quot;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    case 1..10:         //范围</span><br><span class=\"line\">        result = &quot;range&quot;    </span><br><span class=\"line\">    default:</span><br><span class=\"line\">        result=&quot;defalut&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println result  //BigDecimal</span><br></pre></td></tr></table></figure>\n<p>for循环控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//对范围的for循环</span><br><span class=\"line\">def sum =0</span><br><span class=\"line\">for(i in 0..9)&#123;</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println sum //45</span><br><span class=\"line\">//对list的for循环</span><br><span class=\"line\">for(i in [1,2,3,4,5])&#123;</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//对map的for循环</span><br><span class=\"line\">for(i in [&quot;lili&quot;:1,&quot;lucy&quot;:2])&#123;</span><br><span class=\"line\">    println i.key + &quot;:&quot; +i.value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>闭包</li>\n</ol>\n<ul>\n<li>闭包就是一个代码块，所以需要通过{}括起来，def clouser = { println “Hello Groovy!”};clouser.call();clouser();  //推荐call()方式调用来区分是闭包</li>\n<li>def clouser = {String name -&gt; println “Hello Groovy ${name}!”};clouser.call(“a”);clouser(“b”);</li>\n<li>隐式参数it：def clouser = {println “Hello Groovy ${it}!”};clouser.call(“a”);clouser(“b”);</li>\n<li>闭包返回值：总是有返回值的，当闭包体没有明确返回值的时候，返回结果就是null</li>\n<li>如果最后一个参数是闭包，闭包可以写在外面</li>\n</ul>\n<p>闭包的使用</p>\n<ul>\n<li>与基本类型的结合使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int fab1(int number)&#123;</span><br><span class=\"line\">    int result = 1</span><br><span class=\"line\">    1.upto(number,&#123;num -&gt; result *= num  &#125;)</span><br><span class=\"line\">    return  result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int fab2(int number)&#123;</span><br><span class=\"line\">    int result = 1</span><br><span class=\"line\">    number.downto(1) &#123;</span><br><span class=\"line\">        num -&gt; result *= num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return  result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int cal(int number)&#123;</span><br><span class=\"line\">    int result = 0</span><br><span class=\"line\">    number.times &#123;</span><br><span class=\"line\">        num -&gt; result += num</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>与String结合使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def str = &quot;the 2 and 3 is 5&quot;</span><br><span class=\"line\">str.each &#123;String tmp -&gt; print tmp.multiply(2)&#125;  //tthhee  22  aanndd  33  iiss  55</span><br><span class=\"line\">println str.find &#123;String tmp -&gt; tmp.isNumber()&#125; //2</span><br><span class=\"line\">println str.any &#123;String tmp -&gt; tmp.isNumber()&#125;  //true</span><br><span class=\"line\">println str.every &#123;String tmp -&gt; tmp.isNumber()&#125; //false</span><br><span class=\"line\">def list = str.collect &#123;it.toUpperCase()&#125;;println list.toListString()   //[T, H, E,  , 2,  , A, N, D,  , 3,  , I, S,  , 5]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>与数据结构结合使用</li>\n<li>与文件等结合使用</li>\n<li>闭包进阶：闭包关键字（this，owner，delegate）+闭包委托策略</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def scriptClosure = &#123;</span><br><span class=\"line\">    println &quot;scriptClosure this:&quot;+this          //代表闭包定义处的类</span><br><span class=\"line\">    println &quot;scriptClosure owner:&quot;+owner        //代表闭包定义处的类或对象</span><br><span class=\"line\">    println &quot;scriptClosure delegate:&quot;+delegate  //代表任意对象，默认值为owner</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">scriptClosure.call()</span><br><span class=\"line\"></span><br><span class=\"line\">//scriptClosure this:Test@3c130745</span><br><span class=\"line\">//scriptClosure owner:Test@3c130745</span><br><span class=\"line\">//scriptClosure delegate:Test@3c130745</span><br><span class=\"line\"></span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    def static classClosure = &#123;</span><br><span class=\"line\">        println &quot;classClosure this:&quot;+this</span><br><span class=\"line\">        println &quot;classClosure owner:&quot;+owner</span><br><span class=\"line\">        println &quot;classClosure delegate:&quot;+delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    def static say()&#123;</span><br><span class=\"line\">        def methodClosure = &#123;</span><br><span class=\"line\">            println &quot;methodClosure this:&quot;+this</span><br><span class=\"line\">            println &quot;methodClosure owner:&quot;+owner</span><br><span class=\"line\">            println &quot;methodClosure delegate:&quot;+delegate</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        methodClosure.call()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//静态方法调用</span><br><span class=\"line\">Person.classClosure()</span><br><span class=\"line\">Person.say()</span><br><span class=\"line\">//全部指向Person类,闭包指向离他最近的封闭类</span><br><span class=\"line\">//classClosure this:class Person</span><br><span class=\"line\">//classClosure owner:class Person</span><br><span class=\"line\">//classClosure delegate:class Person</span><br><span class=\"line\">//methodClosure this:class Person</span><br><span class=\"line\">//methodClosure owner:class Person</span><br><span class=\"line\">//methodClosure delegate:class Person</span><br><span class=\"line\"></span><br><span class=\"line\">//修改Person类中方法，取消static限定符调用</span><br><span class=\"line\">Person p = new Person()</span><br><span class=\"line\">p.classClosure()</span><br><span class=\"line\">p.say()</span><br><span class=\"line\">//全部指向Person类对象，闭包指向离他最近的封闭类对象</span><br><span class=\"line\">classClosure this:Person@a9cd3b1</span><br><span class=\"line\">classClosure owner:Person@a9cd3b1</span><br><span class=\"line\">classClosure delegate:Person@a9cd3b1</span><br><span class=\"line\">methodClosure this:Person@a9cd3b1</span><br><span class=\"line\">methodClosure owner:Person@a9cd3b1</span><br><span class=\"line\">methodClosure delegate:Person@a9cd3b1</span><br><span class=\"line\"></span><br><span class=\"line\">//嵌套闭包</span><br><span class=\"line\">def outerClosure = &#123;</span><br><span class=\"line\">    def innerClosure = &#123;</span><br><span class=\"line\">        println &quot;innerClosure this:&quot;+this</span><br><span class=\"line\">        println &quot;innerClosure owner:&quot;+owner</span><br><span class=\"line\">        println &quot;innerClosure delegate:&quot;+delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    innerClosure.call()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outerClosure.call()</span><br><span class=\"line\"></span><br><span class=\"line\">//innerClosure this:Test@3c130745</span><br><span class=\"line\">//innerClosure owner:Test$_run_closure7@9353778 //指向outerClosure</span><br><span class=\"line\">//innerClosure delegate:Test$_run_closure7@9353778</span><br></pre></td></tr></table></figure>\n<p>总结：this、owner、delegate的值在大多数情况都是一样的，在嵌套闭包中this的值和owner、delegate的值不一致，只有在给delegate赋值后owner和delegate的值才不一致</p>\n<p>闭包的委托策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student&#123;</span><br><span class=\"line\">    String name</span><br><span class=\"line\">    def sayName = &#123; &quot;My name is $&#123;name&#125;&quot;&#125;</span><br><span class=\"line\">    String toString()&#123;</span><br><span class=\"line\">        sayName.call()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Teacher&#123;</span><br><span class=\"line\">    String name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def stu = new Student(name: &quot;XingFeng&quot;)</span><br><span class=\"line\">println stu.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">def tea = new Teacher(name: &quot;Lily&quot;)</span><br><span class=\"line\">stu.sayName.delegate = tea</span><br><span class=\"line\">println stu.toString()</span><br><span class=\"line\">stu.sayName.resolveStrategy = Closure.DELEGATE_FIRST    //先从delegate中查找name属性，没有了再从owner中查找</span><br><span class=\"line\">println stu.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">//My name is XingFeng</span><br><span class=\"line\">//My name is XingFeng</span><br><span class=\"line\">//My name is Lily</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>数据结构<br>\n列表的定义：def list = [1,2,3,4] 此为一个ArrayList；<br>\n数组的定义：def list = [1,2,3,4] as int[]; int[] arr=[1,2,3]<br>\n列表的排序：def list = [1,12,3,444]; Collections.sort(list);list.sort()</li>\n</ol>\n<p>map的定义：def colors=[“red”:1,“blue”:2];def colors=[red:1,blue:2]<br>\n索引map：println colors.red;println colors[“red”];<br>\n添加map：colors.yellow=3 //Groovy中map可以添加不同类型的数据：colors.complex =[a:1,b:2]<br>\n遍历map： list.each{def tmp,int index -&gt; …}  list.eachWithIndex{ key,value,index -&gt; …}<br>\n查找map： any  find  findAll every<br>\n分组map： groupBy{}<br>\n排序map：sort</p>\n<p>范围Range：定义 def range = 1…10;println range[0];range.contains(10);println range.from;println <a href=\"http://range.to\" target=\"_blank\" rel=\"noopener\">range.to</a><br>\nRange继承自java.util.List</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(number)&#123;</span><br><span class=\"line\">    case 0..&lt;60</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>面向对象<br>\n类、接口等的定义和使用</li>\n</ol>\n<ul>\n<li>Groovy中默认类、方法等都是public类型</li>\n<li>Groovy中无论是直接调用属性还是通过get／set方法其实质都是通过getter／setter方法调用的属性，getter／setter方法默认自动继承</li>\n<li>接口实现需实现接口的所有方法；trait中可以有默认方法实现，没有实现的方法需添加abstract关键字，实现时只需实现abstract的方法即可</li>\n</ul>\n<blockquote>\n<p>元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射</p>\n</blockquote>\n<blockquote>\n<p>元编程通常有两种方式起作用。一种方式是通过应用程序接口（API）来暴露运行时引擎的内部信息。另一种方法是动态执行包含编程命令的字符串。因此，“程序能编写程序”。虽然两种方法都能用，但大多数方法主要靠其中一种。</p>\n</blockquote>\n<p><img src=\"/pub-images/Groovy%E5%85%83%E7%BC%96%E7%A8%8B.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Baby &#123;</span><br><span class=\"line\">    def invokeMethod(String name,Object args)&#123;</span><br><span class=\"line\">        return &quot;the method is $&#123;name&#125;,the args is $&#123;args&#125;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    def methodMissing(String name,Object args)&#123;</span><br><span class=\"line\">        return &quot;the method  $&#123;name&#125; is missing&#125;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def baby = new Baby()</span><br><span class=\"line\">println baby.cry()</span><br></pre></td></tr></table></figure>\n<p>结合上图理解：Java中对象方法的调用没有上图否流程分支，在Groovy中对象方法调用有否分支调用，上例中通过注释invokeMethod、methodMissing方法查看运行效果，通过以下代码可动态添加对象属性和方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Baby.metaClass.sex = &quot;male&quot;</span><br><span class=\"line\">Baby.metaClass.play = &#123; ... &#125;</span><br><span class=\"line\">Baby.metaClass.static.play = &#123; ... &#125;    //静态方法</span><br></pre></td></tr></table></figure>\n<p>通过ExpandoMetaClass.enableGlobally()设置让动态添加方法全局启用</p>\n<ol start=\"6\">\n<li>Json操作</li>\n</ol>\n<ul>\n<li>对象转换成JSON字符串：JsonOutput.toJson()</li>\n<li>Json格式化打印：JsonOutput.prettyPrint(jsonObject)</li>\n<li>Json字符串转对象：def jsonSlurper = new JsonSlurper();jsonSlurper.parse()</li>\n</ul>\n<ol start=\"7\">\n<li>xml操作</li>\n</ol>\n<ul>\n<li>Java对xml的处理：DOM文档驱动处理方式+SAX事件驱动处理方式</li>\n<li>Groovy解析xml数据：def xmlSlurper = new XmlSlurper();def response = xmlSlurper.parse(xml); ／／response对象可以逐级访问节点，节点的属性添加@符号，如：response.books.@id，也可以通过闭包过滤信息</li>\n<li>Groovy深度遍历xml：可以通过逐级遍历解析后的response数据，也可通过response.depFirst().find{ …}遍历或 response.’<strong>’.find{ …}遍历（’</strong>'代表深度遍历）</li>\n<li>Groovy深度遍历xml：response.books.children().find{…}或response.books.’<em>’.find{…}（’</em>'代表深度遍历）</li>\n<li>Groovy创建xml数据：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">&lt;langs type=&apos;current&apos; count=&apos;3&apos;&gt;</span><br><span class=\"line\">    &lt;language flavor=&apos;static&apos; version=&apos;1.5&apos; /&gt;</span><br><span class=\"line\">    &lt;language flavor=&apos;public&apos; version=&apos;2.5&apos; /&gt;</span><br><span class=\"line\">&lt;/langs&gt;</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">def sw = new StringWriter()</span><br><span class=\"line\">def xmlBuilder = new MarkupBuilder(sw)</span><br><span class=\"line\">xmlBuilder.langs(type:&apos;current&apos;,count:3)&#123;</span><br><span class=\"line\">    language(flavor:&apos;static&apos;,version:&apos;1.5&apos;)</span><br><span class=\"line\">    language(flavor:&apos;public&apos;,version:&apos;2.5&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println sw</span><br><span class=\"line\"></span><br><span class=\"line\">def langs = new Langs()</span><br><span class=\"line\">xmlBuilder.langs(type:langs.type,count:langs.count)&#123;</span><br><span class=\"line\">     langs.languages.each &#123;</span><br><span class=\"line\">         language(flavor:it.flavor,version:it.version)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println sw</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>文件操作</li>\n</ol>\n<ul>\n<li>Java文件处理：节点流（InputStream、OutputStream及其子类）+处理流（Reader、Writer及其子类），所有Java对文件的操作Groovy都支持</li>\n<li>遍历文件内容：def file = new File(“Test.iml”);file.eachLine { println it } 或 def text = file.getText() 或 def text = file.readLines() …</li>\n</ul>\n<h1 id=\"gradle\"><a class=\"markdownIt-Anchor\" href=\"#gradle\"></a> gradle</h1>\n<p>Gradle是一款最新的，功能强大的构建工具，使用程序代替传统的xml配置，项目构建更加灵活，有丰富的第三方库</p>\n<p>gradle组成：groovy核心语法+build script block+gradle api</p>\n<h2 id=\"gradle生命周期\"><a class=\"markdownIt-Anchor\" href=\"#gradle生命周期\"></a> gradle生命周期</h2>\n<p>执行./gradlew clean 观察执行过程，其生命周期包括：初始化、配置、执行<br>\n<img src=\"/pub-images/gradle%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"image\"></p>\n<h2 id=\"gradle生命周期的监听\"><a class=\"markdownIt-Anchor\" href=\"#gradle生命周期的监听\"></a> gradle生命周期的监听</h2>\n<p>在项目的build.gradle中添加如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在配置阶段开始之前的回调</span><br><span class=\"line\">this.beforeEvaluate &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//配置阶段完成以后的回调</span><br><span class=\"line\">this.afterEvaluate &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//gradle生命周期执行完以后的回调</span><br><span class=\"line\">this.gradle.buildFinished &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"gradle-project\"><a class=\"markdownIt-Anchor\" href=\"#gradle-project\"></a> Gradle Project</h1>\n<p>./gradlew projects //查看工程Project数量，学会区分Project与module及根Project与子Project，每个Project必须有一个build.gradle文件</p>\n<p>Project API组成：</p>\n<ol>\n<li>Project相关API：如何管理父Project及如何操作子Project</li>\n</ol>\n<ul>\n<li>this.getAllProjects()，this.getSubProjects(),this.getParent()，在gradl文件中，对应allprojects、project、subprojects进行操作</li>\n</ul>\n<p>./gradlew projects可实现显示所有项目，自我实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def getProjects()&#123;</span><br><span class=\"line\">    println &quot;------------------------&quot;</span><br><span class=\"line\">    this.getAllprojects().eachWithIndex&#123; Project project, int index -&gt;</span><br><span class=\"line\">        if(index == 0)&#123;</span><br><span class=\"line\">            println &quot;Root project:$&#123;project.name&#125;&quot;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            println &quot;+--- project:$&#123;project.name&#125;&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">this.getProjects()</span><br><span class=\"line\"></span><br><span class=\"line\">//------------------------</span><br><span class=\"line\">//Root project:MyApplication</span><br><span class=\"line\">//+--- project:app</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>task相关API</p>\n</li>\n<li>\n<p>属性相关API</p>\n</li>\n</ol>\n<ul>\n<li>父Project的属性在子项目中会被继承，可直接使用</li>\n<li>可以在项目中通过common.gradle文件来定义扩展属性ext，然后在根Project中通过apply from:this.file(‘common.gradle’)引入后，按rootProject.ext.定义属性的方式使用</li>\n<li>在gradle.properties中定义key-value属性，如：isLoadTest=false，然后在settings.gradle中就可以编码控制是否加载Test项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123;</span><br><span class=\"line\">    include &apos;:Test&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义属性的两种方式：ext方式+gradle.properties中定义<br>\n4. file相关API</p>\n<ul>\n<li>路径获取API：getRootdir()、getBuildDir()、getProjectDir()</li>\n<li>文件操作相关API：都是基于根工程操作的，不支持跨工程操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//文件／文件夹拷贝</span><br><span class=\"line\">copy &#123;</span><br><span class=\"line\">   from file(&apos;test.txt&apos;)</span><br><span class=\"line\">   into getRootProject().getBuildDir()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//文件树遍历</span><br><span class=\"line\">fileTree(&apos;build/&apos;)&#123;</span><br><span class=\"line\">    FileTree fileTree -&gt; fileTree.visit&#123; FileTreeElement element -&gt; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>gradle生命周期API</p>\n</li>\n<li>\n<p>其他API</p>\n</li>\n</ol>\n<ul>\n<li>依赖相关API</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:3.2.1&apos; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等价于以下操作：</span><br><span class=\"line\">buildscript &#123; ScriptHandler scriptHandler -&gt;</span><br><span class=\"line\">    scriptHandler.repositories &#123;  RepositoryHandler repositoryHandler -&gt;</span><br><span class=\"line\">        repositoryHandler.google()</span><br><span class=\"line\">        repositoryHandler.jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    scriptHandler.dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:3.2.1&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依赖传递：A模块依赖B模块，B模块依赖C模块，如果A模块也需要C模块功能，不需依赖使用，防止B修改后去掉C依赖而导致错误，可在A中引入C模块，通过exclude排除依赖，transitive禁止依赖传递</p>\n<p>占位编译provided：A.类库只在编译阶段起作用 B.父项目已引入类库，子项目直接使用父项目类库，但为了子项目编译通过使用占位编译</p>\n<ul>\n<li>外部命令执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task abc() &#123;</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def command = &apos;ls&apos;</span><br><span class=\"line\">        exec&#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                executable &apos;bash&apos;</span><br><span class=\"line\">                args &apos;-c&apos;,command</span><br><span class=\"line\">                println &apos;command is execute success.&apos;</span><br><span class=\"line\">            &#125;catch(GradleException ex)&#123;</span><br><span class=\"line\">                println &quot;Excepiotn....&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行：./gradlew abc</p>\n<h1 id=\"task\"><a class=\"markdownIt-Anchor\" href=\"#task\"></a> Task</h1>\n<ol>\n<li>Task定义及配置<br>\n直接通过task函数去创建</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task(&quot;abcd&quot;) &#123;</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def command = &apos;ls -al&apos;</span><br><span class=\"line\">        exec&#123;</span><br><span class=\"line\">            try&#123;</span><br><span class=\"line\">                executable &apos;bash&apos;</span><br><span class=\"line\">                args &apos;-c&apos;,command</span><br><span class=\"line\">                println &apos;command is execute success.&apos;</span><br><span class=\"line\">            &#125;catch(GradleException ex)&#123;</span><br><span class=\"line\">                println &quot;Excepiotn....&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过TaskContainer创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.tasks.create(&quot;aa&quot;)&#123;</span><br><span class=\"line\">    println &apos;Hello task&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Task创建之后可在开发工具的gradle插件重查找到task，如果没有设置group，则默认在other分组中，更多配置可通过task源码查看<br>\n2. Task执行详解<br>\ndoFirst/doLast执行阶段执行，否则在配置阶段执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task aa&#123;</span><br><span class=\"line\">    doFirst&#123;</span><br><span class=\"line\">        println &apos;Hello  2&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task.doFirst&#123;</span><br><span class=\"line\">    println &apos;Hello  1&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Hello  1</span><br><span class=\"line\">//Hello  2</span><br></pre></td></tr></table></figure>\n<p>编写一个统计build时长的task<br>\napp.gradle中编写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def startBuilderTime,endBuilderTime</span><br><span class=\"line\">this.afterEvaluate &#123; Project project -&gt;</span><br><span class=\"line\">    def preBuildTask = this.tasks.getByName(&quot;preBuild&quot;)</span><br><span class=\"line\">    preBuildTask.doFirst &#123;</span><br><span class=\"line\">        startBuilderTime = System.currentTimeMillis()</span><br><span class=\"line\">        println &apos;------开始计时...&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    def buildTask = this.tasks.getByName(&quot;build&quot;)</span><br><span class=\"line\">    buildTask.doLast &#123;</span><br><span class=\"line\">        endBuilderTime = System.currentTimeMillis()</span><br><span class=\"line\">        println &apos;------计时结束,耗时：&apos;+(endBuilderTime - startBuilderTime)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>./gradlew build执行查看结果<br>\n3. Task的依赖及执行顺序</p>\n<ul>\n<li>dependsOn强依赖方式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;</span><br><span class=\"line\">task t2() &lt;&lt; &#123; println &apos;task t2&apos; &#125;      //此处&quot;&lt;&lt;&quot;等同于doLast</span><br><span class=\"line\">task t3(dependsOn:[t1,t2]) &#123; doLast&#123;println &apos;task t3&apos;&#125; &#125;</span><br><span class=\"line\">task t4() &#123; dependsOn this.tasks.findAll &#123; task -&gt; return task.name.equals(&quot;t2&quot;)&#125;;doLast&#123;println &apos;task t4&apos;&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//./gradlew t3: (t1和t2执行顺序是随机的)</span><br><span class=\"line\">//task t1</span><br><span class=\"line\">//task t2</span><br><span class=\"line\">//task t3</span><br><span class=\"line\"></span><br><span class=\"line\">//./gradlew t4</span><br><span class=\"line\">//task t2</span><br><span class=\"line\">//task t4</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过Task输入输出指定<br>\nTaskInputs:参数为任意对象及文件、文件夹；TaskOutputs:只输出文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext&#123;</span><br><span class=\"line\">    println &apos;------配置中...&apos;</span><br><span class=\"line\">    versionCode = 100</span><br><span class=\"line\">    versionName = &quot;V2.0.0&quot;</span><br><span class=\"line\">    versionInfo = &quot;第一个版本&quot;</span><br><span class=\"line\">    destFile = file(&quot;release.xml&quot;)</span><br><span class=\"line\">    if(destFile != null &amp;&amp; !destFile.exists())&#123;</span><br><span class=\"line\">        destFile.createNewFile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class VersionMsg&#123;</span><br><span class=\"line\">    Integer versionCode</span><br><span class=\"line\">    String versionName</span><br><span class=\"line\">    String versionInfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task writerTask&#123;</span><br><span class=\"line\">    //为task指定输入</span><br><span class=\"line\">    inputs.property(&quot;versionCode&quot;,this.versionCode)</span><br><span class=\"line\">    inputs.property(&quot;versionName&quot;,this.versionName)</span><br><span class=\"line\">    inputs.property(&quot;versionInfo&quot;,this.versionInfo)</span><br><span class=\"line\">    //为task指定输出</span><br><span class=\"line\">    outputs.file destFile</span><br><span class=\"line\"></span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def data = inputs.getProperties()</span><br><span class=\"line\">        File file = outputs.getFiles().getSingleFile()</span><br><span class=\"line\">        def versionMsg = new VersionMsg(data)</span><br><span class=\"line\">        def sw = new StringWriter()</span><br><span class=\"line\">        def xmlBuilder = new groovy.xml.MarkupBuilder(sw)</span><br><span class=\"line\">        if(file.text != null &amp;&amp; file.text.size() &lt;=0)&#123;</span><br><span class=\"line\">            xmlBuilder.releases&#123;</span><br><span class=\"line\">                release&#123;</span><br><span class=\"line\">                    versionCode(versionMsg.versionCode)</span><br><span class=\"line\">                    versionName(versionMsg.versionName)</span><br><span class=\"line\">                    versionInfo(versionMsg.versionInfo)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            file.withWriter &#123; writer -&gt;</span><br><span class=\"line\">                writer.append(sw.toString())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            def lines = file.readLines()</span><br><span class=\"line\">            def lengths = lines.size() - 1</span><br><span class=\"line\">            file.withWriter &#123; writer -&gt;</span><br><span class=\"line\">                lines.eachWithIndex&#123; String line, int index -&gt;</span><br><span class=\"line\">                    if(index != lengths)&#123;</span><br><span class=\"line\">                        writer.append(line +&quot;\\r\\n&quot;)</span><br><span class=\"line\">                    &#125;else if(index == lengths)&#123;</span><br><span class=\"line\">                        writer.append(&quot;\\r\\n&quot; + sw.toString()+&quot;\\r\\n&quot;)</span><br><span class=\"line\">                        writer.append(lines.get(lengths))</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task readTask&#123;</span><br><span class=\"line\">    inputs.file destFile</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        def file = inputs.files.singleFile</span><br><span class=\"line\">        println file.text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task taskTest&#123;</span><br><span class=\"line\">    dependsOn readTask,writerTask</span><br><span class=\"line\">    doLast&#123;</span><br><span class=\"line\">        println &quot;输入输出任务结束&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>destFile作为writerTask输出结果输入到readTask</p>\n<ul>\n<li>通过API指定执行顺序：mustRunAfter／shouldRunAfter</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task t1() &#123; doLast&#123;println &apos;task t1&apos;&#125; &#125;</span><br><span class=\"line\">task t2() &#123; mustRunAfter t1 doLast &#123;println &apos;task t2&apos;&#125; &#125;</span><br></pre></td></tr></table></figure>\n<p>通过./gradlew t2 t1查看执行结果<br>\n4. Task类型<br>\n详见官方文档：<a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete\" target=\"_blank\" rel=\"noopener\">https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Delete.html#org.gradle.api.tasks.Delete</a><br>\n5. 构建到生命周期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.project.afterEvaluate &#123;project -&gt;</span><br><span class=\"line\">    println &quot;开始挂接...&quot;</span><br><span class=\"line\">    def buildTask = project.tasks.getByName(&quot;build&quot;)</span><br><span class=\"line\">    if(buildTask == null) throw GradleException(&quot;build Task not found&quot;)</span><br><span class=\"line\">    buildTask.doLast &#123;</span><br><span class=\"line\">        writerTask.execute()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"gradle其他模块\"><a class=\"markdownIt-Anchor\" href=\"#gradle其他模块\"></a> Gradle其他模块</h1>\n<ol>\n<li>Settings类：对应Settings.gradle</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(hasProperty(&apos;isLoadTest&apos;)? isLoadTest.toBoolean() : false)&#123;</span><br><span class=\"line\">    include &apos;:Test&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>SourceSet类:AndroidSourceSet/JavaSourceSet,决定了代码、资源、第三方库要存放的位置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//修改.so等jnilibs的存放位置</span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        main&#123;</span><br><span class=\"line\">            jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class=\"line\">            res.srcDirs = [&apos;src/main/res&apos;,&apos;src/main/res-ad&apos;]    //对res文件夹内容进行分类，但是只能在Project视图查看到效果</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>Gradle的Plugin</li>\n</ol>\n<ul>\n<li>Gradle没有提供创建自定义Gradle插件工程的模板，需要开发者手动创建Gradle插件工程</li>\n<li>使用Groovy开发，其Gradle插件工程必须遵循如下的目录结构：<br>\ngroovy代码必须位于xxxProject/src/main/groovy/目录下<br>\n提供插件属性声明文件，该文件必须位于xxxProject/src/main/resources/META-INF/gradle-plugins/xxx.properties</li>\n</ul>\n<ol start=\"4\">\n<li>android插件对gradle的扩展<br>\nandroid具体能配置那些属性，可查看源码通过BaseExtension查看</li>\n</ol>\n<p>gradle插件： <a href=\"https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html\" target=\"_blank\" rel=\"noopener\">https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html</a></p>\n<p>varints变体</p>\n"},{"title":"Cordova入门","copyright":true,"comments":1,"toc":true,"date":"2018-10-02T14:10:23.000Z","password":null,"_content":"\n~~~\n* 官网网站：http://cordova.apache.org/\n* 中文文档：http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html\n* 英文文档：http://cordova.apache.org/docs/en/latest/\n~~~\n\n# 概述\n> Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等\n\n# 架构\n![image](http://note.youdao.com/yws/api/personal/file/WEB7dabb8e22b881e78ccd35c9157eed9d4?method=download&shareKey=eb7b4d2c01ba8878b4a483c1becf19e1)\n* WebView：Cordova启用的WebView可以给应用提供完整用户访问界面。在一些平台中，他也可以作为一个组件给大的、混合应用，这些应用混合和Webview和原生的应用组件\n* Web App：这是你应用程序代码存在的地方。应用的实现是通过web页面，默认的本地文件名称是是index.html，这个本地文件应用CSS,JavaScript,图片，媒体文件和其他运行需要的资源。应用执行在原生应用包装的WebView中，这个原生应用是你分发到app stores中的；这个容器中包含一个非常重要文件- config.xml 文件他提供App的重要的信息和特定的参数用来影响App的工作\n* 插件：提供了Cordova和原生组件相互通信的接口并绑定到了标准的设备API上。这使你能够通过JavaScript调用原生代码.\n> 注意:当你创建一个Cordova项目它不存在任何插件。这是新的默认行为。任何你需要的组件，哪怕是核心组件，你也必须明确添加。\n* 开发工作流:Cordova提供两个基本的工作流用来创建移动App.\n1. 跨平台(CLI)的工作流:如果你想你的App运行在尽可能多的移动操作系统，那么就使用这个工作流，你只需要很少的特定平台开发。这个工作流围绕这'cordova'CLI(命令行)。CLI把公用的web资源复制到每个移动平台的子目录，根据每个平台做必要的配置变化，运行构建脚本生成2进制文件。一般都是使用这种方式。\n2. 平台为中心的工作流:如果你专注于构建单独平台的App或者需要需要在底层修改它那么就使用这个工作流吧。\n\n# 创建第一个App\n## 安装Cordova CLI\n* 下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm \n* mac上xcode开发环境已OK\n* mac上Android开发环境已OK，且Android的全局变量已配置，如：ANDROID_HOME\n~~~\nexport ANDROID_HOME=/Users/Neel/Documents/Softwares/adt-bundle-mac-x86_64-20140321/sdk\nexport PATH=${PATH}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools\n~~~\n* sudo npm install -g cordova  //-g标志是告诉 npm 我们全局安装 cordova\n* 命令行输入cordova,检验是否安装成功\n~~~\nCLI命令概要\n\nHelp：显示可用CLI命令的信息。\nCreate：创建Cordova项目并关联项目文件夹和文件。\nPlateform：管理Cordova项目使用的移动平台。\nPlugin：管理Cordova插件的安装和卸载。\nPrepare：从Cordova项目的www文件夹复制web应用内容到项目移动平台项目文件夹中。\nCompile：把web应用打包成Cordova应用。\nBuild：先执行Prepare命令然后打包web应用。\nEmulate：在一个或多个移动设备平台的设备模拟器中运行Cordova应用。\nRun：在一个或多个移动设备中运行Cordova应用。\nServe：启动一个服务器加载web内容以便于用浏览器访问\n~~~\n\n## 创建App\n* 方法一：cordova create hello com.example.hello HelloWorld\n* 方法二：webstorm创建\n1. webstorm添加cordova支持：Settings → Plugins\n2. webstorm创建项目\n\n## 添加平台\n1. 检查你当前平台设置状况:cordova platform ls，运行add或者remove平台的命令将会影响项目 platforms的内容，在这个目录中每个指定平台都有一个子目录\n2. 添加Android平台支持：cordova platform add android --save\n3. 添加IOS平台支持：cordova platform add ios --save\n4. 添加浏览器支持：cordova platform add browser --save\n5. npm install ios-sim -g //如果ios环境，可能需要添加这个\n\n## 构建及测试\n* 安装构建先决条件检查：cordova requirements\n* 构建App：cordova build，构建所有平台；cordova build ios，构建特定平台\n* 测试：模拟器-cordova emulate android；或者可将手机插入电脑，在手机上直接测试-cordova run android\n* 说明：构建和测试也可通过webstorm直接进行\n \n## 添加插件\n> App要接触设备级别的特性，就需要你添加插件了.个插件 通过JavascriptAPI暴露原生SDK功能。插件通常由npm分发(http://cordova.axuer.com/plugins/),一些关键的API由Apache Cordova开源项目提供并且这些插件是作为[核心插件API]的.\n\n* 搜索插件：cordova plugin search camera\n* 查看当前安装的插件:cordova plugin ls\n* 添加插件：cordova plugin add cordova-plugin-camera  //plugin要添加camera插件，我们需要指定camera的npm包名\n* 添加插件：cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git\n\n## 使用 merges自定义每个平台\n> 顶级merges目录提供了特定平台部署特定资源的地方。每个特定平台在merges中的子目录反映了www 源代码树中的结构， 允许你重写和添加文件。\n\n> 存放各个平台特殊的文件，会和www进行合并编译，相同的文件merges下的文件优先。\n\n比如： \n~~~\nmerges/ \n|-- ios/ \n| `-- app.js \n|-- android/ \n| `-- android.js \nwww/ \n`-- app.js\n~~~\n编译成iOS应用的话，包含merges/ios/app.js；而Android应用的话，包含www/app.js、merges/android/android.js \n\n## hooks目录\n> 存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。  \nHook可以采用任何编程语言来写，Cordova CLI采用的是Node.js，所以一般都是用它来写\n\n## 更新Cordova和项目\n* 要查找最新的cordova版本:npm info cordova version\n* 查看当前版本:cordova -v\n* 更新到最新版本:sudo npm update -g cordova\n* 安装指定版本:sudo npm install -g cordova@3.1.0-0.2.0\n* 更新目标项目的平台:cordova platform update android --save\n\n# 平台开发\n* 查看所有支持的模拟器：cordova run --list\n\n## Android\n* 要想知道你的Cordova项目中安装的Cordova Android包的版本，你可以在项目目录中运行cordova platform ls\n* 平台搭建过程\n1. 安装Java Development Kit (JDK) 7或者最新的\n2. 安装Android SDK\n3. 添加SDK包：\n~~~\nAndroid API级别查看：http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels\n~~~\n打开Android SDK Manager (例如，在终端上运行`android)，并确保下面已经安装:\n\n- - 目标Android版本的Android Platform SDK\n- -  Android SDK build-tools，版本19.1.0或者之上\n- - Android Support Repository (在\"Extras\"查找)\n4. 设置环境变量\n- - 设置JAVA_HOME环境变量，指定为JDK安装路径\n- - 设置ANDROID_HOME环境变量，指定为Android SDK安装路径\n- - 添加Android SDK的tools和platform-tools目录到你的PATH\n5. Android Studio调试\n> Cordova的Android项目可以被Android IDEAndroid Studio打开;\n\n> 如果你想使用Android Studio内置的Android调试/分析工具或者你要开发Android插件这是十分有用的\n\n在Android Studio中打开Cordova的Android项目:\n* 启动 Android Studio.\n* 选择 Import Project (Eclipse ADT, Gradle, etc).\n* 选择你项目中的Android platform目录(<your-project>/platforms/android)\n* 对于Gradle Sync问题你可以简单的回答 Yes.\n\n==注意==：当在Android studio里打开你的项目，建议你不要编辑你的代码在IDE中。这会在 platforms目录中编辑你的代码(而不是 www),并且变化将会被重写。而是编辑www目录并通过运行cordova build来拷贝过来你的变化。\n6. Cordova和Android的生命周期 \n\nCordova事件\t| 粗略的Android等效\t|含义\n---|---|------\ndeviceready\t|onCreate()\t|应用程序开始(不是从背景)\npause|\tonPause()\t|应用程序移动到背景\nresume|\tonResume()|\t应用程序返回到前景\n\n关于生命周期：\n> 在Android设备中，操作系统可以选择在后台杀死活动来释放资源，如果当前设备运行程序的内存过低。由于这个原因，你的应用程序知道生命周期被触发并维持任何确保用户在离开应用程序用户上下文不丢失的状态，是必须的。\n\n> 应该通过bindEvents 方法来注册应用程序回调来回应生命周期事件来保存状态。保存什么息和怎么保存信息由你决定，但是你要确保保存足够的信息，来精确的恢复到用户离开的地方\n~~~\n// 这个状态代表了应用程序的状态并且会在onResume()和onPause()中保存和恢复\nvar appState = {\n    takingPicture: true,\n    imageUri: \"\"\n};\n\nvar APP_STORAGE_KEY = \"exampleAppState\";\n\nvar app = {\n    initialize: function() {\n        this.bindEvents();\n    },\n    bindEvents: function() {\n        // 这里我们注册我们关心的生命周期事件回调\n        document.addEventListener('deviceready', this.onDeviceReady, false);\n        document.addEventListener('pause', this.onPause, false);\n        document.addEventListener('resume', this.onResume, false);\n    },\n    onDeviceReady: function() {\n        document.getElementById(\"take-picture-button\").addEventListener(\"click\", function() {\n            //由于camera插件方法启动了一个外部活动\n            //这里有一次机会我们的应用程序被kill掉在回调被成功或者失败调用之前\n            // 在onPause()和onResume()那里我们保存和恢复状态，来处理这个事情\n            appState.takingPicture = true;\n\n            navigator.camera.getPicture(cameraSuccessCallback, cameraFailureCallback,\n                {\n                    sourceType: Camera.PictureSourceType.CAMERA,\n                    destinationType: Camera.DestinationType.FILE_URI,\n                    targetWidth: 250,\n                    targetHeight: 250\n                }\n            );\n        });\n    },\n    onPause: function() {\n        // 这里我们检测我们是否在获取图片，如果在，我们希望保存我们的状态以便onResume()\n        // 恢复的时候使用，如果我们获得了图片URI我们也要存储\n        if(appState.takingPicture || appState.imageUri) {\n            window.localStorage.setItem(APP_STORAGE_KEY, JSON.stringify(appState));\n        }\n    },\n    onResume: function(event) {\n        // 这里我们检差存储的状态，如果需要恢复他。由你跟踪任何添加的插件结果的来源\n        //  (也就是说你代码的哪一步被调用)，还有什么参数提供给插件如果相关\n        var storedState = window.localStorage.getItem(APP_STORAGE_KEY);\n\n        if(storedState) {\n            appState = JSON.parse(storedState);\n        }\n\n        // 检查如果我们需要恢复我们的图片\n        if(!appState.takingPicture && appState.imageUri) {\n            document.getElementById(\"get-picture-result\").src = appState.imageUri;\n        }\n        // 现在我们可以检测如果插件结果在事件对象里面\n        // 这里需要cordova-android 5.1.0+\n        else if(appState.takingPicture && event.pendingResult) {\n            // 检测插件调用是否成功并调用相应的回调。对于camera插件，\"OK\"\n            //意味着成功其他意味着错误\n            if(event.pendingResult.pluginStatus === \"OK\") {\n                // camera放置同样的结果在resume对象，因为成功回调传递给了getPicture(),\n                // 因此我们可以传递同样的回调，返回一些其他东西。查询文档，了解怎么解释你使用\n                // 插件的结果字段\n                cameraSuccessCallback(event.pendingResult.result);\n            } else {\n                cameraFailureCallback(event.pendingResult.result);\n            }\n        }\n    }\n}\n\n// 这里是回调我们传入getPicture()\nfunction cameraSuccessCallback(imageUri) {\n    appState.takingPicture = false;\n    appState.imageUri = imageUri;\n    document.getElementById(\"get-picture-result\").src = imageUri;\n}\n\nfunction cameraFailureCallback(error) {\n    appState.takingPicture = false;\n    console.log(error);\n}\n\napp.initialize();\n~~~\n\n# 自定义图标(Icon)\n> 对启动画面(splash screen)的支持已经被移动到Cordova自己的插件中了，http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/\n\n> 当工作在CLI工作流中，你可以通过<icon>元素(config.xml)定义你的app图标。如果没用指定图标将使用ApacheCordova的logo.\n\n属性 |\t描述\n-----|-----\nsrc\t|必要 图片文件位置，相对于项目根路径\nplatform|\t可选 目标平台\nwidth|\t可选 图片的像素宽度\nheight|\t可选 图片的像素高度\ndensity|\t可选 \nAndroid |指定图标密度\ntarget|\t可选 \nWindows |图片文件和所有多渲染目标(MRT)伙伴的目标文件名\n~~~\n<icon src=\"res/icon.png\" />     //用来定义用于所有平台的唯一默认图标\n~~~\n\nAndroid\n~~~\n<platform name=\"android\">\n        <!--\n            ldpi    : 36x36 px\n            mdpi    : 48x48 px\n            hdpi    : 72x72 px\n            xhdpi   : 96x96 px\n            xxhdpi  : 144x144 px\n            xxxhdpi : 192x192 px\n        -->\n        <icon src=\"res/android/ldpi.png\" density=\"ldpi\" />\n        <icon src=\"res/android/mdpi.png\" density=\"mdpi\" />\n        <icon src=\"res/android/hdpi.png\" density=\"hdpi\" />\n        <icon src=\"res/android/xhdpi.png\" density=\"xhdpi\" />\n        <icon src=\"res/android/xxhdpi.png\" density=\"xxhdpi\" />\n        <icon src=\"res/android/xxxhdpi.png\" density=\"xxxhdpi\" />\n    </platform>\n~~~\nIOS\n~~~\n<platform name=\"ios\">\n        <!-- iOS 8.0+ -->\n        <!-- iPhone 6 Plus  -->\n        <icon src=\"res/ios/icon-60@3x.png\" width=\"180\" height=\"180\" />\n        <!-- iOS 7.0+ -->\n        <!-- iPhone / iPod Touch  -->\n        <icon src=\"res/ios/icon-60.png\" width=\"60\" height=\"60\" />\n        <icon src=\"res/ios/icon-60@2x.png\" width=\"120\" height=\"120\" />\n        <!-- iPad -->\n        <icon src=\"res/ios/icon-76.png\" width=\"76\" height=\"76\" />\n        <icon src=\"res/ios/icon-76@2x.png\" width=\"152\" height=\"152\" />\n        <!-- iOS 6.1 -->\n        <!-- Spotlight Icon -->\n        <icon src=\"res/ios/icon-40.png\" width=\"40\" height=\"40\" />\n        <icon src=\"res/ios/icon-40@2x.png\" width=\"80\" height=\"80\" />\n        <!-- iPhone / iPod Touch -->\n        <icon src=\"res/ios/icon.png\" width=\"57\" height=\"57\" />\n        <icon src=\"res/ios/icon@2x.png\" width=\"114\" height=\"114\" />\n        <!-- iPad -->\n        <icon src=\"res/ios/icon-72.png\" width=\"72\" height=\"72\" />\n        <icon src=\"res/ios/icon-72@2x.png\" width=\"144\" height=\"144\" />\n        <!-- iPhone Spotlight and Settings Icon -->\n        <icon src=\"res/ios/icon-small.png\" width=\"29\" height=\"29\" />\n        <icon src=\"res/ios/icon-small@2x.png\" width=\"58\" height=\"58\" />\n        <!-- iPad Spotlight and Settings Icon -->\n        <icon src=\"res/ios/icon-50.png\" width=\"50\" height=\"50\" />\n        <icon src=\"res/ios/icon-50@2x.png\" width=\"100\" height=\"100\" />\n    </platform>\n~~~\n\n# 存储数据\n## LocalStorage\n> LocalStorage提供了简单和同步的键值对存储方式，而且在各个Cordova平台，底层的WebView实现都支持它。\n\n> LocalStorage可以通过window.localStorage访问到。以下的代码片段展示了返回的storage对象的最重要的几个方法。\n~~~\nvar storage = window.localStorage;\nvar value = storage.getItem(key); // 传递键的名字获取对应的值。\nstorage.setItem(key, value) // 传递键的名字和对应的值去添加或者更新这个键值对。\nstorage.removeItem(key) // 传递键的名字去从LocalStorage里删除这个键值对。\n~~~\n\n## SQLite 插件\n* cordova-sqlite-storage - 包含sqlite3实现的核心版本，它支持iOS, Android和Windows平台。\n* cordova-sqlite-ext - 包含Android和iOS的正则支持等额外特性的扩展版本。\n* cordova-sqlite-evfree - 与cordova-sqlite-ext类似，但提供了高级的内存管理。GPL版本低于v3或者有商业许可的话可用。\n\n# 安全管理建议\n* 使用app内置浏览器打开外链：因为app内置浏览器会使用原生浏览器的安全特性，而且不会让你的Cordova环境被外部访问到\n* 校验所有的用户输入，服务端同样需要验证输入，特别是在传递数据到后台服务之前。\n* 不要缓存敏感信息\n* 不要使用eval()除非你知道你自己正在做什么\n\n# 白名单\n> 外部域是应用无法控制的，而域名白名单则是一种控制访问外部域的安全模型。Cordova提供了一项可配置的安全策略来定义哪些外部站点可以访问。默认情况下，新的app被配置成可以访问任何站点。然而在发布到生产环境前，你应该制定一份白名单，限制应用可以访问的域名和子域名。\n\n## 对于Android\n可以使用cordova-plugin-whitelist实现，虽然实现白名单插件是可能的，但还是不推荐这样做，除非你的app有非常明确的安全策略需要\n\n## 对于其他平台\n依赖于使用app的config.xml文件里的<access>标签，它是用来声明可以访问的特定域名的。\n\n# 事件\nCordova给我们提供了很多的事件，可以在应用程序中使用。应用程序代码中可以添加这些事件的监听。事件相关定义都在www/js/index.js中\n\n支持的平台/\n事件|\tandroid|ios|备注\n-----|----|---|---|---|---|----\ndeviceready|||Cordova设备API准备好并可以访问的信号\t\t\t\npause\t|||当原生平台把应用程序放入后台这个pause事件会触发，通常是用户切换到了不同的应用程序\t\t\nresume\t|||当原生平台将应用程序从后台运行拉出resume事件就会触发\nbackbutton\t||X|当用户按下返回按钮事件触发 \t\t\nmenubutton\t||X|当用户按下菜单按钮事件触发\nsearchbutton||X|当用户按下搜索按钮事件触发\nstartcallbutton|X|X|当用户按下通话按钮事件触发\nendcallbutton\t|X|X|当用户按下挂断通话按钮事件触发\t\t\nvolumedownbutton||X|当用户按下降低声音按钮事件触发\nvolumeupbutton\t||X|当用户按下增加声音按钮事件触发\n\n# 参考\n## config.xml\nhttp://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html\n\n# 问题解决：\nhttps://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11\n\n\nhttp://ionicframework.com/docs/components/#overview\n\nhttp://www.runoob.com/ionic/ionic-tutorial.html\n\nhttps://creator.ionic.io/app/dashboard/projects\n\n~~~\nionic run ios --device\nionic run ios --emulator\nionic run ios --target=\"iPhone-5s\"\nionic run ios --target=\"iPhone-6\"\nionic run ios --target=\"iPhone-6s\"\nionic run ios --emulator --target=\"iPhone-6s\" -l  \n\n\nhttp://localhost:8100/ \n\nios-sim showdevicetypes\n\ncordova run ios --target \"iPad-Pro\" --emulator\n\nxcrun simctl list devices\n~~~\n\nios-sim命令行工具。\n\nios-sim 是一个可以在命令控制iOS模拟器的工具。利用这个命令，我们可以启动一个模拟器，安装app，启动app，查询iOS SDK。它可以使我们像自动化测试一样不用打开Xcode。\n\n~~~\nUsage: ios-sim <command></command> <options> [--args ...]\n \n    Commands:\n      showsdks                        List the available iOS SDK versions\n      showdevicetypes                 List the available device types\n      launch <application path>       Launch the application at the specified path on the iOS Simulator\n      start                           Launch iOS Simulator without an app\n      install <application path>      Install the application at the specified path on the iOS Simulator without launching the app\n \n    Options:\n      --version                       Print the version of ios-sim\n      --help                          Show this help text\n      --exit                          Exit after startup\n      --log <log file path>           The path where log of the app running in the Simulator will be redirected to\n      --devicetypeid <device type>    The id of the device type that should be simulated (Xcode6+). Use 'showdevicetypes' to list devices.\n                                      e.g \"com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone6, 8.0\"\n \n    Removed in version 4.x:\n      --stdout <stdout file path>     The path where stdout of the simulator will be redirected to (defaults to stdout of ios-sim)\n      --stderr <stderr file path>     The path where stderr of the simulator will be redirected to (defaults to stderr of ios-sim)\n      --sdk <sdkversion>              The iOS SDK version to run the application on (defaults to the latest)\n      --family <device family>        The device type that should be simulated (defaults to `iphone')\n      --retina                        Start a retina device\n      --tall                          In combination with --retina flag, start the tall version of the retina device (e.g. iPhone 5 (4-inch))\n      --64bit                         In combination with --retina flag and the --tall flag, start the 64bit version of the tall retina device (e.g. iPhone 5S (4-inch 64bit))\n \n    Unimplemented in this version:\n      --verbose                       Set the output level to verbose\n      --timeout <seconds>             The timeout time to wait for a response from the Simulator. Default value: 30 seconds\n      --args <...>                    All following arguments will be passed on to the application\n      --env <environment file path>   A plist file containing environment key-value pairs that should be set\n      --setenv NAME=VALUE             Set an environment variable</environment file path></seconds></device family></sdkversion></stderr file path></stdout file path></device type></log file path></application path></application path></options>\n~~~\nios-sim launch /Users/YDZ/Desktop/app.app --devicetypeid iPhone-6s\n其中，/Users/YDZ/Desktop/app.app这个是设计师收到app之后的路径。--devicetypeid参数后面是给定一个模拟器的版本。\n\n只需要把上面的命令发给设计师，无脑粘贴到命令行，装好app的模拟器就会自动启动，打开app了。\n \n大公司的话可以应该有两个账号，一个上appstore的开发账户，这个严格保密。还有一个打线下包的企业账号，这样就能达到需求了 \n\n\n\n\n\n\n","source":"_posts/移动开发/Cordova入门.md","raw":"---\ntitle: Cordova入门\ntags: \n  - Cordova  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-10-02 22:10:23\ncategories: 移动开发\npassword:\n---\n\n~~~\n* 官网网站：http://cordova.apache.org/\n* 中文文档：http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html\n* 英文文档：http://cordova.apache.org/docs/en/latest/\n~~~\n\n# 概述\n> Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等\n\n# 架构\n![image](http://note.youdao.com/yws/api/personal/file/WEB7dabb8e22b881e78ccd35c9157eed9d4?method=download&shareKey=eb7b4d2c01ba8878b4a483c1becf19e1)\n* WebView：Cordova启用的WebView可以给应用提供完整用户访问界面。在一些平台中，他也可以作为一个组件给大的、混合应用，这些应用混合和Webview和原生的应用组件\n* Web App：这是你应用程序代码存在的地方。应用的实现是通过web页面，默认的本地文件名称是是index.html，这个本地文件应用CSS,JavaScript,图片，媒体文件和其他运行需要的资源。应用执行在原生应用包装的WebView中，这个原生应用是你分发到app stores中的；这个容器中包含一个非常重要文件- config.xml 文件他提供App的重要的信息和特定的参数用来影响App的工作\n* 插件：提供了Cordova和原生组件相互通信的接口并绑定到了标准的设备API上。这使你能够通过JavaScript调用原生代码.\n> 注意:当你创建一个Cordova项目它不存在任何插件。这是新的默认行为。任何你需要的组件，哪怕是核心组件，你也必须明确添加。\n* 开发工作流:Cordova提供两个基本的工作流用来创建移动App.\n1. 跨平台(CLI)的工作流:如果你想你的App运行在尽可能多的移动操作系统，那么就使用这个工作流，你只需要很少的特定平台开发。这个工作流围绕这'cordova'CLI(命令行)。CLI把公用的web资源复制到每个移动平台的子目录，根据每个平台做必要的配置变化，运行构建脚本生成2进制文件。一般都是使用这种方式。\n2. 平台为中心的工作流:如果你专注于构建单独平台的App或者需要需要在底层修改它那么就使用这个工作流吧。\n\n# 创建第一个App\n## 安装Cordova CLI\n* 下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm \n* mac上xcode开发环境已OK\n* mac上Android开发环境已OK，且Android的全局变量已配置，如：ANDROID_HOME\n~~~\nexport ANDROID_HOME=/Users/Neel/Documents/Softwares/adt-bundle-mac-x86_64-20140321/sdk\nexport PATH=${PATH}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools\n~~~\n* sudo npm install -g cordova  //-g标志是告诉 npm 我们全局安装 cordova\n* 命令行输入cordova,检验是否安装成功\n~~~\nCLI命令概要\n\nHelp：显示可用CLI命令的信息。\nCreate：创建Cordova项目并关联项目文件夹和文件。\nPlateform：管理Cordova项目使用的移动平台。\nPlugin：管理Cordova插件的安装和卸载。\nPrepare：从Cordova项目的www文件夹复制web应用内容到项目移动平台项目文件夹中。\nCompile：把web应用打包成Cordova应用。\nBuild：先执行Prepare命令然后打包web应用。\nEmulate：在一个或多个移动设备平台的设备模拟器中运行Cordova应用。\nRun：在一个或多个移动设备中运行Cordova应用。\nServe：启动一个服务器加载web内容以便于用浏览器访问\n~~~\n\n## 创建App\n* 方法一：cordova create hello com.example.hello HelloWorld\n* 方法二：webstorm创建\n1. webstorm添加cordova支持：Settings → Plugins\n2. webstorm创建项目\n\n## 添加平台\n1. 检查你当前平台设置状况:cordova platform ls，运行add或者remove平台的命令将会影响项目 platforms的内容，在这个目录中每个指定平台都有一个子目录\n2. 添加Android平台支持：cordova platform add android --save\n3. 添加IOS平台支持：cordova platform add ios --save\n4. 添加浏览器支持：cordova platform add browser --save\n5. npm install ios-sim -g //如果ios环境，可能需要添加这个\n\n## 构建及测试\n* 安装构建先决条件检查：cordova requirements\n* 构建App：cordova build，构建所有平台；cordova build ios，构建特定平台\n* 测试：模拟器-cordova emulate android；或者可将手机插入电脑，在手机上直接测试-cordova run android\n* 说明：构建和测试也可通过webstorm直接进行\n \n## 添加插件\n> App要接触设备级别的特性，就需要你添加插件了.个插件 通过JavascriptAPI暴露原生SDK功能。插件通常由npm分发(http://cordova.axuer.com/plugins/),一些关键的API由Apache Cordova开源项目提供并且这些插件是作为[核心插件API]的.\n\n* 搜索插件：cordova plugin search camera\n* 查看当前安装的插件:cordova plugin ls\n* 添加插件：cordova plugin add cordova-plugin-camera  //plugin要添加camera插件，我们需要指定camera的npm包名\n* 添加插件：cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git\n\n## 使用 merges自定义每个平台\n> 顶级merges目录提供了特定平台部署特定资源的地方。每个特定平台在merges中的子目录反映了www 源代码树中的结构， 允许你重写和添加文件。\n\n> 存放各个平台特殊的文件，会和www进行合并编译，相同的文件merges下的文件优先。\n\n比如： \n~~~\nmerges/ \n|-- ios/ \n| `-- app.js \n|-- android/ \n| `-- android.js \nwww/ \n`-- app.js\n~~~\n编译成iOS应用的话，包含merges/ios/app.js；而Android应用的话，包含www/app.js、merges/android/android.js \n\n## hooks目录\n> 存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。  \nHook可以采用任何编程语言来写，Cordova CLI采用的是Node.js，所以一般都是用它来写\n\n## 更新Cordova和项目\n* 要查找最新的cordova版本:npm info cordova version\n* 查看当前版本:cordova -v\n* 更新到最新版本:sudo npm update -g cordova\n* 安装指定版本:sudo npm install -g cordova@3.1.0-0.2.0\n* 更新目标项目的平台:cordova platform update android --save\n\n# 平台开发\n* 查看所有支持的模拟器：cordova run --list\n\n## Android\n* 要想知道你的Cordova项目中安装的Cordova Android包的版本，你可以在项目目录中运行cordova platform ls\n* 平台搭建过程\n1. 安装Java Development Kit (JDK) 7或者最新的\n2. 安装Android SDK\n3. 添加SDK包：\n~~~\nAndroid API级别查看：http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels\n~~~\n打开Android SDK Manager (例如，在终端上运行`android)，并确保下面已经安装:\n\n- - 目标Android版本的Android Platform SDK\n- -  Android SDK build-tools，版本19.1.0或者之上\n- - Android Support Repository (在\"Extras\"查找)\n4. 设置环境变量\n- - 设置JAVA_HOME环境变量，指定为JDK安装路径\n- - 设置ANDROID_HOME环境变量，指定为Android SDK安装路径\n- - 添加Android SDK的tools和platform-tools目录到你的PATH\n5. Android Studio调试\n> Cordova的Android项目可以被Android IDEAndroid Studio打开;\n\n> 如果你想使用Android Studio内置的Android调试/分析工具或者你要开发Android插件这是十分有用的\n\n在Android Studio中打开Cordova的Android项目:\n* 启动 Android Studio.\n* 选择 Import Project (Eclipse ADT, Gradle, etc).\n* 选择你项目中的Android platform目录(<your-project>/platforms/android)\n* 对于Gradle Sync问题你可以简单的回答 Yes.\n\n==注意==：当在Android studio里打开你的项目，建议你不要编辑你的代码在IDE中。这会在 platforms目录中编辑你的代码(而不是 www),并且变化将会被重写。而是编辑www目录并通过运行cordova build来拷贝过来你的变化。\n6. Cordova和Android的生命周期 \n\nCordova事件\t| 粗略的Android等效\t|含义\n---|---|------\ndeviceready\t|onCreate()\t|应用程序开始(不是从背景)\npause|\tonPause()\t|应用程序移动到背景\nresume|\tonResume()|\t应用程序返回到前景\n\n关于生命周期：\n> 在Android设备中，操作系统可以选择在后台杀死活动来释放资源，如果当前设备运行程序的内存过低。由于这个原因，你的应用程序知道生命周期被触发并维持任何确保用户在离开应用程序用户上下文不丢失的状态，是必须的。\n\n> 应该通过bindEvents 方法来注册应用程序回调来回应生命周期事件来保存状态。保存什么息和怎么保存信息由你决定，但是你要确保保存足够的信息，来精确的恢复到用户离开的地方\n~~~\n// 这个状态代表了应用程序的状态并且会在onResume()和onPause()中保存和恢复\nvar appState = {\n    takingPicture: true,\n    imageUri: \"\"\n};\n\nvar APP_STORAGE_KEY = \"exampleAppState\";\n\nvar app = {\n    initialize: function() {\n        this.bindEvents();\n    },\n    bindEvents: function() {\n        // 这里我们注册我们关心的生命周期事件回调\n        document.addEventListener('deviceready', this.onDeviceReady, false);\n        document.addEventListener('pause', this.onPause, false);\n        document.addEventListener('resume', this.onResume, false);\n    },\n    onDeviceReady: function() {\n        document.getElementById(\"take-picture-button\").addEventListener(\"click\", function() {\n            //由于camera插件方法启动了一个外部活动\n            //这里有一次机会我们的应用程序被kill掉在回调被成功或者失败调用之前\n            // 在onPause()和onResume()那里我们保存和恢复状态，来处理这个事情\n            appState.takingPicture = true;\n\n            navigator.camera.getPicture(cameraSuccessCallback, cameraFailureCallback,\n                {\n                    sourceType: Camera.PictureSourceType.CAMERA,\n                    destinationType: Camera.DestinationType.FILE_URI,\n                    targetWidth: 250,\n                    targetHeight: 250\n                }\n            );\n        });\n    },\n    onPause: function() {\n        // 这里我们检测我们是否在获取图片，如果在，我们希望保存我们的状态以便onResume()\n        // 恢复的时候使用，如果我们获得了图片URI我们也要存储\n        if(appState.takingPicture || appState.imageUri) {\n            window.localStorage.setItem(APP_STORAGE_KEY, JSON.stringify(appState));\n        }\n    },\n    onResume: function(event) {\n        // 这里我们检差存储的状态，如果需要恢复他。由你跟踪任何添加的插件结果的来源\n        //  (也就是说你代码的哪一步被调用)，还有什么参数提供给插件如果相关\n        var storedState = window.localStorage.getItem(APP_STORAGE_KEY);\n\n        if(storedState) {\n            appState = JSON.parse(storedState);\n        }\n\n        // 检查如果我们需要恢复我们的图片\n        if(!appState.takingPicture && appState.imageUri) {\n            document.getElementById(\"get-picture-result\").src = appState.imageUri;\n        }\n        // 现在我们可以检测如果插件结果在事件对象里面\n        // 这里需要cordova-android 5.1.0+\n        else if(appState.takingPicture && event.pendingResult) {\n            // 检测插件调用是否成功并调用相应的回调。对于camera插件，\"OK\"\n            //意味着成功其他意味着错误\n            if(event.pendingResult.pluginStatus === \"OK\") {\n                // camera放置同样的结果在resume对象，因为成功回调传递给了getPicture(),\n                // 因此我们可以传递同样的回调，返回一些其他东西。查询文档，了解怎么解释你使用\n                // 插件的结果字段\n                cameraSuccessCallback(event.pendingResult.result);\n            } else {\n                cameraFailureCallback(event.pendingResult.result);\n            }\n        }\n    }\n}\n\n// 这里是回调我们传入getPicture()\nfunction cameraSuccessCallback(imageUri) {\n    appState.takingPicture = false;\n    appState.imageUri = imageUri;\n    document.getElementById(\"get-picture-result\").src = imageUri;\n}\n\nfunction cameraFailureCallback(error) {\n    appState.takingPicture = false;\n    console.log(error);\n}\n\napp.initialize();\n~~~\n\n# 自定义图标(Icon)\n> 对启动画面(splash screen)的支持已经被移动到Cordova自己的插件中了，http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/\n\n> 当工作在CLI工作流中，你可以通过<icon>元素(config.xml)定义你的app图标。如果没用指定图标将使用ApacheCordova的logo.\n\n属性 |\t描述\n-----|-----\nsrc\t|必要 图片文件位置，相对于项目根路径\nplatform|\t可选 目标平台\nwidth|\t可选 图片的像素宽度\nheight|\t可选 图片的像素高度\ndensity|\t可选 \nAndroid |指定图标密度\ntarget|\t可选 \nWindows |图片文件和所有多渲染目标(MRT)伙伴的目标文件名\n~~~\n<icon src=\"res/icon.png\" />     //用来定义用于所有平台的唯一默认图标\n~~~\n\nAndroid\n~~~\n<platform name=\"android\">\n        <!--\n            ldpi    : 36x36 px\n            mdpi    : 48x48 px\n            hdpi    : 72x72 px\n            xhdpi   : 96x96 px\n            xxhdpi  : 144x144 px\n            xxxhdpi : 192x192 px\n        -->\n        <icon src=\"res/android/ldpi.png\" density=\"ldpi\" />\n        <icon src=\"res/android/mdpi.png\" density=\"mdpi\" />\n        <icon src=\"res/android/hdpi.png\" density=\"hdpi\" />\n        <icon src=\"res/android/xhdpi.png\" density=\"xhdpi\" />\n        <icon src=\"res/android/xxhdpi.png\" density=\"xxhdpi\" />\n        <icon src=\"res/android/xxxhdpi.png\" density=\"xxxhdpi\" />\n    </platform>\n~~~\nIOS\n~~~\n<platform name=\"ios\">\n        <!-- iOS 8.0+ -->\n        <!-- iPhone 6 Plus  -->\n        <icon src=\"res/ios/icon-60@3x.png\" width=\"180\" height=\"180\" />\n        <!-- iOS 7.0+ -->\n        <!-- iPhone / iPod Touch  -->\n        <icon src=\"res/ios/icon-60.png\" width=\"60\" height=\"60\" />\n        <icon src=\"res/ios/icon-60@2x.png\" width=\"120\" height=\"120\" />\n        <!-- iPad -->\n        <icon src=\"res/ios/icon-76.png\" width=\"76\" height=\"76\" />\n        <icon src=\"res/ios/icon-76@2x.png\" width=\"152\" height=\"152\" />\n        <!-- iOS 6.1 -->\n        <!-- Spotlight Icon -->\n        <icon src=\"res/ios/icon-40.png\" width=\"40\" height=\"40\" />\n        <icon src=\"res/ios/icon-40@2x.png\" width=\"80\" height=\"80\" />\n        <!-- iPhone / iPod Touch -->\n        <icon src=\"res/ios/icon.png\" width=\"57\" height=\"57\" />\n        <icon src=\"res/ios/icon@2x.png\" width=\"114\" height=\"114\" />\n        <!-- iPad -->\n        <icon src=\"res/ios/icon-72.png\" width=\"72\" height=\"72\" />\n        <icon src=\"res/ios/icon-72@2x.png\" width=\"144\" height=\"144\" />\n        <!-- iPhone Spotlight and Settings Icon -->\n        <icon src=\"res/ios/icon-small.png\" width=\"29\" height=\"29\" />\n        <icon src=\"res/ios/icon-small@2x.png\" width=\"58\" height=\"58\" />\n        <!-- iPad Spotlight and Settings Icon -->\n        <icon src=\"res/ios/icon-50.png\" width=\"50\" height=\"50\" />\n        <icon src=\"res/ios/icon-50@2x.png\" width=\"100\" height=\"100\" />\n    </platform>\n~~~\n\n# 存储数据\n## LocalStorage\n> LocalStorage提供了简单和同步的键值对存储方式，而且在各个Cordova平台，底层的WebView实现都支持它。\n\n> LocalStorage可以通过window.localStorage访问到。以下的代码片段展示了返回的storage对象的最重要的几个方法。\n~~~\nvar storage = window.localStorage;\nvar value = storage.getItem(key); // 传递键的名字获取对应的值。\nstorage.setItem(key, value) // 传递键的名字和对应的值去添加或者更新这个键值对。\nstorage.removeItem(key) // 传递键的名字去从LocalStorage里删除这个键值对。\n~~~\n\n## SQLite 插件\n* cordova-sqlite-storage - 包含sqlite3实现的核心版本，它支持iOS, Android和Windows平台。\n* cordova-sqlite-ext - 包含Android和iOS的正则支持等额外特性的扩展版本。\n* cordova-sqlite-evfree - 与cordova-sqlite-ext类似，但提供了高级的内存管理。GPL版本低于v3或者有商业许可的话可用。\n\n# 安全管理建议\n* 使用app内置浏览器打开外链：因为app内置浏览器会使用原生浏览器的安全特性，而且不会让你的Cordova环境被外部访问到\n* 校验所有的用户输入，服务端同样需要验证输入，特别是在传递数据到后台服务之前。\n* 不要缓存敏感信息\n* 不要使用eval()除非你知道你自己正在做什么\n\n# 白名单\n> 外部域是应用无法控制的，而域名白名单则是一种控制访问外部域的安全模型。Cordova提供了一项可配置的安全策略来定义哪些外部站点可以访问。默认情况下，新的app被配置成可以访问任何站点。然而在发布到生产环境前，你应该制定一份白名单，限制应用可以访问的域名和子域名。\n\n## 对于Android\n可以使用cordova-plugin-whitelist实现，虽然实现白名单插件是可能的，但还是不推荐这样做，除非你的app有非常明确的安全策略需要\n\n## 对于其他平台\n依赖于使用app的config.xml文件里的<access>标签，它是用来声明可以访问的特定域名的。\n\n# 事件\nCordova给我们提供了很多的事件，可以在应用程序中使用。应用程序代码中可以添加这些事件的监听。事件相关定义都在www/js/index.js中\n\n支持的平台/\n事件|\tandroid|ios|备注\n-----|----|---|---|---|---|----\ndeviceready|||Cordova设备API准备好并可以访问的信号\t\t\t\npause\t|||当原生平台把应用程序放入后台这个pause事件会触发，通常是用户切换到了不同的应用程序\t\t\nresume\t|||当原生平台将应用程序从后台运行拉出resume事件就会触发\nbackbutton\t||X|当用户按下返回按钮事件触发 \t\t\nmenubutton\t||X|当用户按下菜单按钮事件触发\nsearchbutton||X|当用户按下搜索按钮事件触发\nstartcallbutton|X|X|当用户按下通话按钮事件触发\nendcallbutton\t|X|X|当用户按下挂断通话按钮事件触发\t\t\nvolumedownbutton||X|当用户按下降低声音按钮事件触发\nvolumeupbutton\t||X|当用户按下增加声音按钮事件触发\n\n# 参考\n## config.xml\nhttp://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html\n\n# 问题解决：\nhttps://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11\n\n\nhttp://ionicframework.com/docs/components/#overview\n\nhttp://www.runoob.com/ionic/ionic-tutorial.html\n\nhttps://creator.ionic.io/app/dashboard/projects\n\n~~~\nionic run ios --device\nionic run ios --emulator\nionic run ios --target=\"iPhone-5s\"\nionic run ios --target=\"iPhone-6\"\nionic run ios --target=\"iPhone-6s\"\nionic run ios --emulator --target=\"iPhone-6s\" -l  \n\n\nhttp://localhost:8100/ \n\nios-sim showdevicetypes\n\ncordova run ios --target \"iPad-Pro\" --emulator\n\nxcrun simctl list devices\n~~~\n\nios-sim命令行工具。\n\nios-sim 是一个可以在命令控制iOS模拟器的工具。利用这个命令，我们可以启动一个模拟器，安装app，启动app，查询iOS SDK。它可以使我们像自动化测试一样不用打开Xcode。\n\n~~~\nUsage: ios-sim <command></command> <options> [--args ...]\n \n    Commands:\n      showsdks                        List the available iOS SDK versions\n      showdevicetypes                 List the available device types\n      launch <application path>       Launch the application at the specified path on the iOS Simulator\n      start                           Launch iOS Simulator without an app\n      install <application path>      Install the application at the specified path on the iOS Simulator without launching the app\n \n    Options:\n      --version                       Print the version of ios-sim\n      --help                          Show this help text\n      --exit                          Exit after startup\n      --log <log file path>           The path where log of the app running in the Simulator will be redirected to\n      --devicetypeid <device type>    The id of the device type that should be simulated (Xcode6+). Use 'showdevicetypes' to list devices.\n                                      e.g \"com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone6, 8.0\"\n \n    Removed in version 4.x:\n      --stdout <stdout file path>     The path where stdout of the simulator will be redirected to (defaults to stdout of ios-sim)\n      --stderr <stderr file path>     The path where stderr of the simulator will be redirected to (defaults to stderr of ios-sim)\n      --sdk <sdkversion>              The iOS SDK version to run the application on (defaults to the latest)\n      --family <device family>        The device type that should be simulated (defaults to `iphone')\n      --retina                        Start a retina device\n      --tall                          In combination with --retina flag, start the tall version of the retina device (e.g. iPhone 5 (4-inch))\n      --64bit                         In combination with --retina flag and the --tall flag, start the 64bit version of the tall retina device (e.g. iPhone 5S (4-inch 64bit))\n \n    Unimplemented in this version:\n      --verbose                       Set the output level to verbose\n      --timeout <seconds>             The timeout time to wait for a response from the Simulator. Default value: 30 seconds\n      --args <...>                    All following arguments will be passed on to the application\n      --env <environment file path>   A plist file containing environment key-value pairs that should be set\n      --setenv NAME=VALUE             Set an environment variable</environment file path></seconds></device family></sdkversion></stderr file path></stdout file path></device type></log file path></application path></application path></options>\n~~~\nios-sim launch /Users/YDZ/Desktop/app.app --devicetypeid iPhone-6s\n其中，/Users/YDZ/Desktop/app.app这个是设计师收到app之后的路径。--devicetypeid参数后面是给定一个模拟器的版本。\n\n只需要把上面的命令发给设计师，无脑粘贴到命令行，装好app的模拟器就会自动启动，打开app了。\n \n大公司的话可以应该有两个账号，一个上appstore的开发账户，这个严格保密。还有一个打线下包的企业账号，这样就能达到需求了 \n\n\n\n\n\n\n","slug":"移动开发-Cordova入门","published":1,"updated":"2019-02-14T02:45:47.000Z","layout":"post","photos":[],"link":"","_id":"cjs4eue5b00er5b8hoypr8hc5","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 官网网站：http://cordova.apache.org/</span><br><span class=\"line\">* 中文文档：http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html</span><br><span class=\"line\">* 英文文档：http://cordova.apache.org/docs/en/latest/</span><br></pre></td></tr></table></figure>\n<h1 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h1>\n<blockquote>\n<p>Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等</p>\n</blockquote>\n<h1 id=\"架构\"><a class=\"markdownIt-Anchor\" href=\"#架构\"></a> 架构</h1>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB7dabb8e22b881e78ccd35c9157eed9d4?method=download&amp;shareKey=eb7b4d2c01ba8878b4a483c1becf19e1\" alt=\"image\"></p>\n<ul>\n<li>WebView：Cordova启用的WebView可以给应用提供完整用户访问界面。在一些平台中，他也可以作为一个组件给大的、混合应用，这些应用混合和Webview和原生的应用组件</li>\n<li>Web App：这是你应用程序代码存在的地方。应用的实现是通过web页面，默认的本地文件名称是是index.html，这个本地文件应用CSS,JavaScript,图片，媒体文件和其他运行需要的资源。应用执行在原生应用包装的WebView中，这个原生应用是你分发到app stores中的；这个容器中包含一个非常重要文件- config.xml 文件他提供App的重要的信息和特定的参数用来影响App的工作</li>\n<li>插件：提供了Cordova和原生组件相互通信的接口并绑定到了标准的设备API上。这使你能够通过JavaScript调用原生代码.</li>\n</ul>\n<blockquote>\n<p>注意:当你创建一个Cordova项目它不存在任何插件。这是新的默认行为。任何你需要的组件，哪怕是核心组件，你也必须明确添加。</p>\n</blockquote>\n<ul>\n<li>开发工作流:Cordova提供两个基本的工作流用来创建移动App.</li>\n</ul>\n<ol>\n<li>跨平台(CLI)的工作流:如果你想你的App运行在尽可能多的移动操作系统，那么就使用这个工作流，你只需要很少的特定平台开发。这个工作流围绕这’cordova’CLI(命令行)。CLI把公用的web资源复制到每个移动平台的子目录，根据每个平台做必要的配置变化，运行构建脚本生成2进制文件。一般都是使用这种方式。</li>\n<li>平台为中心的工作流:如果你专注于构建单独平台的App或者需要需要在底层修改它那么就使用这个工作流吧。</li>\n</ol>\n<h1 id=\"创建第一个app\"><a class=\"markdownIt-Anchor\" href=\"#创建第一个app\"></a> 创建第一个App</h1>\n<h2 id=\"安装cordova-cli\"><a class=\"markdownIt-Anchor\" href=\"#安装cordova-cli\"></a> 安装Cordova CLI</h2>\n<ul>\n<li>下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm</li>\n<li>mac上xcode开发环境已OK</li>\n<li>mac上Android开发环境已OK，且Android的全局变量已配置，如：ANDROID_HOME</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ANDROID_HOME=/Users/Neel/Documents/Softwares/adt-bundle-mac-x86_64-20140321/sdk</span><br><span class=\"line\">export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>\n<ul>\n<li>sudo npm install -g cordova  //-g标志是告诉 npm 我们全局安装 cordova</li>\n<li>命令行输入cordova,检验是否安装成功</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CLI命令概要</span><br><span class=\"line\"></span><br><span class=\"line\">Help：显示可用CLI命令的信息。</span><br><span class=\"line\">Create：创建Cordova项目并关联项目文件夹和文件。</span><br><span class=\"line\">Plateform：管理Cordova项目使用的移动平台。</span><br><span class=\"line\">Plugin：管理Cordova插件的安装和卸载。</span><br><span class=\"line\">Prepare：从Cordova项目的www文件夹复制web应用内容到项目移动平台项目文件夹中。</span><br><span class=\"line\">Compile：把web应用打包成Cordova应用。</span><br><span class=\"line\">Build：先执行Prepare命令然后打包web应用。</span><br><span class=\"line\">Emulate：在一个或多个移动设备平台的设备模拟器中运行Cordova应用。</span><br><span class=\"line\">Run：在一个或多个移动设备中运行Cordova应用。</span><br><span class=\"line\">Serve：启动一个服务器加载web内容以便于用浏览器访问</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建app\"><a class=\"markdownIt-Anchor\" href=\"#创建app\"></a> 创建App</h2>\n<ul>\n<li>方法一：cordova create hello com.example.hello HelloWorld</li>\n<li>方法二：webstorm创建</li>\n</ul>\n<ol>\n<li>webstorm添加cordova支持：Settings → Plugins</li>\n<li>webstorm创建项目</li>\n</ol>\n<h2 id=\"添加平台\"><a class=\"markdownIt-Anchor\" href=\"#添加平台\"></a> 添加平台</h2>\n<ol>\n<li>检查你当前平台设置状况:cordova platform ls，运行add或者remove平台的命令将会影响项目 platforms的内容，在这个目录中每个指定平台都有一个子目录</li>\n<li>添加Android平台支持：cordova platform add android --save</li>\n<li>添加IOS平台支持：cordova platform add ios --save</li>\n<li>添加浏览器支持：cordova platform add browser --save</li>\n<li>npm install ios-sim -g //如果ios环境，可能需要添加这个</li>\n</ol>\n<h2 id=\"构建及测试\"><a class=\"markdownIt-Anchor\" href=\"#构建及测试\"></a> 构建及测试</h2>\n<ul>\n<li>安装构建先决条件检查：cordova requirements</li>\n<li>构建App：cordova build，构建所有平台；cordova build ios，构建特定平台</li>\n<li>测试：模拟器-cordova emulate android；或者可将手机插入电脑，在手机上直接测试-cordova run android</li>\n<li>说明：构建和测试也可通过webstorm直接进行</li>\n</ul>\n<h2 id=\"添加插件\"><a class=\"markdownIt-Anchor\" href=\"#添加插件\"></a> 添加插件</h2>\n<blockquote>\n<p>App要接触设备级别的特性，就需要你添加插件了.个插件 通过JavascriptAPI暴露原生SDK功能。插件通常由npm分发(<a href=\"http://cordova.axuer.com/plugins/\" target=\"_blank\" rel=\"noopener\">http://cordova.axuer.com/plugins/</a>),一些关键的API由Apache Cordova开源项目提供并且这些插件是作为[核心插件API]的.</p>\n</blockquote>\n<ul>\n<li>搜索插件：cordova plugin search camera</li>\n<li>查看当前安装的插件:cordova plugin ls</li>\n<li>添加插件：cordova plugin add cordova-plugin-camera  //plugin要添加camera插件，我们需要指定camera的npm包名</li>\n<li>添加插件：cordova plugin add <a href=\"https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git\" target=\"_blank\" rel=\"noopener\">https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git</a></li>\n</ul>\n<h2 id=\"使用-merges自定义每个平台\"><a class=\"markdownIt-Anchor\" href=\"#使用-merges自定义每个平台\"></a> 使用 merges自定义每个平台</h2>\n<blockquote>\n<p>顶级merges目录提供了特定平台部署特定资源的地方。每个特定平台在merges中的子目录反映了www 源代码树中的结构， 允许你重写和添加文件。</p>\n</blockquote>\n<blockquote>\n<p>存放各个平台特殊的文件，会和www进行合并编译，相同的文件merges下的文件优先。</p>\n</blockquote>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merges/ </span><br><span class=\"line\">|-- ios/ </span><br><span class=\"line\">| `-- app.js </span><br><span class=\"line\">|-- android/ </span><br><span class=\"line\">| `-- android.js </span><br><span class=\"line\">www/ </span><br><span class=\"line\">`-- app.js</span><br></pre></td></tr></table></figure>\n<p>编译成iOS应用的话，包含merges/ios/app.js；而Android应用的话，包含www/app.js、merges/android/android.js</p>\n<h2 id=\"hooks目录\"><a class=\"markdownIt-Anchor\" href=\"#hooks目录\"></a> hooks目录</h2>\n<blockquote>\n<p>存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。<br>\nHook可以采用任何编程语言来写，Cordova CLI采用的是Node.js，所以一般都是用它来写</p>\n</blockquote>\n<h2 id=\"更新cordova和项目\"><a class=\"markdownIt-Anchor\" href=\"#更新cordova和项目\"></a> 更新Cordova和项目</h2>\n<ul>\n<li>要查找最新的cordova版本:npm info cordova version</li>\n<li>查看当前版本:cordova -v</li>\n<li>更新到最新版本:sudo npm update -g cordova</li>\n<li>安装指定版本:sudo npm install -g cordova@3.1.0-0.2.0</li>\n<li>更新目标项目的平台:cordova platform update android --save</li>\n</ul>\n<h1 id=\"平台开发\"><a class=\"markdownIt-Anchor\" href=\"#平台开发\"></a> 平台开发</h1>\n<ul>\n<li>查看所有支持的模拟器：cordova run --list</li>\n</ul>\n<h2 id=\"android\"><a class=\"markdownIt-Anchor\" href=\"#android\"></a> Android</h2>\n<ul>\n<li>要想知道你的Cordova项目中安装的Cordova Android包的版本，你可以在项目目录中运行cordova platform ls</li>\n<li>平台搭建过程</li>\n</ul>\n<ol>\n<li>安装Java Development Kit (JDK) 7或者最新的</li>\n<li>安装Android SDK</li>\n<li>添加SDK包：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Android API级别查看：http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels</span><br></pre></td></tr></table></figure>\n<p>打开Android SDK Manager (例如，在终端上运行`android)，并确保下面已经安装:</p>\n<ul>\n<li>\n<ul>\n<li>目标Android版本的Android Platform SDK</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>Android SDK build-tools，版本19.1.0或者之上</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>Android Support Repository (在&quot;Extras&quot;查找)</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>设置环境变量</li>\n</ol>\n<ul>\n<li>\n<ul>\n<li>设置JAVA_HOME环境变量，指定为JDK安装路径</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>设置ANDROID_HOME环境变量，指定为Android SDK安装路径</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>添加Android SDK的tools和platform-tools目录到你的PATH</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>Android Studio调试</li>\n</ol>\n<blockquote>\n<p>Cordova的Android项目可以被Android IDEAndroid Studio打开;</p>\n</blockquote>\n<blockquote>\n<p>如果你想使用Android Studio内置的Android调试/分析工具或者你要开发Android插件这是十分有用的</p>\n</blockquote>\n<p>在Android Studio中打开Cordova的Android项目:</p>\n<ul>\n<li>启动 Android Studio.</li>\n<li>选择 Import Project (Eclipse ADT, Gradle, etc).</li>\n<li>选择你项目中的Android platform目录(<your-project>/platforms/android)</your-project></li>\n<li>对于Gradle Sync问题你可以简单的回答 Yes.</li>\n</ul>\n<p>==注意==：当在Android studio里打开你的项目，建议你不要编辑你的代码在IDE中。这会在 platforms目录中编辑你的代码(而不是 www),并且变化将会被重写。而是编辑www目录并通过运行cordova build来拷贝过来你的变化。<br>\n6. Cordova和Android的生命周期</p>\n<table>\n<thead>\n<tr>\n<th>Cordova事件</th>\n<th>粗略的Android等效</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>deviceready</td>\n<td>onCreate()</td>\n<td>应用程序开始(不是从背景)</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>onPause()</td>\n<td>应用程序移动到背景</td>\n</tr>\n<tr>\n<td>resume</td>\n<td>onResume()</td>\n<td>应用程序返回到前景</td>\n</tr>\n</tbody>\n</table>\n<p>关于生命周期：</p>\n<blockquote>\n<p>在Android设备中，操作系统可以选择在后台杀死活动来释放资源，如果当前设备运行程序的内存过低。由于这个原因，你的应用程序知道生命周期被触发并维持任何确保用户在离开应用程序用户上下文不丢失的状态，是必须的。</p>\n</blockquote>\n<blockquote>\n<p>应该通过bindEvents 方法来注册应用程序回调来回应生命周期事件来保存状态。保存什么息和怎么保存信息由你决定，但是你要确保保存足够的信息，来精确的恢复到用户离开的地方</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这个状态代表了应用程序的状态并且会在onResume()和onPause()中保存和恢复</span><br><span class=\"line\">var appState = &#123;</span><br><span class=\"line\">    takingPicture: true,</span><br><span class=\"line\">    imageUri: &quot;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var APP_STORAGE_KEY = &quot;exampleAppState&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">var app = &#123;</span><br><span class=\"line\">    initialize: function() &#123;</span><br><span class=\"line\">        this.bindEvents();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bindEvents: function() &#123;</span><br><span class=\"line\">        // 这里我们注册我们关心的生命周期事件回调</span><br><span class=\"line\">        document.addEventListener(&apos;deviceready&apos;, this.onDeviceReady, false);</span><br><span class=\"line\">        document.addEventListener(&apos;pause&apos;, this.onPause, false);</span><br><span class=\"line\">        document.addEventListener(&apos;resume&apos;, this.onResume, false);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onDeviceReady: function() &#123;</span><br><span class=\"line\">        document.getElementById(&quot;take-picture-button&quot;).addEventListener(&quot;click&quot;, function() &#123;</span><br><span class=\"line\">            //由于camera插件方法启动了一个外部活动</span><br><span class=\"line\">            //这里有一次机会我们的应用程序被kill掉在回调被成功或者失败调用之前</span><br><span class=\"line\">            // 在onPause()和onResume()那里我们保存和恢复状态，来处理这个事情</span><br><span class=\"line\">            appState.takingPicture = true;</span><br><span class=\"line\"></span><br><span class=\"line\">            navigator.camera.getPicture(cameraSuccessCallback, cameraFailureCallback,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    sourceType: Camera.PictureSourceType.CAMERA,</span><br><span class=\"line\">                    destinationType: Camera.DestinationType.FILE_URI,</span><br><span class=\"line\">                    targetWidth: 250,</span><br><span class=\"line\">                    targetHeight: 250</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onPause: function() &#123;</span><br><span class=\"line\">        // 这里我们检测我们是否在获取图片，如果在，我们希望保存我们的状态以便onResume()</span><br><span class=\"line\">        // 恢复的时候使用，如果我们获得了图片URI我们也要存储</span><br><span class=\"line\">        if(appState.takingPicture || appState.imageUri) &#123;</span><br><span class=\"line\">            window.localStorage.setItem(APP_STORAGE_KEY, JSON.stringify(appState));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onResume: function(event) &#123;</span><br><span class=\"line\">        // 这里我们检差存储的状态，如果需要恢复他。由你跟踪任何添加的插件结果的来源</span><br><span class=\"line\">        //  (也就是说你代码的哪一步被调用)，还有什么参数提供给插件如果相关</span><br><span class=\"line\">        var storedState = window.localStorage.getItem(APP_STORAGE_KEY);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(storedState) &#123;</span><br><span class=\"line\">            appState = JSON.parse(storedState);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 检查如果我们需要恢复我们的图片</span><br><span class=\"line\">        if(!appState.takingPicture &amp;&amp; appState.imageUri) &#123;</span><br><span class=\"line\">            document.getElementById(&quot;get-picture-result&quot;).src = appState.imageUri;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 现在我们可以检测如果插件结果在事件对象里面</span><br><span class=\"line\">        // 这里需要cordova-android 5.1.0+</span><br><span class=\"line\">        else if(appState.takingPicture &amp;&amp; event.pendingResult) &#123;</span><br><span class=\"line\">            // 检测插件调用是否成功并调用相应的回调。对于camera插件，&quot;OK&quot;</span><br><span class=\"line\">            //意味着成功其他意味着错误</span><br><span class=\"line\">            if(event.pendingResult.pluginStatus === &quot;OK&quot;) &#123;</span><br><span class=\"line\">                // camera放置同样的结果在resume对象，因为成功回调传递给了getPicture(),</span><br><span class=\"line\">                // 因此我们可以传递同样的回调，返回一些其他东西。查询文档，了解怎么解释你使用</span><br><span class=\"line\">                // 插件的结果字段</span><br><span class=\"line\">                cameraSuccessCallback(event.pendingResult.result);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                cameraFailureCallback(event.pendingResult.result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里是回调我们传入getPicture()</span><br><span class=\"line\">function cameraSuccessCallback(imageUri) &#123;</span><br><span class=\"line\">    appState.takingPicture = false;</span><br><span class=\"line\">    appState.imageUri = imageUri;</span><br><span class=\"line\">    document.getElementById(&quot;get-picture-result&quot;).src = imageUri;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cameraFailureCallback(error) &#123;</span><br><span class=\"line\">    appState.takingPicture = false;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.initialize();</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义图标icon\"><a class=\"markdownIt-Anchor\" href=\"#自定义图标icon\"></a> 自定义图标(Icon)</h1>\n<blockquote>\n<p>对启动画面(splash screen)的支持已经被移动到Cordova自己的插件中了，<a href=\"http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/\" target=\"_blank\" rel=\"noopener\">http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/</a></p>\n</blockquote>\n<blockquote>\n<p>当工作在CLI工作流中，你可以通过<icon>元素(config.xml)定义你的app图标。如果没用指定图标将使用ApacheCordova的logo.</icon></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src</td>\n<td>必要 图片文件位置，相对于项目根路径</td>\n</tr>\n<tr>\n<td>platform</td>\n<td>可选 目标平台</td>\n</tr>\n<tr>\n<td>width</td>\n<td>可选 图片的像素宽度</td>\n</tr>\n<tr>\n<td>height</td>\n<td>可选 图片的像素高度</td>\n</tr>\n<tr>\n<td>density</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>Android</td>\n<td>指定图标密度</td>\n</tr>\n<tr>\n<td>target</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>Windows</td>\n<td>图片文件和所有多渲染目标(MRT)伙伴的目标文件名</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;icon src=&quot;res/icon.png&quot; /&gt;     //用来定义用于所有平台的唯一默认图标</span><br></pre></td></tr></table></figure>\n<p>Android</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;platform name=&quot;android&quot;&gt;</span><br><span class=\"line\">        &lt;!--</span><br><span class=\"line\">            ldpi    : 36x36 px</span><br><span class=\"line\">            mdpi    : 48x48 px</span><br><span class=\"line\">            hdpi    : 72x72 px</span><br><span class=\"line\">            xhdpi   : 96x96 px</span><br><span class=\"line\">            xxhdpi  : 144x144 px</span><br><span class=\"line\">            xxxhdpi : 192x192 px</span><br><span class=\"line\">        --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/ldpi.png&quot; density=&quot;ldpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/mdpi.png&quot; density=&quot;mdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/hdpi.png&quot; density=&quot;hdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/xhdpi.png&quot; density=&quot;xhdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/xxhdpi.png&quot; density=&quot;xxhdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/xxxhdpi.png&quot; density=&quot;xxxhdpi&quot; /&gt;</span><br><span class=\"line\">    &lt;/platform&gt;</span><br></pre></td></tr></table></figure>\n<p>IOS</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;platform name=&quot;ios&quot;&gt;</span><br><span class=\"line\">        &lt;!-- iOS 8.0+ --&gt;</span><br><span class=\"line\">        &lt;!-- iPhone 6 Plus  --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-60@3x.png&quot; width=&quot;180&quot; height=&quot;180&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iOS 7.0+ --&gt;</span><br><span class=\"line\">        &lt;!-- iPhone / iPod Touch  --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-60.png&quot; width=&quot;60&quot; height=&quot;60&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-60@2x.png&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPad --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-76.png&quot; width=&quot;76&quot; height=&quot;76&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-76@2x.png&quot; width=&quot;152&quot; height=&quot;152&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iOS 6.1 --&gt;</span><br><span class=\"line\">        &lt;!-- Spotlight Icon --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-40.png&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-40@2x.png&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPhone / iPod Touch --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon.png&quot; width=&quot;57&quot; height=&quot;57&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon@2x.png&quot; width=&quot;114&quot; height=&quot;114&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPad --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-72.png&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-72@2x.png&quot; width=&quot;144&quot; height=&quot;144&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPhone Spotlight and Settings Icon --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-small.png&quot; width=&quot;29&quot; height=&quot;29&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-small@2x.png&quot; width=&quot;58&quot; height=&quot;58&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPad Spotlight and Settings Icon --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-50.png&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-50@2x.png&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;</span><br><span class=\"line\">    &lt;/platform&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"存储数据\"><a class=\"markdownIt-Anchor\" href=\"#存储数据\"></a> 存储数据</h1>\n<h2 id=\"localstorage\"><a class=\"markdownIt-Anchor\" href=\"#localstorage\"></a> LocalStorage</h2>\n<blockquote>\n<p>LocalStorage提供了简单和同步的键值对存储方式，而且在各个Cordova平台，底层的WebView实现都支持它。</p>\n</blockquote>\n<blockquote>\n<p>LocalStorage可以通过window.localStorage访问到。以下的代码片段展示了返回的storage对象的最重要的几个方法。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var storage = window.localStorage;</span><br><span class=\"line\">var value = storage.getItem(key); // 传递键的名字获取对应的值。</span><br><span class=\"line\">storage.setItem(key, value) // 传递键的名字和对应的值去添加或者更新这个键值对。</span><br><span class=\"line\">storage.removeItem(key) // 传递键的名字去从LocalStorage里删除这个键值对。</span><br></pre></td></tr></table></figure>\n<h2 id=\"sqlite-插件\"><a class=\"markdownIt-Anchor\" href=\"#sqlite-插件\"></a> SQLite 插件</h2>\n<ul>\n<li>cordova-sqlite-storage - 包含sqlite3实现的核心版本，它支持iOS, Android和Windows平台。</li>\n<li>cordova-sqlite-ext - 包含Android和iOS的正则支持等额外特性的扩展版本。</li>\n<li>cordova-sqlite-evfree - 与cordova-sqlite-ext类似，但提供了高级的内存管理。GPL版本低于v3或者有商业许可的话可用。</li>\n</ul>\n<h1 id=\"安全管理建议\"><a class=\"markdownIt-Anchor\" href=\"#安全管理建议\"></a> 安全管理建议</h1>\n<ul>\n<li>使用app内置浏览器打开外链：因为app内置浏览器会使用原生浏览器的安全特性，而且不会让你的Cordova环境被外部访问到</li>\n<li>校验所有的用户输入，服务端同样需要验证输入，特别是在传递数据到后台服务之前。</li>\n<li>不要缓存敏感信息</li>\n<li>不要使用eval()除非你知道你自己正在做什么</li>\n</ul>\n<h1 id=\"白名单\"><a class=\"markdownIt-Anchor\" href=\"#白名单\"></a> 白名单</h1>\n<blockquote>\n<p>外部域是应用无法控制的，而域名白名单则是一种控制访问外部域的安全模型。Cordova提供了一项可配置的安全策略来定义哪些外部站点可以访问。默认情况下，新的app被配置成可以访问任何站点。然而在发布到生产环境前，你应该制定一份白名单，限制应用可以访问的域名和子域名。</p>\n</blockquote>\n<h2 id=\"对于android\"><a class=\"markdownIt-Anchor\" href=\"#对于android\"></a> 对于Android</h2>\n<p>可以使用cordova-plugin-whitelist实现，虽然实现白名单插件是可能的，但还是不推荐这样做，除非你的app有非常明确的安全策略需要</p>\n<h2 id=\"对于其他平台\"><a class=\"markdownIt-Anchor\" href=\"#对于其他平台\"></a> 对于其他平台</h2>\n<p>依赖于使用app的config.xml文件里的<access>标签，它是用来声明可以访问的特定域名的。</access></p>\n<h1 id=\"事件\"><a class=\"markdownIt-Anchor\" href=\"#事件\"></a> 事件</h1>\n<p>Cordova给我们提供了很多的事件，可以在应用程序中使用。应用程序代码中可以添加这些事件的监听。事件相关定义都在www/js/index.js中</p>\n<p>支持的平台/</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>android</th>\n<th>ios</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>deviceready</td>\n<td></td>\n<td></td>\n<td>Cordova设备API准备好并可以访问的信号</td>\n</tr>\n<tr>\n<td>pause</td>\n<td></td>\n<td></td>\n<td>当原生平台把应用程序放入后台这个pause事件会触发，通常是用户切换到了不同的应用程序</td>\n</tr>\n<tr>\n<td>resume</td>\n<td></td>\n<td></td>\n<td>当原生平台将应用程序从后台运行拉出resume事件就会触发</td>\n</tr>\n<tr>\n<td>backbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下返回按钮事件触发</td>\n</tr>\n<tr>\n<td>menubutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下菜单按钮事件触发</td>\n</tr>\n<tr>\n<td>searchbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下搜索按钮事件触发</td>\n</tr>\n<tr>\n<td>startcallbutton</td>\n<td>X</td>\n<td>X</td>\n<td>当用户按下通话按钮事件触发</td>\n</tr>\n<tr>\n<td>endcallbutton</td>\n<td>X</td>\n<td>X</td>\n<td>当用户按下挂断通话按钮事件触发</td>\n</tr>\n<tr>\n<td>volumedownbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下降低声音按钮事件触发</td>\n</tr>\n<tr>\n<td>volumeupbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下增加声音按钮事件触发</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\"></a> 参考</h1>\n<h2 id=\"configxml\"><a class=\"markdownIt-Anchor\" href=\"#configxml\"></a> config.xml</h2>\n<p><a href=\"http://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html\" target=\"_blank\" rel=\"noopener\">http://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html</a></p>\n<h1 id=\"问题解决\"><a class=\"markdownIt-Anchor\" href=\"#问题解决\"></a> 问题解决：</h1>\n<p><a href=\"https://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11\" target=\"_blank\" rel=\"noopener\">https://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11</a></p>\n<p><a href=\"http://ionicframework.com/docs/components/#overview\" target=\"_blank\" rel=\"noopener\">http://ionicframework.com/docs/components/#overview</a></p>\n<p><a href=\"http://www.runoob.com/ionic/ionic-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/ionic/ionic-tutorial.html</a></p>\n<p><a href=\"https://creator.ionic.io/app/dashboard/projects\" target=\"_blank\" rel=\"noopener\">https://creator.ionic.io/app/dashboard/projects</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ionic run ios --device</span><br><span class=\"line\">ionic run ios --emulator</span><br><span class=\"line\">ionic run ios --target=&quot;iPhone-5s&quot;</span><br><span class=\"line\">ionic run ios --target=&quot;iPhone-6&quot;</span><br><span class=\"line\">ionic run ios --target=&quot;iPhone-6s&quot;</span><br><span class=\"line\">ionic run ios --emulator --target=&quot;iPhone-6s&quot; -l  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost:8100/ </span><br><span class=\"line\"></span><br><span class=\"line\">ios-sim showdevicetypes</span><br><span class=\"line\"></span><br><span class=\"line\">cordova run ios --target &quot;iPad-Pro&quot; --emulator</span><br><span class=\"line\"></span><br><span class=\"line\">xcrun simctl list devices</span><br></pre></td></tr></table></figure>\n<p>ios-sim命令行工具。</p>\n<p>ios-sim 是一个可以在命令控制iOS模拟器的工具。利用这个命令，我们可以启动一个模拟器，安装app，启动app，查询iOS SDK。它可以使我们像自动化测试一样不用打开Xcode。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: ios-sim &lt;command&gt;&lt;/command&gt; &lt;options&gt; [--args ...]</span><br><span class=\"line\"> </span><br><span class=\"line\">    Commands:</span><br><span class=\"line\">      showsdks                        List the available iOS SDK versions</span><br><span class=\"line\">      showdevicetypes                 List the available device types</span><br><span class=\"line\">      launch &lt;application path&gt;       Launch the application at the specified path on the iOS Simulator</span><br><span class=\"line\">      start                           Launch iOS Simulator without an app</span><br><span class=\"line\">      install &lt;application path&gt;      Install the application at the specified path on the iOS Simulator without launching the app</span><br><span class=\"line\"> </span><br><span class=\"line\">    Options:</span><br><span class=\"line\">      --version                       Print the version of ios-sim</span><br><span class=\"line\">      --help                          Show this help text</span><br><span class=\"line\">      --exit                          Exit after startup</span><br><span class=\"line\">      --log &lt;log file path&gt;           The path where log of the app running in the Simulator will be redirected to</span><br><span class=\"line\">      --devicetypeid &lt;device type&gt;    The id of the device type that should be simulated (Xcode6+). Use &apos;showdevicetypes&apos; to list devices.</span><br><span class=\"line\">                                      e.g &quot;com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone6, 8.0&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">    Removed in version 4.x:</span><br><span class=\"line\">      --stdout &lt;stdout file path&gt;     The path where stdout of the simulator will be redirected to (defaults to stdout of ios-sim)</span><br><span class=\"line\">      --stderr &lt;stderr file path&gt;     The path where stderr of the simulator will be redirected to (defaults to stderr of ios-sim)</span><br><span class=\"line\">      --sdk &lt;sdkversion&gt;              The iOS SDK version to run the application on (defaults to the latest)</span><br><span class=\"line\">      --family &lt;device family&gt;        The device type that should be simulated (defaults to `iphone&apos;)</span><br><span class=\"line\">      --retina                        Start a retina device</span><br><span class=\"line\">      --tall                          In combination with --retina flag, start the tall version of the retina device (e.g. iPhone 5 (4-inch))</span><br><span class=\"line\">      --64bit                         In combination with --retina flag and the --tall flag, start the 64bit version of the tall retina device (e.g. iPhone 5S (4-inch 64bit))</span><br><span class=\"line\"> </span><br><span class=\"line\">    Unimplemented in this version:</span><br><span class=\"line\">      --verbose                       Set the output level to verbose</span><br><span class=\"line\">      --timeout &lt;seconds&gt;             The timeout time to wait for a response from the Simulator. Default value: 30 seconds</span><br><span class=\"line\">      --args &lt;...&gt;                    All following arguments will be passed on to the application</span><br><span class=\"line\">      --env &lt;environment file path&gt;   A plist file containing environment key-value pairs that should be set</span><br><span class=\"line\">      --setenv NAME=VALUE             Set an environment variable&lt;/environment file path&gt;&lt;/seconds&gt;&lt;/device family&gt;&lt;/sdkversion&gt;&lt;/stderr file path&gt;&lt;/stdout file path&gt;&lt;/device type&gt;&lt;/log file path&gt;&lt;/application path&gt;&lt;/application path&gt;&lt;/options&gt;</span><br></pre></td></tr></table></figure>\n<p>ios-sim launch /Users/YDZ/Desktop/app.app --devicetypeid iPhone-6s<br>\n其中，/Users/YDZ/Desktop/app.app这个是设计师收到app之后的路径。–devicetypeid参数后面是给定一个模拟器的版本。</p>\n<p>只需要把上面的命令发给设计师，无脑粘贴到命令行，装好app的模拟器就会自动启动，打开app了。</p>\n<p>大公司的话可以应该有两个账号，一个上appstore的开发账户，这个严格保密。还有一个打线下包的企业账号，这样就能达到需求了</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 官网网站：http://cordova.apache.org/</span><br><span class=\"line\">* 中文文档：http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html</span><br><span class=\"line\">* 英文文档：http://cordova.apache.org/docs/en/latest/</span><br></pre></td></tr></table></figure>\n<h1 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h1>\n<blockquote>\n<p>Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等</p>\n</blockquote>\n<h1 id=\"架构\"><a class=\"markdownIt-Anchor\" href=\"#架构\"></a> 架构</h1>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB7dabb8e22b881e78ccd35c9157eed9d4?method=download&amp;shareKey=eb7b4d2c01ba8878b4a483c1becf19e1\" alt=\"image\"></p>\n<ul>\n<li>WebView：Cordova启用的WebView可以给应用提供完整用户访问界面。在一些平台中，他也可以作为一个组件给大的、混合应用，这些应用混合和Webview和原生的应用组件</li>\n<li>Web App：这是你应用程序代码存在的地方。应用的实现是通过web页面，默认的本地文件名称是是index.html，这个本地文件应用CSS,JavaScript,图片，媒体文件和其他运行需要的资源。应用执行在原生应用包装的WebView中，这个原生应用是你分发到app stores中的；这个容器中包含一个非常重要文件- config.xml 文件他提供App的重要的信息和特定的参数用来影响App的工作</li>\n<li>插件：提供了Cordova和原生组件相互通信的接口并绑定到了标准的设备API上。这使你能够通过JavaScript调用原生代码.</li>\n</ul>\n<blockquote>\n<p>注意:当你创建一个Cordova项目它不存在任何插件。这是新的默认行为。任何你需要的组件，哪怕是核心组件，你也必须明确添加。</p>\n</blockquote>\n<ul>\n<li>开发工作流:Cordova提供两个基本的工作流用来创建移动App.</li>\n</ul>\n<ol>\n<li>跨平台(CLI)的工作流:如果你想你的App运行在尽可能多的移动操作系统，那么就使用这个工作流，你只需要很少的特定平台开发。这个工作流围绕这’cordova’CLI(命令行)。CLI把公用的web资源复制到每个移动平台的子目录，根据每个平台做必要的配置变化，运行构建脚本生成2进制文件。一般都是使用这种方式。</li>\n<li>平台为中心的工作流:如果你专注于构建单独平台的App或者需要需要在底层修改它那么就使用这个工作流吧。</li>\n</ol>\n<h1 id=\"创建第一个app\"><a class=\"markdownIt-Anchor\" href=\"#创建第一个app\"></a> 创建第一个App</h1>\n<h2 id=\"安装cordova-cli\"><a class=\"markdownIt-Anchor\" href=\"#安装cordova-cli\"></a> 安装Cordova CLI</h2>\n<ul>\n<li>下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm</li>\n<li>mac上xcode开发环境已OK</li>\n<li>mac上Android开发环境已OK，且Android的全局变量已配置，如：ANDROID_HOME</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ANDROID_HOME=/Users/Neel/Documents/Softwares/adt-bundle-mac-x86_64-20140321/sdk</span><br><span class=\"line\">export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>\n<ul>\n<li>sudo npm install -g cordova  //-g标志是告诉 npm 我们全局安装 cordova</li>\n<li>命令行输入cordova,检验是否安装成功</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CLI命令概要</span><br><span class=\"line\"></span><br><span class=\"line\">Help：显示可用CLI命令的信息。</span><br><span class=\"line\">Create：创建Cordova项目并关联项目文件夹和文件。</span><br><span class=\"line\">Plateform：管理Cordova项目使用的移动平台。</span><br><span class=\"line\">Plugin：管理Cordova插件的安装和卸载。</span><br><span class=\"line\">Prepare：从Cordova项目的www文件夹复制web应用内容到项目移动平台项目文件夹中。</span><br><span class=\"line\">Compile：把web应用打包成Cordova应用。</span><br><span class=\"line\">Build：先执行Prepare命令然后打包web应用。</span><br><span class=\"line\">Emulate：在一个或多个移动设备平台的设备模拟器中运行Cordova应用。</span><br><span class=\"line\">Run：在一个或多个移动设备中运行Cordova应用。</span><br><span class=\"line\">Serve：启动一个服务器加载web内容以便于用浏览器访问</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建app\"><a class=\"markdownIt-Anchor\" href=\"#创建app\"></a> 创建App</h2>\n<ul>\n<li>方法一：cordova create hello com.example.hello HelloWorld</li>\n<li>方法二：webstorm创建</li>\n</ul>\n<ol>\n<li>webstorm添加cordova支持：Settings → Plugins</li>\n<li>webstorm创建项目</li>\n</ol>\n<h2 id=\"添加平台\"><a class=\"markdownIt-Anchor\" href=\"#添加平台\"></a> 添加平台</h2>\n<ol>\n<li>检查你当前平台设置状况:cordova platform ls，运行add或者remove平台的命令将会影响项目 platforms的内容，在这个目录中每个指定平台都有一个子目录</li>\n<li>添加Android平台支持：cordova platform add android --save</li>\n<li>添加IOS平台支持：cordova platform add ios --save</li>\n<li>添加浏览器支持：cordova platform add browser --save</li>\n<li>npm install ios-sim -g //如果ios环境，可能需要添加这个</li>\n</ol>\n<h2 id=\"构建及测试\"><a class=\"markdownIt-Anchor\" href=\"#构建及测试\"></a> 构建及测试</h2>\n<ul>\n<li>安装构建先决条件检查：cordova requirements</li>\n<li>构建App：cordova build，构建所有平台；cordova build ios，构建特定平台</li>\n<li>测试：模拟器-cordova emulate android；或者可将手机插入电脑，在手机上直接测试-cordova run android</li>\n<li>说明：构建和测试也可通过webstorm直接进行</li>\n</ul>\n<h2 id=\"添加插件\"><a class=\"markdownIt-Anchor\" href=\"#添加插件\"></a> 添加插件</h2>\n<blockquote>\n<p>App要接触设备级别的特性，就需要你添加插件了.个插件 通过JavascriptAPI暴露原生SDK功能。插件通常由npm分发(<a href=\"http://cordova.axuer.com/plugins/\" target=\"_blank\" rel=\"noopener\">http://cordova.axuer.com/plugins/</a>),一些关键的API由Apache Cordova开源项目提供并且这些插件是作为[核心插件API]的.</p>\n</blockquote>\n<ul>\n<li>搜索插件：cordova plugin search camera</li>\n<li>查看当前安装的插件:cordova plugin ls</li>\n<li>添加插件：cordova plugin add cordova-plugin-camera  //plugin要添加camera插件，我们需要指定camera的npm包名</li>\n<li>添加插件：cordova plugin add <a href=\"https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git\" target=\"_blank\" rel=\"noopener\">https://git-wip-us.apache.org/repos/asf/cordova-plugin-camera.git</a></li>\n</ul>\n<h2 id=\"使用-merges自定义每个平台\"><a class=\"markdownIt-Anchor\" href=\"#使用-merges自定义每个平台\"></a> 使用 merges自定义每个平台</h2>\n<blockquote>\n<p>顶级merges目录提供了特定平台部署特定资源的地方。每个特定平台在merges中的子目录反映了www 源代码树中的结构， 允许你重写和添加文件。</p>\n</blockquote>\n<blockquote>\n<p>存放各个平台特殊的文件，会和www进行合并编译，相同的文件merges下的文件优先。</p>\n</blockquote>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merges/ </span><br><span class=\"line\">|-- ios/ </span><br><span class=\"line\">| `-- app.js </span><br><span class=\"line\">|-- android/ </span><br><span class=\"line\">| `-- android.js </span><br><span class=\"line\">www/ </span><br><span class=\"line\">`-- app.js</span><br></pre></td></tr></table></figure>\n<p>编译成iOS应用的话，包含merges/ios/app.js；而Android应用的话，包含www/app.js、merges/android/android.js</p>\n<h2 id=\"hooks目录\"><a class=\"markdownIt-Anchor\" href=\"#hooks目录\"></a> hooks目录</h2>\n<blockquote>\n<p>存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。<br>\nHook可以采用任何编程语言来写，Cordova CLI采用的是Node.js，所以一般都是用它来写</p>\n</blockquote>\n<h2 id=\"更新cordova和项目\"><a class=\"markdownIt-Anchor\" href=\"#更新cordova和项目\"></a> 更新Cordova和项目</h2>\n<ul>\n<li>要查找最新的cordova版本:npm info cordova version</li>\n<li>查看当前版本:cordova -v</li>\n<li>更新到最新版本:sudo npm update -g cordova</li>\n<li>安装指定版本:sudo npm install -g cordova@3.1.0-0.2.0</li>\n<li>更新目标项目的平台:cordova platform update android --save</li>\n</ul>\n<h1 id=\"平台开发\"><a class=\"markdownIt-Anchor\" href=\"#平台开发\"></a> 平台开发</h1>\n<ul>\n<li>查看所有支持的模拟器：cordova run --list</li>\n</ul>\n<h2 id=\"android\"><a class=\"markdownIt-Anchor\" href=\"#android\"></a> Android</h2>\n<ul>\n<li>要想知道你的Cordova项目中安装的Cordova Android包的版本，你可以在项目目录中运行cordova platform ls</li>\n<li>平台搭建过程</li>\n</ul>\n<ol>\n<li>安装Java Development Kit (JDK) 7或者最新的</li>\n<li>安装Android SDK</li>\n<li>添加SDK包：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Android API级别查看：http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels</span><br></pre></td></tr></table></figure>\n<p>打开Android SDK Manager (例如，在终端上运行`android)，并确保下面已经安装:</p>\n<ul>\n<li>\n<ul>\n<li>目标Android版本的Android Platform SDK</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>Android SDK build-tools，版本19.1.0或者之上</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>Android Support Repository (在&quot;Extras&quot;查找)</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>设置环境变量</li>\n</ol>\n<ul>\n<li>\n<ul>\n<li>设置JAVA_HOME环境变量，指定为JDK安装路径</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>设置ANDROID_HOME环境变量，指定为Android SDK安装路径</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>添加Android SDK的tools和platform-tools目录到你的PATH</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>Android Studio调试</li>\n</ol>\n<blockquote>\n<p>Cordova的Android项目可以被Android IDEAndroid Studio打开;</p>\n</blockquote>\n<blockquote>\n<p>如果你想使用Android Studio内置的Android调试/分析工具或者你要开发Android插件这是十分有用的</p>\n</blockquote>\n<p>在Android Studio中打开Cordova的Android项目:</p>\n<ul>\n<li>启动 Android Studio.</li>\n<li>选择 Import Project (Eclipse ADT, Gradle, etc).</li>\n<li>选择你项目中的Android platform目录(<your-project>/platforms/android)</your-project></li>\n<li>对于Gradle Sync问题你可以简单的回答 Yes.</li>\n</ul>\n<p>==注意==：当在Android studio里打开你的项目，建议你不要编辑你的代码在IDE中。这会在 platforms目录中编辑你的代码(而不是 www),并且变化将会被重写。而是编辑www目录并通过运行cordova build来拷贝过来你的变化。<br>\n6. Cordova和Android的生命周期</p>\n<table>\n<thead>\n<tr>\n<th>Cordova事件</th>\n<th>粗略的Android等效</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>deviceready</td>\n<td>onCreate()</td>\n<td>应用程序开始(不是从背景)</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>onPause()</td>\n<td>应用程序移动到背景</td>\n</tr>\n<tr>\n<td>resume</td>\n<td>onResume()</td>\n<td>应用程序返回到前景</td>\n</tr>\n</tbody>\n</table>\n<p>关于生命周期：</p>\n<blockquote>\n<p>在Android设备中，操作系统可以选择在后台杀死活动来释放资源，如果当前设备运行程序的内存过低。由于这个原因，你的应用程序知道生命周期被触发并维持任何确保用户在离开应用程序用户上下文不丢失的状态，是必须的。</p>\n</blockquote>\n<blockquote>\n<p>应该通过bindEvents 方法来注册应用程序回调来回应生命周期事件来保存状态。保存什么息和怎么保存信息由你决定，但是你要确保保存足够的信息，来精确的恢复到用户离开的地方</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这个状态代表了应用程序的状态并且会在onResume()和onPause()中保存和恢复</span><br><span class=\"line\">var appState = &#123;</span><br><span class=\"line\">    takingPicture: true,</span><br><span class=\"line\">    imageUri: &quot;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var APP_STORAGE_KEY = &quot;exampleAppState&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">var app = &#123;</span><br><span class=\"line\">    initialize: function() &#123;</span><br><span class=\"line\">        this.bindEvents();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bindEvents: function() &#123;</span><br><span class=\"line\">        // 这里我们注册我们关心的生命周期事件回调</span><br><span class=\"line\">        document.addEventListener(&apos;deviceready&apos;, this.onDeviceReady, false);</span><br><span class=\"line\">        document.addEventListener(&apos;pause&apos;, this.onPause, false);</span><br><span class=\"line\">        document.addEventListener(&apos;resume&apos;, this.onResume, false);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onDeviceReady: function() &#123;</span><br><span class=\"line\">        document.getElementById(&quot;take-picture-button&quot;).addEventListener(&quot;click&quot;, function() &#123;</span><br><span class=\"line\">            //由于camera插件方法启动了一个外部活动</span><br><span class=\"line\">            //这里有一次机会我们的应用程序被kill掉在回调被成功或者失败调用之前</span><br><span class=\"line\">            // 在onPause()和onResume()那里我们保存和恢复状态，来处理这个事情</span><br><span class=\"line\">            appState.takingPicture = true;</span><br><span class=\"line\"></span><br><span class=\"line\">            navigator.camera.getPicture(cameraSuccessCallback, cameraFailureCallback,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    sourceType: Camera.PictureSourceType.CAMERA,</span><br><span class=\"line\">                    destinationType: Camera.DestinationType.FILE_URI,</span><br><span class=\"line\">                    targetWidth: 250,</span><br><span class=\"line\">                    targetHeight: 250</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onPause: function() &#123;</span><br><span class=\"line\">        // 这里我们检测我们是否在获取图片，如果在，我们希望保存我们的状态以便onResume()</span><br><span class=\"line\">        // 恢复的时候使用，如果我们获得了图片URI我们也要存储</span><br><span class=\"line\">        if(appState.takingPicture || appState.imageUri) &#123;</span><br><span class=\"line\">            window.localStorage.setItem(APP_STORAGE_KEY, JSON.stringify(appState));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onResume: function(event) &#123;</span><br><span class=\"line\">        // 这里我们检差存储的状态，如果需要恢复他。由你跟踪任何添加的插件结果的来源</span><br><span class=\"line\">        //  (也就是说你代码的哪一步被调用)，还有什么参数提供给插件如果相关</span><br><span class=\"line\">        var storedState = window.localStorage.getItem(APP_STORAGE_KEY);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(storedState) &#123;</span><br><span class=\"line\">            appState = JSON.parse(storedState);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 检查如果我们需要恢复我们的图片</span><br><span class=\"line\">        if(!appState.takingPicture &amp;&amp; appState.imageUri) &#123;</span><br><span class=\"line\">            document.getElementById(&quot;get-picture-result&quot;).src = appState.imageUri;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 现在我们可以检测如果插件结果在事件对象里面</span><br><span class=\"line\">        // 这里需要cordova-android 5.1.0+</span><br><span class=\"line\">        else if(appState.takingPicture &amp;&amp; event.pendingResult) &#123;</span><br><span class=\"line\">            // 检测插件调用是否成功并调用相应的回调。对于camera插件，&quot;OK&quot;</span><br><span class=\"line\">            //意味着成功其他意味着错误</span><br><span class=\"line\">            if(event.pendingResult.pluginStatus === &quot;OK&quot;) &#123;</span><br><span class=\"line\">                // camera放置同样的结果在resume对象，因为成功回调传递给了getPicture(),</span><br><span class=\"line\">                // 因此我们可以传递同样的回调，返回一些其他东西。查询文档，了解怎么解释你使用</span><br><span class=\"line\">                // 插件的结果字段</span><br><span class=\"line\">                cameraSuccessCallback(event.pendingResult.result);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                cameraFailureCallback(event.pendingResult.result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这里是回调我们传入getPicture()</span><br><span class=\"line\">function cameraSuccessCallback(imageUri) &#123;</span><br><span class=\"line\">    appState.takingPicture = false;</span><br><span class=\"line\">    appState.imageUri = imageUri;</span><br><span class=\"line\">    document.getElementById(&quot;get-picture-result&quot;).src = imageUri;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cameraFailureCallback(error) &#123;</span><br><span class=\"line\">    appState.takingPicture = false;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.initialize();</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义图标icon\"><a class=\"markdownIt-Anchor\" href=\"#自定义图标icon\"></a> 自定义图标(Icon)</h1>\n<blockquote>\n<p>对启动画面(splash screen)的支持已经被移动到Cordova自己的插件中了，<a href=\"http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/\" target=\"_blank\" rel=\"noopener\">http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-splashscreen/</a></p>\n</blockquote>\n<blockquote>\n<p>当工作在CLI工作流中，你可以通过<icon>元素(config.xml)定义你的app图标。如果没用指定图标将使用ApacheCordova的logo.</icon></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src</td>\n<td>必要 图片文件位置，相对于项目根路径</td>\n</tr>\n<tr>\n<td>platform</td>\n<td>可选 目标平台</td>\n</tr>\n<tr>\n<td>width</td>\n<td>可选 图片的像素宽度</td>\n</tr>\n<tr>\n<td>height</td>\n<td>可选 图片的像素高度</td>\n</tr>\n<tr>\n<td>density</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>Android</td>\n<td>指定图标密度</td>\n</tr>\n<tr>\n<td>target</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>Windows</td>\n<td>图片文件和所有多渲染目标(MRT)伙伴的目标文件名</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;icon src=&quot;res/icon.png&quot; /&gt;     //用来定义用于所有平台的唯一默认图标</span><br></pre></td></tr></table></figure>\n<p>Android</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;platform name=&quot;android&quot;&gt;</span><br><span class=\"line\">        &lt;!--</span><br><span class=\"line\">            ldpi    : 36x36 px</span><br><span class=\"line\">            mdpi    : 48x48 px</span><br><span class=\"line\">            hdpi    : 72x72 px</span><br><span class=\"line\">            xhdpi   : 96x96 px</span><br><span class=\"line\">            xxhdpi  : 144x144 px</span><br><span class=\"line\">            xxxhdpi : 192x192 px</span><br><span class=\"line\">        --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/ldpi.png&quot; density=&quot;ldpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/mdpi.png&quot; density=&quot;mdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/hdpi.png&quot; density=&quot;hdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/xhdpi.png&quot; density=&quot;xhdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/xxhdpi.png&quot; density=&quot;xxhdpi&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/android/xxxhdpi.png&quot; density=&quot;xxxhdpi&quot; /&gt;</span><br><span class=\"line\">    &lt;/platform&gt;</span><br></pre></td></tr></table></figure>\n<p>IOS</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;platform name=&quot;ios&quot;&gt;</span><br><span class=\"line\">        &lt;!-- iOS 8.0+ --&gt;</span><br><span class=\"line\">        &lt;!-- iPhone 6 Plus  --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-60@3x.png&quot; width=&quot;180&quot; height=&quot;180&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iOS 7.0+ --&gt;</span><br><span class=\"line\">        &lt;!-- iPhone / iPod Touch  --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-60.png&quot; width=&quot;60&quot; height=&quot;60&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-60@2x.png&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPad --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-76.png&quot; width=&quot;76&quot; height=&quot;76&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-76@2x.png&quot; width=&quot;152&quot; height=&quot;152&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iOS 6.1 --&gt;</span><br><span class=\"line\">        &lt;!-- Spotlight Icon --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-40.png&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-40@2x.png&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPhone / iPod Touch --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon.png&quot; width=&quot;57&quot; height=&quot;57&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon@2x.png&quot; width=&quot;114&quot; height=&quot;114&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPad --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-72.png&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-72@2x.png&quot; width=&quot;144&quot; height=&quot;144&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPhone Spotlight and Settings Icon --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-small.png&quot; width=&quot;29&quot; height=&quot;29&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-small@2x.png&quot; width=&quot;58&quot; height=&quot;58&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- iPad Spotlight and Settings Icon --&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-50.png&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;</span><br><span class=\"line\">        &lt;icon src=&quot;res/ios/icon-50@2x.png&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;</span><br><span class=\"line\">    &lt;/platform&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"存储数据\"><a class=\"markdownIt-Anchor\" href=\"#存储数据\"></a> 存储数据</h1>\n<h2 id=\"localstorage\"><a class=\"markdownIt-Anchor\" href=\"#localstorage\"></a> LocalStorage</h2>\n<blockquote>\n<p>LocalStorage提供了简单和同步的键值对存储方式，而且在各个Cordova平台，底层的WebView实现都支持它。</p>\n</blockquote>\n<blockquote>\n<p>LocalStorage可以通过window.localStorage访问到。以下的代码片段展示了返回的storage对象的最重要的几个方法。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var storage = window.localStorage;</span><br><span class=\"line\">var value = storage.getItem(key); // 传递键的名字获取对应的值。</span><br><span class=\"line\">storage.setItem(key, value) // 传递键的名字和对应的值去添加或者更新这个键值对。</span><br><span class=\"line\">storage.removeItem(key) // 传递键的名字去从LocalStorage里删除这个键值对。</span><br></pre></td></tr></table></figure>\n<h2 id=\"sqlite-插件\"><a class=\"markdownIt-Anchor\" href=\"#sqlite-插件\"></a> SQLite 插件</h2>\n<ul>\n<li>cordova-sqlite-storage - 包含sqlite3实现的核心版本，它支持iOS, Android和Windows平台。</li>\n<li>cordova-sqlite-ext - 包含Android和iOS的正则支持等额外特性的扩展版本。</li>\n<li>cordova-sqlite-evfree - 与cordova-sqlite-ext类似，但提供了高级的内存管理。GPL版本低于v3或者有商业许可的话可用。</li>\n</ul>\n<h1 id=\"安全管理建议\"><a class=\"markdownIt-Anchor\" href=\"#安全管理建议\"></a> 安全管理建议</h1>\n<ul>\n<li>使用app内置浏览器打开外链：因为app内置浏览器会使用原生浏览器的安全特性，而且不会让你的Cordova环境被外部访问到</li>\n<li>校验所有的用户输入，服务端同样需要验证输入，特别是在传递数据到后台服务之前。</li>\n<li>不要缓存敏感信息</li>\n<li>不要使用eval()除非你知道你自己正在做什么</li>\n</ul>\n<h1 id=\"白名单\"><a class=\"markdownIt-Anchor\" href=\"#白名单\"></a> 白名单</h1>\n<blockquote>\n<p>外部域是应用无法控制的，而域名白名单则是一种控制访问外部域的安全模型。Cordova提供了一项可配置的安全策略来定义哪些外部站点可以访问。默认情况下，新的app被配置成可以访问任何站点。然而在发布到生产环境前，你应该制定一份白名单，限制应用可以访问的域名和子域名。</p>\n</blockquote>\n<h2 id=\"对于android\"><a class=\"markdownIt-Anchor\" href=\"#对于android\"></a> 对于Android</h2>\n<p>可以使用cordova-plugin-whitelist实现，虽然实现白名单插件是可能的，但还是不推荐这样做，除非你的app有非常明确的安全策略需要</p>\n<h2 id=\"对于其他平台\"><a class=\"markdownIt-Anchor\" href=\"#对于其他平台\"></a> 对于其他平台</h2>\n<p>依赖于使用app的config.xml文件里的<access>标签，它是用来声明可以访问的特定域名的。</access></p>\n<h1 id=\"事件\"><a class=\"markdownIt-Anchor\" href=\"#事件\"></a> 事件</h1>\n<p>Cordova给我们提供了很多的事件，可以在应用程序中使用。应用程序代码中可以添加这些事件的监听。事件相关定义都在www/js/index.js中</p>\n<p>支持的平台/</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>android</th>\n<th>ios</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>deviceready</td>\n<td></td>\n<td></td>\n<td>Cordova设备API准备好并可以访问的信号</td>\n</tr>\n<tr>\n<td>pause</td>\n<td></td>\n<td></td>\n<td>当原生平台把应用程序放入后台这个pause事件会触发，通常是用户切换到了不同的应用程序</td>\n</tr>\n<tr>\n<td>resume</td>\n<td></td>\n<td></td>\n<td>当原生平台将应用程序从后台运行拉出resume事件就会触发</td>\n</tr>\n<tr>\n<td>backbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下返回按钮事件触发</td>\n</tr>\n<tr>\n<td>menubutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下菜单按钮事件触发</td>\n</tr>\n<tr>\n<td>searchbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下搜索按钮事件触发</td>\n</tr>\n<tr>\n<td>startcallbutton</td>\n<td>X</td>\n<td>X</td>\n<td>当用户按下通话按钮事件触发</td>\n</tr>\n<tr>\n<td>endcallbutton</td>\n<td>X</td>\n<td>X</td>\n<td>当用户按下挂断通话按钮事件触发</td>\n</tr>\n<tr>\n<td>volumedownbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下降低声音按钮事件触发</td>\n</tr>\n<tr>\n<td>volumeupbutton</td>\n<td></td>\n<td>X</td>\n<td>当用户按下增加声音按钮事件触发</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"参考\"><a class=\"markdownIt-Anchor\" href=\"#参考\"></a> 参考</h1>\n<h2 id=\"configxml\"><a class=\"markdownIt-Anchor\" href=\"#configxml\"></a> config.xml</h2>\n<p><a href=\"http://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html\" target=\"_blank\" rel=\"noopener\">http://cordova.axuer.com/docs/zh-cn/latest/config_ref/index.html</a></p>\n<h1 id=\"问题解决\"><a class=\"markdownIt-Anchor\" href=\"#问题解决\"></a> 问题解决：</h1>\n<p><a href=\"https://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11\" target=\"_blank\" rel=\"noopener\">https://forum.ionicframework.com/t/ionic-3-ionic-serve-error-cannot-read-property-filter-of-undefined/85682/11</a></p>\n<p><a href=\"http://ionicframework.com/docs/components/#overview\" target=\"_blank\" rel=\"noopener\">http://ionicframework.com/docs/components/#overview</a></p>\n<p><a href=\"http://www.runoob.com/ionic/ionic-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/ionic/ionic-tutorial.html</a></p>\n<p><a href=\"https://creator.ionic.io/app/dashboard/projects\" target=\"_blank\" rel=\"noopener\">https://creator.ionic.io/app/dashboard/projects</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ionic run ios --device</span><br><span class=\"line\">ionic run ios --emulator</span><br><span class=\"line\">ionic run ios --target=&quot;iPhone-5s&quot;</span><br><span class=\"line\">ionic run ios --target=&quot;iPhone-6&quot;</span><br><span class=\"line\">ionic run ios --target=&quot;iPhone-6s&quot;</span><br><span class=\"line\">ionic run ios --emulator --target=&quot;iPhone-6s&quot; -l  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost:8100/ </span><br><span class=\"line\"></span><br><span class=\"line\">ios-sim showdevicetypes</span><br><span class=\"line\"></span><br><span class=\"line\">cordova run ios --target &quot;iPad-Pro&quot; --emulator</span><br><span class=\"line\"></span><br><span class=\"line\">xcrun simctl list devices</span><br></pre></td></tr></table></figure>\n<p>ios-sim命令行工具。</p>\n<p>ios-sim 是一个可以在命令控制iOS模拟器的工具。利用这个命令，我们可以启动一个模拟器，安装app，启动app，查询iOS SDK。它可以使我们像自动化测试一样不用打开Xcode。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: ios-sim &lt;command&gt;&lt;/command&gt; &lt;options&gt; [--args ...]</span><br><span class=\"line\"> </span><br><span class=\"line\">    Commands:</span><br><span class=\"line\">      showsdks                        List the available iOS SDK versions</span><br><span class=\"line\">      showdevicetypes                 List the available device types</span><br><span class=\"line\">      launch &lt;application path&gt;       Launch the application at the specified path on the iOS Simulator</span><br><span class=\"line\">      start                           Launch iOS Simulator without an app</span><br><span class=\"line\">      install &lt;application path&gt;      Install the application at the specified path on the iOS Simulator without launching the app</span><br><span class=\"line\"> </span><br><span class=\"line\">    Options:</span><br><span class=\"line\">      --version                       Print the version of ios-sim</span><br><span class=\"line\">      --help                          Show this help text</span><br><span class=\"line\">      --exit                          Exit after startup</span><br><span class=\"line\">      --log &lt;log file path&gt;           The path where log of the app running in the Simulator will be redirected to</span><br><span class=\"line\">      --devicetypeid &lt;device type&gt;    The id of the device type that should be simulated (Xcode6+). Use &apos;showdevicetypes&apos; to list devices.</span><br><span class=\"line\">                                      e.g &quot;com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone6, 8.0&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">    Removed in version 4.x:</span><br><span class=\"line\">      --stdout &lt;stdout file path&gt;     The path where stdout of the simulator will be redirected to (defaults to stdout of ios-sim)</span><br><span class=\"line\">      --stderr &lt;stderr file path&gt;     The path where stderr of the simulator will be redirected to (defaults to stderr of ios-sim)</span><br><span class=\"line\">      --sdk &lt;sdkversion&gt;              The iOS SDK version to run the application on (defaults to the latest)</span><br><span class=\"line\">      --family &lt;device family&gt;        The device type that should be simulated (defaults to `iphone&apos;)</span><br><span class=\"line\">      --retina                        Start a retina device</span><br><span class=\"line\">      --tall                          In combination with --retina flag, start the tall version of the retina device (e.g. iPhone 5 (4-inch))</span><br><span class=\"line\">      --64bit                         In combination with --retina flag and the --tall flag, start the 64bit version of the tall retina device (e.g. iPhone 5S (4-inch 64bit))</span><br><span class=\"line\"> </span><br><span class=\"line\">    Unimplemented in this version:</span><br><span class=\"line\">      --verbose                       Set the output level to verbose</span><br><span class=\"line\">      --timeout &lt;seconds&gt;             The timeout time to wait for a response from the Simulator. Default value: 30 seconds</span><br><span class=\"line\">      --args &lt;...&gt;                    All following arguments will be passed on to the application</span><br><span class=\"line\">      --env &lt;environment file path&gt;   A plist file containing environment key-value pairs that should be set</span><br><span class=\"line\">      --setenv NAME=VALUE             Set an environment variable&lt;/environment file path&gt;&lt;/seconds&gt;&lt;/device family&gt;&lt;/sdkversion&gt;&lt;/stderr file path&gt;&lt;/stdout file path&gt;&lt;/device type&gt;&lt;/log file path&gt;&lt;/application path&gt;&lt;/application path&gt;&lt;/options&gt;</span><br></pre></td></tr></table></figure>\n<p>ios-sim launch /Users/YDZ/Desktop/app.app --devicetypeid iPhone-6s<br>\n其中，/Users/YDZ/Desktop/app.app这个是设计师收到app之后的路径。–devicetypeid参数后面是给定一个模拟器的版本。</p>\n<p>只需要把上面的命令发给设计师，无脑粘贴到命令行，装好app的模拟器就会自动启动，打开app了。</p>\n<p>大公司的话可以应该有两个账号，一个上appstore的开发账户，这个严格保密。还有一个打线下包的企业账号，这样就能达到需求了</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjs4eudwt00085b8hhw1al0yh","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudx5000k5b8h213ygo4j"},{"post_id":"cjs4eudx3000i5b8h0gvaosck","category_id":"cjs4eudx2000f5b8hpoyo4hah","_id":"cjs4eudx8000q5b8hk97yieig"},{"post_id":"cjs4eudwx00095b8hpe3jt22r","category_id":"cjs4eudx2000f5b8hpoyo4hah","_id":"cjs4eudx9000u5b8h5wa66899"},{"post_id":"cjs4eudx4000j5b8hn2d6yipv","category_id":"cjs4eudx2000f5b8hpoyo4hah","_id":"cjs4eudxa000x5b8h004psk99"},{"post_id":"cjs4eudwz000c5b8hb0yto4xh","category_id":"cjs4eudx5000l5b8hr9raekcs","_id":"cjs4eudxb00115b8hl09pim8d"},{"post_id":"cjs4eudx1000d5b8hz3iayig5","category_id":"cjs4eudx8000r5b8hhddul7vh","_id":"cjs4eudxd00145b8hlrevlr05"},{"post_id":"cjs4eudxc00135b8hhd6ofbyu","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudxh001b5b8hlds4yhcc"},{"post_id":"cjs4eudx6000n5b8hyy6fjx6f","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxj001f5b8h5y4jjasq"},{"post_id":"cjs4eudxd00155b8hxq3hi5bj","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxk001i5b8hffvj3jh9"},{"post_id":"cjs4eudxf00195b8h1g91ndvd","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxm001m5b8hxlp0dnp6"},{"post_id":"cjs4eudx7000p5b8hl2ymwi15","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxo001o5b8hzzj31cqi"},{"post_id":"cjs4eudxg001a5b8hsv67yvnq","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxp001s5b8hg0goeyea"},{"post_id":"cjs4eudx8000t5b8hu9r0lg8e","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxr001v5b8h9wf5nufl"},{"post_id":"cjs4eudx9000w5b8hbsj682jy","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxs00205b8hk13wc2ng"},{"post_id":"cjs4eudxb00105b8h6s8eebpo","category_id":"cjs4eudxa000y5b8hqijlxuin","_id":"cjs4eudxt00225b8htecf1aml"},{"post_id":"cjs4eudxi001e5b8h5gb07al4","category_id":"cjs4eudxr001w5b8h2r3oyazf","_id":"cjs4eudxw00285b8h0o1z5n4g"},{"post_id":"cjs4eudxk001h5b8hdievur0m","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eudy3002f5b8hrkd6cagk"},{"post_id":"cjs4eudxl001l5b8hk8wq4zqm","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eudy6002l5b8heh8j2p2u"},{"post_id":"cjs4eudxn001n5b8h9gwyea6l","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eudy9002s5b8hhrgjffhi"},{"post_id":"cjs4eudxo001r5b8htsn0dyt6","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eudyb002x5b8hnclbx7n7"},{"post_id":"cjs4eudxq001u5b8h3pknh1k8","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eudye00335b8hc5vucb6k"},{"post_id":"cjs4eudxs001z5b8hecb25auc","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eudyh00385b8h5wh1ycnb"},{"post_id":"cjs4eudye00345b8hf9sxvdmq","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyj003c5b8hw6zkxm86"},{"post_id":"cjs4eudxt00215b8h75ixkp33","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyl003h5b8h5lx3a6ul"},{"post_id":"cjs4eudyf00375b8hbvru5das","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyn003k5b8hc9id7lz0"},{"post_id":"cjs4eudyh003a5b8hg8csm1ot","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyp003o5b8h1jmmta85"},{"post_id":"cjs4eudxu00245b8hx0bzhzor","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyr003q5b8hp1909ame"},{"post_id":"cjs4eudyl003g5b8hfojjezmm","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudyu003u5b8h7kihmjsc"},{"post_id":"cjs4eudxw00275b8hi974k8l3","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyw003x5b8hae7e5ywk"},{"post_id":"cjs4eudym003j5b8hc4a0y7g0","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudyy00425b8hbcvw9l93"},{"post_id":"cjs4eudxx002b5b8h00sks71y","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudyz00455b8h1vgwbjr3"},{"post_id":"cjs4eudyq003p5b8hk2powtau","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudz100495b8h0odbujyu"},{"post_id":"cjs4eudyt003t5b8hm7cibwx3","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudz2004b5b8hhodruzly"},{"post_id":"cjs4eudxz002d5b8hzg9wxuik","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudz4004e5b8hamvd7jk3"},{"post_id":"cjs4eudyv003w5b8hfbmitcht","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudz5004i5b8hrjumbr9v"},{"post_id":"cjs4eudyx00415b8hdtsnz2s2","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eudz7004m5b8hjzhoz8m1"},{"post_id":"cjs4eudy3002g5b8hgkxokeoh","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudz9004q5b8hmj2d5m9p"},{"post_id":"cjs4eudy5002i5b8huctoprh4","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudzb004u5b8hzw903wbt"},{"post_id":"cjs4eudy6002m5b8hw97kjg0a","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudzc004x5b8h9fyjd0y6"},{"post_id":"cjs4eudy8002p5b8hyemlcote","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudzg00505b8hy3t0zt41"},{"post_id":"cjs4eudy9002t5b8h1e5ucu7q","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudzj00555b8h7iaupme3"},{"post_id":"cjs4eudya002v5b8hdsl1a93z","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eudzv005c5b8h2gdm6bwj"},{"post_id":"cjs4eudyc002y5b8hm8wkm03d","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eue00005i5b8hfadcyrdj"},{"post_id":"cjs4eudyd00305b8hn2j6rmh4","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eue04005m5b8hc5hyyqb4"},{"post_id":"cjs4eudyi003b5b8hs41dbi39","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue07005t5b8hc1b581c7"},{"post_id":"cjs4eudyo003n5b8h7l9qgx08","category_id":"cjs4eue05005o5b8h7s48lto5","_id":"cjs4eue0a00605b8hhgi29wmd"},{"post_id":"cjs4eudyy00445b8h63e1sj15","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0c00665b8hb9pe2kpk"},{"post_id":"cjs4eudz000485b8ht0epwfkr","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0f006d5b8hu23t3uxz"},{"post_id":"cjs4eudz2004a5b8hgrgnlgtp","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0h006j5b8hrayq36wl"},{"post_id":"cjs4eudz3004d5b8hhpu7b6lo","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0k006p5b8h03jua2g6"},{"post_id":"cjs4eue0g006g5b8h60t5ou3y","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eue0l006s5b8hzuuc4tqi"},{"post_id":"cjs4eudz4004h5b8hrjg5jkue","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0o006x5b8hwqxm8kcj"},{"post_id":"cjs4eudz6004l5b8h0i3fcfqw","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0r00735b8hmtm5a8b1"},{"post_id":"cjs4eudz8004p5b8hv0gcstxq","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0u007a5b8ht56rlo3t"},{"post_id":"cjs4eudza004t5b8hj8a5bd36","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue0x007g5b8hz4d0quz9"},{"post_id":"cjs4eudzc004w5b8h5hvfedez","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue10007n5b8hd75yto8y"},{"post_id":"cjs4eudzd004z5b8hvq54y5x9","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue14007u5b8heyagb99c"},{"post_id":"cjs4eudzi00525b8hk642a8a6","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue1700815b8h9vap6clf"},{"post_id":"cjs4eue12007s5b8h6psyfvft","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eue1900835b8hfrpjmk3q"},{"post_id":"cjs4eue14007w5b8hyooln991","category_id":"cjs4eue05005o5b8h7s48lto5","_id":"cjs4eue1a00875b8h66dcdjd5"},{"post_id":"cjs4eudzj00565b8hbfo6ayrw","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue1b00895b8h5aqjf5i4"},{"post_id":"cjs4eue1800825b8hpf9k7b1p","category_id":"cjs4eudwz000a5b8hh288oegw","_id":"cjs4eue1c008c5b8h7fou77ox"},{"post_id":"cjs4eudzq00595b8hahopbu78","category_id":"cjs4eue1700805b8hmalbm4ic","_id":"cjs4eue1c008e5b8hewds647u"},{"post_id":"cjs4eue1900855b8hkb4pdqqp","category_id":"cjs4eudx2000f5b8hpoyo4hah","_id":"cjs4eue1d008h5b8hoq395usc"},{"post_id":"cjs4eudzv005d5b8hk5dv11n1","category_id":"cjs4eue1700805b8hmalbm4ic","_id":"cjs4eue1d008j5b8hvckgde7t"},{"post_id":"cjs4eudzz005f5b8h5awwvmba","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue1f008n5b8hshxvphbk"},{"post_id":"cjs4eue03005l5b8hcun0318t","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue1g008r5b8ht0ssuwpr"},{"post_id":"cjs4eue04005n5b8hl9q04d0x","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue1h008u5b8h96hcwuff"},{"post_id":"cjs4eue05005q5b8h1geufi8v","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue1x008y5b8hd97vf2aa"},{"post_id":"cjs4eue06005s5b8h4xzts8gh","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue2700925b8hecrbccow"},{"post_id":"cjs4eue08005x5b8hw65ukmsv","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue2800965b8h8qdq9bbz"},{"post_id":"cjs4eue09005y5b8hr46tatjr","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue2900995b8hy8ky7gqw"},{"post_id":"cjs4eue0a00615b8hcif7yllf","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue2a009d5b8he6xx9r3h"},{"post_id":"cjs4eue0b00645b8h3sce7xid","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue2a009g5b8hybd69sr2"},{"post_id":"cjs4eue0c00685b8h9bebzb8o","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue2b009l5b8h5f1pdlvt"},{"post_id":"cjs4eue0e006a5b8h045fe5w7","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue2b009o5b8hklwt12wa"},{"post_id":"cjs4eue0f006e5b8h31k88h64","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue2c009s5b8hxok83yev"},{"post_id":"cjs4eue0i006k5b8h067tbfk3","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue2d009x5b8hwdidzoz6"},{"post_id":"cjs4eue0j006n5b8htdx06wwf","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue2d00a05b8hv64fdr83"},{"post_id":"cjs4eue0k006r5b8hn4regyl1","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2e00a55b8h89gfskhd"},{"post_id":"cjs4eue0n006u5b8hrknhmxu3","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2f00a95b8hd7vspzbc"},{"post_id":"cjs4eue0o006y5b8hbpr91ld1","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2f00ac5b8h14cs5uw7"},{"post_id":"cjs4eue0q00715b8hrnpsfuq4","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2g00ag5b8h24c6uke6"},{"post_id":"cjs4eue0s00755b8htab69k9q","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2g00ak5b8h5cyhw7sf"},{"post_id":"cjs4eue0t00775b8h4fjw0a7y","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2h00ao5b8htl5l4p0q"},{"post_id":"cjs4eue0v007b5b8hws4galig","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2i00ar5b8h5zzcxjuh"},{"post_id":"cjs4eue0x007e5b8hrqr6bbn4","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2i00av5b8h8mv5s9q8"},{"post_id":"cjs4eue0y007i5b8hf6apm5x2","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2j00ay5b8hx5u22snd"},{"post_id":"cjs4eue0z007l5b8h7ism8fpy","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2k00b25b8hi1t8sglc"},{"post_id":"cjs4eue11007p5b8hle6zrx9p","category_id":"cjs4eue2d009w5b8hyf8pm2ji","_id":"cjs4eue2l00b65b8h076qklvb"},{"post_id":"cjs4eue16007y5b8h5ef51vop","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue2l00b95b8hur9az1e0"},{"post_id":"cjs4eue3f00de5b8h01d5bvmd","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eue3k00dk5b8hdc4nqlvh"},{"post_id":"cjs4eue3h00df5b8htploeigb","category_id":"cjs4eudxu00235b8h9fa9c0kl","_id":"cjs4eue3l00dn5b8hbjb0y6lh"},{"post_id":"cjs4eue3i00dh5b8hik2jdb8h","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eue3m00dq5b8h9w5isto2"},{"post_id":"cjs4eue3j00dj5b8hdcg3k66b","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3n00dt5b8hlgyvf42g"},{"post_id":"cjs4eue3k00dm5b8h1o3bisik","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3o00dw5b8hnxtqths0"},{"post_id":"cjs4eue3l00dp5b8h4bvkjv2o","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3r00dz5b8h8rdpxf4k"},{"post_id":"cjs4eue3m00ds5b8h0pcp3ryu","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3s00e25b8hsbhetips"},{"post_id":"cjs4eue3n00dv5b8hhtj73axo","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3t00e65b8hq1ruicql"},{"post_id":"cjs4eue3r00dy5b8h2j8h737s","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3u00e85b8h4i0kfpps"},{"post_id":"cjs4eue3s00e15b8hzxuv1jwc","category_id":"cjs4eue00005h5b8h59rgv7sh","_id":"cjs4eue3u00eb5b8hjafussp8"},{"post_id":"cjs4eue3t00e55b8hd09q45hm","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue3u00ed5b8hnqhx86s6"},{"post_id":"cjs4eue5600ej5b8hdlhede9x","category_id":"cjs4eudye00325b8hl618o3o4","_id":"cjs4eue5b00ep5b8hf1gi6i5y"},{"post_id":"cjs4eue5700ek5b8hyz3hjmdx","category_id":"cjs4eue2a009c5b8h5v0p46pp","_id":"cjs4eue5c00es5b8hphdzjizl"},{"post_id":"cjs4eue5a00eo5b8h3mfdhj8z","category_id":"cjs4eudx2000f5b8hpoyo4hah","_id":"cjs4eue5d00ev5b8haifm42u6"},{"post_id":"cjs4eue5b00er5b8hoypr8hc5","category_id":"cjs4eue1c008d5b8hhiqy23en","_id":"cjs4eue5e00ex5b8hdw2l3cmb"},{"post_id":"cjs4eue5800em5b8h152wxm7w","category_id":"cjs4eue5b00eq5b8h8mz9n0sv","_id":"cjs4eue5e00ez5b8hy9pvdnyo"}],"PostTag":[{"post_id":"cjs4eudq500005b8hkdks0dkv","tag_id":"cjs4eudqc00035b8hy5xunr87","_id":"cjs4eudqf00075b8h39wfoyw3"},{"post_id":"cjs4eudwt00085b8hhw1al0yh","tag_id":"cjs4eudwz000b5b8hn1cni67c","_id":"cjs4eudx3000h5b8hwv4empgj"},{"post_id":"cjs4eudwx00095b8hpe3jt22r","tag_id":"cjs4eudx3000g5b8hqf4sq52g","_id":"cjs4eudx7000o5b8hxsx27yg6"},{"post_id":"cjs4eudwz000c5b8hb0yto4xh","tag_id":"cjs4eudx6000m5b8htkjif68d","_id":"cjs4eudx9000v5b8h45jnrr4h"},{"post_id":"cjs4eudx1000d5b8hz3iayig5","tag_id":"cjs4eudx8000s5b8h6hdbmohz","_id":"cjs4eudxc00125b8hkygonhq5"},{"post_id":"cjs4eudx3000i5b8h0gvaosck","tag_id":"cjs4eudxb000z5b8h4f7etnf4","_id":"cjs4eudxf00185b8hmxk8r3u9"},{"post_id":"cjs4eudx4000j5b8hn2d6yipv","tag_id":"cjs4eudxd00175b8h10qs3d9q","_id":"cjs4eudxj001g5b8hg8ltcejc"},{"post_id":"cjs4eudx6000n5b8hyy6fjx6f","tag_id":"cjs4eudxi001d5b8hgfrkff2z","_id":"cjs4eudxq001t5b8hok7ndsio"},{"post_id":"cjs4eudx6000n5b8hyy6fjx6f","tag_id":"cjs4eudxl001k5b8h1xdynxn0","_id":"cjs4eudxr001x5b8h31t9yl4c"},{"post_id":"cjs4eudx7000p5b8hl2ymwi15","tag_id":"cjs4eudxi001d5b8hgfrkff2z","_id":"cjs4eudxv00265b8hxro1bu2m"},{"post_id":"cjs4eudx7000p5b8hl2ymwi15","tag_id":"cjs4eudxr001y5b8hv0x6desy","_id":"cjs4eudxx002a5b8hdl1j1ps7"},{"post_id":"cjs4eudx8000t5b8hu9r0lg8e","tag_id":"cjs4eudxi001d5b8hgfrkff2z","_id":"cjs4eudy6002j5b8hakoayrkf"},{"post_id":"cjs4eudx8000t5b8hu9r0lg8e","tag_id":"cjs4eudxy002c5b8h9zl5e3os","_id":"cjs4eudy7002n5b8hcwcj9i4v"},{"post_id":"cjs4eudx9000w5b8hbsj682jy","tag_id":"cjs4eudxi001d5b8hgfrkff2z","_id":"cjs4eudy8002q5b8hmdhr4x5w"},{"post_id":"cjs4eudxb00105b8h6s8eebpo","tag_id":"cjs4eudxi001d5b8hgfrkff2z","_id":"cjs4eudye00315b8hhahgxfet"},{"post_id":"cjs4eudxb00105b8h6s8eebpo","tag_id":"cjs4eudya002u5b8hy2jjpcs8","_id":"cjs4eudyf00355b8hvw6x6fxv"},{"post_id":"cjs4eudxc00135b8hhd6ofbyu","tag_id":"cjs4eudyd002z5b8hwegy2jp8","_id":"cjs4eudyk003f5b8hvcfdcygf"},{"post_id":"cjs4eudxc00135b8hhd6ofbyu","tag_id":"cjs4eudyf00365b8hw1iuwqwy","_id":"cjs4eudym003i5b8h79wmqore"},{"post_id":"cjs4eudxd00155b8hxq3hi5bj","tag_id":"cjs4eudxi001d5b8hgfrkff2z","_id":"cjs4eudyv003v5b8hqnwkf35e"},{"post_id":"cjs4eudxd00155b8hxq3hi5bj","tag_id":"cjs4eudyn003l5b8hy32443gv","_id":"cjs4eudyw003y5b8h4fat4o6w"},{"post_id":"cjs4eudxg001a5b8hsv67yvnq","tag_id":"cjs4eudys003r5b8hgsexpztw","_id":"cjs4eudyy00435b8h286o9zbq"},{"post_id":"cjs4eudxi001e5b8h5gb07al4","tag_id":"cjs4eudyw003z5b8h7obru3pu","_id":"cjs4eudz4004g5b8hfa8h0bmv"},{"post_id":"cjs4eudxi001e5b8h5gb07al4","tag_id":"cjs4eudz000475b8hxfs0vt9a","_id":"cjs4eudz6004k5b8hx3t8mc29"},{"post_id":"cjs4eudz4004h5b8hrjg5jkue","tag_id":"cjs4eudz000475b8hxfs0vt9a","_id":"cjs4eudz8004o5b8h6obfneul"},{"post_id":"cjs4eudxk001h5b8hdievur0m","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eudza004s5b8h5nwodkqr"},{"post_id":"cjs4eudxl001l5b8hk8wq4zqm","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eudzj00535b8hig45yss2"},{"post_id":"cjs4eudxl001l5b8hk8wq4zqm","tag_id":"cjs4eudzb004v5b8hp6r5n836","_id":"cjs4eudzp00575b8hmb5idea9"},{"post_id":"cjs4eudxn001n5b8h9gwyea6l","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eudzu005a5b8htx11v7ds"},{"post_id":"cjs4eudxo001r5b8htsn0dyt6","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eue00005g5b8hreungz2s"},{"post_id":"cjs4eudxq001u5b8h3pknh1k8","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eue06005r5b8h28uhf9e3"},{"post_id":"cjs4eudxq001u5b8h3pknh1k8","tag_id":"cjs4eue02005k5b8hsljgd5r0","_id":"cjs4eue07005v5b8hfolf1mnl"},{"post_id":"cjs4eudxs001z5b8hecb25auc","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eue0b00635b8hcva2goqy"},{"post_id":"cjs4eudxs001z5b8hecb25auc","tag_id":"cjs4eue08005w5b8hki8ojlzj","_id":"cjs4eue0c00675b8h1hpyoeq1"},{"post_id":"cjs4eudxt00215b8h75ixkp33","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0e006b5b8hwv55fyns"},{"post_id":"cjs4eudxw00275b8hi974k8l3","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0h006h5b8h7y0yil90"},{"post_id":"cjs4eue0g006g5b8h60t5ou3y","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0j006m5b8hw0ngwnjt"},{"post_id":"cjs4eudxx002b5b8h00sks71y","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0k006q5b8hsds0r9ez"},{"post_id":"cjs4eudxz002d5b8hzg9wxuik","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0n006v5b8hfrh9u2c4"},{"post_id":"cjs4eue0n006u5b8hrknhmxu3","tag_id":"cjs4eudyd002z5b8hwegy2jp8","_id":"cjs4eue0q00705b8hf259vogh"},{"post_id":"cjs4eudy3002g5b8hgkxokeoh","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0r00745b8he4yhab5i"},{"post_id":"cjs4eudy5002i5b8huctoprh4","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0u00785b8hjnlr8w49"},{"post_id":"cjs4eue0t00775b8h4fjw0a7y","tag_id":"cjs4eudxd00175b8h10qs3d9q","_id":"cjs4eue0w007d5b8hu5b0mtam"},{"post_id":"cjs4eudy6002m5b8hw97kjg0a","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue0y007h5b8hfdrvedfp"},{"post_id":"cjs4eue0x007e5b8hrqr6bbn4","tag_id":"cjs4eudxd00175b8h10qs3d9q","_id":"cjs4eue0z007k5b8h8tf5gcuf"},{"post_id":"cjs4eue0x007e5b8hrqr6bbn4","tag_id":"cjs4eudyd002z5b8hwegy2jp8","_id":"cjs4eue11007o5b8hcn3v4vqa"},{"post_id":"cjs4eudy8002p5b8hyemlcote","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue12007r5b8hi6f4d9nl"},{"post_id":"cjs4eudy9002t5b8h1e5ucu7q","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue14007v5b8hsf9828qr"},{"post_id":"cjs4eudya002v5b8hdsl1a93z","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue17007z5b8hxdd05bxx"},{"post_id":"cjs4eudyc002y5b8hm8wkm03d","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue1a00865b8hwcjhn2y9"},{"post_id":"cjs4eudyd00305b8hn2j6rmh4","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue1b008b5b8hluq1hsa5"},{"post_id":"cjs4eudye00345b8hf9sxvdmq","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue1d008g5b8hafa2gvrz"},{"post_id":"cjs4eudyf00375b8hbvru5das","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue1e008l5b8hz02sy2j3"},{"post_id":"cjs4eudyh003a5b8hg8csm1ot","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue1f008p5b8hfwjs02n4"},{"post_id":"cjs4eudyi003b5b8hs41dbi39","tag_id":"cjs4eue1f008o5b8h9zc5vvwb","_id":"cjs4eue1x008w5b8hlhdqngax"},{"post_id":"cjs4eudyi003b5b8hs41dbi39","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue27008z5b8h7rthneiu"},{"post_id":"cjs4eudyl003g5b8hfojjezmm","tag_id":"cjs4eue1h008v5b8hhhtz857b","_id":"cjs4eue2700935b8hxrb6bc0l"},{"post_id":"cjs4eudym003j5b8hc4a0y7g0","tag_id":"cjs4eue2700905b8h9bqb04x0","_id":"cjs4eue29009a5b8hswjlqbrt"},{"post_id":"cjs4eudym003j5b8hc4a0y7g0","tag_id":"cjs4eue2800945b8h58guh565","_id":"cjs4eue29009b5b8hrw78exft"},{"post_id":"cjs4eudyo003n5b8h7l9qgx08","tag_id":"cjs4eue2900975b8hc90zhx38","_id":"cjs4eue2a009f5b8hx9misoqv"},{"post_id":"cjs4eudyq003p5b8hk2powtau","tag_id":"cjs4eue2a009e5b8hfg1wq565","_id":"cjs4eue2b009j5b8hljcv72va"},{"post_id":"cjs4eudyt003t5b8hm7cibwx3","tag_id":"cjs4eue2a009i5b8hqi72175x","_id":"cjs4eue2c009q5b8hj26ob02l"},{"post_id":"cjs4eudyt003t5b8hm7cibwx3","tag_id":"cjs4eue2b009m5b8h9ihvewha","_id":"cjs4eue2c009t5b8h7dcdw8xs"},{"post_id":"cjs4eudyv003w5b8hfbmitcht","tag_id":"cjs4eue2c009p5b8hn51mg3n3","_id":"cjs4eue2d009v5b8hqs45r6lg"},{"post_id":"cjs4eudyx00415b8hdtsnz2s2","tag_id":"cjs4eue2c009u5b8hpnado3tz","_id":"cjs4eue2d009z5b8hmlrnzvz4"},{"post_id":"cjs4eudyy00445b8h63e1sj15","tag_id":"cjs4eue2d009y5b8hjxxb39ew","_id":"cjs4eue2e00a35b8hx7fiza5u"},{"post_id":"cjs4eudz000485b8ht0epwfkr","tag_id":"cjs4eue2d009y5b8hjxxb39ew","_id":"cjs4eue2e00a75b8hxsjb3y7j"},{"post_id":"cjs4eudz2004a5b8hgrgnlgtp","tag_id":"cjs4eue2e00a65b8hn0fb5wub","_id":"cjs4eue2f00ad5b8hkhsuh7is"},{"post_id":"cjs4eudz3004d5b8hhpu7b6lo","tag_id":"cjs4eue2f00aa5b8h09mqm98m","_id":"cjs4eue2g00ah5b8h4160fjw2"},{"post_id":"cjs4eudz6004l5b8h0i3fcfqw","tag_id":"cjs4eue2f00ae5b8h3gywot6o","_id":"cjs4eue2h00al5b8hnodkp3iw"},{"post_id":"cjs4eudz8004p5b8hv0gcstxq","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue2h00ap5b8hzdthjww9"},{"post_id":"cjs4eudza004t5b8hj8a5bd36","tag_id":"cjs4eue2h00am5b8hh2l6rqi0","_id":"cjs4eue2i00at5b8hsi41276j"},{"post_id":"cjs4eudzc004w5b8h5hvfedez","tag_id":"cjs4eue2i00as5b8hiqedj4iz","_id":"cjs4eue2k00b05b8htm3iv2ca"},{"post_id":"cjs4eudzc004w5b8h5hvfedez","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue2k00b35b8ht4q4m6t0"},{"post_id":"cjs4eudzd004z5b8hvq54y5x9","tag_id":"cjs4eue2e00a65b8hn0fb5wub","_id":"cjs4eue2k00b55b8hm6x0j4ht"},{"post_id":"cjs4eudzi00525b8hk642a8a6","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue2l00b85b8hn7xuxe2t"},{"post_id":"cjs4eudzj00565b8hbfo6ayrw","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue2l00bb5b8hkqw857la"},{"post_id":"cjs4eudzq00595b8hahopbu78","tag_id":"cjs4eue2l00ba5b8hhng0kqab","_id":"cjs4eue2m00bd5b8hbxlrx80z"},{"post_id":"cjs4eudzv005d5b8hk5dv11n1","tag_id":"cjs4eue2m00bc5b8huxpophv1","_id":"cjs4eue2m00bf5b8hndu818ms"},{"post_id":"cjs4eudzz005f5b8h5awwvmba","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2n00bh5b8hxald3sqa"},{"post_id":"cjs4eue03005l5b8hcun0318t","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2n00bj5b8hzzl99sg3"},{"post_id":"cjs4eue04005n5b8hl9q04d0x","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2o00bl5b8hhgrnsu0v"},{"post_id":"cjs4eue05005q5b8h1geufi8v","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2p00bn5b8hmrq7v7k5"},{"post_id":"cjs4eue06005s5b8h4xzts8gh","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2p00bp5b8hg20nmcjl"},{"post_id":"cjs4eue08005x5b8hw65ukmsv","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2q00br5b8htrvjsqg2"},{"post_id":"cjs4eue09005y5b8hr46tatjr","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2q00bt5b8hq9ozq3kh"},{"post_id":"cjs4eue0a00615b8hcif7yllf","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2q00bv5b8hcganwd55"},{"post_id":"cjs4eue0b00645b8h3sce7xid","tag_id":"cjs4eue2m00be5b8hvxpklbvp","_id":"cjs4eue2r00bx5b8hb1i189wu"},{"post_id":"cjs4eue0c00685b8h9bebzb8o","tag_id":"cjs4eue2q00bw5b8h2fb81kz8","_id":"cjs4eue2r00c05b8hips1citb"},{"post_id":"cjs4eue0c00685b8h9bebzb8o","tag_id":"cjs4eue2r00by5b8hof7ywf1j","_id":"cjs4eue2r00c15b8hvgvhnsac"},{"post_id":"cjs4eue0e006a5b8h045fe5w7","tag_id":"cjs4eue2r00bz5b8hy1igcxhz","_id":"cjs4eue2r00c35b8hwhoh8ef3"},{"post_id":"cjs4eue0f006e5b8h31k88h64","tag_id":"cjs4eue2r00bz5b8hy1igcxhz","_id":"cjs4eue2s00c55b8hk4ixbprw"},{"post_id":"cjs4eue0i006k5b8h067tbfk3","tag_id":"cjs4eue2q00bw5b8h2fb81kz8","_id":"cjs4eue2s00c85b8h9sxz0kzg"},{"post_id":"cjs4eue0i006k5b8h067tbfk3","tag_id":"cjs4eue2r00by5b8hof7ywf1j","_id":"cjs4eue2s00c95b8h0q3hgxex"},{"post_id":"cjs4eue0j006n5b8htdx06wwf","tag_id":"cjs4eue2s00c75b8hzd58s9pw","_id":"cjs4eue2t00cc5b8ha16qe2i0"},{"post_id":"cjs4eue0j006n5b8htdx06wwf","tag_id":"cjs4eue2r00by5b8hof7ywf1j","_id":"cjs4eue2t00cd5b8hhvym5vfb"},{"post_id":"cjs4eue0k006r5b8hn4regyl1","tag_id":"cjs4eue2t00cb5b8hxss91lu3","_id":"cjs4eue2t00cf5b8hsc917gwd"},{"post_id":"cjs4eue0o006y5b8hbpr91ld1","tag_id":"cjs4eue2b009m5b8h9ihvewha","_id":"cjs4eue2u00ch5b8h65jlgxzl"},{"post_id":"cjs4eue0q00715b8hrnpsfuq4","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue2u00cj5b8hflazmtcm"},{"post_id":"cjs4eue0s00755b8htab69k9q","tag_id":"cjs4eue0b00625b8hf37ws260","_id":"cjs4eue2v00cl5b8h5own6n3z"},{"post_id":"cjs4eue0s00755b8htab69k9q","tag_id":"cjs4eue2u00ci5b8hni6nt2a6","_id":"cjs4eue2v00cm5b8haj9bg904"},{"post_id":"cjs4eue0v007b5b8hws4galig","tag_id":"cjs4eue2u00ck5b8h5def8o6o","_id":"cjs4eue2v00cp5b8hetm6tsxs"},{"post_id":"cjs4eue0v007b5b8hws4galig","tag_id":"cjs4eue2u00ci5b8hni6nt2a6","_id":"cjs4eue2v00cq5b8hxxo01pn5"},{"post_id":"cjs4eue0y007i5b8hf6apm5x2","tag_id":"cjs4eue2v00co5b8hfs9pyy5y","_id":"cjs4eue2w00cs5b8hd6wxzejn"},{"post_id":"cjs4eue0z007l5b8h7ism8fpy","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue2w00cv5b8hzqh24cd9"},{"post_id":"cjs4eue0z007l5b8h7ism8fpy","tag_id":"cjs4eue2w00ct5b8h3pb8wwn6","_id":"cjs4eue2x00cw5b8hegjdolyc"},{"post_id":"cjs4eue11007p5b8hle6zrx9p","tag_id":"cjs4eue2q00bw5b8h2fb81kz8","_id":"cjs4eue2x00cz5b8h4dqnwucv"},{"post_id":"cjs4eue11007p5b8hle6zrx9p","tag_id":"cjs4eue2r00by5b8hof7ywf1j","_id":"cjs4eue2x00d05b8hgz18wyui"},{"post_id":"cjs4eue12007s5b8h6psyfvft","tag_id":"cjs4eue2b009m5b8h9ihvewha","_id":"cjs4eue2y00d25b8hnneairg2"},{"post_id":"cjs4eue14007w5b8hyooln991","tag_id":"cjs4eue2b009m5b8h9ihvewha","_id":"cjs4eue2y00d55b8hor6wj6ys"},{"post_id":"cjs4eue14007w5b8hyooln991","tag_id":"cjs4eue2y00d35b8hmf46x4uf","_id":"cjs4eue2y00d65b8hyqu58zgz"},{"post_id":"cjs4eue16007y5b8h5ef51vop","tag_id":"cjs4eue2y00d45b8h1xdj3hq2","_id":"cjs4eue2z00d85b8hav3wg7q4"},{"post_id":"cjs4eue1800825b8hpf9k7b1p","tag_id":"cjs4eue2b009m5b8h9ihvewha","_id":"cjs4eue2z00da5b8hvbh98kh7"},{"post_id":"cjs4eue1900855b8hkb4pdqqp","tag_id":"cjs4eue2z00d95b8hpu1sug6p","_id":"cjs4eue2z00dc5b8hd0xjaz5t"},{"post_id":"cjs4eue1900855b8hkb4pdqqp","tag_id":"cjs4eue2z00db5b8h3oqdarp5","_id":"cjs4eue2z00dd5b8h1wmn24jy"},{"post_id":"cjs4eue3f00de5b8h01d5bvmd","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eue3i00dg5b8h1b3np0vz"},{"post_id":"cjs4eue3i00dh5b8hik2jdb8h","tag_id":"cjs4eue2u00ci5b8hni6nt2a6","_id":"cjs4eue3k00dl5b8h4uzs5khb"},{"post_id":"cjs4eue3j00dj5b8hdcg3k66b","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue3l00do5b8hnmg5e8gb"},{"post_id":"cjs4eue3k00dm5b8h1o3bisik","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue3m00dr5b8h855gxegk"},{"post_id":"cjs4eue3h00df5b8htploeigb","tag_id":"cjs4eudz4004f5b8h35ic22pp","_id":"cjs4eue3n00du5b8h2j2yai4w"},{"post_id":"cjs4eue3h00df5b8htploeigb","tag_id":"cjs4eue3j00di5b8hskudc94r","_id":"cjs4eue3r00dx5b8hnz15cusd"},{"post_id":"cjs4eue3l00dp5b8h4bvkjv2o","tag_id":"cjs4eue2i00as5b8hiqedj4iz","_id":"cjs4eue3s00e05b8hs8jrksaq"},{"post_id":"cjs4eue3l00dp5b8h4bvkjv2o","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue3t00e45b8h7y3npssu"},{"post_id":"cjs4eue3m00ds5b8h0pcp3ryu","tag_id":"cjs4eudyd002z5b8hwegy2jp8","_id":"cjs4eue3u00e75b8h2stc3i52"},{"post_id":"cjs4eue3m00ds5b8h0pcp3ryu","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue3u00e95b8hqunn4z0h"},{"post_id":"cjs4eue3n00dv5b8hhtj73axo","tag_id":"cjs4eudyd002z5b8hwegy2jp8","_id":"cjs4eue3u00ec5b8hzis85ocs"},{"post_id":"cjs4eue3n00dv5b8hhtj73axo","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue3u00ee5b8hpovhb4m8"},{"post_id":"cjs4eue3s00e15b8hzxuv1jwc","tag_id":"cjs4eudyd002z5b8hwegy2jp8","_id":"cjs4eue3v00ef5b8hpe2oak3y"},{"post_id":"cjs4eue3s00e15b8hzxuv1jwc","tag_id":"cjs4eue1g008s5b8hb95kz3t5","_id":"cjs4eue3w00eg5b8h4oy1hrrb"},{"post_id":"cjs4eue3r00dy5b8h2j8h737s","tag_id":"cjs4eue3s00e35b8hp52a90dh","_id":"cjs4eue3w00eh5b8he69idm97"},{"post_id":"cjs4eue3t00e55b8hd09q45hm","tag_id":"cjs4eue3u00ea5b8hya4hxptw","_id":"cjs4eue3w00ei5b8hwb76gh7e"},{"post_id":"cjs4eue5700ek5b8hyz3hjmdx","tag_id":"cjs4eue2r00bz5b8hy1igcxhz","_id":"cjs4eue5a00en5b8h6cngp404"},{"post_id":"cjs4eue5600ej5b8hdlhede9x","tag_id":"cjs4eue5800el5b8hipjjme7k","_id":"cjs4eue5d00eu5b8h84mnqyla"},{"post_id":"cjs4eue5800em5b8h152wxm7w","tag_id":"cjs4eue5c00et5b8hfmum9xvg","_id":"cjs4eue5e00ey5b8hfoz20sau"},{"post_id":"cjs4eue5a00eo5b8h3mfdhj8z","tag_id":"cjs4eue2z00d95b8hpu1sug6p","_id":"cjs4eue5e00f15b8hzntv1ttu"},{"post_id":"cjs4eue5a00eo5b8h3mfdhj8z","tag_id":"cjs4eue5d00ew5b8hw6nk1nm6","_id":"cjs4eue5f00f25b8hm6lz120b"},{"post_id":"cjs4eue5b00er5b8hoypr8hc5","tag_id":"cjs4eue5e00f05b8hsvmfgl2h","_id":"cjs4eue5f00f35b8hst8upn82"}],"Tag":[{"name":"编写工具","_id":"cjs4eudqc00035b8hy5xunr87"},{"name":"持续集成","_id":"cjs4eudwz000b5b8hn1cni67c"},{"name":"MyBatis","_id":"cjs4eudx3000g5b8hqf4sq52g"},{"name":"Kotlin","_id":"cjs4eudx6000m5b8htkjif68d"},{"name":"Spring Boot","_id":"cjs4eudx8000s5b8h6hdbmohz"},{"name":"并发编程","_id":"cjs4eudxb000z5b8h4f7etnf4"},{"name":"Java","_id":"cjs4eudxd00175b8h10qs3d9q"},{"name":"ASP.NET","_id":"cjs4eudxi001d5b8hgfrkff2z"},{"name":"MVC","_id":"cjs4eudxl001k5b8h1xdynxn0"},{"name":"WebForms","_id":"cjs4eudxr001y5b8hv0x6desy"},{"name":"Razor","_id":"cjs4eudxy002c5b8h9zl5e3os"},{"name":"WebPages","_id":"cjs4eudya002u5b8hy2jjpcs8"},{"name":"工具","_id":"cjs4eudyd002z5b8hwegy2jp8"},{"name":"版本控制","_id":"cjs4eudyf00365b8hw1iuwqwy"},{"name":"HTML表单元素","_id":"cjs4eudyn003l5b8hy32443gv"},{"name":"C#","_id":"cjs4eudys003r5b8hgsexpztw"},{"name":"react","_id":"cjs4eudyw003z5b8h7obru3pu"},{"name":"Antd","_id":"cjs4eudz000475b8hxfs0vt9a"},{"name":"React","_id":"cjs4eudz4004f5b8h35ic22pp"},{"name":"React-Router","_id":"cjs4eudzb004v5b8hp6r5n836"},{"name":"React组件","_id":"cjs4eue02005k5b8hsljgd5r0"},{"name":"redux组件库","_id":"cjs4eue08005w5b8hki8ojlzj"},{"name":"CentOS","_id":"cjs4eue0b00625b8hf37ws260"},{"name":"nw","_id":"cjs4eue1f008o5b8h9zc5vvwb"},{"name":"node","_id":"cjs4eue1g008s5b8hb95kz3t5"},{"name":"mac工具","_id":"cjs4eue1h008v5b8hhhtz857b"},{"name":"ngrok","_id":"cjs4eue2700905b8h9bqb04x0"},{"name":"网络工具","_id":"cjs4eue2800945b8h58guh565"},{"name":"忘记锁屏密码","_id":"cjs4eue2900975b8hc90zhx38"},{"name":"UML类图","_id":"cjs4eue2a009e5b8hfg1wq565"},{"name":"gitbook","_id":"cjs4eue2a009i5b8hqi72175x"},{"name":"git","_id":"cjs4eue2b009m5b8h9ihvewha"},{"name":"postman","_id":"cjs4eue2c009p5b8hn51mg3n3"},{"name":"SVN","_id":"cjs4eue2c009u5b8hpnado3tz"},{"name":"前端规范","_id":"cjs4eue2d009y5b8hjxxb39ew"},{"name":"Angular","_id":"cjs4eue2e00a65b8hn0fb5wub"},{"name":"dva","_id":"cjs4eue2f00aa5b8h09mqm98m"},{"name":"CSS","_id":"cjs4eue2f00ae5b8h3gywot6o"},{"name":"TypeScript","_id":"cjs4eue2h00am5b8hh2l6rqi0"},{"name":"Express","_id":"cjs4eue2i00as5b8hiqedj4iz"},{"name":"微信公众平台","_id":"cjs4eue2l00ba5b8hhng0kqab"},{"name":"微信","_id":"cjs4eue2m00bc5b8huxpophv1"},{"name":"android","_id":"cjs4eue2m00be5b8hvxpklbvp"},{"name":"MySQL","_id":"cjs4eue2q00bw5b8h2fb81kz8"},{"name":"数据库","_id":"cjs4eue2r00by5b8hof7ywf1j"},{"name":"MongoDB","_id":"cjs4eue2r00bz5b8hy1igcxhz"},{"name":"SQLServer","_id":"cjs4eue2s00c75b8hzd58s9pw"},{"name":"环境搭建","_id":"cjs4eue2t00cb5b8hxss91lu3"},{"name":"Linux","_id":"cjs4eue2u00ci5b8hni6nt2a6"},{"name":"ubuntu","_id":"cjs4eue2u00ck5b8h5def8o6o"},{"name":"容器技术","_id":"cjs4eue2v00co5b8hfs9pyy5y"},{"name":"hexo","_id":"cjs4eue2w00ct5b8h3pb8wwn6"},{"name":"github","_id":"cjs4eue2y00d35b8hmf46x4uf"},{"name":"Android","_id":"cjs4eue2y00d45b8h1xdj3hq2"},{"name":"andrioid","_id":"cjs4eue2z00d95b8hpu1sug6p"},{"name":"RxJava","_id":"cjs4eue2z00db5b8h3oqdarp5"},{"name":"Redux","_id":"cjs4eue3j00di5b8hskudc94r"},{"name":"Vue","_id":"cjs4eue3s00e35b8hp52a90dh"},{"name":"Oracle","_id":"cjs4eue3u00ea5b8hya4hxptw"},{"name":"Shell编程","_id":"cjs4eue5800el5b8hipjjme7k"},{"name":"docker","_id":"cjs4eue5c00et5b8hfmum9xvg"},{"name":"Gradle","_id":"cjs4eue5d00ew5b8hw6nk1nm6"},{"name":"Cordova","_id":"cjs4eue5e00f05b8hsvmfgl2h"}]}}